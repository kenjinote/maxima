@c English version 2011-08-04
@menu
* Introducción a los polinomios::  
* Funciones y variables para polinomios::  
@end menu

@node Introducción a los polinomios, Funciones y variables para polinomios, Polinomios, Polinomios
@section Introducción a los polinomios

Los polinomios se almacenan en Maxima, bien en un formato general, bien en una forma conocida como canónica (Cannonical Rational Expressions, CRE). La última corresponde al formato estándar y se utiliza internamente para realizar operaciones como @code{factor}, @code{ratsimp} y demás.

Las Expresiones Racionales Canónicas (CRE) constituyen un tipo de representación
que es especialmente apropiado para expandir polinomios y funciones racionales
(así como para polinomios parcialmente factorizados y funciones racionales cuando a la variable @code{ratfac} se le asigna el valor @code{true}). En esta forma CRE las variables se ordenan de mayor a menor. Los polinomios se representan recursivamente como una lista compuesta por la variable principal seguida por una serie de pares de expresiones,
una por cada término del polinomio. El primer miembro
de cada par es el exponente de la variable principal en ese término y el
segundo miembro es el coeficiente de ese término, el cual puede ser un número o
un polinomio en otra variable representado también de esta forma. Así,
la parte principal de la forma CRE de 3*X^2-1 es (X 2 3 0 -1) y la de
2*X*Y+X-3 es (Y 1 (X 1 2) 0 (X 1 1 0 -3)) asumiendo que Y es la variable principal, y será (X 1 (Y 1 2 0 1) 0 -3) si se asume que la variable principal es X. Qué variable se considera "principal" se determinada en orden alfabético inverso.
Las "variables" de la expresión CRE no son necesariamente atómicas. De hecho
cualquier subexpresión cuyo operador principal no es + - * / ni ^ con potencia entera
puede ser considerada como una "variable" de la expresión (en forma CRE) en 
el cual aparezca. Por ejemplo las variables CRE de la expresión
X+SIN(X+1)+2*SQRT(X)+1 son X, SQRT(X)  y SIN(X+1).  Si el usuario no
especifica una ordenación de las variables mediante la función @code{ratvars} 
Maxima escogerá una alfabéticamente. En general, laa CRE representan expresiones
racionales, esto es, fracciones de polinomios, donde el numerador y
el denominador  no tienen factores comunes, siendo el denominador es
positivo. La forma interna es esencialmente un par de polinomios (el
numerador y el denominador) precedida por la lista de variables ordenadas. Si
una expresión a ser mostrada está en la forma CRE o contiene alguna
subexpresión en forma de CRE, el simbolo /R/ será seguido por la etiqueta de la línea de comando.
Véase la función @code{rat} para convertir una expresión a la forma CRE. Una
extensión de la forma CRE se utiliza para la representación de las series de Taylor. La
noción de una expresión racional se extiende de manera que los exponentes de las
variables pueden ser números racionales positivos o negativos y no sólo
enteros positivos y los coeficientes pueden ser también expresiones
racionales y no sólo polinomios. Estas expresiones se representan internamente por una forma polinomial recursiva que es similar a la forma CRE, pero que la generaliza, aportando información adicional como el grado de truncamiento. Como con la forma CRE, el símbolo /T/ sigue la etiqueta de línea de comando en la que se encuentra dicha expresión.








@node Funciones y variables para polinomios,  , Introducción a los polinomios, Polinomios
@section Funciones y variables para polinomios

@defvr {Variable opcional} algebraic
Valor por defecto: @code{false}

La variable @code{algebraic} debe valer @code{true} para que se pueda hacer la simplificación de enteros algebraicos.

@end defvr

@defvr {Variable opcional} berlefact
Valor por defecto: @code{true}

Si @code{berlefact} vale @code{false} entonces se utiliza el algoritmo de factorización de Kronecker, en caso contrario se utilizará el algoritmo de Berlekamp, que es el que se aplica por defecto.

@end defvr

@deffn {Función} bezout (@var{p1}, @var{p2}, @var{x})
Es una alternativa a la función @code{resultant}.  Devuelve una matriz.

@example
(%i1) bezout(a*x+b, c*x^2+d, x);
                         [ b c  - a d ]
(%o1)                    [            ]
                         [  a     b   ]
(%i2) determinant(%);
                            2      2
(%o2)                      a  d + b  c
(%i3) resultant(a*x+b, c*x^2+d, x);
                            2      2
(%o3)                      a  d + b  c
@end example
@end deffn

@deffn {Función} bothcoef (@var{expr}, @var{x})
Devuelve una lista cuyo primer miembro es el coeficiente de @var{x} en @var{expr} (que coincide con el que devuelve @code{ratcoef} si @var{expr} está en formato CRE, o el que devuelve @code{coeff} si no está en este formato) y cuyo segundo miembro es la parte restante de @var{expr}. Esto es, @code{[A, B]} donde @code{@var{expr} = A*@var{x} + B}.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c islinear (expr, x) := block ([c],
@c         c: bothcoef (rat (expr, x), x),
@c         is (freeof (x, c) and c[1] # 0))$
@c islinear ((r^2 - (x - r)^2)/x, x);

@example
(%i1) islinear (expr, x) := block ([c],
        c: bothcoef (rat (expr, x), x),
        is (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
@end example

@end deffn

@deffn {Función} coeff (@var{expr}, @var{x}, @var{n})
@deffnx {Función} coeff (@var{expr}, @var{x})
Devuelve el coeficiente de @code{@var{x}^@var{n}} en @var{expr},
donde @var{expr} es un polinomio o monomio en @var{x}.

@code{coeff(@var{expr}, @var{x}^@var{n})} es equivalente a
@code{coeff(@var{expr}, @var{x}, @var{n})}.
@code{coeff(@var{expr}, @var{x}, 0)} devuelve el resto de @var{expr},
el cual no contiene a @var{x}. En caso de omisión, se entiende
que @var{n} es igual a 1.

@var{x} puede ser tanto el nombre de una variable simple como el
de una variable con subíndice, o también una
subexpresión de @var{expr} que contenga un operador junto con
todos sus argumentos.

En ocasiones, es posible calcular los coeficientes de expresiones
equivalentes a @var{expr} aplicando @code{expand} o @code{factor}.
@code{coeff} no aplica ni @code{expand}, ni @code{factor}, ni ninguna otra
función.

@code{coeff} se distribuye sobre listas, matrices y ecuaciones.

Ejemplos:

@code{coeff} devuelve el coeficiente de @code{@var{x}^@var{n}} en @var{expr}.

@c ===beg===
@c coeff (b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
@c ===end===
@example
(%i1) coeff (b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                3
(%o1)                          b
@end example

@code{coeff(@var{expr}, @var{x}^@var{n})} es equivalente
a @code{coeff(@var{expr}, @var{x}, @var{n})}.

@c ===beg===
@c coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
@c coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
@c ===end===
@example
(%i1) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
(%o1)                         - c
                                 3
(%i2) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
(%o2)                         - c
                                 3
@end example

@code{coeff(@var{expr}, @var{x}, 0)} devuelve el resto de @var{expr},
el cual no contiene a @var{x}.

@c ===beg===
@c coeff (a*u + b^2*u^2 + c^3*u^3, b, 0);
@c ===end===
@example
(%i1) coeff (a*u + b^2*u^2 + c^3*u^3, b, 0);
                            3  3
(%o1)                      c  u  + a u
@end example

@var{x} puede ser tanto el nombre de una variable simple como el
de una variable con subíndice, o también una
subexpresión de @var{expr} que contenga un operador junto con
todos sus argumentos.

@c ===beg===
@c coeff (h^4 - 2*%pi*h^2 + 1, h, 2);
@c coeff (v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
@c coeff (sin(1 + x)*sin(x) + sin(1 + x)^3*sin(x)^3, sin(1 + x)^3);
@c coeff ((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
@c ===end===
@example
(%i1) coeff (h^4 - 2*%pi*h^2 + 1, h, 2);
(%o1)                        - 2 %pi
(%i2) coeff (v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
(%o2)                        - 2 %pi
(%i3) coeff (sin(1 + x)*sin(x) + sin(1 + x)^3*sin(x)^3, sin(1 + x)^3);
                                3
(%o3)                        sin (x)
(%i4) coeff ((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
(%o4)                         c - d
@end example

@code{coeff} no aplica ni @code{expand}, ni @code{factor}, ni ninguna otra
función.

@c ===beg===
@c coeff (c*(a + b)^3, a);
@c expand (c*(a + b)^3);
@c coeff (%, a);
@c coeff (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
@c factor (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
@c coeff (%, (a + b)^3);
@c ===end===
@example
(%i1) coeff (c*(a + b)^3, a);
(%o1)                           0
(%i2) expand (c*(a + b)^3);
                 3          2        2        3
(%o2)           b  c + 3 a b  c + 3 a  b c + a  c
(%i3) coeff (%, a);
                                2
(%o3)                        3 b  c
(%i4) coeff (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
(%o4)                           0
(%i5) factor (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                  3
(%o5)                      (b + a)  c
(%i6) coeff (%, (a + b)^3);
(%o6)                           c
@end example

@code{coeff} se distribuye sobre listas, matrices y ecuaciones.

@c ===beg===
@c coeff ([4*a, -3*a, 2*a], a);
@c coeff (matrix ([a*x, b*x], [-c*x, -d*x]), x);
@c coeff (a*u - b*v = 7*u + 3*v, u);
@c ===end===
@example
(%i1) coeff ([4*a, -3*a, 2*a], a);
(%o1)                      [4, - 3, 2]
(%i2) coeff (matrix ([a*x, b*x], [-c*x, -d*x]), x);
@group
                          [  a    b  ]
(%o2)                     [          ]
                          [ - c  - d ]
@end group
(%i3) coeff (a*u - b*v = 7*u + 3*v, u);
(%o3)                         a = 7
@end example
@end deffn



@deffn {Función} content (@var{p_1}, @var{x_1}, ..., @var{x_n})
Devuelve una lista cuyo primer miembro es el máximo común divisor de los coeficientes de los términos del polinomio @var{p_1} de variable @var{x_n} (este es el contenido) y cuyo segundo miembro es el polinomio @var{p_1} dividido por el contenido.
@c APPEARS TO WORK AS ADVERTISED -- ONLY x_n HAS ANY EFFECT ON THE RESULT
@c WHAT ARE THE OTHER VARIABLES x_1 THROUGH x_{n-1} FOR ??

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c content (2*x*y + 4*x^2*y^2, y);

@example
(%i1) content (2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
@end example

@end deffn

@deffn {Función} denom (@var{expr})
Devuelve el denominador de la expresión racional @var{expr}.

@end deffn

@deffn {Función} divide (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Calcula el cociente y el resto del polinomio @var{p_1} dividido por el polinomio @var{p_2}, siendo la variable principal @var{x_n}.
@c SPELL OUT THE PURPOSE OF THE OTHER VARIABLES
Las otras funciones son como en la función @code{ratvars}. El resultado es una lista cuyo primer miembro es el cociente y el segundo miembro el resto.

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c divide (x + y, x - y, x);
@c divide (x + y, x - y);

@example
(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
@end example

@noindent
Nótese que @code{y} es la variable principal en el segundo ejemplo.

@end deffn

@deffn {Función} eliminate ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_k}])
Elimina variables de ecuaciones (o de expresiones que se supone valen cero) tomando resultantes sucesivas. Devuelve una lista con @code{@var{n} - @var{k}} expresiones y @var{k} variables @var{x_1}, ..., @var{x_k} eliminadas.  Primero se elimina  @var{x_1} dando @code{@var{n} - 1} expresiones, después se elimina @code{x_2}, etc.  Si @code{@var{k} = @var{n}} entonces se devuelve una lista con una única expresión, libre de las variables @var{x_1}, ..., @var{x_k}. En este caso se llama a @code{solve} para resolver la última resultante para la última variable.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr1: 2*x^2 + y*x + z;
@c expr2: 3*x + 5*y - z - 1;
@c expr3: z^2 + x - y^2 + 5;
@c eliminate ([expr3, expr2, expr1], [y, z]);

@example
(%i1) expr1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) expr2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) expr3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate ([expr3, expr2, expr1], [y, z]);
             8         7         6          5          4
(%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                    3         2
                            - 5154 x  - 1291 x  + 7688 x + 15376]
@end example

@end deffn

@deffn {Función} ezgcd (@var{p_1}, @var{p_2}, @var{p_3}, ...)
Devuelve una lista cuyo primer elemento es el máximo común divisor (mcd)
de los polinomios @var{p_1}, @var{p_2}, @var{p_3}, @dots{},  siendo los 
miembros restantes los mismos polinomios divididos por el mcd. 
Se utiliza siempre el algoritmo @code{ezgcd}.

Véanse también @code{gcd}, @code{gcdex}, @code{gcdivide} y @code{poly_gcd}.

Ejemplos:

Los tres polinomios tiene como máximo común divisor @code{2*x-3},
el cual se calcula primero con la función @code{gcd} y luego con
@code{ezgcd}.

@example
(%i1) p1 : 6*x^3-17*x^2+14*x-3;
                        3       2
(%o1)                6 x  - 17 x  + 14 x - 3
(%i2) p2 : 4*x^4-14*x^3+12*x^2+2*x-3;
                    4       3       2
(%o2)            4 x  - 14 x  + 12 x  + 2 x - 3
(%i3) p3 : -8*x^3+14*x^2-x-3;
                          3       2
(%o3)                - 8 x  + 14 x  - x - 3

(%i4) gcd(p1, gcd(p2, p3));
(%o4)                        2 x - 3

(%i5) ezgcd(p1, p2, p3);
                   2               3      2           2
(%o5) [2 x - 3, 3 x  - 4 x + 1, 2 x  - 4 x  + 1, - 4 x  + x + 1]
@end example



@end deffn

@defvr {Variable opcional} facexpand
Valor por defecto: @code{true}

La variable @code{facexpand} controla si los factores irreducibles devueltos por @code{factor} están en formato expandido (por defecto) o recursivo  (CRE normal).

@end defvr



@deffn {Función} factor (@var{expr})
@deffnx {Función} factor (@var{expr}, @var{p})

Factoriza la expresión @var{expr}, que puede contener
cualquier número de variables o funciones, en factores 
irreducibles respecto de los enteros. La llamada 
@code{factor (@var{expr}, @var{p})} factoriza @var{expr} 
en el campo de los racionales con un elemento añadido cuyo 
polinomio mínimo es @var{p}.

La función @code{factor} utiliza a @code{ifactors} 
para factorizar enteros.

Si la variable @code{factorflag} vale @code{false} suprime 
la factorización de los factores enteros en las expresiones racionales.

La variable @code{dontfactor} puede contener una lista 
de variables con respecto a las cuales no se factorizará 
(inicialmente está vacía). Tampoco se 
factorizará respecto de cualesquiera otra variables que sean menos importantes (según la ordenación que se sigue en el formato CRE) que aquellas que se encuentran en la lista @code{dontfactor}.

Si la variable @code{savefactors} vale @code{true}, los 
factores de una expresión en forma de producto se guardarán 
por ciertas funciones a fin de acelerar posteriores factorizaciones 
de expresiones que contengan algunos de estos mismos factores.

Si @code{berlefact} vale @code{false} entonces se utiliza el 
algoritmo de factorización de Kronecker, en caso contrario se 
utilizará el algoritmo de Berlekamp, que es el que se aplica por defecto.

Si la variable @code{intfaclim} vale @code{true}, Maxima desistirá de
factorizar enteros si no encuentra ningún factor después de las
divisiones tentativas y de aplicar el método rho de Pollard. Si vale
@code{false} (este es el caso cuando el usuario invoca explícitamente
a @code{factor}), se intentará la factorización completa del entero. El valor
asignado a @code{intfaclim} se utiliza en llamadas internas a @code{factor}. Así,
se puede cambiar el valor de @code{intfaclim} para evitar que Maxima dedique
un tiempo prohibitivo a factorizar números enteros grandes.

Ejemplos:
@c EXAMPLES BELOW ADAPTED FROM examples (factor)
@c factor (2^63 - 1);
@c factor (-8*y - 4*x + z^2*(2*y + x));
@c -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
@c block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
@c factor (1 + %e^(3*x));
@c factor (1 + x^4, a^2 - 2);
@c factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
@c (2 + x)/(3 + x)/(b + x)/(c + x)^2;
@c ratsimp (%);
@c partfrac (%, x);
@c map ('factor, %);
@c ratsimp ((x^5 - 1)/(x - 1));
@c subst (a, x, %);
@c factor (%th(2), %);
@c factor (1 + x^12);
@c factor (1 + x^99);

@example
(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
@end example

@end deffn




@defvr {Variable opcional} factorflag
Valor por defecto: @code{false}

@c WHAT IS THIS ABOUT EXACTLY ??
Si @code{factorflag} vale @code{false} se evita la factorización de factores enteros de expresiones racionales.
@end defvr




@deffn {Función} factorout (@var{expr}, @var{x_1}, @var{x_2}, ...)
Reorganiza la suma @var{expr} como una suma de términos de la forma 
@code{f (@var{x_1}, @var{x_2}, ...)*g}, donde @code{g} es un producto 
de expresiones que no contienen ningún @var{x_i} y @code{f} se factoriza.

Nótese que @code{factorout} ignora la variable opcional @code{keepfloat}.

Ejemplo:

@c ===beg===
@c expand (a*(x+1)*(x-1)*(u+1)^2);
@c factorout(%,x);
@c ===end===
@example
(%i1) expand (a*(x+1)*(x-1)*(u+1)^2);
             2  2          2      2      2
(%o1)     a u  x  + 2 a u x  + a x  - a u  - 2 a u - a
(%i2) factorout(%,x);
         2
(%o2) a u  (x - 1) (x + 1) + 2 a u (x - 1) (x + 1)
                                              + a (x - 1) (x + 1)
@end example
@end deffn




@deffn {Función} factorsum (@var{expr})
Intenta agrupar términos en los factores de @var{expr} que son sumas en grupos de términos tales que su suma sea factorizable. La función @code{factorsum} puede restablecer el recuperar de @code{expand ((x + y)^2 + (z + w)^2)} pero no puede recuperar @code{expand ((x + 1)^2 + (x + y)^2)} porque los términos tienen variables comunes.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
@c factorsum (%);

@example
(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum (%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
@end example

@end deffn

@deffn {Función} fasttimes (@var{p_1}, @var{p_2})
Calcula el producto de los polinomios @var{p_1} y @var{p_2} utilizando un algoritmo especial. Los polinomios @code{p_1} y @code{p_2} deben ser multivariantes, densos y aproximadamente del mismo tamaño. La multiplicación clásica es de orden @code{n_1 n_2} donde @code{n_1} es el grado de  @code{p_1} y  @code{n_2} el grado de @code{p_2}. La función @code{fasttimes} es de orden @code{max (n_1, n_2)^1.585}.

@end deffn

@deffn {Función} fullratsimp (@var{expr})
Aplica repetidamente @code{ratsimp} a una expresión, seguida de simplificaciones no racionales, hasta que no se obtienen más transformaciones; entonces devuelve el resultado.

En presencia de expresiones no racionales, una llamada a @code{ratsimp} seguida de una simplificación no racional ("general") puede no ser suficiente para conseguir un resultado simplificado. En ocasiones serán necesarias más de una llamada a @code{ratsimp}, que es lo que hace precisamente @code{fullratsimp}.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
@c ratsimp (expr);
@c fullratsimp (expr);
@c rat (expr);

@example
(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
@end example

@end deffn

@deffn {Función} fullratsubst (@var{a}, @var{b}, @var{c})
Similar a @code{ratsubst} excepto por el hecho de que se llama a í misma recursivamente hasta que el resultado deja de cambiar. Esta función es útil cuando la expresión a sustituir y la que la sustituye tienen variables comunes.

La función @code{fullratsubst} también acepta sus argumentos en el formato de @code{lratsubst}.

Es necesario ejecutar @code{load ("lrats")} para cargar @code{fullratsubst} y @code{lratsubst}.

Ejemplos:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c CAN PROBABLY CUT OUT THE lratsubst STUFF (lratsubst HAS ITS OWN DESCRIPTION)
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);
@c ratsubst (b*a, a^2, a^3);
@c fullratsubst (b*a, a^2, a^3);
@c fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
@c fullratsubst (a^2 = b*a, a^3);
@c errcatch (fullratsubst (b*a^2, a^2, a^3));

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} puede hacer sustituciones múltiples;
@code{lratsubst} es análoga a @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
Si sólo se quiere una sustitución, entonces se puede dar una única ecuación como primer argumento.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example
@itemize @bullet
@item
@code{fullratsubst} equivale a @code{ratsubst}, 
excepto por el hecho de que se llama a í misma recursivamente hasta que el resultado deja de cambiar.
@end itemize
@example
(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
                                 2
(%o6)                         a b
@end example
@itemize @bullet
@item
@code{fullratsubst} también acepta una lista de ecuaciones o una sóla ecuación como primer argumento.
@end itemize
@example
(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
@end example
@itemize @bullet
@item
@c REWORD THIS SENTENCE
@code{fullratsubst} puede caer en una recursión infinita.
@end itemize
@example
(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
@end example

@end deffn

@deffn {Función} gcd (@var{p_1}, @var{p_2}, @var{x_1}, ...)
Devuelve el máximo común divisor de @var{p_1} y @var{p_2}.
La variable @code{gcd} determiona qué algoritmo se va a utilizar.
Asignándole a @code{gcd} los valores @code{ez}, @code{subres}, @code{red}
o @code{spmod}, se seleccionan los algoritmos @code{ezgcd}, 
subresultante @code{prs}, reducido o modular, respectivamente.
Si @code{gcd} vale @code{false} entonces @code{gcd(@var{p_1}, 
@var{p_2}, @var{x})} devolverá siempre 1 para cualquier @var{x}.
Muchas funciones (por ejemplo,  @code{ratsimp}, @code{factor}, etc.)
hacen uso de @code{gcd} implícitamente.  
En caso de polinomios homogéneos se recomienda darle a 
@code{gcd} el valor @code{subres}.  Para calcular un máximo 
común divisor en presencia de raíces, como en
 @code{gcd (@var{x}^2 - 2*sqrt(2)*@var{x} + 2, @var{x} - sqrt(2))},
la variable @code{algebraic} debe igualarse
a @code{true} y @code{gcd} no puede ser @code{ez}.

Se recomienda utilizar el algoritmo @code{subres} en lugar de @code{red},
por ser aquél más moderno.

Si la variable @code{gcd}, cuyo valor por defecto es @code{spmod},
vale @code{false}, no se calculará el máximo común divisor 
cuando las expresiones se conviertan a su forma canónica (CRE),
lo que redundará en ocasiones en mayor rapidez de cálculo.


@end deffn

@deffn {Función} gcdex (@var{f}, @var{g})
@deffnx {Función} gcdex (@var{f}, @var{g}, @var{x})
Devuelve una lista @code{[@var{a}, @var{b}, @var{u}]} en la que @var{u} es el máximo común divisor (mcd) de @var{f} y @var{g}, e igual a @code{@var{a} @var{f} + @var{b} @var{g}}.
Los argumentos @var{f} y @var{g} deben ser polinomios univariantes, o indicarles la variable principal @var{x} en caso de ser multivariantes. 

La función @code{gcdex} implementa el algoritmo de Euclides, en el que tenemos una secuencia de @code{L[i]: [a[i], b[i], r[i]]} todos ellos ortogonales a @code{[f, g, -1]} siendo el siguiente calculado a partir de @code{q = quotient(r[i]/r[i+1])} y @code{L[i+2]: L[i] - q L[i+1]}; el proceso termina en @code{L[i+1]} cuando el resto @code{r[i+2]} se anula.

@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gcdex (x^2 + 1, x^3 + 4);
@c % . [x^2 + 1, x^3 + 4, -1];

@example
(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
@end example

@c AQUI FALTA PARRAFO

@end deffn


@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@deffn {Función} gcfactor (@var{n})
Factoriza el entero gaussiano @var{n} como producto, a su vez, de enteros gaussianos, (un entero gaussiano es de la forma@code{@var{a} + @var{b} @code{%i}} donde @var{a} y @var{b} son números enteros). Los factores se normalizan de manera que tanto la parte real como imaginaria sean no negativas.
@c NEED EXAMPLES HERE

@end deffn

@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@deffn {Función} gfactor (@var{expr})
Factoriza el polinomio @var{expr} sobre los enteros gaussianos (un entero gaussiano es de la forma@code{@var{a} + @var{b} @code{%i}} donde @var{a} y @var{b} son números enteros).
@c "This is like" -- IS IT THE SAME OR NOT ??
Es como @code{factor (@var{expr}, @var{a}^2+1)} donde @var{a} vale @code{%i}.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gfactor (x^4 - 1);

@example
(%i1) gfactor (x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
@end example

@end deffn

@deffn {Función} gfactorsum (@var{expr})
Esta función es similar a @code{factorsum} pero aplica @code{gfactor} en lugar de @code{factor}.

@end deffn

@deffn {Función} hipow (@var{expr}, @var{x})
Devuelve el mayor exponente explícito de  @var{x} en @var{expr}.
El argumento@var{x} puede ser una variable o una expresión general.
Si @var{x} no aparece en @var{expr}, @code{hipow} devuelve @code{0}.

La función @code{hipow} no tiene en cuenta expresiones equivalentes a @code{expr}.
En particular, @code{hipow} no expande @code{expr}, de manera que @code{hipow (@var{expr}, @var{x})} y @code{hipow (expand (@var{expr}, @var{x}))} pueden dar resultados diferentes.

Ejemplos:

@example
(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
@end example

@end deffn

@defvr {Variable opcional} intfaclim
Valor por defecto: @code{true}

Si vale @code{true}, Maxima  desistirá de
factorizar enteros si no encuentra ningún factor después de las
divisiones tentativas y de aplicar el método rho de Pollard, por lo que 
la factorización puede quedar incompleta.

Si vale @code{false} (este es el caso cuando el usuario invoca explícitamente
a @code{factor}), se intentará la factorización completa del entero. El valor
asignado a @code{intfaclim} se utiliza en llamadas internas a @code{factor}. A la variable
@code{intfaclim} se le asigna el valor @code{false} cuando se calculan factores desde las
funciones @code{divisors}, @code{divsum} y @code{totient}.
@c ANY OTHERS ??

@c WHAT ARE THESE MYSTERIOUS INTERNAL CALLS ?? (LET'S JUST LIST THE FUNCTIONS INVOLVED)
Las llamadas internas a @code{factor} respetan el valor dado por el usuario a @code{intfaclim}.
Asignando a @code{intfaclim} el valor @code{true} se puede reducir  el tiempo que Maxima dedica a
factorizar enteros grandes.
@c NEED EXAMPLES HERE

@end defvr




@defvr {Variable opcional} keepfloat
Valor por defecto: @code{false}

Si @code{keepfloat} vale @code{true}, los números decimales en coma flotante no se racionalizan cuando las expresiones que los contienen se convierten al formato canónico racional (CRE).

Nótese que la función @code{solve} y todas aquellas otras que la
invocan (por ejemplo, @code{eigenvalues}) ignoran esta variable, por
lo que hacen la conversión de los números decimales.

Ejemplos:

@c ===beg===
@c rat(x/2.0);
@c rat(x/2.0), keepfloat;
@c ===end===
@example
(%i1) rat(x/2.0);

`rat' replaced 0.5 by 1/2 = 0.5
                                       x
(%o1)/R/                               -
                                       2
(%i2) rat(x/2.0), keepfloat;

(%o2)/R/                             0.5 x
@end example

@code{solve} ignora @code{keepfloat}:

@c ===beg===
@c solve(1.0-x,x), keepfloat;
@c ===end===
@example
(%i3) solve(1.0-x,x), keepfloat;

`rat' replaced 1.0 by 1/1 = 1.0
(%o3)                               [x = 1]
@end example
@end defvr



@deffn {Función} lopow (@var{expr}, @var{x})

Devuelve el menor exponente de @var{x} que aparece explícitamente
en @var{expr}.

@example
(%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
(%o1)                       min(a, 2)
@end example

@end deffn



@deffn {Función} lratsubst (@var{L}, @var{expr})
Esta función es similar a @code{subst (@var{L}, @var{expr})}, excepto por el hecho de que utiliza @code{ratsubst} en lugar de @code{subst}.

El primer argumento de @code{lratsubst} es una ecuación o lista de ecuaciones idénticas en formato a las aceptadas por @code{subst}.  Las sustituciones se hacen en el orden dado por la lista de ecuaciones, esto es, de izquierda a derecha.

La instrucción @code{load ("lrats")} carga @code{fullratsubst} y @code{lratsubst}.

Ejemplos:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c THIS STUFF CAN PROBABLY STAND REVISION -- EXAMPLES DON'T SEEM VERY ENLIGHTENING
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} can carry out multiple substitutions.
@code{lratsubst} is analogous to @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
If only one substitution is desired, then a single
equation may be given as first argument.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example

@end deffn


@defvr {Variable opcional} modulus
Valor por defecto: @code{false}

Si @code{modulus} es un número positivo @var{p}, las operaciones con números racionales
(como los devueltos por @code{rat} y funciones relacionadas) se realizan módulo @var{p},
utilizando el llamado sistema de módulo balanceado, en el que @code{@var{n} módulo @var{p}}
se define como un entero @var{k} de @code{[-(@var{p}-1)/2, ..., 0, ..., (@var{p}-1)/2]}
si @var{p} es impar, o de @code{[-(@var{p}/2 - 1), ..., 0, ...., @var{p}/2]} si @var{p} es par,
de tal manera que @code{@var{a} @var{p} + @var{k}} es igual a @var{n} para algún entero @var{a}.

Normalmente a @code{modulus} se le asigna un número primo. Se acepta que a @code{modulus}
se le asigne un entero positivo no primo, pero se obtendrá un mensaje de aviso. Maxima 
responderá con un mensaje de error cuando se le asigne a @code{modulus} cero o un número
negativo.

Ejemplos:

@example
(%i1) modulus:7;
(%o1)                           7
(%i2) polymod([0,1,2,3,4,5,6,7]);
(%o2)            [0, 1, 2, 3, - 3, - 2, - 1, 0]
(%i3) modulus:false;
(%o3)                         false
(%i4) poly:x^6+x^2+1;
                            6    2
(%o4)                      x  + x  + 1
(%i5) factor(poly);
                            6    2
(%o5)                      x  + x  + 1
(%i6) modulus:13;
(%o6)                          13
(%i7) factor(poly);
                      2        4      2
(%o7)               (x  + 6) (x  - 6 x  - 2)
(%i8) polymod(%);
                            6    2
(%o8)                      x  + x  + 1
@end example
@end defvr



@deffn {Función} num (@var{expr})
Devuelve el numerador de @var{expr} si se trata de una fracción. Si @var{expr} no es una fracción, se devuelve @var{expr}.

La función @code{num} evalúa su argumento.

@c NEED SOME EXAMPLES HERE
@end deffn

@deffn {Función} polydecomp (@var{p}, @var{x})

Descompone el polinomio @var{p} de variable @var{x} en una composición funcional de polinomios en @var{x}. 
La función @code{polydecomp} devuelve una lista @code{[@var{p_1}, ..., @var{p_n}]} tal que 

@example
lambda([x],p_1)(lambda ([x],p_2)(...(lambda([x],p_n)(x))...))
@end example

es igual a  @var{p}.
El grado de @var{p_i} es mayor que 1 para @var{i} menor que @var{n}.

Esta descomposición no es única.

Ejemplos:

@c ===beg===
@c polydecomp (x^210, x);
@c p : expand (subst (x^3 - x - 1, x, x^2 - a));
@c polydecomp (p, x);
@c ===end===
@example
(%i1) polydecomp (x^210, x);
                          7   5   3   2
(%o1)                   [x , x , x , x ]
(%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                6      4      3    2
(%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
(%i3) polydecomp (p, x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

La siguiente función compone @code{L = [e_1, ..., e_n]} como funciones de @code{x};
se trata de la inversa de @code{polydecomp}:

@c ===beg===
@c compose (L, x) :=
@c   block ([r : x], for e in L do r : subst (e, x, r), r) $
@c ===end===
@example
compose (L, x) :=
  block ([r : x], for e in L do r : subst (e, x, r), r) $
@end example

Se vuelve a obtener el resultado del ejemplo de más arriba haciendo uso de @code{compose}:

@c ===beg===
@c polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
@c ===end===
@example
(%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

Nótese que aunque @code{compose (polydecomp (@var{p}, @var{x}), @var{x})}
devuelve siempre @var{p} (sin expandir),
@code{polydecomp (compose ([@var{p_1}, ..., @var{p_n}], @var{x}), @var{x})}  @i{no}
devuelve necesariamente @code{[@var{p_1}, ..., @var{p_n}]}:

@c ===beg===
@c polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
@c polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
@c ===end===
@example
(%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                          2       2
(%o4)                   [x  + 2, x  + 1]
(%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                      2       2
                     x  + 3  x  + 5
(%o5)               [------, ------, 2 x + 1]
                       4       2
@end example

@end deffn



@deffn {Función} polymod (@var{p})
@deffnx {Función} polymod (@var{p}, @var{m})
Convierte el polinomio @var{p} a una representación modular respecto del módulo actual, que es el valor almacenado en la variable @code{modulus}.  

La llamada @code{polymod (@var{p}, @var{m})} especifica un módulo @var{m} para ser utilizado en lugar de valor almacenado en @code{modulus}.

Véase @code{modulus}.
@end deffn



@c ISN'T THERE AN EQUIVALENT FUNCTION SOMEWHERE ??
@c NEEDS WORK (IF KEPT)
@deffn {Función} powers (@var{expr}, @var{x})
Devuelve las potencias de @var{x} dentro de @var{expr}.

La instrucción @code{load (powers)} carga esta función.
@c HMM, THERE'S A BUNCH OF MAXIMA FUNCTIONS IN src/powers.lisp ...
@c FOR SOME REASON src/powers.lisp IS NOT PART OF THE USUAL BUILD -- STRANGE

@c HERE IS THE TEXT FROM archive/share/unknown/powers.usg -- MERGE !!!
@c THIS FUNCTION IS A GENERALISATION OF "HIPOW" AND "LOPOW"
@c IN THAT IT RETURNS A LIST OF ALL THE POWERS OF VAR OCCURING
@c IN EXPR. IT IS STILL NECESSARY TO EXPAND EXPR BEFORE APPLYING
@c POWERS (ON PAIN OF GETTING THE WRONG ANSWER).
@c 
@c THIS FUNCTION HAS MANY USES, E.G. IF YOU WANT TO FIND ALL
@c THE COEFFICIENTS OF X IN A POLYNOMIAL POLY YOU CAN USE
@c MAP(LAMBDA([POW],COEFF(POLY,X,POW)),POWERS(POLY,X));
@c AND MANY OTHER SIMILAR USEFUL HACKS.

@end deffn



@deffn {Función} quotient (@var{p_1}, @var{p_2})
@deffnx {Función} quotient (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Devuelve el polinomio @var{p_1} dividido por el polinomio @var{p_2}. Los argumentos @var{x_1}, ..., @var{x_n} se interpretan como en la función @code{ratvars}.

La función @code{quotient} devuelve el primer elemento de la lista devuelta por @code{divide}.

@c NEED SOME EXAMPLES HERE
@end deffn


@deffn {Función} rat (@var{expr})
@deffnx {Función} rat (@var{expr}, @var{x_1}, ..., @var{x_n})
Convierte @var{expr} al formato canónico racional (canonical rational expression o CRE) expandiendo y combinando todos los términos sobre un denominador común y cancelando el máximo común divisor del numerador y denominador, así como convirtiendo números decimales en coma flotante a números racionales dentro de la tolerancia indicada por @code{ratepsilon}. Las variables se ordenan de acuerdo a @var{x_1}, ..., @var{x_n} si se han especificado, como en la función @code{ratvars}.

En general, @code{rat} no simplifica otras funciones que no sean la suma @code{+}, resta @code{-}, multiplicación @code{*}, división @code{/} y exponenciación de exponente entero, mientras que @code{ratsimp} sí lo hace.
Nótese que los átomos (números y variables) en expresiones en formato CRE no son los mismos que en el formato general.
Por ejemplo, @code{rat(x)- x} devuelve @code{rat(0)}, que tiene una representación interna diferente de 0.

@c FALTA PARRAFO QUE NECESITA CLARIFICACION EN VERSION INGLESA

Si @code{ratprint} vale @code{false} no aparecerán mensajes informando al usuario sobre la conversión de números decimales en coma flotante a números racionales.

Si @code{keepfloat} vale @code{true} no se convertirán números decimales en coma flotante a números racionales.

Véanse también @code{ratexpand} y  @code{ratsimp}.

Ejemplos:
@c ===beg===
@c ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x)
@c         / (4*y^2 + x^2);
@c rat (%, y, a, x);
@c ===end===
@example
(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x)
         / (4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
@end example

@end deffn

@defvr {Variable opcional} ratalgdenom
Valor por defecto: @code{true}

Si @code{ratalgdenom} vale @code{true}, se permite la racionalización de denominadores eliminando radicales.
La variable @code{ratalgdenom} sólo tiene efecto cuando expresiones en formato canónico (CRE) están siendo utilizadas en modo algebraico.

@end defvr

@deffn {Función} ratcoef (@var{expr}, @var{x}, @var{n})
@deffnx {Función} ratcoef (@var{expr}, @var{x})
Devuelve el coeficiente de la expresión @code{@var{x}^@var{n}} dentro de la expresión @var{expr}. Si se omite, @var{n} se considera igual a 1.

El valor devuelto está libre de las variables en @var{x}, excepto quizás en un sentido no racional. Si no existe un coeficiente de este tipo se devuelve 0.

La función @code{ratcoef} expande y simplifica racionalmente su primer argumento, por lo que puede dar una respuesta diferente a la dada por la función @code{coeff}, la cual tiene un carácter puramente sintáctico.
Así, @code{ratcoef ((x + 1)/y + x, x)} devuelve @code{(y + 1)/y}, 
mientras que @code{coeff} devuelve 1.

La llamada @code{ratcoef (@var{expr}, @var{x}, 0)}, siendo @var{expr} una suma, devuelve una suma formada por los términos que no contienen @var{x}.

Puesto que @var{expr} se simplifica racionalmente antes de ser examinada, algunos coeficientes puede que no aparezcan como en la expresión original.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c s: a*x + b*x + 5$
@c ratcoef (s, a + b);

@example
(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
@end example
@c NEED MORE EXAMPLES HERE

@end deffn

@deffn {Función} ratdenom (@var{expr})
Devuelve el denominador de @var{expr}, después de transformar @var{expr} al formato canónico (CRE). El valor retornado está también en formato CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
El argumento @var{expr} se transforma al formato CRE por la función @code{rat}, a menos que ya esté en este formato.
Esta conversión puede cambiar la forma de @var{expr} colocando todos sus términos sobre un denominador común.

La función @code{denom} es parecida, pero devuelve una expresión general en lugar de una CRE. Tampoco @code{denom} intenta colocar todos sus términos sobre un denominador común, de manera que algunas expresiones que son consideradas como divisiones por @code{ratdenom}, no son tales para @code{denom}.

@c NEEDS AN EXAMPLE HERE
@end deffn

@defvr {Variable opcional} ratdenomdivide
Valor por defecto: @code{true}

Si @code{ratdenomdivide} vale @code{true}, la función @code{ratexpand} expande una fracción en la que el numerador es una suma en una suma de divisiones. En otro caso, @code{ratexpand} reduce una suma de divisiones a una única fracción, cuyo numerador es la suma de los denominadores de cada fracción.

Ejemplos:

@example
(%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                            2
                           x  + x + 1
(%o1)                      ----------
                              2
                             y  + 7
(%i2) ratdenomdivide: true$
(%i3) ratexpand (expr);
                       2
                      x        x        1
(%o3)               ------ + ------ + ------
                     2        2        2
                    y  + 7   y  + 7   y  + 7
(%i4) ratdenomdivide: false$
(%i5) ratexpand (expr);
@group
                            2
                           x  + x + 1
(%o5)                      ----------
                              2
                             y  + 7
@end group
(%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                     2
                           b        a
(%o6)                    ------ + ------
                          2        2
                         b  + 3   b  + 3
(%i7) ratexpand (expr2);
                                  2
                             b + a
(%o7)                        ------
                              2
                             b  + 3
@end example

@end defvr


@deffn {Función} ratdiff (@var{expr}, @var{x})
Deriva la expresión racional @var{expr} con respecto a @var{x}.
El argumento @var{expr} debe ser una fracción algebraica o un polinomio en @var{x}.
El argumento @var{x} puede ser una variable o una subexpresión de @var{expr}.
@c NOT CLEAR (FROM READING CODE) HOW x OTHER THAN A VARIABLE IS HANDLED --
@c LOOKS LIKE (a+b), 10*(a+b), (a+b)^2 ARE ALL TREATED LIKE (a+b);
@c HOW TO DESCRIBE THAT ??

El resultado equivale al devuelto por @code{diff}, aunque es posible que se obtenga en una forma diferente.
La función @code{ratdiff} puede ser más rápida que @code{diff} en expresiones racionales.

La función @code{ratdiff} devuelve una expresión en formato canónico o CRE si @code{expr} es también una expresión CRE. En otro caso, @code{ratdiff} devuelve una expresión general.

La función @code{ratdiff} considera únicamente la dependencia de @var{expr} respecto de @var{x}, ignorando cualquier dependencia establecida por @code{depends}.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
@c ratdiff (expr, x);
@c expr: f(x)^3 - f(x)^2 + 7;
@c ratdiff (expr, f(x));
@c expr: (a + b)^3 + (a + b)^2;
@c ratdiff (expr, a + b);

@example
(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) ratdiff (expr, x);
                    7       5       4       2
                 8 x  + 40 x  - 55 x  - 60 x  - 50
(%o2)          - ---------------------------------
                          10       5
                         x   + 10 x  + 25
(%i3) expr: f(x)^3 - f(x)^2 + 7;
                         3       2
(%o3)                   f (x) - f (x) + 7
(%i4) ratdiff (expr, f(x));
                           2
(%o4)                   3 f (x) - 2 f(x)
(%i5) expr: (a + b)^3 + (a + b)^2;
                              3          2
(%o5)                  (b + a)  + (b + a)
(%i6) ratdiff (expr, a + b);
                    2                    2
(%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a
@end example

@end deffn

@deffn {Función} ratdisrep (@var{expr})
Devuelve su argumento como una expresión general.
Si @var{expr} es una expresión general, se devuelve sin cambios.

Normalmente se invoca a @code{ratdisrep} a fin de convertir una expresión en formato canónico (CRE) al formato general, lo que puede ser utilizado si se quiere parar el contagio que produce el formato CRE, o para utilizar funciones racionales en contextos no racionales.

Véase también @code{totaldisrep}.

@end deffn


@deffn {Función} ratexpand (@var{expr})
@deffnx {Variable opcional} ratexpand
Expande @var{expr} multiplicando productos de sumas y sumas con exponentes, combinando fracciones con común denominador, cancelando el máximo común divisor del numerador y del denominador y luego dividiendo los sumandos del numerador por el denominador.

El valor que devuelve @code{ratexpand} es una expresión general, incluso cuando @var{expr} está en formato canónico o CRE.

Si la variable @code{ratexpand} vale @code{true} hará que las expresiones CRE se expandan completamente cuando se conviertan al formato general o se muestren en el terminal, mientras que si vale @code{false} se mostrarán de forma recursiva. Véase también @code{ratsimp}.

Si @code{ratdenomdivide} vale @code{true},
@code{ratexpand} expande una fracción en la que el numerador es una suma en una suma de fracciones, todas ellas con denominador común. En otro caso, @code{ratexpand} reduce una suma de fracciones en una única fracción, cuyo numerador es la suma de los numeradores de cada fracción.

Si @code{keepfloat} vale @code{true}, los números decimales en coma flotante no se racionalizan cuando las expresiones que los contienen se convierten al formato canónico racional (CRE).

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratexpand ((2*x - 3*y)^3);
@c expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
@c expand (expr);
@c ratexpand (expr);

@example
(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
@end example

@end deffn



@defvr {Variable opcional} ratfac
Valor por defecto: @code{false}

Si @code{ratfac} vale @code{true}, las expresiones canónicas (CRE) se manipulan en una forma parcialmente factorizada.

Durante las operaciones racionales, las expresiones se mantienen completamente factorizadas tanto como sea posible sin llamar a @code{factor}. Esto debería ahorrar espacio y tiempo en algunos cálculos. El numerador y denominador se hacen primos relativos, por ejemplo @code{rat ((x^2 - 1)^4/(x + 1)^2)} devuelve @code{(x - 1)^4 (x + 1)^2)}, pero los factores dentro de cada parte pueden no ser primos relativos.

En el paquete @code{ctensr} sobre manipulación de tensores por componentes, los tensores de Ricci, Einstein, Riemann y Weyl y la curvatura escalar se factorizan automáticamente si @code{ratfac} vale @code{true}; 
@i{@code{ratfac} debe activarse únicamente en aquellos casos en los que se sabe que el número de términos de las componentes tensoriales es pequño.}

Nota: Los esquemas de comportamiento basados en @code{ratfac} y @code{ratweight} son incompatibles y no se debe  pretender usarlos al mismo tiempo.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Función} ratnumer (@var{expr})
Devuelve el numerador de @var{expr}, después de reducir @var{expr} a su forma canónica (CRE).
El valor retornado está también en formato CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
El argumento @var{expr} se transforma al formato CRE por la función @code{rat}, a menos que ya esté en este formato.
Esta conversión puede cambiar la forma de @var{expr} colocando todos sus términos sobre un denominador común.

Es parecida a la función @code{num}, pero devuelve una expresión general en lugar de una CRE.
Además, @code{num} no intenta colocar todos los términos sobre un denominador común, de manera que algunas expresiones que son consideradas fracciones por @code{ratnumer} no se consideran como tales por @code{num}.
@end deffn


@deffn {Función} ratp (@var{expr})
Devuelve @code{true} si @var{expr} es una expresión canónica racional (canonical rational expression o CRE) o una CRE extendida, en caso contrario devuelve @code{false}.

Las expresiones CRE son creadas por @code{rat} y funciones asociadas. Las CRE extendidas son creadas por @code{taylor} y funciones asociadas.

@end deffn

@defvr {Variable opcional} ratprint
Valor por defecto: @code{true}

Si @code{ratprint} vale @code{true}, se muestra al usuario un mensaje dando cuenta de la conversión de números decimales en coma flotante a formato racional.

@end defvr

@deffn {Función} ratsimp (@var{expr})
@deffnx {Función} ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})
Simplifica la expresión @var{expr} y todas sus subexpresiones, incluyendo los argumentos de funciones no racionales. El resultado es un cociente de dos polinomios en una forma recursiva, esto es, los coeficientes de la variable principal son polinomios respecto de las otras variables. Las variables pueden incluir funciones no racionales, como @code{sin (x^2 + 1)}, y los argumentos de tales funciones son también racionalmente simplificados.

La llamada @code{ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})} permite la simplificación racional con la especificación del orden de las variables, como en @code{ratvars}.

Si @code{ratsimpexpons} vale @code{true}, @code{ratsimp} se aplica a los exponentes de las expresiones durante la simplificación.

Véase también @code{ratexpand}. Nótese que @code{ratsimp} se ve afectada por algunas de las variables globales que controlan a @code{ratexpand}.

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
@c ratsimp (%);
@c ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
@c ratsimp (%);
@c x^(a + 1/a), ratsimpexpons: true;

@example
(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
(%i4) ratsimp (%);
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
@end example

@end deffn



@defvr {Variable opcional} ratsimpexpons
Valor por defecto: @code{false}

Si @code{ratsimpexpons} vale @code{true}, @code{ratsimp} se aplica a los exponentes de las expresiones durante la simplificación.
@end defvr


@defvr {Variable opcional} radsubstflag
Valor por defecto: @code{false}

Si @code{radsubstflag} vale @code{true} se permite a @code{ratsubst} hacer la sustitución @code{u} por @code{sqrt (x)} in @code{x}.

@end defvr



@deffn {Función} ratsubst (@var{a}, @var{b}, @var{c})

Sustituye @var{b} por @var{a} en @var{c} y devuelve la expresión resultante.
@c "ETC" SUGGESTS THE READER KNOWS WHAT ELSE GOES THERE -- NOT LIKELY THE CASE
El argumento @var{b} puede ser una suma, un producto, una potencia, etc.

@c WHAT, EXACTLY, DOES ratsubst KNOW ??
La función @code{ratsubst} reconoce el significado de las expresiones, mientras que @code{subst} tan solo realiza sustituciones sintácticas. Así por ejemplo, @code{subst (a, x + y, x + y + z)} devuelve @code{x + y + z}
cuando @code{ratsubst} devuelve @code{z + a}.

Si @code{radsubstflag} vale @code{true},
@code{ratsubst} sustituye radicales en expresiones que no los contienen explícitamente.

@code{ratsubst} ignora el valor @code{true} de la variable 
opcional @code{keepfloat}.

Ejemplos:

@c ===beg===
@c ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
@c cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
@c ratsubst (1 - sin(x)^2, cos(x)^2, %);
@c ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
@c radsubstflag: false$
@c ratsubst (u, sqrt(x), x);
@c radsubstflag: true$
@c ratsubst (u, sqrt(x), x);
@c ===end===
@example
(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
(%i5) radsubstflag: false$
(%i6) ratsubst (u, sqrt(x), x);
(%o6)                           x
(%i7) radsubstflag: true$
(%i8) ratsubst (u, sqrt(x), x);
                                2
(%o8)                          u
@end example
@end deffn



@deffn {Función} ratvars (@var{x_1}, ..., @var{x_n})
@deffnx {Función} ratvars ()
@deffnx {Variable del sistema} ratvars
Declara como variables principales @var{x_1}, ..., @var{x_n} en expresiones racionales. Si @var{x_n} está presente en una expresión racional, se considerará como variable principal. Si no está presente, entonces se considerará principal a la variable @var{x_[n-1]} si aparece en la expresión, se continúa así hasta @var{x_1}, que se considerará como variable principal sólo si ninguna de las variables que le siguen está presente en la expresión.

Si una variable de la expresión racional no está presente en la lista @code{ratvars}, se le dará una prioridad inferior a la de @var{x_1}.

Los argumentos de @code{ratvars} pueden ser tanto variables como funciones no racionales como @code{sin(x)}.

La variable @code{ratvars} es una lista que contiene los argumentos pasados a la función @code{ratvars} la última vez que fue invocada. Cada llamada a la función @code{ratvars} reinicializa la lista. La llamada @code{ratvars ()} vacía la lista.

@end deffn



@defvr {Variable opcional} ratvarswitch
Valor por defecto: @code{true}

Maxima almacena una lista interna en la variable Lisp @code{VARLIST} cuyo
contenido son las variables principales de las expresiones racionales. Cuando @code{ratvarswitch}
vale @code{true}, su valor por defecto, cada evaluación comienza con la lista
@code{VARLIST} vacía. En caso contrario, las variables principales
de las expresiones anteriores se mantienen en la lista @code{VARLIST}.

Las variables principales declaradas con la función @code{ratvars} no se
ven afectadas por la opción @code{ratvarswitch}.

Ejemplos:

Cuando @code{ratvarswitch} vale @code{true}, su valor por defecto, cada 
evaluación comienza con la lista @code{VARLIST} vacía.

@c ===beg===
@c ratvarswitch:true$
@c rat(2*x+y^2);
@c :lisp varlist
@c rat(2*a+b^2);
@c :lisp varlist
@c ===end===
@example
(%i1) ratvarswitch:true$

(%i2) rat(2*x+y^2);
                             2
(%o2)/R/                    y  + 2 x
(%i3) :lisp varlist
($X $Y)

(%i3) rat(2*a+b^2);
                             2
(%o3)/R/                    b  + 2 a

(%i4) :lisp varlist
($A $B)
@end example

Cuando @code{ratvarswitch} vale @code{false}, las variables principales
de las expresiones anteriores se mantienen en lista @code{VARLIST}.

@c ===beg===
@c ratvarswitch:false$
@c rat(2*x+y^2);
@c :lisp varlist
@c rat(2*a+b^2);
@c :lisp varlist
@c ===end===
@example
(%i4) ratvarswitch:false$

(%i5) rat(2*x+y^2);
                             2
(%o5)/R/                    y  + 2 x
(%i6) :lisp varlist
($X $Y)

(%i6) rat(2*a+b^2);
                             2
(%o6)/R/                    b  + 2 a

(%i7) :lisp varlist
($A $B $X $Y)
@end example

@end defvr





@deffn {Función} ratweight (@var{x_1}, @var{w_1}, ..., @var{x_n}, @var{w_n})
@deffnx {Función} ratweight ()
Asigna un peso @var{w_i} a la variable @var{x_i}. Un término será reemplazado por 0 si su peso excede el valor de la variable @code{ratwtlvl} (por defecto no se realiza el truncamiento). El peso de un término es la suma de los productos de los pesos de las variables que lo forman multiplicados por sus exponentes. Por ejemplo, el peso de @code{3 x_1^2 x_2} es @code{2 w_1 + w_2}. El truncamiento basado en @code{ratwtlvl} solamente se lleva a cabo cuando se multiplican o se elevan a potencias expresiones canónicas (CRE).

La llamada @code{ratweight ()} devuelve la lista acumulada de asignaciones de pesos.

Nota: Los esquemas de comportamiento basados en @code{ratfac} y @code{ratweight} son incompatibles y no se debe  pretender usarlos al mismo tiempo.

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratweight (a, 1, b, 1);
@c expr1: rat(a + b + 1)$
@c expr1^2;
@c ratwtlvl: 1$
@c expr1^2;

@example
(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
@end example

@end deffn

@defvr {Variable del sistema} ratweights
Valor por defecto: @code{[]}

La variable @code{ratweights} es una lista que contiene los pesos asignados por @code{ratweight}.
Las lista es acumulativa, en el sentido de que cada llamada a @code{ratweight} añade nuevos elementos a la lista.

@end defvr

@defvr {Variable opcional} ratwtlvl
Valor por defecto: @code{false}

La variable @code{ratwtlvl} se utiliza en combinación con la función @code{ratweight} para controlar el truncamiento de expresiones racionales canónicas (CRE). Con el valor por defecto, @code{false}, no se produce truncamiento alguno.

@end defvr

@deffn {Función} remainder (@var{p_1}, @var{p_2})
@deffnx {Función} remainder (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Devuelve el resto de la división del polinomio @var{p_1} entre @var{p_2}. Los argumentos @var{x_1}, ..., @var{x_n} se interpretan como en @code{ratvars}.

La función @code{remainder} devuelve el segundo elemento de la lista retornada por @code{divide}.

@c NEED SOME EXAMPLES HERE
@end deffn

@deffn {Función} resultant (@var{p_1}, @var{p_2}, @var{x})
Calcula la resultante de los dos polinomios @var{p_1} y @var{p_2}, eliminando
la variable @var{x}. La resultante es un determinante de los coeficientes de @var{x}
en @var{p_1} y @var{p_2}, que es igual a cero si sólo si @var{p_1} y @var{p_2}
tienen un factor común no constante.

Si @var{p_1} o @var{p_2} pueden ser factorizados, puede ser necesario llamar a 
@code{factor} antes que invocar a @code{resultant}.

La variable opcional @code{resultant} controla qué algoritmo será utilizado para calcular la resultante.
Véanse @code{option_resultant} y @code{resultant}.

La función @code{bezout} toma los mismos argumentos que @code{resultant} y devuelve una matriz.
El determinante del valor retornado es la resultante buscada.

Ejemplos:

@example
(%i1) resultant(2*x^2+3*x+1, 2*x^2+x+1, x);
(%o1)                           8
(%i2) resultant(x+1, x+1, x);
(%o2)                           0
(%i3) resultant((x+1)*x, (x+1), x);
(%o3)                           0
(%i4) resultant(a*x^2+b*x+1, c*x + 2, x);
                         2
(%o4)                   c  - 2 b c + 4 a

(%i5) bezout(a*x^2+b*x+1, c*x+2, x);
@group
                        [ 2 a  2 b - c ]
(%o5)                   [              ]
                        [  c      2    ]
@end group
(%i6) determinant(%);
(%o6)                   4 a - (2 b - c) c
@end example
@end deffn



@defvr {Variable opcional} resultant
Valor por defecto: @code{subres}

La variable opcional @code{resultant} controla qué algoritmo será utilizado para
calcular la resultante con la función @code{resultant}. Los  valores posibles son:

@table @code
@item subres
para el algoritmo PRS (@i{polynomial remainder sequence}) subresultante,
@item mod
para el algoritmo resultante modular y
@item red
para el algoritmo PRS (@i{polynomial remainder sequence}) reducido.
@end table

En la mayor parte de problemas, el valor por defecto, @code{subres}, es el
más apropiado. Pero en el caso de problemas bivariantes o univariantes
de grado alto, puede ser mejor utilizar @code{mod}.
@end defvr



@defvr {Variable opcional} savefactors
Valor por defecto: @code{false}

@c "certain functions" -- WHICH ONES ??
Si @code{savefactors} vale @code{true}, los factores de una expresión producto se almacenan por ciertas funciones a fin de acelerar posteriores factorizaciones de expresiones que contengan algunos de estos factores.

@end defvr


@deffn {Función} showratvars (@var{expr})
Devuelve una lista de las variables de expresiones canónicas racionales (CRE) en la expresión @code{expr}.

Véase también @code{ratvars}.

@end deffn



@c FALTA DEFINICION DE sqfr


@deffn {Función} tellrat (@var{p_1}, ..., @var{p_n})
@deffnx {Función} tellrat ()
Añade al anillo de enteros algebraicos conocidos por Maxima los elementos que son soluciones de los polinomios @var{p_1}, ..., @var{p_n}. Cada argumento @var{p_i} es un polinomio de coeficientes enteros.

La llamada @code{tellrat (@var{x})} hace que se sustituya 0 por @var{x} en las funciones racionales.

La llamada @code{tellrat ()} devuelve una lista con las sustituciones actuales.

A la variable @code{algebraic} se le debe asignar el valor @code{true} a fin de poder realizar la simplificación de enteros algebraicos.

Maxima reconoce la unidad imaginaria @code{%i} y todas las raíces de los enteros.

La instrucción @code{untellrat} borra todas las propiedades de @code{tellrat}.

Es ambiguo aplicar @code{tellrat} a un polinomio multivariante tal como @code{tellrat (x^2 - y^2)}, pues no se sabe si sustituir @code{@var{y}^2} por @code{@var{x}^2} o al revés. Maxima sigue un cierto orden, pero si el usuario quiere especificar uno en concreto, puede hacerlo mediante la sintaxis @code{tellrat (y^2 = x^2)}, que indica que se ponga @code{@var{x}^2} en lugar de @code{@var{y}^2}.

Ejemplos:
@c EXAMPLE ADAPTED FROM example (tellrat)
@c 10*(%i + 1)/(%i + 3^(1/3));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (1 + a + a^2);
@c 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (y^2 = x^2);

@example
(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
@end example

@end deffn

@deffn {Función} totaldisrep (@var{expr})
Convierte cada subexpresión  de @var{expr} del formato canónico (CRE) al general y devuelve el resultado.
Si @var{expr} está en formato CRE entonces @code{totaldisrep} es idéntico a @code{ratdisrep}.

La función @code{totaldisrep} puede ser útil para modificar expresiones como las ecuaciones, listas, matrices, etc., que tienen algunas subexpresiones en formato CRE.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Función} untellrat (@var{x_1}, ..., @var{x_n})
Elimina de @var{x_1}, ..., @var{x_n} las propiedades relacionadas con @code{tellrat}.

@c NEED EXAMPLES HERE
@end deffn











































