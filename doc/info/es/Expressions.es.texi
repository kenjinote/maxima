@c English version 2011-09-03
@menu
* Introducción a las expresiones::
* Nombres y verbos::
* Identificadores::
* Desigualdades::
* Funciones y variables para expresiones::
@end menu

@node Introducción a las expresiones, Nombres y verbos, Expresiones, Expresiones
@section Introducción a las expresiones

Existe un cierto número de palabras reservadas
que no deberían
utilizarse como nombres de variables. Su uso podría causar 
errores sintácticos. 

@example
integrate            next           from                 diff            
in                   at             limit                sum             
for                  and            elseif               then            
else                 do             or                   if              
unless               product        while                thru            
step                                                                     
@end example

La mayoría de los objetos en Maxima son expresiones. Una secuencia
de expresiones puede constituir una expresión, separándolas por
comas y colocando paréntesis alrededor de ellas. Esto es similar a 
las @i{expresiones con coma} en @b{C}. 

@example
(%i1) x: 3$
(%i2) (x: x+1, x: x^2);
(%o2)                          16
(%i3) (if (x > 17) then 2 else 4);
(%o3)                           4
(%i4) (if (x > 17) then x: 2 else y: 4, y+x);
(%o4)                          20
@end example

Incluso los bucles en Maxima son expresiones, aunque el valor que
 retornan (@code{done}) no es muy útil. 

@example
(%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
(%i2) y;
(%o2)                         done
@end example

pero quizás se quiera incluir un tercer término en la @i{expresión con coma} para que devuelva el valor de interés. 

@example
(%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
(%i4) y;
(%o4)                        3628800
@end example










@node Nombres y verbos, Identificadores, Introducción a las expresiones, Expresiones
@section Nombres y verbos

Maxima distingue entre operadores que son "nombres" y operadores que son "verbos".
Un verbo es un operador que puede ser ejecutado.
Un nombre es un operador que aparece como un símbolo en una expresión pero sin ser ejecutado.
Por defecto, los nombres de funciones son verbos.
Un verbo puede transformarse en nombre utilizando el apóstrofo o aplicando la función @code{nounify}.
Un nombre puede transformarse en verbo aplicando la función @code{verbify}.
La variable @code{nouns} hace que @code{ev} evalúe los nombres presentes en una expresión.

La forma verbal se distingue mediante la precedencia del carácter dólar @code{$} al correspondiente símbolo de Lisp.
Por otro lado, la forma nominal se distingue mediante la precedencia del carácter porcentaje @code{%} al correspondiente símbolo de Lisp. 
Algunos nombres gozan de propiedades especiales para su representación, como @code{'integrate} o @code{'derivative}
(devuelto por @code{diff}), pero la mayoría no.
Por defecto, las formas nominal y verbal de una función son idénticas cuando se muestran en un terminal.
La variable global @code{noundisp} hace que Maxima muestre los nombres precedidos del apóstrofo @code{'}.

Véanse también @code{noun}, @code{nouns}, @code{nounify} y @code{verbify}.

Ejemplos:

@c ===beg===
@c foo (x) := x^2;
@c foo (42);
@c 'foo (42);
@c 'foo (42), nouns;
@c declare (bar, noun);
@c bar (x) := x/17;
@c bar (52);
@c bar (52), nouns;
@c integrate (1/x, x, 1, 42);
@c 'integrate (1/x, x, 1, 42);
@c ev (%, nouns);
@c ===end===
@example
(%i1) foo (x) := x^2;
                                     2
(%o1)                     foo(x) := x
(%i2) foo (42);
(%o2)                         1764
(%i3) 'foo (42);
(%o3)                        foo(42)
(%i4) 'foo (42), nouns;
(%o4)                         1764
(%i5) declare (bar, noun);
(%o5)                         done
(%i6) bar (x) := x/17;
                                     x
(%o6)                    ''bar(x) := --
                                     17
(%i7) bar (52);
(%o7)                        bar(52)
(%i8) bar (52), nouns;
                               52
(%o8)                          --
                               17
(%i9) integrate (1/x, x, 1, 42);
(%o9)                        log(42)
(%i10) 'integrate (1/x, x, 1, 42);
                             42
                            /
                            [   1
(%o10)                      I   - dx
                            ]   x
                            /
                             1
(%i11) ev (%, nouns);
(%o11)                       log(42)
@end example








@node Identificadores, Desigualdades, Nombres y verbos, Expresiones
@section Identificadores


En Maxima, los identificadores pueden contener caracteres alfabéticos, números del 0 al 9 y cualquier otro carácter precedido de la barra invertida @code{\}.

Un identificador puede comenzar con un carácter numérico si éste va precedido de la barra invertida @code{\}.
Los caracteres numéricos que ocupen la segunda posición o posterior no necesitan ir precedidos de la barra invertida.

Los caracteres pueden declararse como alfabéticos con la función @code{declare}.
Así declarados, no necesitan ir precedidos de la barra invertida en un identificador.
En principio, los caracteres alfabéticos son las letras de @code{A} a @code{Z} y
@code{a} a @code{z}, junto con  @code{%} y @code{_}.

Maxima distingue minúsculas y mayúsculas. Los identificadores @code{foo}, @code{FOO} y @code{Foo} son distintos.
Véase @ref{Lisp y Maxima} para más información.

Un identificador en Maxima es un símbolo Lisp que comienza con el símbolo dólar @code{$}.
Cualquier otro símbolo de Lisp va precedido de la interrogación @code{?} cuando aparece en Maxima.
Véase @ref{Lisp y Maxima} para más información.

Ejemplos:

@c ===beg===
@c %an_ordinary_identifier42;
@c embedded\ spaces\ in\ an\ identifier;
@c symbolp (%);
@c [foo+bar, foo\+bar];
@c [1729, \1729];
@c [symbolp (foo\+bar), symbolp (\1729)];
@c [is (foo\+bar = foo+bar), is (\1729 = 1729)];
@c baz\~quux;
@c declare ("~", alphabetic);
@c baz~quux;
@c [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
@c :lisp (defvar *my-lisp-variable* '$foo)
@c ?\*my\-lisp\-variable\*;
@c ===end===

@example
(%i1) %an_ordinary_identifier42;
(%o1)               %an_ordinary_identifier42
(%i2) embedded\ spaces\ in\ an\ identifier;
(%o2)           embedded spaces in an identifier
(%i3) symbolp (%);
(%o3)                         true
(%i4) [foo+bar, foo\+bar];
(%o4)                 [foo + bar, foo+bar]
(%i5) [1729, \1729];
(%o5)                     [1729, 1729]
(%i6) [symbolp (foo\+bar), symbolp (\1729)];
(%o6)                     [true, true]
(%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
(%o7)                    [false, false]
(%i8) baz\~quux;
(%o8)                       baz~quux
(%i9) declare ("~", alphabetic);
(%o9)                         done
(%i10) baz~quux;
(%o10)                      baz~quux
(%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
(%o11)                [false, false, false]
(%i12) :lisp (defvar *my-lisp-variable* '$foo)
*MY-LISP-VARIABLE*
(%i12) ?\*my\-lisp\-variable\*;
(%o12)                         foo
@end example









@node Desigualdades, Funciones y variables para expresiones, Identificadores, Expresiones
@section Desigualdades


Maxima dispone de los operadores de desigualdad @code{<}, @code{<=}, @code{>=}, @code{>}, @code{#} y @code{notequal}.
Véase @code{if} para una descripción de las expresiones condicionales.







@node Funciones y variables para expresiones,  , Desigualdades, Expresiones
@section Funciones y variables para expresiones


@deffn {Función} alias (@var{new_name_1}, @var{old_name_1}, ..., @var{new_name_n}, @var{old_name_n})
provee un nombre
alternativo para una (bien sea definida por el usuario o por el sistema) función, variable, arreglo, etc. 
Cualquier número par de argumentos puede ser usado. 
@end deffn


@defvr {Variable del sistema} aliases
Valor por defecto: @code{[]}

La variable @code{aliases} es la lista de átomos que tienen un "alias" definido por el usuario (establecido mediante las funciones  @code{alias}, @code{ordergreat} o @code{orderless} o declarando el átomo como un @code{noun} (nombre) con @code{declare}.
@end defvr



@defvr {Clave} allbut
Opera con los comandos @code{part} (como @code{part}, @code{inpart}, @code{substpart},
@code{substinpart}, @code{dpart} y @code{lpart}). Por ejemplo:

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, [2, 5]);
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, [2, 5]);
(%o2)                         d + a
@end example

mientras que: 

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, allbut (2, 5));
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, allbut (2, 5));
(%o2)                       e + c + b
@end example

La función @code{kill} también reconoce a @code{allbut}.

@c ===beg===
@c [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
@c kill (allbut (cc, dd));
@c [aa, bb, cc, dd];
@c ===end===
@example
(%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
(%o1)                 [11, 22, 33, 44, 55]
(%i2) kill (allbut (cc, dd));
(%o0)                         done
(%i1) [aa, bb, cc, dd];
(%o1)                   [aa, bb, 33, 44]
@end example

La sentencia @code{kill(allbut(@var{a_1}, @var{a_2}, ...))}
tiene el mismo efecto que @code{kill(all)}, excepto que no
elimina los símbolos @var{a_1}, @var{a_2}, ... .

@end defvr



@deffn {Función} args (@var{expr})

Devuelve la lista de argumentos de @code{expr}, que puede ser cualquier tipo de expresión a excepción de un átomo. Tan solo se muestran los argumentos del operador principal; subexpresiones de @code{expr} aparecen como elementos o subexpresiones de elementos de la lista de argumentos.

El orden de los miembros de la lista puede depender de la variable global @code{inflag}.

La llamada @code{args (@var{expr})} es equivalente a @code{substpart ("[", @var{expr}, 0)}.

Véanse también @code{substpart} y @code{op}.

@end deffn



@deffn {Función} atom (@var{expr})

Devuelve @code{true} si @var{expr} es un átomo (número, nombre o cadena alfanumérica) y @code{false} en caso contario. Así, @code{atom(5)} devolverá @code{true}, mientras que @code{atom(a[1])} y @code{atom(sin(x))} darán como resultado @code{false} (dando por hecho que tanto @code{a[1]} como @code{x} no tienen valores asignados).

@end deffn



@deffn {Función} box (@var{expr})
@deffnx {Función} box (@var{expr}, @var{a})
Devuelve @var{expr} encerrada en una caja.
El valor devuelto es una expresión con @code{box} como operador y @var{expr} como argumento.
Se dibujará una caja cuando @code{display2d} valga @code{true}.

La llamada @code{box (@var{expr}, @var{a})}
encierra @var{expr} en una caja etiquetada con el símbolo @var{a}.
La etiqueta se recorta si es más larga que el ancho de la caja.

La función @code{box} evalúa su argumento. Sin embargo, la expresión 
encerrada no se evalúa, siendo excluída de los cálculos.

La variable @code{boxchar} guarda el carácter a utilizar para dibujar la caja en las funciones @code{box}, @code{dpart} y @code{lpart}.

Ejemplos:

@c ===beg===
@c box (a^2 + b^2);
@c a : 1234;
@c b : c - d;
@c box (a^2 + b^2);
@c box (a^2 + b^2, term_1);
@c 1729 - box (1729);
@c boxchar: "-";
@c box (sin(x) + cos(y));
@c ===end===
@example
(%i1) box (a^2 + b^2);
                            """""""""
                            " 2    2"
(%o1)                       "b  + a "
                            """""""""
(%i2) a : 1234;
(%o2)                         1234
(%i3) b : c - d;
(%o3)                         c - d
(%i4) box (a^2 + b^2);
                      """"""""""""""""""""
                      "       2          "
(%o4)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i5) box (a^2 + b^2, term_1);
                      term_1""""""""""""""
                      "       2          "
(%o5)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i6) 1729 - box (1729);
                                 """"""
(%o6)                     1729 - "1729"
                                 """"""
(%i7) boxchar: "-";
(%o7)                           -
(%i8) box (sin(x) + cos(y));
                        -----------------
(%o8)                   -cos(y) + sin(x)-
                        -----------------
@end example

@end deffn



@defvr {Variable opcional} boxchar
Valor por defecto: @code{"}

La variable @code{boxchar} guarda el carácter a utilizar para dibujar la caja en las funciones @code{box}, @code{dpart} y @code{lpart}.

Todas las cajas en una expresión se dibujan con el valor actual de @code{boxchar}, carácter que no se almacena con las expresión encerrada.

@end defvr



@deffn {Función} collapse (@var{expr})

Colapsa @var{expr} haciendo que todas las subexpresiones que sean iguales
compartan las mismas celdas, ahorrando espacio. @code{collapse} es una
subrutina utilizada por la instrucción @code{optimize}. El uso de 
@code{collapse} puede ser útil después de  cargar un fichero 
creado con @code{save}. Se pueden colapsar varias expresiones de forma
conjunta utilizando @code{collapse ([@var{expr_1}, ..., @var{expr_n}])}.
También se pueden colapsar los elementos del array @code{A}
haciendo @code{collapse (listarray ('A))}.
@end deffn




@deffn {Función} disolate (@var{expr}, @var{x_1}, ..., @var{x_n})
Es similar a @code{isolate (@var{expr}, @var{x})}, excepto que permite al usuario aislar más de una variable simultáneamente. Puede ser útil para hacer un cambio de variables en integrales múltiples en las que tales variables dependan de de dos o más variables de integración.  Esta función se carga automáticamente desde 
@file{simplification/disol.mac}.  Se dispone de una demostyración en @code{demo("disol")$}.

@end deffn

@deffn {Función} dispform (@var{expr})
@deffnx {Function} dispform (@var{expr}, all)

@code{dispform(@var{expr})} devuelve la representación externa de
@var{expr} respecto del operador del nivel superior.
@code{dispform(@var{expr}, all)} devuelve la representación
externa respecto de todos los operadores que haya en @var{expr}.

Véase también @code{part}, @code{inpart} y @code{inflag}.

Ejemplos:

La representación interna de @code{- x} es "menos uno 
multiplicado por @code{x}", mientras que la representación externa es
"menos @code{x}".

@c ===beg===
@c - x;
@c ?format (true, "~S~%", %);
@c dispform (- x);
@c ?format (true, "~S~%", %);
@c ===end===
@example
(%i1) - x;
(%o1)                          - x
(%i2) ?format (true, "~S~%", %);
((MTIMES SIMP) -1 $X)
(%o2)                         false
(%i3) dispform (- x);
(%o3)                          - x
(%i4) ?format (true, "~S~%", %);
((MMINUS SIMP) $X)
(%o4)                         false
@end example

La representación interna de @code{sqrt(x)} es 
"@code{x} elevado a 1/2", mientras que su representación
externa es "raíz de @code{x}".

@c ===beg===
@c sqrt (x);
@c ?format (true, "~S~%", %);
@c dispform (sqrt (x));
@c ?format (true, "~S~%", %);
@c ===end===
@example
(%i1) sqrt (x);
(%o1)                        sqrt(x)
(%i2) ?format (true, "~S~%", %);
((MEXPT SIMP) $X ((RAT SIMP) 1 2))
(%o2)                         false
(%i3) dispform (sqrt (x));
(%o3)                        sqrt(x)
(%i4) ?format (true, "~S~%", %);
((%SQRT SIMP) $X)
(%o4)                         false
@end example

Utilización del argumento opcional @code{all}.

@c ===beg===
@c expr : sin (sqrt (x));
@c freeof (sqrt, expr);
@c freeof (sqrt, dispform (expr));
@c freeof (sqrt, dispform (expr, all));
@c ===end===
@example
(%i1) expr : sin (sqrt (x));
(%o1)                     sin(sqrt(x))
(%i2) freeof (sqrt, expr);
(%o2)                         true
(%i3) freeof (sqrt, dispform (expr));
(%o3)                         true
(%i4) freeof (sqrt, dispform (expr, all));
(%o4)                         false
@end example
@end deffn



@deffn {Función} dpart (@var{expr}, @var{n_1}, ..., @var{n_k})
Selecciona la misma expresión que @code{part}, pero en lugar de devolver esa expresión como su valor, devuelve la expresión completa con la subexpresión seleccionada dentro de una caja. La caja es parte de la expresión.

@example
(%i1) dpart (x+y/z^2, 1, 2, 1);
                             y
(%o1)                       ---- + x
                               2
                            """
                            "z"
                            """
@end example
@end deffn



@defvr {Variable opcional} exptisolate
Valor por defecto: @code{false}

Véase @code{isolate}.

@end defvr



@defvr {Variable opcional} exptsubst
Valor por defecto: @code{false}

Si @code{exptsubst} vale @code{true} permite la sustitución @code{y} por @code{%e^x} en @code{%e^(a x)}.

@c NEED EXAMPLES HERE
@end defvr




@deffn {Función} freeof (@var{x_1}, ..., @var{x_n}, @var{expr})

@code{freeof (@var{x_1}, @var{expr})}
devuelve @code{true} si ninguna subexpresión de @var{expr} coincide con @var{x_1},
o si @var{x_1} aparece como variable muda en @var{expr}, o si @var{x_1} no es ni
una forma nominal ni verbal de cualesquiera operadores presentes en @var{expr},
devolviendo @code{false} en otro caso.

La llamada @code{freeof (@var{x_1}, ..., @var{x_n}, @var{expr})}
equivale a @code{freeof (@var{x_1}, @var{expr}) and ... and freeof (@var{x_n}, @var{expr})}.

Los argumentos @var{x_1}, ..., @var{x_n} 
pueden seer nombres de funciones y variables, nombres subindicados,
operadores (encerrados entre comillas dobles) o expresiones generales.

La función @code{freeof} evalúa sus argumentos.

Una variable es una variable muda en una expresión si no tiene valor asignado fuera de la expresión.
Variable mudas reconocidas por  @code{freeof} son el índice de una suma o producto, la variable límite en @code{limit},
la variable de integración en la versión de integral definida de @code{integrate},
la variable original en @code{laplace},
variables formales en expresiones @code{at} y
los argumentos de las expresiones  @code{lambda}.

La versión indefinida de  @code{integrate} no está libre de su variable de integración.

Ejemplos:

Los argumentos son nombres de funciones, variables, nombres subindicados, operaores y expresiones. La llamada @code{freeof (a, b, expr)} equivale a @code{freeof (a, expr) and freeof (b, expr)}.

@example
(%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                 d + c  3
(%o1)                   cos(a ) b      z
                             1
(%i2) freeof (z, expr);
(%o2)                         false
(%i3) freeof (cos, expr);
(%o3)                         false
(%i4) freeof (a[1], expr);
(%o4)                         false
(%i5) freeof (cos (a[1]), expr);
(%o5)                         false
(%i6) freeof (b^(c+d), expr);
(%o6)                         false
(%i7) freeof ("^", expr);
(%o7)                         false
(%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
(%o8)                         true
@end example

@code{freeof} evalúa sus argumentos.

@example
(%i1) expr: (a+b)^5$
(%i2) c: a$
(%i3) freeof (c, expr);
(%o3)                         false
@end example

@code{freeof} no considera funciones equivalentes.
La simplificación puede dar una expresión equivalente pero diferente.

@example
(%i1) expr: (a+b)^5$
(%i2) expand (expr);
          5        4       2  3       3  2      4      5
(%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
(%i3) freeof (a+b, %);
(%o3)                         true
(%i4) freeof (a+b, expr);
(%o4)                         false
(%i5) exp (x);
                                 x
(%o5)                          %e
(%i6) freeof (exp, exp (x));
(%o6)                         true
@end example

Un sumatorio o integral definida está libre de su variable muda.
Una integral indefinida de  @code{integrate} no está libre de su variable de integración.

@example
(%i1) freeof (i, 'sum (f(i), i, 0, n));
(%o1)                         true
(%i2) freeof (x, 'integrate (x^2, x, 0, 1));
(%o2)                         true
(%i3) freeof (x, 'integrate (x^2, x));
(%o3)                         false
@end example
@end deffn




@defvr {Variable opcional} inflag
Valor por defecto: @code{false}

Si @code{inflag} vale @code{true}, las funciones para la extracción de partes inspeccionan la forma interna de @code{expr}.

Nótese que el simplificador reordena expresiones.
Así,  @code{first (x + y)} devuelve @code{x} si @code{inflag}
vale @code{true} y @code{y} si @code{inflag} vale @code{false}.
(@code{first (y + x)} devuelve el mismo resultado.)

Además, dándole a  @code{inflag} el valor @code{true} y llamando a @code{part} o  a @code{substpart} es lo mismo que llamar a @code{inpart} o a @code{substinpart}.

Las funciones que se ven afectadas por el valor de @code{inflag} son:
@code{part}, @code{substpart}, @code{first}, @code{rest}, @code{last}, @code{length},
la construcción @code{for} ... @code{in},
@code{map}, @code{fullmap}, @code{maplist}, @code{reveal} y @code{pickapart}.

@c NEED EXAMPLES HERE
@end defvr




@c NEEDS WORK
@deffn {Función} inpart (@var{expr}, @var{n_1}, ..., @var{n_k})
Similar a @code{part}, pero trabaja con la representación interna de la expresión, siendo más rápida. Se debe tener cuidado con el orden de subexpresiones en sumas y productos, pues el orden de las variables en la forma interna es normalmente diferente al que se muestra por el terminal, y cuando se trata con el signo menos unario, resta y división, pues estos operadores desaparecen de la expresión. Las llamadas @code{part (x+y, 0)} o @code{inpart (x+y, 0)} devuelven @code{+}, siendo necesario encerrar el operador entre comillas dobles cuando se haga referencia aél. Por ejemplo,
@code{... if inpart (%o9,0) = "+" then ...}.

Ejemplos:

@example
(%i1) x + y + w*z;
(%o1)                      w z + y + x
(%i2) inpart (%, 3, 2);
(%o2)                           z
(%i3) part (%th (2), 1, 2);
(%o3)                           z
(%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                  g(x + 1)
(%o4)                 limit   f(x)
                      x -> 0-
(%i5) inpart (%, 1, 2);
(%o5)                       g(x + 1)
@end example

@end deffn




@c NEEDS WORK
@deffn {Función} isolate (@var{expr}, @var{x})
Devuelve @var{expr} con subexpresiones que son sumas y que no contienen variables reemplazadas por etiquetas de expresiones intermedias (tales etiquetas son símbolos atómicos como @code{%t1}, @code{%t2}, ...).  Esta función es de utilidad para evitar la expansión innecesaria de subexpresiones que no contienen la variable de interés. Puesto que las etiquetas intermedias toman el valor de subexpresiones pueden ser todas sustituidas evaluando la expresión en la que aparecen.

Si la variable @code{exptisolate}, cuyo valor por defecto es @code{false}, vale @code{true} hará que @code{isolate} busque exponentes de átomos (como @code{%e}) que contengan la variable.

Si @code{isolate_wrt_times} vale @code{true}, entonces @code{isolate} también aislará respecto de los productos. Véase @code{isolate_wrt_times}.

Para ejemplos, ejecútese @code{example (isolate)}.

@end deffn

@c NEEDS WORK
@defvr {Variable opcional} isolate_wrt_times
Valor por defecto: @code{false}

Si @code{isolate_wrt_times} vale @code{true}, entonces @code{isolate} también aislará respecto de los productos. Compárese el comportamiento de @code{isolate} al cambiar el valor de esta variable global en el siguiente ejemplo,

@example
(%i1) isolate_wrt_times: true$
(%i2) isolate (expand ((a+b+c)^2), c);

(%t2)                          2 a


(%t3)                          2 b


                          2            2
(%t4)                    b  + 2 a b + a

                     2
(%o4)               c  + %t3 c + %t2 c + %t4
(%i4) isolate_wrt_times: false$
(%i5) isolate (expand ((a+b+c)^2), c);
                     2
(%o5)               c  + 2 b c + 2 a c + %t4
@end example

@end defvr




@c NEEDS EXAMPLES
@defvr {Variable opcional} listconstvars
Valor por defecto: @code{false}

Si @code{listconstvars} vale @code{true}, hará que @code{listofvars} incluya @code{%e}, @code{%pi}, @code{%i} y cualquier otra variable que sea declarada constante de las que aparezcan en el argumento de @code{listofvars}.
Estas constantes se omiten por defecto.

@end defvr

@defvr {Variable opcional} listdummyvars
Valor por defecto: @code{true}

Si @code{listdummyvars} vale @code{false}, las "variables mudas" de la expresión no serán incluídas en la lista devuelta por @code{listofvars}. (La definición de "variables mudas" se encuentra en la descripción de @code{freeof}.
"Variables mudas" son objetos matemáticos como el índice de un sumatorio o producto, una variable límite o la variable de una integración definida.)
Ejemplo:

@example
(%i1) listdummyvars: true$
(%i2) listofvars ('sum(f(i), i, 0, n));
(%o2)                        [i, n]
(%i3) listdummyvars: false$
(%i4) listofvars ('sum(f(i), i, 0, n));
(%o4)                          [n]
@end example

@end defvr




@c NEEDS WORK
@deffn {Función} listofvars (@var{expr})
Devuelve una lista con las variables presentes en @var{expr}.

Si la variable @code{listconstvars} vale @code{true} entonces
@code{listofvars} incluirá @code{%e}, @code{%pi}, @code{%i}
y cualquier otra variable declarada constante de las que aparezcan
en @var{expr}.  Estas constantes se omiten por defecto.

Véase también la variable opcional @code{listdummyvars} para
excluir o incluir variables ficticias en la lista de variables.

Ejemplo:

@example
(%i1) listofvars (f (x[1]+y) / g^(2+a));
(%o1)                     [g, a, x , y]
                                  1
@end example

@end deffn

@c NEEDS WORK
@deffn {Función} lfreeof (@var{list}, @var{expr})
Para cada miembro  @var{m} de @var{list}, realiza la llamada @code{freeof (@var{m}, @var{expr})}.
Devuelve @code{false} si alguna de estas llamadas a @code{freeof} retornó @code{false}, y @code{true} en caso contrario.
@end deffn



@c NEEDS WORK
@deffn {Función} lpart (@var{label}, @var{expr}, @var{n_1}, ..., @var{n_k})
Similar a @code{dpart} pero utiliza una caja etiquetada. Una caja etiquetada es similar a la que produce @code{dpart}, pero con un nombre en la línea superior.
@end deffn




@defvr {Propiedad} mainvar
Se pueden declarar variables de tipo @code{mainvar}.  El orden de los átomos 
es: números < constantes (como @code{%e} o @code{%pi}) <
escalares < otras variables < "mainvars".  Por ejemplo, compárese @code{expand ((X+Y)^4)}
con @code{(declare (x, mainvar), expand ((x+y)^4))}.  (Nota: Se debe tener cuidado si se quiere hacer uso de esta declaración. Por ejemplo, si se resta una expresión en la que @code{x} ha sido declarada como @code{mainvar} de otra en la que @code{x} no es @code{mainvar}, puede ser necesario volver a simplificar, @code{ev (expr, simp)}, a fin de obtener cancelaciones.  Además, si se guarda una expresión en la que @code{x} es @code{mainvar}, quizás sea necesario guardar también @code{x}.)

@end defvr



@defvr {Propiedad} noun
El símbolo @code{noun} es una de las opciones de la instrucción @code{declare}. Hace que una función se declare como "nombre", lo que significa que no se evaluará automáticamente.

@end defvr




@defvr {Variable opcional} noundisp
Valor por defecto: @code{false}

Si @code{noundisp} vale @code{true}, los nombres se muestran precedidos de un apóstrofo. Siempre debe valer @code{true} cuando se quiera representar la definición de funciones.

@end defvr



@c NEEDS WORK
@deffn {Función} nounify (@var{f})
Devuelve la forma nominal de la función cuyo nombre es @var{f}.  Puede ser útil cuando se quiera hacer referencia al nombre de una función sin que ésta se ejecute.  Nótese que algunas funciones verbales devolverán su forma nominal si no pueden ser evaluadas para ciertos argumentos.  Esta es también la expresión que se obtiene cuando la llamada a una función va precedida por del apóstrofo.

@end deffn

@c NEEDS WORK
@deffn {Función} nterms (@var{expr})
Devuelve el número de términos que  @var{expr} llegaría a tener si fuese completamente expandida y no hubiesen cancelaciones ni combinaciones de términos semejantes.
Nótese que expresiones como @code{sin (@var{expr})}, @code{sqrt (@var{expr})}, @code{exp (@var{expr})}, etc.
cuentan como un sólo término, independientemente de cuántos términos tenga a su vez @var{expr} en caso de tratarse de una suma.

@end deffn




@c NEEDS WORK
@deffn {Función} op (@var{expr})
Devuelve el operador principal de la expresión @var{expr}. La llamada
@code{op (@var{expr})} equivale a @code{part (@var{expr}, 0)}. 

La función @code{op} devuelve una cadena si el operador principal es un operador prefijo, infijo (binario o @code{n}-ario), postfijo, "bi-fijo" o "no-fijo" ("bi-fijo"  se refiere a un par de símbolos que encierran su o sus argumentos, y "no-fijo" es un operador que no necesita argumentos).
Si @var{expr} es la expresión de una función
subindicada, @code{op} devuelve la función subindicada;
en cuyo caso el valor devuelto no es un átomo.
En otro caso, @var{expr} es la expresión de una función array u
ordinaria, y entonces @code{op} devuelve un símbolo.

La función @code{op} observa el valor de la variable global @code{inflag}.

La función @code{op} evalúa sus argumentos.

Véase también @code{args}.

Ejemplos:

@c ===beg===
@c stringdisp: true$
@c op (a * b * c);
@c op (a * b + c);
@c op ('sin (a + b));
@c op (a!);
@c op (-a);
@c op ([a, b, c]);
@c op ('(if a > b then c else d));
@c op ('foo (a));
@c prefix (foo);
@c op (foo a);
@c op (F [x, y] (a, b, c));
@c op (G [u, v, w]);
@c ===end===

@example
(%i1) stringdisp: true$
(%i2) op (a * b * c);
(%o2)                          "*"
(%i3) op (a * b + c);
(%o3)                          "+"
(%i4) op ('sin (a + b));
(%o4)                          sin
(%i5) op (a!);
(%o5)                          "!"
(%i6) op (-a);
(%o6)                          "-"
(%i7) op ([a, b, c]);
(%o7)                          "["
(%i8) op ('(if a > b then c else d));
(%o8)                         "if"
(%i9) op ('foo (a));
(%o9)                          foo
(%i10) prefix (foo);
(%o10)                        "foo"
(%i11) op (foo a);
(%o11)                        "foo"
(%i12) op (F [x, y] (a, b, c));
(%o12)                        F
                               x, y
(%i13) op (G [u, v, w]);
(%o13)                          G
@end example

@end deffn


@c NEEDS WORK
@deffn {Función} operatorp (@var{expr}, @var{op})
@deffnx {Función} operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])

La llamada @code{operatorp (@var{expr}, @var{op})} devuelve @code{true}
si @var{op} es igual al operador de @var{expr}.

La llamada @code{operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])} devuelve @code{true}
si algún elemento  @var{op_1}, ..., @var{op_n} es igual al operador de @var{expr}.

@end deffn



@defvr {Variable opcional} opsubst
Valor por defecto: @code{true}

Si @code{opsubst} vale @code{false}, @code{subst} no sustituye el operdor de una expresión, de manera que @code{(opsubst: false, subst (x^2, r, r+r[0]))} trabajará correctamente.

@end defvr




@c NEEDS WORK
@deffn {Función} optimize (@var{expr})
Devuelve una expresión que produce el mismo valor y efectos secundarios que @var{expr}, pero de forma más eficiente al evitar recalcular subexpresiones comunes. La función @code{optimize} también tiene el efecto secundario de colapsar su argumento de manera que se compartan todas sus subexpresiones comunes.
Hágase @code{example (optimize)} para ver ejemplos.

@end deffn

@defvr {Variable opcional} optimprefix
Valor por defecto: @code{%}

La variable @code{optimprefix} es el prefijo utilizado para los símbolos generados por la instrucción @code{optimize}.

@end defvr

@deffn {Función} ordergreat (@var{v_1}, ..., @var{v_n})
@deffnx {Función} orderless (@var{v_1}, ..., @var{v_n})

@code{ordergreat} cambia el orden canónico de las expresiones de
Maxima, de manera que @var{v_1} prevalece sobre @var{v_2}, que
prevalece sobre ..., que prevalece sobre @var{v_n}, que prevalece
sobre cualquier otro símbolo no presente en la
lista de argumentos.

@code{orderless} cambia el orden canónico de las expresiones de
Maxima, de manera que @var{v_1} precede a @var{v_2}, que precede a ...,
que precede a @var{v_n}, que precede a cualquier otra variable no 
presente en la lista de argumentos.

El orden impuesto por @code{ordergreat} y @code{orderless} se 
destruye con @code{unorder}. @code{ordergreat} y @code{orderless}
sólo se pueden llamar una vez, a menos que se invoque a @code{unorder}.
La última llamada a @code{ordergreat} y @code{orderless} es la que
se mantiene activa.

Véase también @code{ordergreatp}.

@end deffn


@deffn {Función} ordergreatp (@var{expr_1}, @var{expr_2})
@deffnx {Función} orderlessp (@var{expr_1}, @var{expr_2})

@code{ordergreatp} devuelve @code{true} si @var{expr_1} prevalece sobre
@var{expr_2} en el orden canónico de las expresiones de Maxima, o
@code{false} en caso contrario.

@code{orderlessp} devuelve @code{true} si @var{expr_1} precede a
@var{expr_2} en el orden canónico de las expresiones de Maxima, o
@code{false} en caso contrario.

Todos los átomos y expresiones de Maxima son comparables bajo 
@code{ordergreatp} y @code{orderlessp}, aunque existen ejemplos aislados
de expresiones para los que estos predicados no son transitivos.

La ordenación canónica de átomos (símbolos, números
literales y cadenas) es la siguiente: (enteros y decimales en coma flotante)
preceden a (números decimales grandes o @i{bigfloats}), que preceden a (constantes
declaradas), que preceden a (cadenas), que preceden a (escalares declarados), que preceden a 
(primer argumento de @code{orderless}), que precede a ..., que precede a (último
argumento de @code{orderless}), que precede a (otros símbolos), que
preceden a (último argumento de @code{ordergreat}), que precede a ..., que
precede a (primer argumento de @code{ordergreat}), que precede a (variables
principales declaradas).

Para las expresiones no atómicas, la ordenación canónica se deriva de la
ordenación de átomos. Para los operadores nativos @code{+}, @code{*} y @code{^},
los criterios de ordenación no son sencillos de resumir.
Para otros operadores nativos, y todas las demás funciones y operadores,
las expresiones se ordenan por sus argumentos (empezando por el primero),
después por el nombre del operador o función. En caso de expresiones
con subíndices, el símbolo subindicado se
considera operador y el subíndice un argumento del mismo.

El orden canónico de expresiones se modifica mediante las funciones
@code{ordergreat} y @code{orderless}, así como por las 
declaraciones @code{mainvar}, @code{constant} y @code{scalar}.

Véase también @code{sort}.

Ejemplos:

Ordenación de símbolos comunes y constantes.
Nótese que @code{%pi} no se ordena en función de su valor
numérico.

@c ===beg===
@c stringdisp : true;
@c sort ([%pi, 3b0, 3.0, x, X, "foo", 3, a, 4, "bar", 4.0, 4b0]);
@c ===end===
@example
(%i1) stringdisp : true;
(%o1)                         true
(%i2) sort ([%pi, 3b0, 3.0, x, X, "foo", 3, a, 4, "bar", 4.0, 4b0]);
(%o2) [3, 3.0, 4, 4.0, 3.0b0, 4.0b0, %pi, "bar", "foo", a, x, X]
@end example

Efecto producido por las funciones @code{ordergreat} y @code{orderless}.

@c ===beg===
@c sort ([M, H, K, T, E, W, G, A, P, J, S]);
@c ordergreat (S, J);
@c orderless (M, H);
@c sort ([M, H, K, T, E, W, G, A, P, J, S]);
@c ===end===
@example
(%i1) sort ([M, H, K, T, E, W, G, A, P, J, S]);
(%o1)           [A, E, G, H, J, K, M, P, S, T, W]
(%i2) ordergreat (S, J);
(%o2)                         done
(%i3) orderless (M, H);
(%o3)                         done
(%i4) sort ([M, H, K, T, E, W, G, A, P, J, S]);
(%o4)           [M, H, A, E, G, K, P, T, W, J, S]
@end example

Efecto producido por las declaraciones @code{mainvar}, @code{constant} y @code{scalar}.

@c ===beg===
@c sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
@c declare (aa, mainvar);
@c declare ([baz, quux], constant);
@c declare ([A1, B1], scalar);
@c sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
@c ===end===
@example
(%i1) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
(%o1)   [aa, bar, baz, bb, cc, dd, foo, quux, A1, B1, C1]
(%i2) declare (aa, mainvar);
(%o2)                         done
(%i3) declare ([baz, quux], constant);
(%o3)                         done
(%i4) declare ([A1, B1], scalar);
(%o4)                         done
(%i5) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
(%o5)   [baz, quux, A1, B1, bar, bb, cc, dd, foo, C1, aa]
@end example

Ordenación de expresiones no atómicas.

@c ===beg===
@c sort ([1, 2, n, f(1), f(2), f(2, 1), g(1), g(1, 2), g(n), f(n, 1)]);
@c sort ([foo(1), X[1], X[k], foo(k), 1, k]);
@c ===end===
@example
(%i1) sort ([1, 2, n, f(1), f(2), f(2, 1), g(1), g(1, 2), g(n), f(n, 1)]);
(%o1) [1, 2, f(1), g(1), g(1, 2), f(2), f(2, 1), n, g(n), 
                                                         f(n, 1)]
(%i2) sort ([foo(1), X[1], X[k], foo(k), 1, k]);
(%o2)            [1, foo(1), X , k, foo(k), X ]
                              1              k
@end example
@end deffn


@c NEEDS WORK
@deffn {Función} part (@var{expr}, @var{n_1}, ..., @var{n_k})
Devuelve partes de la forma mostrada de @code{expr}. Obtiene la 
parte de @code{expr} que se especifica por los índices 
@var{n_1}, ..., @var{n_k}.  Primero se obtiene la parte @var{n_1} de 
@code{expr}, después la parte @var{n_2} del resultado anterior, 
y así sucesivamente.  El resultado que se obtiene es 
la parte @var{n_k} de ... la parte @var{n_2} de la parte @var{n_1} de @code{expr}.
Si no se especifican índices, devuelve @code{expr}.

La función @code{part} se puede utilizar para obtener un elemento 
de una lista, una fila de una matriz, etc.

@c "If the last argument to a part function" => FOLLOWING APPLIES TO OTHER FUNCTIONS ??
@c ATTEMPT TO VERIFY; IF SO, COPY THIS COMMENTARY TO DESCRIPTIONS OF OTHER FUNCTIONS
Si el último argumento de la función @code{part} es una lista de 
índices, entonces se toman varias subexpresiones, cada 
una de las cuales correspondiente a un índice de la lista.
Así, @code{part (x + y + z, [1, 3])} devuelve @code{z+x}.

La variable @code{piece} guarda la última expresión seleccionada
con la función @code{part}. Se actualiza durante la ejecución de
la función, por lo que puede ser referenciada en la misma función.

Si @code{partswitch} vale @code{true} entonces de devuelve @code{end}
cuando no exista la parte seleccionada de una expresión, si vale
@code{false} se mostrará un mensaje de error.

Véanse también @code{inpart}, @code{substpart}, @code{substinpart},
@code{dpart} y @code{lpart}.

Ejemplos:

@c ===beg===
@c part(z+2*y+a,2);
@c part(z+2*y+a,[1,3]);
@c part(z+2*y+a,2,1);
@c ===end===
@example
(%i1) part(z+2*y+a,2);
(%o1)                                 2 y
(%i2) part(z+2*y+a,[1,3]);
(%o2)                                z + a
(%i3) part(z+2*y+a,2,1);
(%o3)                                  2
@end example

La instrucción @code{example (part)} muestra más ejemplos.

@end deffn




@c NEEDS WORK
@deffn {Función} partition (@var{expr}, @var{x})
Devuelve una lista con dos expresiones, que son: (1) los factores de 
@var{expr} si es un producto, los términos de @var{expr} si es una
suma, o los elementos de @var{expr}, si es una lista, que no contengan
a @var{x}, (2) los factores, términos o lista que contengan a @var{x}.

@example
(%i1) partition (2*a*x*f(x), x);
(%o1)                     [2 a, x f(x)]
(%i2) partition (a+b, x);
(%o2)                      [b + a, 0]
(%i3) partition ([a, b, f(a), c], a); 
(%o3)                  [[b, c], [a, f(a)]]
@end example

@end deffn

@c NEEDS EXAMPLE
@defvr {Variable opcional} partswitch
Valor por defecto: @code{false}

Si @code{partswitch} vale @code{true} entonces de devuelve @code{end} cuando no exista la parte seleccionada de una expresión, si vale @code{false} se mostrará un mensaje de error.

@end defvr

@deffn {Función} pickapart (@var{expr}, @var{n})
Asigna etiquetas de expresiones intermedias a subexpresiones de @var{expr} al nivel de profundidad @var{n}, que es un entero. A las subexpresiones a un nivel de profundidad mayor o menor no se les asignan etiquetas. La función
@code{pickapart} devuelve una expresión en términos de expresiones intermedias equivalente a la expresión original @var{expr}.

Véanse también @code{part}, @code{dpart}, @code{lpart}, @code{inpart} y @code{reveal}.

Ejemplos:

@example
(%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                          2
                                     sin(x )   b + a
(%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2
(%i2) pickapart (expr, 0);

                                          2
                                     sin(x )   b + a
(%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2

(%o2)                          %t2
(%i3) pickapart (expr, 1);

(%t3)                - log(sqrt(x + 1) + 1)


                                  2
                             sin(x )
(%t4)                        -------
                                3


                              b + a
(%t5)                         -----
                                2

(%o5)                    %t5 + %t4 + %t3
(%i5) pickapart (expr, 2);

(%t6)                 log(sqrt(x + 1) + 1)


                                  2
(%t7)                        sin(x )


(%t8)                         b + a

                         %t8   %t7
(%o8)                    --- + --- - %t6
                          2     3
(%i8) pickapart (expr, 3);

(%t9)                    sqrt(x + 1) + 1


                                2
(%t10)                         x

                  b + a              sin(%t10)
(%o10)            ----- - log(%t9) + ---------
                    2                    3
(%i10) pickapart (expr, 4);

(%t11)                     sqrt(x + 1)

                      2
                 sin(x )   b + a
(%o11)           ------- + ----- - log(%t11 + 1)
                    3        2
(%i11) pickapart (expr, 5);

(%t12)                        x + 1

                   2
              sin(x )   b + a
(%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                 3        2
(%i12) pickapart (expr, 6);
                  2
             sin(x )   b + a
(%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                3        2
@end example

@end deffn

@c NEEDS WORK
@defvr {Variable del sistema} piece
Guarda la última expresión seleccionada por las funciones @code{part}.

@c NEED "SEE ALSO" TO POINT TO LIST OF ALL RELEVANT FUNCTIONS

@end defvr



@deffn  {Función} psubst (@var{list}, @var{expr})
@deffnx {Función} psubst (@var{a}, @var{b}, @var{expr})

@code{psubst(@var{a}, @var{b}, @var{expr})} es simliar a @code{subst}.  Véase 
@code{subst}.

A diferencia de @code{subst}, la función @code{psubst} hace sustituciones
en paralelo si su primer argumento es una lista de ecuaciones.

Véase también @code{sublis} para hacer sustituciones en paralelo.

Ejemplo:

El primer ejemplo muestra la sustitución en paralelo con @code{psubst}.
El segundo ejemplo muestra el resultado de la función @code{subst},
que realiza la sustitución en serie.

@c ===beg===
@c psubst ([a^2=b, b=a], sin(a^2) + sin(b));
@c subst ([a^2=b, b=a], sin(a^2) + sin(b));
@c ===end===
@example
(%i4) psubst ([a^2=b, b=a], sin(a^2) + sin(b));
(%o4)                           sin(b) + sin(a)
(%i5) subst ([a^2=b, b=a], sin(a^2) + sin(b));
(%o5)                              2 sin(a)
@end example

@end deffn




@deffn {Función} rembox (@var{expr}, unlabelled)
@deffnx {Función} rembox (@var{expr}, @var{label})
@deffnx {Función} rembox (@var{expr})
Elimina cajas de @var{expr}.

La llamada @code{rembox (@var{expr}, unlabelled)} elimina todas las cajas no etiquetadas de @var{expr}.

La llamada @code{rembox (@var{expr}, @var{label})} sólo elimina las cajas etiquetadas con @var{label}.

La llamada @code{rembox (@var{expr})} elimina todas las caajs, independientemente de que estén etiquetadas o no.

Las cajas son dibujadas por las funciones @code{box}, @code{dpart} y @code{lpart}.

Ejemplos:

@c ===beg===
@c expr: (a*d - b*c)/h^2 + sin(%pi*x);
@c dpart (dpart (expr, 1, 1), 2, 2);
@c expr2: lpart (BAR, lpart (FOO, %, 1), 2);
@c rembox (expr2, unlabelled);
@c rembox (expr2, FOO);
@c rembox (expr2, BAR);
@c rembox (expr2);
@c ===end===
@example
(%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                  a d - b c
(%o1)                sin(%pi x) + ---------
                                      2
                                     h
(%i2) dpart (dpart (expr, 1, 1), 2, 2);
                        """""""    a d - b c
(%o2)               sin("%pi x") + ---------
                        """""""      """"
                                     " 2"
                                     "h "
                                     """"
(%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                  FOO"""""""""""   BAR""""""""
                  "    """"""" "   "a d - b c"
(%o3)             "sin("%pi x")" + "---------"
                  "    """"""" "   "  """"   "
                  """"""""""""""   "  " 2"   "
                                   "  "h "   "
                                   "  """"   "
                                   """""""""""
(%i4) rembox (expr2, unlabelled);
                                  BAR""""""""
                   FOO"""""""""   "a d - b c"
(%o4)              "sin(%pi x)" + "---------"
                   """"""""""""   "    2    "
                                  "   h     "
                                  """""""""""
(%i5) rembox (expr2, FOO);
                                  BAR""""""""
                       """""""    "a d - b c"
(%o5)              sin("%pi x") + "---------"
                       """""""    "  """"   "
                                  "  " 2"   "
                                  "  "h "   "
                                  "  """"   "
                                  """""""""""
(%i6) rembox (expr2, BAR);
                   FOO"""""""""""
                   "    """"""" "   a d - b c
(%o6)              "sin("%pi x")" + ---------
                   "    """"""" "     """"
                   """"""""""""""     " 2"
                                      "h "
                                      """"
(%i7) rembox (expr2);
                                  a d - b c
(%o7)                sin(%pi x) + ---------
                                      2
                                     h
@end example

@end deffn




@deffn {Función} reveal (@var{expr}, @var{nivel})
Reemplaza partes de @var{expr} al @var{nivel} especificado y las sutituye por descripciones cortas.

@itemize @bullet
@item
Las sumas y restas se reemplazan por @code{Sum(@var{n})},
siendo @var{n} el número de términos de la suma.
@item
Los productos se reemplazan por @code{Product(@var{n})},
siendo @var{n} el número de factores del producto.
@item
Las potencias se reemplazan por @code{Expt}. 
@item
Los cocientes se reemplazan por @code{Quotient}.
@item
El símbolo negativo se reemplaza por @code{Negterm}.
@item
Las listas se reemplazan por @code{List(@var{n})}, siendo @var{n} el número de
elementos de la lista.
@end itemize

Si el entero  @var{depth} es mayor o igual que la profundidad máxima de @var{expr},
@code{reveal (@var{expr}, @var{depth})} devuelve @var{expr} sin modificar.

La función @code{reveal} evalúa sus argumentos y devuelve la expresión con las modificaciones solicitadas.

Ejemplo:

@c ===beg===
@c e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
@c reveal (e, 1);
@c reveal (e, 2);
@c reveal (e, 3);
@c reveal (e, 4);
@c reveal (e, 5);
@c reveal (e, 6);
@c ===end===
@example
(%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                          2            2
                         b  - 2 a b + a
(%o1)               -------------------------
                        b + a     2 b     2 a
                    2 %e      + %e    + %e
(%i2) reveal (e, 1);
(%o2)                       Quotient
(%i3) reveal (e, 2);
                             Sum(3)
(%o3)                        ------
                             Sum(3)
(%i4) reveal (e, 3);
                     Expt + Negterm + Expt
(%o4)               ------------------------
                    Product(2) + Expt + Expt
(%i5) reveal (e, 4);
                       2                 2
                      b  - Product(3) + a
(%o5)         ------------------------------------
                         Product(2)     Product(2)
              2 Expt + %e           + %e
(%i6) reveal (e, 5);
                         2            2
                        b  - 2 a b + a
(%o6)              --------------------------
                       Sum(2)     2 b     2 a
                   2 %e       + %e    + %e
(%i7) reveal (e, 6);
                          2            2
                         b  - 2 a b + a
(%o7)               -------------------------
                        b + a     2 b     2 a
                    2 %e      + %e    + %e
@end example
@end deffn



@deffn {Función} sublis (@var{list}, @var{expr})

Hace sustituciones múltiples en paralelo dentro de las expresiones.
@var{list} es una lista de ecuaciones, cuyos miembros izquierdos deben
ser átomos.

La variable @code{sublis_apply_lambda} controla la simplificación
después de @code{sublis}.

Véase también @code{psubst} para hacer sustituciones en paralelo.

Ejemplo:

@c ===beg===
@c sublis ([a=b, b=a], sin(a) + cos(b));
@c ===end===
@example
(%i1) sublis ([a=b, b=a], sin(a) + cos(b));
(%o1)                    sin(b) + cos(a)
@end example
@end deffn



@defvr {Variable opcional} sublis_apply_lambda
Valor por defecto: @code{true}

Controla si los @code{lambda} sustituidos son aplicados en la simplificación después de invocar a @code{sublis}, o si se tiene que hacer un @code{ev} para hacerlo. Si @code{sublis_apply_lambda} vale @code{true}, significa que se ejecute la aplicación.

@end defvr



@defvr {Variable opcional} subnumsimp
Valor por defecto: @code{false}

Si vale @code{true}, las funciones @code{subst} y @code{psubst} puede sustituir
una variable subindicada @code{f[x]} por un número simplemente utilizando el
símbolo @code{f}.

Véase también @code{subst}.

@example
(%i1) subst(100,g,g[x]+2);

subst: cannot substitute 100 for operator g in expression g
                                                           x
 -- an error. To debug this try: debugmode(true);

(%i2) subst(100,g,g[x]+2),subnumsimp:true;
(%o2)                          102
@end example

@end defvr




@deffn {Función} subst (@var{a}, @var{b}, @var{c})
Sustituye @var{a} por @var{b} en @var{c}. El argumento  @var{b} debe ser un átomo o una subexpresión completa de @var{c}.  Por ejemplo, @code{x+y+z} es una subexpresión completa de  @code{2*(x+y+z)/w} mientras que @code{x+y} no lo es. Cuando @var{b} no cumple esta característica, se puede utilizar en algunos casos @code{substpart} o @code{ratsubst}
(ver más abajo).  Alternativamente, si @var{b} no es de la forma @code{e/f} entonces se puede usar @code{subst (a*f, e, c)}, pero si @var{b} es de la forma @code{e^(1/f)} se debe usar @code{subst (a^f, e, c)}.  La instrucción @code{subst} también reconoce @code{x^y} en @code{x^-y}, de manera que  @code{subst (a, sqrt(x), 1/sqrt(x))} da @code{1/a}. Los argumentos @var{a} y @var{b} también pueden ser operadores de una expresión acotados por comillas dobles @code{"} o nombres de funciones.  Si se quiere sustituir la variable independiente en expresiones con derivadas se debe utilizar la función @code{at} (ver más abajo).

La función @code{subst} es sinónimo de @code{substitute}.

La llamada @code{subst (@var{eq_1}, @var{expr})} o 
@code{subst ([@var{eq_1}, ..., @var{eq_k}], @var{expr})}
están permitidas. Las @var{eq_i} son ecuaciones que indican las sustituciones a realizar.
Para cada ecuación, el miembro izquierdo será sustituido por la expresión del 
miembro derecho en @var{expr}. Las ecuaciones se sustituyen secuencialmente de
izquierda a derecha en @var{expr}. Véanse las funciones @code{sublis} y @code{psubst} 
para sustituciones en paralelo.

Si la variable @code{exptsubst} vale @code{true} se permiten ciertas
sustituciones de exponentes; por ejemplo, sustituir @code{y} por @code{%e^x}
en @code{%e^(a*x)}.

Si @code{opsubst} vale @code{false},
@code{subst} no intentará sustituir un operador de una expresión. Por ejemplo, 
@code{(opsubst: false, subst (x^2, r, r+r[0]))} trabajará sin problemas.

Ejemplos:

@c ===beg===
@c subst (a, x+y, x + (x+y)^2 + y);
@c subst (-%i, %i, a + b*%i);
@c ===end===
@example
(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
@end example

La sustitución se hace secuencialmente según una lista de
ecuaciones. Compárese con la sustitución en paralelo.

@c ===beg===
@c subst([a=b, b=c], a+b);
@c sublis([a=b, b=c], a+b);
@c ===end===
@example
(%i3) subst([a=b, b=c], a+b);
(%o3)                                 2 c
(%i4) sublis([a=b, b=c], a+b);
(%o4)                                c + b
@end example

@noindent
Para más ejemplos, ejecútese @code{example (subst)}.

@end deffn



@deffn {Función} substinpart (@var{x}, @var{expr}, @var{n_1}, @dots{}, @var{n_k})

Es similar a @code{substinpart}, pero trabaja con la representación interna de @var{expr}.

Ejemplos:

@c ===beg===
@c x . 'diff (f(x), x, 2);
@c substinpart (d^2, %, 2);
@c substinpart (f1, f[1](x + 1), 0);
@c ===end===
@example
(%i1) x . 'diff (f(x), x, 2);
                              2
                             d
(%o1)                   x . (--- (f(x)))
                               2
                             dx
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x + 1), 0);
(%o3)                       f1(x + 1)
@end example

Si el último argumento pasado a la función @code{part} es una
lista de índices, se obtendrá la lista de subexpresiones
correspondientes a cada uno de los índices.

@c ===beg===
@c part (x + y + z, [1, 3]);
@c ===end===
@example
(%i1) part (x + y + z, [1, 3]);
(%o1)                         z + x
@end example

La variable @code{piece} guarda el valor de la última expresión seleccionada al
utilizar las funciones @code{part}. El valor es asignado durante la 
ejecución de la función y puede ser utilizada tal como se muestra más
abajo. Si a @code{partswitch} se le asigna el valor @code{true} entonces se
devolverá @code{end} cuando no existe la parte solicitada; con otro
valor devuelve un mensaje de error.

@c ===beg===
@c expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
@c part (expr, 2, [1, 3]);
@c sqrt (piece/54);
@c substpart (factor (piece), expr, [1, 2, 3, 5]);
@c expr: 1/x + y/x - 1/z;
@c substpart (xthru (piece), expr, [2, 3]);
@c ===end===
@example
(%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
              3         2       2            3
(%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
(%i2) part (expr, 2, [1, 3]);
                                  2
(%o2)                         54 y
(%i3) sqrt (piece/54);
(%o3)                        abs(y)
(%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                               3
(%o4)               (3 y + 2 x)  + y + x + 1
(%i5) expr: 1/x + y/x - 1/z;
                             1   y   1
(%o5)                      - - + - + -
                             z   x   x
(%i6) substpart (xthru (piece), expr, [2, 3]);
                            y + 1   1
(%o6)                       ----- - -
                              x     z
@end example

Además, dándole a @code{inflag} el valor @code{true} y llamando a
@code{part} o @code{substpart} es lo mismo que invocar a  @code{inpart} o @code{substinpart}.

@end deffn



@deffn {Función} substpart (@var{x}, @var{expr}, @var{n_1}, @dots{}, @var{n_k})

Sustituye por @var{x} la subexpresión que se obtiene de aplicar el resto de
argumentos a la función @code{part}, devolviendo el nuevo valor de @var{expr}.
@var{x} puede ser un operador que sustituya otro operador de @var{expr}. En
ciertos casos, @var{x} necesita estar entrecomillado por comillas dobles (@code{"});
por ejemplo, de @code{substpart ("+", a*b, 0)} se obtiene @code{b + a}.

Ejemplo:

@c ===beg===
@c 1/(x^2 + 2);
@c substpart (3/2, %, 2, 1, 2);
@c a*x + f(b, y);
@c substpart ("+", %, 1, 0);
@c ===end===
@example
(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
                               1
(%o2)                       --------
                             3/2
                            x    + 2
(%i3) a*x + f(b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart ("+", %, 1, 0);
(%o4)                    x + f(b, y) + a
@end example

Además, dándole a @code{inflag} el valor @code{true} y llamando a
@code{part} o @code{substpart} es lo mismo que invocar a  @code{inpart} o @code{substinpart}.

@end deffn



@deffn {Función} symbolp (@var{expr})
Devuelve @code{true} si @var{expr} es un símbolo y @code{false} en caso contrario.
La llamada @code{symbolp(x)} equivale al predicado @code{atom(x) and not numberp(x)}.

Véase también @code{Identifiers}.

@end deffn




@deffn {Función} unorder ()
Desactiva las asociaciones creadas por la última utilización de los comandos de ordenación @code{ordergreat} y @code{orderless}, los cuales no pueden ser utilizados más de una vez sin invocar a @code{unorder}. 

@code{unorder} no sustituye en expresiones los símbolos originales
por los alias introducidos por @code{ordergreat} y @code{orderless}. Es por ello
que tras la ejecuciÃ³n de @code{unorder} los alias aparecen en expresiones
anteriores.

Véase también @code{ordergreat} y @code{orderless}.

Ejemplos:

@code{ordergreat(a)} introduce un alias para el símbolo @code{a},
razón por la cual la diferencia de @code{%o2} y @code{%o4} no se anula.
@code{unorder} no restablece el símbolo @code{a} y el alias
aparece en el resultado @code{%o7}.

@c ===beg===
@c unorder();
@c b*x + a^2;
@c ordergreat (a);
@c b*x + a^2;
@c  %th(1) - %th(3);
@c unorder();
@c %th(2);
@c ===end===
@example
(%i1) 
(%o1)                          []
(%i2) b*x+a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat(a);
(%o3)                         done
(%i4) b*x+a^2;
                             2
(%o4)                       a  + b x
(%i5) %th(1)-%th(3);
                              2    2
(%o5)                        a  - a
(%i6) unorder();
(%o6)                          [a]
(%i7) %th(2);
                                2    2
(%o7)                      _101a  - a
@end example
@end deffn




@deffn {Función} verbify (@var{f})
Devuelve la forma verbal del nombre de función @var{f}.

Véanse también @code{verb}, @code{noun} y @code{nounify}.

Ejemplos:

@c ===beg===
@c verbify ('foo);
@c :lisp $%
@c nounify (foo);
@c :lisp $%
@c ===end===
@example
(%i1) verbify ('foo);
(%o1)                          foo
(%i2) :lisp $%
$FOO
(%i2) nounify (foo);
(%o2)                          foo
(%i3) :lisp $%
%FOO
@end example

@end deffn

