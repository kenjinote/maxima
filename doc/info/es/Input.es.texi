@c English version 2011-08-21
@menu
* Comentarios::
* Archivos::
* Funciones y variables para lectura y escritura::
* Funciones y variables para salida TeX::
* Funciones y variables para salida Fortran::
@end menu

@node Comentarios, Archivos, Lectura y escritura, Lectura y escritura
@section Comentarios

En Maxima, un comentario es cualquier texto encerrado entre las
marcas @code{/*} y @code{*/}.

El analizador sintáctico de Maxima trata los comentarios como
espacios en blanco a efectos de encontrar @i{tokens} en el flujo
de entrada. Una entrada tal como @code{a/* foo */b} contiene dos
@i{tokens}, @code{a} y @code{b}, no un único @i{token} @code{ab}.
En cualquier otro contexto, los comentarios son ignorados por Maxima;
no se almacenan ni sus contenidos ni sus localizaciones.

Los comentarios pueden anidarse hasta una profundidad arbitraria.
Las marcas  @code{/*} y @code{*/} deben emparejarse y debe haber igual número
de ambos.

Ejemplos:

@c ===beg===
@c /* aa is a variable of interest */  aa : 1234;
@c /* Value of bb depends on aa */  bb : aa^2;
@c /* User-defined infix operator */  infix ("b");
@c /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
@c /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
@c ===end===
@example
(%i1) /* aa is a variable of interest */  aa : 1234;
(%o1)                         1234
(%i2) /* Value of bb depends on aa */  bb : aa^2;
(%o2)                        1522756
(%i3) /* User-defined infix operator */  infix ("b");
(%o3)                           b
(%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
(%o4)                         a b c
(%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
(%o5)                        xyz + 1
@end example


@node Archivos, Funciones y variables para lectura y escritura, Comentarios, Lectura y escritura
@section Archivos

Un archivo no es más que una área de un cierto dispositivo de almacenamiento que contiene datos o texto.
Los archivos se agrupan en los discos en "directorios", que son listas de archivos.
Instrucciones que operan con archivos son:

@example
   appendfile           batch                 batchload
   closefile            file_output_append    filename_merge
   file_search          file_search_maxima    file_search_lisp
   file_search_demo     file_search_usage     file_search_tests
   file_type            file_type_lisp        file_type_maxima
   load                 load_pathname         loadfile
   loadprint            pathname_directory    pathname_name
   pathname_type        printfile             save
   stringout            with_stdout           writefile
@end example

Cuando el nombre de un fichero se pasa a funciones como @code{plot2d}, @code{save} o 
@code{writefile} y en él no se incluye la ruta de acceso, Maxima almacena
el fichero en la carpeta de trabajo actual. La ubicación de la carpeta de 
trabajo depende del sistema operativo y de la instalación.


@node Funciones y variables para lectura y escritura, Funciones y variables para salida TeX, Archivos, Lectura y escritura
@section Funciones y variables para lectura y escritura


@deffn {Función} appendfile (@var{filename})
Añade información de la consola a @var{filename}, de igual manera que lo hace @code{writefile}, pero con la salvedad de que si el archivo ya existe la información queda añadida al final de su contenido.

La función @code{closefile} cierra los archivos abiertos por @code{appendfile} o @code{writefile}.

@end deffn



@deffn {Función} batch (@var{filename})
@deffnx {Function} batch (@var{filename}, @code{option})

@code{batch(@var{filename})} lee expresiones de Maxima desde @var{filename} y 
las evalúa. La función @code{batch} busca @var{filename} en la lista 
@code{file_search_maxima}. Véase @code{file_search}.

@code{batch(@var{filename}, @code{test})} es como @code{run_testsuite} con la
opción @code{display_all=true}. En este caso @code{batch} busca @var{filename} 
en la lista @code{file_search_maxima} y no en @code{file_search_tests} como hace
@code{run_testsuite}. Además, @code{run_testsuite} ejecuta tests que están
en la lista @code{testsuite_files}. Con @code{batch} es posible ejecutar
cualquier fichero que se encuentre en @code{file_search_maxima} en modo de prueba.

El contenido de @var{filename} debe ser una secuencia de expresiones de Maxima,
cada una de las cuales termina en @code{;} o @code{$}.
La variable especial @code{%} y la función @code{%th}
se refieren a resultados previos dentro del archivo.
El archivo puede incluir construcciones del tipo @code{:lisp}.
Espacios, tabulaciones y saltos de línea en el archivo se ignoran.
Un archivo de entrada válido puede crearse con un editor de texto o con la 
función @code{stringout}.

La función @code{batch} lee las expresiones del archivo @var{filename}, 
muestra las entradas en la consola, realiza los cálculos solicitados y 
muestra las expresiones de los resultados.
A las expresiones de entrada se les asignan etiquetas, así 
como a las de salida. La función @code{batch} evalúa todas las expresiones 
de entrada del archivo a menos que se produzca un error. Si se le solicita 
información al usuario (con @code{asksign} o @code{askinteger}, por ejemplo)
@code{batch} se detiene para leer la nueva información para luego continuar.

Es posible detener  @code{batch} tecleando @code{control-C} desde la consola.
El efecto de @code{control-C} depende del entorno Lisp instalado.

La función @code{batch} tiene diversas aplicaciones, tales como servir de 
almacén de código escrito por el usuario, suministrar demostraciones
libres de errores o ayudar a organizar el trabajo del usuario en la resolución 
de problemas complejos.

La función @code{batch} evalúa su argumento y devuelve la ruta hacia
@var{filename} en formato cadena cuando es invocada sin segundo argumento
o con la opción @code{demo}. Cuando es llamada con la opción @code{test}, 
devuelve la lista vacía @code{[]} o una lista con @var{filename}
y los números de tests que han fallado.

Véanse también  @code{load}, @code{batchload} y @code{demo}.

@end deffn

@deffn {Función} batchload (@var{filename})
Lee expresiones de Maxima desde @var{filename} y las evalúa sin mostrar las entradas ni las salidas y sin asignarles etiquetas. Sin embargo, las salidas producidas por  @code{print} o @code{describe} sí se muestran.

La variable especial @code{%} y la función @code{%th} se refieren a resultados previos del intérprete interactivo, no a los del propio archivo. El archivo no puede incluir construcciones del tipo @code{:lisp}.

La función @code{batchload} devuelve la ruta de @var{filename} en formato de cadena.

La función @code{batchload} evalúa sus argumentos.

Véanse también @code{batch} y @code{load}.
@c batchload APPEARS TO HAVE THE SAME EFFECT AS load. WHY NOT GET RID OF batchload ???

@end deffn



@deffn {Función} closefile ()
La función @code{closefile} cierra los archivos abiertos por @code{appendfile} o @code{writefile}.

@end deffn


@defvr {Variable opcional} file_output_append
Valor por defecto: @code{false}

La variable @code{file_output_append} controla si las funciones de escritura de ficheros añaden información o sustituyen el fichero de salida. Cuando @code{file_output_append} toma el valor @code{true}, estas funciones amplían el contenido de sus ficheros de salida; en otro caso, sustituyen el fichero anterior de igual nombre por otro con el nuevo contenido.

Las funciones @code{save}, @code{stringout} y @code{with_stdout} se ven afectadas por el valor que tome la variable @code{file_output_append}. Otras funciones que también escriben en ficheros de salida no tienen en cuenta este valor; en concreto, las funciones para la representación de gráficos y las de traducción siempre sustituyen el fichero anterior por uno nuevo de igual nombre, mientras que las funciones @code{tex} y @code{appendfile} siempre añaden información al fichero de salida sin eliminar la información anterior.
@c WHAT ABOUT WRITEFILE ??

@end defvr



@deffn {Función} filename_merge (@var{path}, @var{filename})
Construye una ruta modificada a partir de @var{path} y @var{filename}.
Si la componente final de @var{path} es de la forma @code{###.@var{something}},
la componente se reemplaza con @code{@var{filename}.@var{something}}.
En otro caso, la componente final se reemplaza simplemente por @var{filename}.

El resultado es un objeto Lisp de tipo @i{pathname}.
@end deffn



@deffn {Función} file_search (@var{filename})
@deffnx {Función} file_search (@var{filename}, @var{pathlist})

La función @code{file_search} busca el archivo @var{filename} y devuelve su ruta como una cadena; si no lo encuentra,  @code{file_search} devuelve @code{false}. La llamada 
@code{file_search (@var{filename})} busca en los directorios de búsqueda por defecto,
que son los especificados por las variables @code{file_search_maxima}, @code{file_search_lisp} y @code{file_search_demo}.

La función @code{file_search} analiza primero si el nombre del argumento existe antes de hacerlo coincidir con los comodines de los patrones de búsqueda de archivos.
Véase @code{file_search_maxima} para más información sobre patrones de búsqueda de archivos.

El argumento @var{filename} puede ser una ruta con nombre de archivo,
o simplemente el nombre del archivo, o, si el directorio de búsqueda de archivo incluye un patrón de búsqueda, es suficiente con el nombre de archivo sin extensión.
Por ejemplo,

@example
file_search ("/home/wfs/special/zeta.mac");
file_search ("zeta.mac");
file_search ("zeta");
@end example

todos buscan el mismo archivo, dando por hecho que el archivo existe y que @code{/home/wfs/special/###.mac}
está en @code{file_search_maxima}.

La llamada @code{file_search (@var{filename}, @var{pathlist})} busca solamente en los directorios especificados por @var{pathlist}, que es una lista de cadenas.
El argumento @var{pathlist} ignora los directorios de búsqueda por defecto, de manera que si se da la lista de rutas, @code{file_search} busca solamente en ellas y no en los directorios por defecto.
Incluso si hay un único directorio en @var{pathlist}, debe ser suministrado como una lista de un único elemento.

El usuario puede modificar los directorios de búsqueda por defecto; véase para ello See @code{file_search_maxima}.

La función @code{file_search} es llamada por @code{load} con los directorios de búsqueda @code{file_search_maxima} y @code{file_search_lisp}.
@end deffn



@defvr {Variable opcional} file_search_maxima
@defvrx {Variable opcional} file_search_lisp
@defvrx {Variable opcional} file_search_demo
@defvrx {Variable opcional} file_search_usage
@defvrx {Variable opcional} file_search_tests

Estas variables especifican listas de directorios en los que deben buscar la funciones  @code{load}, @code{demo} y algunas otras. Los valores por defecto de estas variables nombran directorios de la instalación de Maxima.

El usuario puede modificar estas variables, bien reemplazando los valores por defecto, bien añadiendo nuevos directorios.
Por ejemplo,

@example
file_search_maxima: ["/usr/local/foo/###.mac",
    "/usr/local/bar/###.mac"]$
@end example

reemplaza el valor por defecto de @code{file_search_maxima}, mintras que

@example
file_search_maxima: append (file_search_maxima,
    ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$
@end example

añade dos directorios más. Puede ser conveniente colocar una expresión como esta en el archivo @code{maxima-init.mac}, de manera que la ruta de búsqueda de ficheros se asigne automáticamente cada vez que arranca Maxima.

Se pueden especificar varias extensiones de archivos y rutas con comodines especiales.
La cadena @code{###} representa el nombre del archivo buscado y una lista separada de comas y encerrada entre llaves,  @code{@{foo,bar,baz@}} representa múltiples cadenas.
Por ejemplo, suponiendo que se busca el nombre @code{neumann},

@example
"/home/@{wfs,gcj@}/###.@{lisp,mac@}"
@end example

se interpreta como @code{/home/wfs/neumann.lisp}, @code{/home/gcj/neumann.lisp}, @code{/home/wfs/neumann.mac} y @code{/home/gcj/neumann.mac}.
@end defvr


@deffn {Función} file_type (@var{filename})
Devuelve una descripción del contenido de @var{filename} basada en la 
extensión, sin intentar abrir el archivo para inspeccionar su contenido.

El valor devuelto es un símbolo @code{object}, @code{lisp} o 
@code{maxima}. Si la extensión es "mac", "mc", "demo", "dem", "dm1", "dm2", 
"dm3" o "dmt", @code{file_type} devuelve @code{maxima}. Si la extensión es 
"l", "lsp" o "lisp", @code{file_type} devuelve @code{lisp}. Si la extensión
no es ninguna de las anteriores, @code{file_type} devuelve @code{object}.

Véase también @code{pathname_type}.

Ejemplos:

@c ===beg===
@c map('file_type,["test.lisp", "test.mac", "test.dem", "test.txt"]);
@c ===end===
@example
(%i2) map('file_type,["test.lisp", "test.mac", "test.dem", "test.txt"]);
(%o2)            [lisp, maxima, maxima, object]
@end example
@end deffn



@defvr {Variable opcional} file_type_lisp
Valor por defecto:  @code{[l, lsp, lisp]}

@code{file_type_lisp} es una lista con extensiones de ficheros que Maxima 
reconoce como fuente de Lisp.

Véase también @code{file_type}
@end defvr



@defvr {Variable opcional} file_type_maxima
Valor por defecto:  @code{[mac, mc, demo, dem, dm1, dm2, dm3, dmt]}

@code{file_type_maxima} es una lista con extensiones de ficheros que Maxima 
reconoce como fuente de Maxima.

Véase también @code{file_type}
@end defvr




@deffn {Función} load (@var{filename})
Evalúa las expresiones del archivo @var{filename}, trayendo variables,
funciones y otros objetos a Maxima. Una asignación hecha previamente a 
una variable en Maxima será destruida por otra asignación que se le 
haga en @var{filename}. Para encontrar el fichero, @code{load} llama a 
@code{file_search} con @code{file_search_maxima} y @code{file_search_lisp} 
como directorios de búsqueda. Si la llamada a @code{load} funciona correctamente, 
devuelve el nombre del fichero; en caso contrario, @code{load} muestra un mensaje de error.

La función @code{load} trabaja indistintamente con código Lisp y Maxima.
Los ficheros creados con @code{save}, @code{translate_file} y @code{compile_file}, 
que crea código Lisp, y @code{stringout}, que crea código Maxima, todos ellos 
pueden ser procesados por @code{load}. La función @code{load} llama a @code{loadfile} 
para cargar archivos en Lisp y a  @code{batchload} para cargar archivos en Maxima.

La función @code{load} no reconoce las construcciones de tipo @code{:lisp} en
ficheros de Maxima. Además, mientras se está procesando @var{filename},
las variables globales @code{_}, @code{__}, @code{%} y @code{%th} mantienen los
valores que tenían cuando se realizó la llamada a @code{load}.

Véanse también @code{loadfile}, @code{batch}, @code{batchload} y @code{demo};
@code{loadfile} procesa archivos en Lisp; @code{batch}, @code{batchload} y @code{demo}
procesan archivos en Maxima.

Véase @code{file_search} para más detalles sobre el mecanismo de búsqueda de archivos.

La función @code{load} evalúa sus argumentos.

@end deffn



@defvr {Variable del sistema} load_pathname
Valor por defecto: @code{false}

Cuando se carga un fichero con las funciones @code{load}, @code{loadfile}
o @code{batchload}, a la variable @code{load_pathname} se le asigna la
ruta al fichero en cuestión.

Se puede acceder a la variable @code{load_pathname} mientras se está
cargando el fichero.

Ejemplo:

Supóngase que se tiene el fichero @code{test.mac} en la carpeta
@code{"/home/usuario/workspace/mymaxima/temp/"} con las siguientes
instrucciones:

@example
print("The value of load_pathname is: ", load_pathname)$
print("End of batchfile")$
@end example

Entonces se obtiene el siguiente resultado:

@example
(%i1) load("/home/usuario/workspace/mymaxima/temp/test.mac")$
The value of load_pathname is:  
                   /home/usuario/workspace/mymaxima/temp/test.mac 
End of batchfile
@end example
@end defvr


@deffn {Función} loadfile (@var{filename})
Evalúa las expresiones Lisp del archivo @var{filename}. La función
@code{loadfile} no llama a @code{file_search}, de manera que @code{filename} debe incluir la extensión del archivo y su ruta completa.

La función @code{loadfile} puede procesar ficheros creados por  @code{save}, @code{translate_file} y @code{compile_file}.
Puede ser más conveniente utilizar @code{load} en lugar de @code{loadfile}.
@end deffn



@defvr {Variable opcional} loadprint
Valor por defecto: @code{true}

La variable @code{loadprint} indica si mostrar un mensaje cuando se carga un archivo.

@itemize @bullet
@item
Si @code{loadprint} vale @code{true}, se muestra siempre un mensaje.
@item
Si @code{loadprint} vale @code{'loadfile}, muestra un mensaje sólo si el archivo es cargado con la función @code{loadfile}.
@item
Si @code{loadprint} vale @code{'autoload}, muestra un mensaje sólo cuandi un archivo se carga automáticamente. Véase  @code{setup_autoload}.
@item
Si @code{loadprint} vale @code{false}, nunca mostrará mensajes.
@end itemize

@end defvr



@defvr {Variable opcional} packagefile
Valor por defecto: @code{false}

Los desarrolladores de paquetes que utilizan @code{save} o @code{translate}
para crear paquetes (ficheros) que van a ser utilizados por terceros pueden
hacer @code{packagefile: true} para evitar que se añada información a la
listas de información de Maxima, como @code{values} o @code{functions}.
@end defvr



@deffn  {Función} pathname_directory (@var{pathname})
@deffnx {Función} pathname_name (@var{pathname})
@deffnx {Función} pathname_type (@var{pathname})

Estas funciones devuelven las componentes de @var{pathname}.

Ejemplos:

@c ===beg===
@c pathname_directory("/home/usuario/maxima/changelog.txt");
@c pathname_name("/home/usuario/maxima/changelog.txt");
@c pathname_type("/home/usuario/maxima/changelog.txt");
@c ===end===
@example 
(%i1) pathname_directory("/home/usuario/maxima/changelog.txt");
(%o1)                 /home/usuario/maxima/
(%i2) pathname_name("/home/usuario/maxima/changelog.txt");
(%o2)                       changelog
(%i3) pathname_type("/home/usuario/maxima/changelog.txt");
(%o3)                          txt
@end example

@end deffn



@deffn {Función} printfile (@var{path})

Envía el fichero al que hace referncia la ruta @var{path}
a la consola. @var{path} puede ser una cadena o un símbolo,
en cuyo caso se convertirá en una cadena.

Si @var{path} hace referencia a un fichero accesible desde el directorio
actual de trabajo, entonces se enviará a la consola; en caso contrario,
@code{printfile} intentará localizar el fichero añadiéndole @var{path}
a cada uno de los elementos de @code{file_search_usage} a través de 
@code{filename_merge}.

@code{printfile} devuelve la ruta del fichero encontado.

@end deffn




@deffn {Función} save (@var{filename}, @var{name_1}, @var{name_2}, @var{name_3}, ...)
@deffnx {Función} save (@var{filename}, values, functions, labels, ...)
@deffnx {Función} save (@var{filename}, [@var{m}, @var{n}])
@deffnx {Función} save (@var{filename}, @var{name_1}=@var{expr_1}, ...)
@deffnx {Función} save (@var{filename}, all)
@deffnx {Función} save (@var{filename}, @var{name_1}=@var{expr_1}, @var{name_2}=@var{expr_2}, ...)

Alamacena los valores actuales de @var{name_1}, @var{name_2}, @var{name_3}, ..., 
en el archivo @var{filename}. Los argumentos son nombres de variables, funciones 
u otros objetos. Si un nombre no tiene un valor o una función asociado a él, 
entonces se ignora.

La función @code{save} devuelve @var{filename}.

La función @code{save} almacena datos en forma de expresiones Lisp.
Los datos almacenados por @code{save} pueden recuperarse con @code{load (@var{filename})}.
El resultado de ejecutar  @code{save} cuando @var{filename} ya existe depende 
del soporte Lisp implementado; el archivo puede ser sobreescrito o que @code{save} 
envíe un mesaje de error.

La llamada @code{save (@var{filename}, values, functions, labels, ...)}
almacena los elementos cuyos nombres son @code{values}, @code{functions}, 
@code{labels}, etc. Los nombres pueden ser cualesquiera de los especificados 
por la variable @code{infolists}; @code{values} incluye todas las variables 
definidas por el usuario.

La llamada @code{save (@var{filename}, [@var{m}, @var{n}])} almacena los valores 
de las etiquetas de entrada y salida desde @var{m} hasta @var{n}. Nótese que 
@var{m} y @var{n} deben ser números. Las etiquetas de entrada y salida 
también se pueden almacenar una a una, por ejemplo, @code{save ("foo.1", %i42, %o42)}.
La llamada @code{save (@var{filename}, labels)} almacena todas las etiquetas de 
entrada y salida. Cuando las etiquetas almacenadas en el archivo sean posteriormente 
recuperadas, se sobreescribirán las activas en ese momento.

La llamada @code{save (@var{filename}, @var{name_1}=@var{expr_1}, @var{name_2}=@var{expr_2}, ...)}
almacena los valores de @var{expr_1}, @var{expr_2}, ...,
con los nombres @var{name_1}, @var{name_2}, ....
Es útil hacer este tipo de llamada para con etiquetas de entrada y salida, por ejemplo, @code{save ("foo.1", aa=%o88)}.
El miembro derecho de la igualdad puede ser cualquier expresión, que será evaluada.
Esta llamada a la función @code{save} no incorpora nuevos nombres a la sesión actual de Maxima,
simplemente los almacena en el archivo @var{filename}.

Todas estas formas de llamar a la función @code{save} se pueden combinar a voluntad.
Por ejemplo, @code{save (@var{filename}, aa, bb, cc=42, functions, [11, 17])}.

La llamada @code{save (@var{filename}, all)} almacena el estado actual de Maxima, 
lo que incluye todas las variables definidas por el usuario, funciones, arreglos, etc., 
así como algunos objetos definidos automáticamente.
Los elementos almacenados incluyen variables del sistema, como @code{file_search_maxima} o 
@code{showtime}, si han sido modificadas por el usuario. Véase @code{myoptions}.

@code{save} evalúa @var{filename} pero no el resto de argumentos.
@end deffn



@deffn {Función} stringout (@var{filename}, @var{expr_1}, @var{expr_2}, @var{expr_3}, ...)
@deffnx {Función} stringout (@var{filename}, [@var{m}, @var{n}])
@deffnx {Función} stringout (@var{filename}, input)
@deffnx {Función} stringout (@var{filename}, functions)
@deffnx {Función} stringout (@var{filename}, values)

La función @code{stringout} escribe expresiones en un archivo de la misma forma en 
que se escribirían como expresiones de entrada. El archivo puede ser 
utilizado entonces como entrada a las funciones @code{batch} o @code{demo}, y puede 
ser editado para cualquier otro propósito.

La forma general de @code{stringout} escribe los valores de una o más expresiones 
en el archivo de salida. Nótese que si una expresión es una variable, solamente se 
escribirá el valor de la variable y no el nombre de ésta. Como caso especial, y muy 
útil en algunas ocasiones, las expresiones pueden ser etiquetas de entrada (@code{%i1}, 
@code{%i2}, @code{%i3}, ...) o de salida (@code{%o1}, @code{%o2}, @code{%o3}, ...).

Si @code{grind} vale @code{true}, @code{stringout} formatea la salida utilizando @code{grind}. 
En caso contrario, se utilizará el formato @code{string}. Véanse @code{grind} y @code{string}.

La forma especial @code{stringout (@var{filename}, [@var{m}, @var{n}])} escribe los valores 
de las etiquetas de entrada desde la m hasta la n, ambas inclusive. 

La forma especial @code{stringout (@var{filename}, input)} escribe todas las etiquetas de
entrada en el archivo.

La forma especial @code{stringout (@var{filename}, functions)} escribe todas las funciones 
definidas por el usuario, contenidas en la lista global @code{functions}, en el archivo.

La forma especial @code{stringout (@var{filename}, values)} escribe todas las variables 
asignadas por el usuario, contenidas en la lista global @code{values}, en el archivo. 
Cada variable se escribe como una sentencia de asignación, con el nombre de la variable 
seguida de dos puntos y a continuación su valor. Nótese que la forma general de 
@code{stringout} no escribe las variables como sentencias de asignación.
@end deffn


@deffn {Función} with_stdout (@var{f}, @var{expr_1}, @var{expr_2}, @var{expr_3}, ...)
@deffnx {Función} with_stdout (@var{s}, @var{expr_1}, @var{expr_2}, @var{expr_3}, ...)
Evalúa  @var{expr_1}, @var{expr_2}, @var{expr_3}, ...
y escribe los resultados en el fichero @var{f} o flujo de salida @var{s}.
Las expresiones que se evalúan no se escriben. La salida puede generarse por medio
de @code{print}, @code{display}, @code{grind} entre otras funciones.

La variable global @code{file_output_append} controla si @code{with_stdout}
añade o reinicia el contenido del fichero de salida @var{f}.
Si @code{file_output_append} vale @code{true}, @code{with_stdout} añade
contenido al fichero de salida. En cualquier caso, @code{with_stdout}
crea el fichero si éste no existe.

La función @code{with_stdout} devuelve el valor de su último argumento.

Véase también @code{writefile}.

@c THIS DOESN'T SEEM VERY IMPORTANT TO MENTION ...
@c Note the binding of display2d to be
@c false, otherwise the printing will have things like "- 3" instead
@c of "-3".
@c
@example
@c THIS EXAMPLE USES SOME UNIX-ISH CONSTRUCTS -- WILL IT WORK IN WINDOWS ???
@c ALSO IT'S SORT OF COMPLICATED AND THE SIMPLER SECOND EXAMPLE ILLUSTRATES with_stdout BETTER !!!
@c mygnuplot (f, var, range, number_ticks) :=
@c  block ([numer:true, display2d:false],
@c  with_stdout("tmp.out",
@c    dx: (range[2]-range[1])/number_ticks,
@c    for x: range[1] thru range[2] step dx
@c       do print (x, at (f, var=x))),
@c  system ("echo \"set data style lines; set title '", f,"' ;plot '/tmp/gnu'
@c ;pause 10 \" | gnuplot"))$
(%i1) with_stdout ("tmp.out", 
                   for i:5 thru 10 do print (i, "! yields", i!))$
(%i2) printfile ("tmp.out")$
5 ! yields 120 
6 ! yields 720 
7 ! yields 5040 
8 ! yields 40320 
9 ! yields 362880 
10 ! yields 3628800
@end example
@end deffn




@deffn {Función} writefile (@var{filename})
Comienza escribiendo una transcripción de la sesión de Maxima en el archivo @var{filename}.
Cualquier interacción entre Maxima y el usuario se almacena también en este archivo, tal como aparece en la consola.

Puesto que la transcripción se escribe en el formato de salida a la consola, su contenido no es interpretable por Maxima.
Para hacer un archivo que contenga expresiones que puedan ser nuevamente cargadas en Maxima, véanse @code{save} y @code{stringout}; la función @code{save} almacena expresiones en formato Lisp, mientras que @code{stringout} lo hace en formato Maxima.

El resultado de ejecutar @code{writefile} cuando el archivo @var{filename} ya existe depende del entorno Lisp operativo; el contenido anterior puede ser sobreescrito o ampliado con la sesión actual. La función @code{appendfile} siempre añade la sesión al contenido actual.

Puede ser útil ejecutar @code{playback} después de @code{writefile} para guardar las interacciones previas de la sesión. Puesto que  @code{playback} muestra solamente las variables de entrada y salida (@code{%i1}, @code{%o1}, etc.),
cualquier salida generada por una sentencia de impresión desde dentro de una función no es mostrada por @code{playback}.

La función @code{closefile} cierra los archivos abiertos por @code{writefile} o @code{appendfile}.
@end deffn




@node Funciones y variables para salida TeX, Funciones y variables para salida Fortran, Funciones y variables para lectura y escritura, Lectura y escritura
@section Funciones y variables para salida TeX


@deffn {Función} tex (@var{expr})
@deffnx {Función} tex (@var{expr}, @var{destination})
@deffnx {Función} tex (@var{expr}, false)
@deffnx {Función} tex (@var{label})
@deffnx {Función} tex (@var{label}, @var{destination})
@deffnx {Función} tex (@var{label}, false)

Devuelve la expresión en un formato apropiado para para ser 
incorporado a un documento basado en TeX. El resultado que se 
obtiene es un fragmento de código que puede incluirse en un documento mayor, pero que
no puede ser procesado aisladamente.

La instrucción @code{tex (@var{expr})} imprime en la consola 
la representación en TeX de @var{expr}.

La instrucción @code{tex (@var{label})} imprime en la consola la 
representación en TeX de la expresión a la que hace referencia la 
etiqueta @var{label}, asignándole a su vez una etiqueta de ecuación 
que será mostrada al lado izquierdo de la misma. La etiqueta de la 
expresión en TeX es la misma que la de Maxima.

@var{destination} puede ser tanto un flujo de salida como el nombre de un fichero.

Si @var{destination} es el nombre de un fichero, @code{tex} añade la salida al fichero.
Las funciones @code{openw} y @code{opena} crean flujos de salida.

Las instrucciones @code{tex (@var{expr}, false)} y @code{tex (@var{label}, false)}
devuelven el código TeX en formato de cadena.

La función @code{tex} evalúa su primer argumento tras
comprobar si se trata de una etiqueta. La doble comilla simple @code{''} 
fuerza la evaluación del argumento, anulando la comprobación sobre la etiqueta.

Véase también @code{texput}.

Ejemplos:

@example
(%i1) integrate (1/(1+x^3), x);
                                    2 x - 1
                  2            atan(-------)
             log(x  - x + 1)        sqrt(3)    log(x + 1)
(%o1)      - --------------- + ------------- + ----------
                    6             sqrt(3)          3
(%i2) tex (%o1);
$$-@{@{\log \left(x^2-x+1\right)@}\over@{6@}@}+@{@{\arctan \left(@{@{2\,x-1
 @}\over@{\sqrt@{3@}@}@}\right)@}\over@{\sqrt@{3@}@}@}+@{@{\log \left(x+1\right)
 @}\over@{3@}@}\leqno@{\tt (\%o1)@}$$
(%o2)                          (\%o1)
(%i3) tex (integrate (sin(x), x));
$$-\cos x$$
(%o3)                           false
(%i4) tex (%o1, "foo.tex");
(%o4)                          (\%o1)
@end example

@code{tex (@var{expr}, false)} devuelve el código TeX en formato de cadena.

@c ===beg===
@c S : tex (x * y * z, false);
@c S;
@c ===end===
@example
(%i1) S : tex (x * y * z, false);
(%o1) $$x\,y\,z$$
(%i2) S;
(%o2) $$x\,y\,z$$
@end example
@end deffn




@deffn {Función} tex1 (@var{e})
Devuelve una cadena con el código TeX de la expresión @var{e}.
El código TeX no se encierra entre delimitadores para una ecuación
ni cualesquiera otros entornos.

Ejemplo:

@c ===beg===
@c tex1 (sin(x) + cos(x));
@c ===end===
@example
(%i1) tex1 (sin(x) + cos(x));
(%o1)                     \sin x+\cos x
@end example
@end deffn


@deffn {Función} texput (@var{a}, @var{s})
@deffnx {Función} texput (@var{a}, @var{f})
@deffnx {Función} texput (@var{a}, @var{s}, @var{operator_type})
@deffnx {Función} texput (@var{a}, [@var{s_1}, @var{s_2}], matchfix)
@deffnx {Función} texput (@var{a}, [@var{s_1}, @var{s_2}, @var{s_3}], matchfix)

Establece el formato en TeX del átomo @var{a}, el cual puede ser un
símbolo o el nombre de un operador.

La instrucción @code{texput (@var{a}, @var{s})} hace que la función
@code{tex} introduzca @var{s} en la salida TeX en el lugar de @var{a}.

La instrucción @code{texput (@var{a}, @var{f})} hace que @code{tex} llame
a la función @var{f} para que genere código TeX. La función @var{f} 
debe aceptar un único argumento, el cual es una expresión que tenga como
operador @var{a} y que devuelva una cadena con el código TeX. Esta función
puede llamar a @code{tex1} para generar el código TeX para los argumentos
de la expresión de entrada.

La instrucción @code{texput (@var{a}, @var{s}, @var{operator_type})},
en la que @var{operator_type} es @code{prefix}, @code{infix} o
@code{postfix}, @code{nary} o @code{nofix},hace que la función
@code{tex} introduzca @var{s} en la salida TeX en el lugar de @var{a},
colocándolo en el lugar correcto.

La instrucción @code{texput (@var{a}, [@var{s_1}, @var{s_2}], matchfix)}
hace que la función @code{tex} introduzca @var{s_1} y @var{s_2} en la
salida TeX a los lados de los argumentos de @var{a}. Si son más de uno,
los argumentos se separan por comas.

La instrucción @code{texput (@var{a}, [@var{s_1}, @var{s_2}, @var{s_3}],
matchfix)} hace que la función @code{tex} introduzca @var{s_1} y
@var{s_2} en la salida TeX a los lados de los argumentos de @var{a},
con @var{s_3} separando los argumentos.

Ejemplos:

Asigna código TeX para una variable.
@c ===beg===
@c texput (me,"\\mu_e");
@c tex (me);
@c ===end===

Llama a una función que genera código TeX.

@c ===beg===
@c texfoo (e) := block ([a, b], [a, b] : args (e),
@c   concat ("\\left[\\stackrel{", tex1 (b), "}{", tex1 (a), "}\\right]"))$
@c texput (foo, texfoo);
@c tex (foo (2^x, %pi));
@c ===end===
@example
(%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
  concat ("\\left[\\stackrel@{", tex1 (b), 
          "@}@{", tex1 (a), "@}\\right]"))$
(%i2) texput (foo, texfoo);
(%o2)                        texfoo
(%i3) tex (foo (2^x, %pi));
$$\left[\stackrel@{\pi@}@{2^@{x@}@}\right]$$
(%o3)                         false
@end example

@example
(%i1) texput (me,"\\mu_e");
(%o1)                         \mu_e
(%i2) tex (me);
$$\mu_e$$
(%o2)                         false
@end example

Asigna código TeX para una función ordinaria (no para un operador).
@c ===beg===
@c texput (lcm, "\\mathrm{lcm}");
@c tex (lcm (a, b));
@c ===end===

@example
(%i1) texput (lcm, "\\mathrm@{lcm@}");
(%o1)                     \mathrm@{lcm@}
(%i2) tex (lcm (a, b));
$$\mathrm@{lcm@}\left(a , b\right)$$
(%o2)                         false
@end example

Asigna código TeX para un operador prefijo.
@c ===beg===
@c prefix ("grad");
@c texput ("grad", " \\nabla ", prefix);
@c tex (grad f);
@c ===end===

@example
(%i1) prefix ("grad");
(%o1)                         grad
(%i2) texput ("grad", " \\nabla ", prefix);
(%o2)                        \nabla 
(%i3) tex (grad f);
$$ \nabla f$$
(%o3)                         false
@end example

Asigna código TeX para un operador infijo.
@c ===beg===
@c infix ("~");
@c texput ("~", " \\times ", infix);
@c tex (a ~ b);
@c ===end===

@example
(%i1) infix ("~");
(%o1)                           ~
(%i2) texput ("~", " \\times ", infix);
(%o2)                        \times 
(%i3) tex (a ~ b);
$$a \times b$$
(%o3)                         false
@end example

Asigna código TeX para un operador postfijo..
@c ===beg===
@c postfix ("##");
@c texput ("##", "!!", postfix);
@c tex (x ##);
@c ===end===

@example
(%i1) postfix ("##");
(%o1)                          ##
(%i2) texput ("##", "!!", postfix);
(%o2)                          !!
(%i3) tex (x ##);
$$x!!$$
(%o3)                         false
@end example

Asigna código TeX para un operador n-ario.
@c ===beg===
@c nary ("@@");
@c texput ("@@", " \\circ ", nary);
@c tex (a @@ b @@ c @@ d);
@c ===end===

@example
(%i1) nary ("@@@@");
(%o1)                          @@@@
(%i2) texput ("@@@@", " \\circ ", nary);
(%o2)                         \circ 
(%i3) tex (a @@@@ b @@@@ c @@@@ d);
$$a \circ b \circ c \circ d$$
(%o3)                         false
@end example

Asigna código TeX para un operador "no-fijo".
@c ===beg===
@c nofix ("foo");
@c texput ("foo", "\\mathsc{foo}", nofix);
@c tex (foo);
@c ===end===

@example
(%i1) nofix ("foo");
(%o1)                          foo
(%i2) texput ("foo", "\\mathsc@{foo@}", nofix);
(%o2)                     \mathsc@{foo@}
(%i3) tex (foo);
$$\mathsc@{foo@}$$
(%o3)                         false
@end example

Asigna código TeX para un operador "bi-fijo" (matchfix).
@c ===beg===
@c matchfix ("<<", ">>");
@c texput ("<<", [" \\langle ", " \\rangle "], matchfix);
@c tex (<<a>>);
@c tex (<<a, b>>);
@c texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"], 
@c       matchfix);
@c tex (<<a>>);
@c tex (<<a, b>>);
@c ===end===

@example
(%i1) matchfix ("<<", ">>");
(%o1)                          <<
(%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
(%o2)                [ \langle ,  \rangle ]
(%i3) tex (<<a>>);
$$ \langle a \rangle $$
(%o3)                         false
(%i4) tex (<<a, b>>);
$$ \langle a , b \rangle $$
(%o4)                         false
(%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
      matchfix);
(%o5)           [ \langle ,  \rangle ,  \, | \,]
(%i6) tex (<<a>>);
$$ \langle a \rangle $$
(%o6)                         false
(%i7) tex (<<a, b>>);
$$ \langle a \, | \,b \rangle $$
(%o7)                         false
@end example
@end deffn




@deffn {Función} get_tex_environment (@var{op})
@deffnx {Función} set_tex_environment (@var{op}, @var{before}, @var{after})

Gestiona el entorno de las salidas TeX que se obtienen de la función @code{tex}.
El entorno TeX está formado por dos cadenas: una que se escribe antes que
cualquier salida en TeX, y otra que se escribe después.

@code{get_tex_environment} devuelve el entorno TeX que se aplica al operador @var{op}.
Si no se ha asignado ningún entorno, devolverá el que tenga por defecto.

@code{set_tex_environment} asigna el entorno TeX al operador @var{op}.

Ejemplos:

@c ===beg===
@c get_tex_environment (":=");
@c tex (f (x) := 1 - x);
@c set_tex_environment (":=", "$$", "$$");
@c tex (f (x) := 1 - x);
@c ===end===
@example
(%i1) get_tex_environment (":=");
(%o1) [
\begin@{verbatim@}
, ;
\end@{verbatim@}
]
(%i2) tex (f (x) := 1 - x);

\begin@{verbatim@}
f(x):=1-x;
\end@{verbatim@}

(%o2)                         false
(%i3) set_tex_environment (":=", "$$", "$$");
(%o3)                       [$$, $$]
(%i4) tex (f (x) := 1 - x);
$$f(x):=1-x$$
(%o4)                         false
@end example
@end deffn

@deffn {Función} get_tex_environment_default ()
@deffnx {Función} set_tex_environment_default (@var{before}, @var{after})

Gestiona el entorno de las salidas TeX que se obtienen de la función @code{tex}.
El entorno TeX está formado por dos cadenas: una que se escribe antes que
cualquier salida en TeX, y otra que se escribe después.

@code{get_tex_environment_default} devuelve el entorno TeX que se aplica
a expresiones para las cuales el operador de mayor rango no tiene entorno
TeX asignado (mediante @code{set_tex_environment}).

@code{set_tex_environment_default} asigna el entorno TeX por defecto.

Ejemplos:

@c ===beg===
@c get_tex_environment_default ();
@c tex (f(x) + g(x));
@c set_tex_environment_default ("\\begin{equation}
@c ", "
@c \\end{equation}");
@c tex (f(x) + g(x));
@c ===end===
@example
(%i1) get_tex_environment_default ();
(%o1)                       [$$, $$]
(%i2) tex (f(x) + g(x));
$$g\left(x\right)+f\left(x\right)$$
(%o2)                         false
(%i3) set_tex_environment_default ("\\begin@{equation@}
", "
\\end@{equation@}");
(%o3) [\begin@{equation@}
, 
\end@{equation@}]
(%i4) tex (f(x) + g(x));
\begin@{equation@}
g\left(x\right)+f\left(x\right)
\end@{equation@}
(%o4)                         false
@end example
@end deffn


@node Funciones y variables para salida Fortran, , Funciones y variables para salida TeX, Lectura y escritura
@section Funciones y variables para salida Fortran

@defvr {Variable opcional} fortindent
Valor por defecto: 0

La variable @code{fortindent} controla el margen izquierdo de las expresiones que 
escribe la instrucción @code{fortran}.  El valor 0 escribe con un margen normal 
de 6 espacios; valores positivos harán que las expresiones se escriban más a la derecha.
@end defvr



@deffn {Función} fortran (@var{expr})
Escribe @var{expr} en código Fortran. La salida se escribe con márgenes, y si ésta es demasiado larga @code{fortran} sigue escribiendo en líneas sucesivas. La función @code{fortran} escribe el operador de exponenciación @code{^} como @code{**}, e imprime un número complejo @code{a + b %i} como @code{(a,b)}.

El argumento @var{expr} puede ser una ecuación. En tal caso, @code{fortran} escribe una sentencia de asignación, dándole el valor del miembro derecho de la expresión al miembro izquierdo. En particular, si el miembro derecho de @var{expr} es el nombre de una matriz, entonces @code{fortran} escribe una sentencia de asignación para cada elemento de la matriz.

Si @var{expr} no es reconozida por @code{fortran}, la expresión se escribe en formato @code{grind} sin avisos. La función @code{fortran} no reconoce listas, arreglos ni funciones.

La variable @code{fortindent} controla el margen izquierdo de las expresiones que escribe la instrucción @code{fortran}.  El valor 0 escribe con un margen normal de 6 espacios; valores positivos harán que las expresiones se escriban más a la derecha.

Si @code{fortspaces} vale @code{true}, @code{fortran} rellena las líneas con espacios de 80 columnas.

La función @code{fortran} evalúa sus argumentos; un argumento precedido de apóstrofo previene de la evaluación.
La función @code{fortran} siempre devuelve @code{done}.

Ejemplos:

@verbatim
(%i1) expr: (a + b)^12$
(%i2) fortran (expr);
      (b+a)**12                                                                 
(%o2)                         done
(%i3) fortran ('x=expr);
      x = (b+a)**12                                                             
(%o3)                         done
(%i4) fortran ('x=expand (expr));
      x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792        
     1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b        
     2   **3+66*a**10*b**2+12*a**11*b+a**12                                     
(%o4)                         done
(%i5) fortran ('x=7+5*%i);
      x = (7,5)                                                                 
(%o5)                         done
(%i6) fortran ('x=[1,2,3,4]);
      x = [1,2,3,4]                                                             
(%o6)                         done
(%i7) f(x) := x^2$
(%i8) fortran (f);
      f                                                                         
(%o8)                         done
@end verbatim
@end deffn


@defvr {Variable opcional} fortspaces
Valor por defecto: @code{false}

Si @code{fortspaces} vale @code{true}, @code{fortran} rellena las líneas 
con espacios de 80 columnas.
@end defvr


