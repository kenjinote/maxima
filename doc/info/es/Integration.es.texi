@c English version 2001-11-03
@menu
* Introducción a la integración::
* Funciones y variables para integración::
* Introducción a QUADPACK::
* Funciones y variables para QUADPACK::
@end menu
    
@node Introducción a la integración, Funciones y variables para integración, Integración, Integración

@section Introducción a la integración   

Maxima tiene varias rutinas para calcular integrales. La función @code{integrate} hace uso de la mayor parte de ellas.  También está el paquete @code{antid}, que opera con funciones no especificadas y sus derivadas. Para usos numéricos se dispone de la batería de integradores adaptativos de @code{QUADPACK}, como @code{quad_qag}, @code{quad_qags}, etc., que se describen en la sección @code{QUADPACK}.
También se trabajan funciones hipergeométricas, véase @code{specint} para más detalles. En términos generales, Maxima sólo opera con funciones que son integrables en términos de funciones elementales, como las racionales, trigonométricas, logarítmicas, exponenciales, radicales, etc., y unas pocas extensiones de éstas, como la función de error o los dilogaritmos. No opera con integrales en términos de funciones desconocidas, como  @code{g(x)} o @code{h(x)}.

@c end concepts Integration
@node Funciones y variables para integración, Introducción a QUADPACK, Introducción a la integración, Integración
@section Funciones y variables para integración 

@c NEEDS WORK
@deffn {Función} changevar (@var{expr}, @var{f(x,y)}, @var{y}, @var{x})
Hace el cambio de variable dado por @code{@var{f(x,y)} = 0} en todas las integrales que aparecen en @var{expr} con la integración respecto de @var{x}. La nueva variable será @var{y}.

@c HMM, THIS EXAMPLE YIELDS A CORRECT BUT SLIGHTLY STRANGE RESULT...
@example
(%i1) assume(a > 0)$
(%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                      4
                     /
                     [    sqrt(a) sqrt(y)
(%o2)                I  %e                dy
                     ]
                     /
                      0
(%i3) changevar (%, y-z^2/a, z, y);
                      0
                     /
                     [                abs(z)
                   2 I            z %e       dz
                     ]
                     /
                      - 2 sqrt(a)
(%o3)            - ----------------------------
                                a
@end example

Si una expresión contiene formas nominales, como aquélla en la que aparece @code{'integrate} en el ejemplo, podrá ser evaluada por @code{ev} si se utiliza el término @code{nouns}. Por ejemplo, la expresión devuelta por @code{changevar} se puede evaluar haciendo @code{ev (%o3, nouns)}.

La función @code{changevar} también se puede utilizar para cambiar los índices de una suma o producto.  Sin embargo, debe tenerse en cuenta que cuando se realiza un cambio en una suma o producto, el mismo debe expresarse en términos de sumas, como @code{i = j+ ...}, no como una función de mayor grado.

Ejemplo:

@example
(%i4) sum (a[i]*x^(i-2), i, 0, inf);
                         inf
                         ====
                         \         i - 2
(%o4)                     >    a  x
                         /      i
                         ====
                         i = 0
(%i5) changevar (%, i-2-n, n, i);
                        inf
                        ====
                        \               n
(%o5)                    >      a      x
                        /        n + 2
                        ====
                        n = - 2
@end example

@end deffn

@c THIS ITEM IS A MESS, BUT DON'T BOTHER TO CLEAN IT UP:
@c THE GAUSS-KRONROD FUNCTIONS (QUADPACK) MAKE THIS OBSOLETE
@deffn {Función} dblint (@var{f}, @var{r}, @var{s}, @var{a}, @var{b})
Es una rutina para integrales dobles escrita en lenguaje Maxima y posteriormente traducida y compilada a código máquina. La instrucción @code{load (dblint)} carga esta función. Utiliza el método de Simpson en las dos direcciones @code{x} e @code{y} para calcular

@tex
$$\int_a^b \int_{r\left(x\right)}^{s\left(x\right)} f\left(x,y\right) \, dy \, dx.$$
@end tex
@ifnottex
@example
/b /s(x)
|  |
|  |    f(x,y) dy dx
|  |
/a /r(x)
@end example
@end ifnottex


La función @var{f} debe ser una función traducida o compilada de dos variables, a la vez que @var{r} y @var{s} deben ser cada una de ellas una función traducida o compilada de una variable, mientras que @var{a} y @var{b} deben ser números en coma flotante. La rutina tiene dos variables globales que determinan el número de divisiones de los intervalos @code{x} e @code{y}: @code{dblint_x} y @code{dblint_y}, ambos con un valor por defecto de 10, pero que pueden cambiarse de forma independiente a otros valores enteros (hay @code{2*dblint_x+1} puntos a calcular en la dirección @code{x} y @code{2*dblint_y+1} en la dirección @code{y}). La rutina subdivide el eje X y luego para cada valor de X calcula primero @code{@var{r}(x)} y @code{@var{s}(x)}; entonces se subdivide el eje Y entre @code{@var{r}(x)} y @code{@var{s}(x)}, evaluándose la integral a lo largo del eje Y aplicando la regla de Simpson; a continuación, se evalúa la integral a lo largo del eje X utilizando también la regla de Simpson tomando como valores de función las integrales sobre Y. Este procedimiento puede ser numéricamente inestable por múltiples motivos, pero es razonablemente rápido: evítese su uso con funciones con grandes oscilaciones o que tengan singularidades. Las integrales del eje Y dependen de la proximidad de los límites @code{@var{r}(x)} y @code{@var{s}(x)}, de manera que si la distancia @code{@var{s}(x) - @var{r}(x)} varía rápidamente con X, puede dar lugar errores importantes debido a truncamientos de diferente amplitud en las integrales de Y. Se puede aumentar @code{dblint_x} y @code{dblint_y} al objeto de mejorar el recubrimiento de la región de integración, pero a costa del tiempo de cómputo. Es necesario que las funciones @var{f}, @var{r} y @var{s} estén traducidas o compiladas antes de utilizar @code{dblint}, lo cual redundará en una mejora del tiempo de ejecución de varios órdenes de magnitud respecto de la ejecución de código interpretado.

@end deffn

@deffn {Función} defint (@var{expr}, @var{x}, @var{a}, @var{b})
Intenta calcular una integral definida. La función @code{defint} es invocada por  @code{integrate} cuando se especifican los límites de integración, por ejemplo @code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}. Así, desde el punto de vista del usuario, es suficiente con utilizar @code{integrate}.
@c SHOULD WE BOTHER TO DOCUMENT defint ??? NO FUNCTIONALITY HERE THAT IS NOT ALREADY PRESENT IN integrate !!!

La función @code{defint} devuelve una expresión simbólica, bien sea el resultado calculado o la forma nominal.
Véase @code{quad_qag} y sus funciones relacionadas para aproximaciones numéricas de integrales definidas.

@end deffn


@defvr {Variable optativa} erfflag
Valor por defecto: @code{true}

Si @code{erfflag} vale @code{false}, la función @code{risch} no introduce la función @code{erf} en el resultado si no había ninguna en el integrando.

@end defvr

@deffn {Función} ilt (@var{expr}, @var{s}, @var{t})
Calcula la transformada inversa de Laplace de @var{expr} con respecto de @var{s} y parámetro @var{t}. El argumento  @var{expr} debe ser una fracción de polinomios cuyo denominador tenga sólo factores lineales y cuadráticos. Utilizando las funciones @code{laplace} y @code{ilt}, junto con las funciones @code{solve} o @code{linsolve}, el usuario podrá resolver ciertas ecuaciones integrales.

@example
(%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
              t
             /
             [                                    2
(%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
             ]
             /
              0
(%i2) laplace (%, t, s);
                               a laplace(f(t), t, s)   2
(%o2)  b laplace(f(t), t, s) + --------------------- = --
                                       2    2           3
                                      s  - a           s
(%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                        2      2
                                     2 s  - 2 a
(%o3)     [laplace(f(t), t, s) = --------------------]
                                    5         2     3
                                 b s  + (a - a  b) s
(%i4) ilt (rhs (first (%)), s, t);
Is  a b (a b - 1)  positive, negative, or zero?

pos;
               sqrt(a b (a b - 1)) t
        2 cosh(---------------------)       2
                         b               a t
(%o4) - ----------------------------- + -------
              3  2      2               a b - 1
             a  b  - 2 a  b + a

                                                       2
                                             + ------------------
                                                3  2      2
                                               a  b  - 2 a  b + a
@end example

@end deffn


@defvr {Variable opcional} intanalysis
Valor por defecto: @code{true}

Cuando vale @code{true}, la integración definida trata de encontrar polos
en el integrando dentro del intervalo de integración. Si encuentra 
alguno, entonces la integral se calcula como valor principal. Si @code{intanalysis}
vale @code{false}, entonces no se realiza esta comprobaciÃ³n y la integración se
realiza sin tener en cuenta los polos.

Véase también @code{ldefint}.

Ejemplos:

Maxima puede calcular las siguientes integrales cuando a @code{intanalysis}
se le asigna el valor @code{false}:

@c ===beg===
@c integrate(1/(sqrt(x+1)+1),x,0,1);
@c integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
@c integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
@c intanalysis:false$
@c integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
@c ===end===
@example
(%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                1
                               /
                               [       1
(%o1)                          I  ----------- dx
                               ]  sqrt(x) + 1
                               /
                                0

(%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
(%o2)                            2 - 2 log(2)

(%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
The number 1 isn't in the domain of atanh
 -- an error. To debug this try: debugmode(true);

(%i4) intanalysis:false$
(%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                      %pi
(%o5)                                 ---
                                       2
@end example

@end defvr


@deffn {Función} integrate (@var{expr}, @var{x})
@deffnx {Función} integrate (@var{expr}, @var{x}, @var{a}, @var{b})
Calcula simbólicamente la integral de @var{expr} respecto de @var{x}. La llamada
@code{integrate (@var{expr}, @var{x})} resuelve una integral indefinida, mientras que 
 @code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})} resuelve una integral definida con 
límites de integración @var{a} y @var{b}.
Los límites no pueden contener a @var{x}. El argumento
@var{a} no necesita ser menor que @var{b}.
Si @var{b} es igual a @var{a}, @code{integrate} devuelve cero.

Véase @code{quad_qag} y funciones relacionadas para la aproximación numérica de integrales definidas.
Véase @code{residue} para el cálculo de residuos (integración compleja).
Véase @code{antid} para un método alternativo de resolución de integrales indefinidas.

Se obtendrá una integral (es decir, una expresión sin @code{integrate}) si @code{integrate} tiene éxito en el cálculo. En otro caso, la respuesta es la forma nominal de la integral (esto es, el operador @code{'integrate} precedido de apóstrofo) o una expresión que contiene una o más formas nominales. La forma nominal de @code{integrate} se muestra con un símbolo integral.

En ciertos casos es útil proporcionar una forma nominal 'a mano', haciendo preceder @code{integrate} con una comilla simple o apóstrofo, como en @code{'integrate (@var{expr}, @var{x})}.
Por ejemplo, la integral puede depender de algunos parámetros que todavía no han sido calculados.
La forma nominal puede aplicarse después a sus argumentos haciendo @code{ev (@var{i}, nouns)}
donde @var{i} es la forma nominal de interés.

@c BEGIN EXPOSITION ON HEURISTICS
La función @code{integrate} trata de manera diferente las integrales definidas de las indefinidas,
empleando una batería de heurísticas especial para cada caso.
Casos especiales de integrales definidas incluyen las que tienen límites de integración iguales a cero o a infinito (@code{inf} o @code{minf}), funciones trigonométricas con límites de integración igual a cero y @code{%pi} o @code{2 %pi}, funciones racionales, integrales relacionadas con las funciones @code{beta} y @code{psi} y algunas integrales logarítmicas y trigonométricas. El tratamiento de funciones racionales puede incluir el cálculo de residuos.
Si no se reconoce ninguno de los casos especiales, se intenta resolver la integral idefinida y evaluarla en los límites de integración. Esto incluye tomar límites cuando alguno de los extremos del intervalo de integración se acerca a más infinito o a menos infinito; véase también @code{ldefint}.

Casos especiales de integrales indefinidas incluyen a las funciones trigonométricas, exponenciales, logarítmicas y racionales. La función @code{integrate} también hace uso de una pequeña tabla de integrales elementales.

La función @code{integrate} puede llevar a cabo cambios de variable si el integrando es de la forma @code{f(g(x)) * diff(g(x), x)}, entonces @code{integrate} trata de encontrar una subexpresión de @code{g(x)} tal que la derivada de  @code{g(x)} divida el integrando. Esta búsqueda puede hacer uso de las derivadas establecidas con la función @code{gradef}.
Véanse también @code{changevar} y @code{antid}.

Si ninguna de las heurísticas descritas resuelve la integral indefinida, se ejecuta el algoritmo de Risch.
La variable @code{risch} puede utilizarse como una @code{evflag}, en una llamada a @code{ev} o en la línea de comandos
por ejemplo, @code{ev (integrate (@var{expr}, @var{x}), risch)} o @code{integrate (@var{expr}, @var{x}), risch}.
Si @code{risch} está presenta, @code{integrate} llama a la función @code{risch} sin intentar primero las heurísticas. Véase también @code{risch}.
@c END EXPOSITION ON HEURISTICS

La función @code{integrate} opera únicamente con relaciones funcionales que se representen explícitamente con la notación @code{f(x)}, sin considerar las dependencias implícitas establecidas mediante la función @code{depends}.

Es posible que @code{integrate} necesite conocer alguna propiedad de alguno de los parámetros presentes en el integrando, en cuyo caso @code{integrate} consultará en primer lugar la base de datos creada con @code{assume}, y si la variable de interés no se encuentra ahí, @code{integrate} le preguntará al usuario. Dependiendo de la pregunta, posibles respuestas son: @code{yes;}, @code{no;}, @code{pos;}, @code{zero;} o @code{neg;}.

Por defecto, @code{integrate} no se considera lineal. Véanse @code{declare} y @code{linear}.

La función @code{integrate} intentará la integración por partes sólo en casos especiales.

Ejemplos:

@itemize @bullet
@item
Integrales elementales indefinidas y definidas.

@example
(%i1) integrate (sin(x)^3, x);
                           3
                        cos (x)
(%o1)                   ------- - cos(x)
                           3
(%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                 2    2
(%o2)                    - sqrt(b  - x )
(%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                               %pi
                           3 %e      3
(%o3)                      ------- - -
                              5      5
(%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                            sqrt(%pi)
(%o4)                       ---------
                                2
@end example

@item
Utilización de @code{assume} e interacción.

@example
(%i1) assume (a > 1)$
(%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
    2 a + 2
Is  -------  an integer?
       5

no;
Is  2 a - 3  positive, negative, or zero?

neg;
                                   3
(%o2)                  beta(a + 1, - - a)
                                   2
@end example

@item
Cambio de variable. En este ejemplo hay dos cambios de variable:
uno utilizando una derivada establecida con @code{gradef} y otra utilizando la derivada @code{diff(r(x))} de una función no especificada @code{r(x)}.

@example
(%i3) gradef (q(x), sin(x**2));
(%o3)                         q(x)
(%i4) diff (log (q (r (x))), x);
                      d               2
                     (-- (r(x))) sin(r (x))
                      dx
(%o4)                ----------------------
                            q(r(x))
(%i5) integrate (%, x);
(%o5)                     log(q(r(x)))
@end example

@item
El valor devuelto contiene la forma nominal @code{'integrate}.
En este ejemplo, Maxima puede extraer un factor del denominador de una función racional, pero no puede factorizar el resto. La función @code{grind} muestra la forma nominal @code{'integrate} del resultado.
Véase también @code{integrate_use_rootsof} para más información sobre integrales de funciones racionales.

@example
(%i1) expand ((x-4) * (x^3+2*x+1));
                    4      3      2
(%o1)              x  - 4 x  + 2 x  - 7 x - 4
(%i2) integrate (1/%, x);
                              /  2
                              [ x  + 4 x + 18
                              I ------------- dx
                              ]  3
                 log(x - 4)   / x  + 2 x + 1
(%o2)            ---------- - ------------------
                     73               73
(%i3) grind (%);
log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$
@end example

@item
Definición de una función mediante una integral.
El cuerpo de una función no se evalúa cuando ésta se define, de manera que el cuerpo de 
@code{f_1} en este ejemplo contiene la forma nominal de @code{integrate}.
El operador comilla-comilla @code{'@w{}'} hace que se evalúe la integral y su resultado será el que defina a la función @code{f_2}.

@example
(%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                     3
(%o1)           f_1(a) := integrate(x , x, 1, a)
(%i2) ev (f_1 (7), nouns);
(%o2)                          600
(%i3) /* Note parentheses around integrate(...) here */
      f_2 (a) := ''(integrate (x^3, x, 1, a));
                                   4
                                  a    1
(%o3)                   f_2(a) := -- - -
                                  4    4
(%i4) f_2 (7);
(%o4)                          600
@end example
@end itemize

@end deffn

@defvr {Variable del sistema} integration_constant
Valor por defecto: @code{%c}

Cuando una constante de integración se crea durante la integración definida
de una ecuación, el nombre de la constante se construye concatenando
@code{integration_constant} y @code{integration_constant_counter}.

A @code{integration_constant} se le puede asignar un símbolo cualquiera.

Ejemplos:

@c ===beg===
@c integrate (x^2 = 1, x);
@c integration_constant : 'k;
@c integrate (x^2 = 1, x);
@c ===end===
@example
@group
(%i1) integrate (x^2 = 1, x);
                           3
                          x
(%o1)                     -- = x + %c1
                          3
@end group
@group
(%i2) integration_constant : 'k;
(%o2)                           k
@end group
@group
(%i3) integrate (x^2 = 1, x);
                            3
                           x
(%o3)                      -- = x + k2
                           3
@end group
@end example

@end defvr

@defvr {Variable del sistema} integration_constant_counter
Valor por defecto: 0

Cuando una constante de integración se crea durante la integración definida
de una ecuación, el nombre de la constante se construye concatenando
@code{integration_constant} y @code{integration_constant_counter}.

La variable @code{integration_constant_counter} se incrementa antes de construir la
constante de integración siguiente.

Ejemplos:

@c ===beg===
@c integrate (x^2 = 1, x);
@c integrate (x^2 = 1, x);
@c integrate (x^2 = 1, x);
@c reset (integration_constant_counter);
@c integrate (x^2 = 1, x);
@c ===end===
@example
@group
(%i1) integrate (x^2 = 1, x);
                           3
                          x
(%o1)                     -- = x + %c1
                          3
@end group
@group
(%i2) integrate (x^2 = 1, x);
                           3
                          x
(%o2)                     -- = x + %c2
                          3
@end group
@group
(%i3) integrate (x^2 = 1, x);
                           3
                          x
(%o3)                     -- = x + %c3
                          3
@end group
@group
(%i4) reset (integration_constant_counter);
(%o4)            [integration_constant_counter]
@end group
@group
(%i5) integrate (x^2 = 1, x);
                           3
                          x
(%o5)                     -- = x + %c1
                          3
@end group
@end example
@end defvr

@defvr {Variable optativa} integrate_use_rootsof
Valor por defecto: @code{false}

Si @code{integrate_use_rootsof} vale @code{true} y el denominador de una función racional no se puede factorizar,  @code{integrate} devuelve la integral como una suma respecto de las raíces desconocidas del denominador.

Por ejemplo, dándole a @code{integrate_use_rootsof} el valor @code{false},
@code{integrate} devuelve la integral no resuelta de la función racional en forma nominal:

@example
(%i1) integrate_use_rootsof: false$
(%i2) integrate (1/(1+x+x^5), x);
        /  2
        [ x  - 4 x + 5
        I ------------ dx                            2 x + 1
        ]  3    2                2            5 atan(-------)
        / x  - x  + 1       log(x  + x + 1)          sqrt(3)
(%o2)   ----------------- - --------------- + ---------------
                7                 14             7 sqrt(3)
@end example

Si ahora se le da a la variable el valor @code{true}, la parte no resuelta de la integral se expresa como una suma cuyos sumandos dependen de las raíces del denominador de la función racional:

@example
(%i3) integrate_use_rootsof: true$
(%i4) integrate (1/(1+x+x^5), x);
      ====        2
      \       (%r4  - 4 %r4 + 5) log(x - %r4)
       >      -------------------------------
      /                    2
      ====            3 %r4  - 2 %r4
                        3      2
      %r4 in rootsof(%r4  - %r4  + 1, %r4)
(%o4) ----------------------------------------------------------
               7

                                                       2 x + 1
                                   2            5 atan(-------)
                              log(x  + x + 1)          sqrt(3)
                            - --------------- + ---------------
                                    14             7 sqrt(3)
@end example

Alternativamente, el usuario puede calcular las raíces del denominador separadamente y luego representar el integrando en función de dichas raíces, como por ejemplo @code{1/((x - a)*(x - b)*(x - c))} o @code{1/((x^2 - (a+b)*x + a*b)*(x - c))}
si el denominador es un polinomio de tercer grado. En algunos casos, esto ayudará a Maxima mejorar sus resultados.

@end defvr

@c NEEDS EXAMPLES
@deffn {Función} ldefint (@var{expr}, @var{x}, @var{a}, @var{b})
Calcula la integral definida de @var{expr} utilizando @code{limit} tras el cálculo de la integral indefinida de @var{expr} respecto a @var{x} en los extremos de integración @var{b} y @var{a}.
Si no consigue calcular la integral definida,
@code{ldefint} devuelve una expresión con los límites en forma nominal.

La función @code{integrate} no llama a @code{ldefint},
de modo que la ejecución de @code{ldefint (@var{expr}, @var{x}, @var{a}, @var{b})} puede dar un resultado diferente que 
@code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}. La función 
@code{ldefint} siempre utiliza el mismo método para calcular la integral definida,
mientras que @code{integrate} puede hacer uso de varias heurísticas y reconocer así casos especiales.

@end deffn


@c FALTA DEFINICION SOBRE potential

@deffn {Función} residue (@var{expr}, @var{z}, @var{z_0})
Calcula el residuo en el plano complejo de la expresión  @var{expr} cuando la variable @var{z} toma el valor @var{z_0}.  El residuo es el coeficiente de @code{(@var{z} - @var{z_0})^(-1)} en el desarrollo de Laurent de @var{expr}.

@example
(%i1) residue (s/(s**2+a**2), s, a*%i);
                                1
(%o1)                           -
                                2
(%i2) residue (sin(a*x)/x**4, x, 0);
                                 3
                                a
(%o2)                         - --
                                6
@end example

@end deffn

@deffn {Función} risch (@var{expr}, @var{x})
Integra @var{expr} respecto de @var{x} utilizando el caso trascendental del algoritmo de Risch. El caso algebraico del algoritmo de Risch no se ha implementado. Este método trata los casos de exponenciales y logaritmos anidados que no resuelve el procedimiento principal de @code{integrate}. La función @code{integrate} llamará automáticamente a @code{risch} si se presentan estos casos.

Si la variable @code{erfflag} vale @code{false}, evita que @code{risch} introduzca la función @code{erf}
en la respuesta si ésta no estaba presente previamente en el integrando.

@example
(%i1) risch (x^2*erf(x), x);
                                                        2
             3                      2                - x
        %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
(%o1)   -------------------------------------------------
                              3 %pi
(%i2) diff(%, x), ratsimp;
                             2
(%o2)                       x  erf(x)
@end example

@end deffn


@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@deffn {Función} tldefint (@var{expr}, @var{x}, @var{a}, @var{b})
Equivale a @code{ldefint} cuando @code{tlimswitch} vale @code{true}.

@end deffn



@node Introducción a QUADPACK, Funciones y variables para QUADPACK, Funciones y variables para integración, Integración
@section Introducción a QUADPACK

@c FOLLOWING TEXT ADAPTED WITH HEAVY MODIFICATION FROM http://www.netlib.org/slatec/src/qpdoc.f

QUADPACK es un conjunto de funciones para el cálculo numérico de
integrales definidas de una variable. Se creó a partir de un trabajo conjunto de
R. Piessens @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
E. de Doncker @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
C. Ueberhuber @footnote{Institut f@"ur Mathematik, T.U. Wien},
and D. Kahaner @footnote{National Bureau of Standards, Washington, D.C., U.S.A}.

La librería QUADPACK incluida en Maxima es una traducción automática
(mediante el programa @code{f2cl}) del código fuente Fortran de QUADPACK tal como
se encuentra en la SLATEC Common Mathematical Library,Versión 4.1 @footnote{@url{http://www.netlib.org/slatec}}.
La librería SLATEC está fechada en julio de 1993,
pero las funciones QUADPACK fueron escritas algunos años antes.
Hay otra versión de QUADPACK en Netlib @footnote{@url{http://www.netlib.org/quadpack}},
pero no está claro hasta qué punto difiere de la que forma parte de la
librería SLATEC.

Las funciones QUADPACK incluidas en Maxima son todas automáticas,
en el sentido de que estas funciones intentan calcular sus resultados
con una exactitud especificada, requiriendo un número indeterminado 
de evaluaciones de funciones.
La traducción a Lisp que Maxima hace de QUADPACK incluye también
algunas funciones que no son automáticas, pero que no son accesibles 
desde el nivel de Maxima.

Se puede encontrar más información sobre QUADPACK  en el libro
@footnote{R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K. Kahaner.
@i{QUADPACK: A Subroutine Package for Automatic Integration.}
Berlin: Springer-Verlag, 1983, ISBN 0387125531.}.

@subsection Perspectiva general

@table @code
@item quad_qag
Integración de una función general en un intervalo finito.
La función @code{quad_qag} implementa un integrador global 
adaptativo simple utilizando una estrategia de Aind (Piessens, 1973).
Se puede escoger entre seis pares de fórmulas de cuadratura de
Gauss-Kronrod para la regla de evaluación.
Las reglas de rango superior son útiles en los casos en los que
los integrandos tienen un alto grado de oscilación.

@item quad_qags
Integración de una función general en un intervalo finito.
La función @code{quad_qags} implementa la subdivisión de intervalos 
global adaptativa con extrapolación (de Doncker, 1978) mediante
el algoritmo Epsilon  (Wynn, 1956).

@item quad_qagi
Integración de una función general en un intervalo infinito o semi-infinito.
El intervalo se proyecta sobre un intervalo finito y luego se aplica la
misma estrategia que en @code{quad_qags}.

@item quad_qawo
Integración de @math{cos(omega x) f(x)} o @math{sin(omega x) f(x)} en un
intervalo finito, siendo @math{omega} una constante. La regla de 
evaluación se basa en la técnica modificada de Clenshaw-Curtis.
La función @code{quad_qawo} aplica la subdivisión adaptativa con extrapolación, 
de forma similar a @code{quad_qags}.

@item quad_qawf
Calcula la transformada seno o coseno de Fourier en un intervalo semi-infinito.
Se aplica el mismo método que en @code{quad_qawo} a sucesivos intervalos
finitos, acelerando la convergencia mediante el algoritmo Epsilon (Wynn, 1956).

@item quad_qaws
Integración de @math{w(x) f(x)} en un intervalo finito @math{[a, b]},
siendo @math{w} una función de la forma @math{(x - a)^alpha (b - x)^beta v(x)},
con  @math{v(x)} igual a 1, a @math{log(x - a)}, a @math{log(b - x)} o a
@math{log(x - a) log(b - x)} y con @math{alpha > -1}, y @math{beta > -1}.
Se aplica una estrategia de subdivisión adaptativa global,
con integración de Clenshaw-Curtis modificada en los subintervalos que
contienen a @math{a} y a @math{b}.

@item quad_qawc
Calcula el valor principal de Cauchy de @math{f(x)/(x - c)} en un
intervalo finito @math{(a, b)} para una @math{c} dada.
La estrategia es global adaptativa, utilizando la integración de 
Clenshaw-Curtis modificada en los subintervalos que contienen a @math{x = c}.

@item quad_qagp
Básicamente hace lo mismo que @code{quad_qags}, pero los puntos de singularidad
o discontinuidad deben ser aportados por el usuario. Esto hace que el cálculo
de una buena solución sea más fácil para el integrador.
@end table

@node Funciones y variables para QUADPACK, , Introducción a QUADPACK, Integración
@section Funciones y variables para QUADPACK

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Función} quad_qag (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{key}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Función} quad_qag (@var{f}, @var{x}, @var{a}, @var{b}, @var{key}, [@var{epsrel}, @var{epsabs}, @var{limit}])
Integración de una función general en un intervalo finito.
La función @code{quad_qag} implementa un integrador global 
adaptativo simple utilizando una estrategia de Aind (Piessens, 1973).
Se puede escoger entre seis pares de fórmulas de cuadratura de
Gauss-Kronrod para la regla de evaluación.
Las reglas de rango superior son útiles en los casos en los que
los integrandos tienen un alto grado de oscilación.

La función @code{quad_qag} calcula numéricamente la integral

@ifhtml
@math{integrate (f(x), x, a, b)}
@end ifhtml
@ifinfo
@math{integrate (f(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b {f(x) dx}$$
@end tex

utilizando un integrador adaptativo simple.

La función a integrar es @var{f(x)}, con variable independiente @var{x},
siendo el intervalo de integración el comprendido entre @var{a} y @var{b}.
El argumento @var{key} indica el integrador a utilizar y debe ser un número
entero entre 1 y 6, ambos inclusive.  El valor de @var{key} selecciona el
orden de la regla de integración de Gauss-Kronrod.
Las reglas de rango superior son útiles en los casos en los que
los integrandos tienen un alto grado de oscilación.

El integrando se puede especificar con el nombre de una función u operador de Maxima 
o de Lisp, como una expresión lambda o como una expresión general de Maxima.

La integración numérica se hace de forma adaptativa particionando la región de integración en subintervalos hasta conseguir la precisión requerida.

Los argumentos opcionales pueden especificarse en cualquier orden. 
Todos ellos toman la forma @code{key=val}. Tales argumentos son:

@table @code
@item epsrel
Error relativo deseado de la aproximación. El valor por defecto es 1d-8.
@item epsabs
Error absoluto deseado de la aproximación. El valor por defecto es 0.
@item limit
Tamaño del array interno utilizado para realizar la cuadratura. 
@var{limit} es el número máximo de subintervalos
a utilizar. El valor por defecto es 200.
@end table

La función @code{quad_qag} devuelve una lista de cuatro elementos:

@itemize
@item
la aproximación a la integral,
@item
el error absoluto estimado de la aproximación, 
@item
el número de evaluaciones del integrando,
@item
un código de error.
@end itemize

El código de error (el cuarto elemento del resultado) puede tener los siguientes valores:

@table @code
@item 0
si no ha habido problemas; 
@item 1
si se utilizaron demasiados intervalos;
@item 2
si se encontró un número excesivo de errores de redondeo;
@item 3
si el integrando ha tenido un comportamiento extraño frente a la integración;
@item 6
si los argumentos de entrada no son válidos.
@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Ejemplos:

@example
(%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
(%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
(%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                4
(%o2)                           -
                                9
@end example
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Función} quad_qags (@var{f(x)}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Función} quad_qags (@var{f}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
Integración de una función general en un intervalo finito.
La función @code{quad_qags} implementa la subdivisión de intervalos 
global adaptativa con extrapolación (de Doncker, 1978) mediante
el algoritmo Epsilon  (Wynn, 1956).

La función @code{quad_qags} calcula la integral

@ifhtml
@math{integrate (f(x), x, a, b)}
@end ifhtml
@ifinfo
@math{integrate (f(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b {f(x) dx}$$
@end tex

La función a integrar es @var{f(x)}, de variable independiente @var{x}, 
siendo el intervalo de integración el comprendido entre @var{a} y @var{b}.

El integrando se puede especificar con el nombre de una función u operador de Maxima 
o de Lisp, como una expresión lambda o como una expresión general de Maxima.

Los argumentos opcionales pueden especificarse en cualquier orden. 
Todos ellos toman la forma @code{key=val}. Tales argumentos son:

@table @code
@item epsrel
Error relativo deseado de la aproximación. El valor por defecto es 1d-8.
@item epsabs
Error absoluto deseado de la aproximación. El valor por defecto es 0.
@item limit
Tamaño del array interno utilizado para realizar la cuadratura. 
@var{limit} es el número máximo de subintervalos
a utilizar. El valor por defecto es 200.
@end table

La función @code{quad_qags} devuelve una lista de cuatro elementos:

@itemize
@item
la aproximación a la integral,
@item
el error absoluto estimado de la aproximación, 
@item
el número de evaluaciones del integrando,
@item
un código de error.
@end itemize

El código de error (el cuarto elemento del resultado) puede tener los siguientes valores:

@table @code
@item 0
si no ha habido problemas; 
@item 1
si se utilizaron demasiados intervalos;
@item 2
si se encontró un número excesivo de errores de redondeo;
@item 3
si el integrando ha tenido un comportamiento extraño frente a la integración;
@item 4
fallo de convergencia;
@item 5
la integral es probablemente divergente o de convergencia lenta;
@item 6
si los argumentos de entrada no son válidos.
@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Ejemplos:

@example
(%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
(%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]
@end example

Nótese que @code{quad_qags} es más precisa y eficiente que @code{quad_qag} para este integrando.

@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Función} quad_qagi (@var{f(x)}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Función} quad_qagi (@var{f}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Integración de una función general en un intervalo infinito o semi-infinito.
El intervalo se proyecta sobre un intervalo finito y luego se aplica la
misma estrategia que en @code{quad_qags}.

La función @code{quad_qagi} calcula cualquiera las siguientes integrales:

@ifhtml
@math{integrate (f(x), x, a, inf)}
@end ifhtml
@ifinfo
@math{integrate (f(x), x, a, inf)}
@end ifinfo
@tex
$$\int_a^\infty {f(x) dx}$$
@end tex

@ifhtml
@math{integrate (f(x), x, minf, a)}
@end ifhtml
@ifinfo
@math{integrate (f(x), x, minf, a)}
@end ifinfo
@tex
$$\int_\infty^a {f(x) dx}$$
@end tex

@ifhtml
@math{integrate (f(x), x, minf, inf)}
@end ifhtml
@ifinfo
@math{integrate (f(x), x, minf, inf)}
@end ifinfo
@tex
$$\int_{-\infty}^\infty {f(x) dx}$$
@end tex

utilizando la rutina QAGI de Quadpack QAGI. La función a integrar es @var{f(x)}, con variable independiente @var{x}, siendo el intervalo de integración de rango infinito.

El integrando se puede especificar con el nombre de una función u operador de Maxima 
o de Lisp, como una expresión lambda o como una expresión general de Maxima.

Uno de los límites de integración debe ser infinito. De no ser
así, @code{quad_qagi} devolverá una forma nominal.

Los argumentos opcionales pueden especificarse en cualquier orden. 
Todos ellos toman la forma @code{key=val}. Tales argumentos son:

@table @code
@item epsrel
Error relativo deseado de la aproximación. El valor por defecto es 1d-8.
@item epsabs
Error absoluto deseado de la aproximación. El valor por defecto es 0.
@item limit
Tamaño del array interno utilizado para realizar la cuadratura. 
@var{limit} es el número máximo de subintervalos
a utilizar. El valor por defecto es 200.
@end table

La función @code{quad_qagi} devuelve una lista de cuatro elementos:

@itemize
@item
la aproximación a la integral,
@item
el error absoluto estimado de la aproximación, 
@item
el número de evaluaciones del integrando,
@item
un código de error.
@end itemize

El código de error (el cuarto elemento del resultado) puede tener los siguientes valores:

@table @code
@item 0
si no ha habido problemas; 
@item 1
si se utilizaron demasiados intervalos;
@item 2
si se encontró un número excesivo de errores de redondeo;
@item 3
si el integrando ha tenido un comportamiento extraño frente a la integración;
@item 4
fallo de convergencia;
@item 5
la integral es probablemente divergente o de convergencia lenta;
@item 6
si los argumentos de entrada no son válidos.
@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Ejemplos:

@example
(%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
(%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
(%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                               1
(%o2)                          --
                               32
@end example

@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Función} quad_qawc (@var{f(x)}, @var{x}, @var{c}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Función} quad_qawc (@var{f}, @var{x}, @var{c}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
Calcula el valor principal de Cauchy de @math{f(x)/(x - c)} en un
intervalo finito @math{(a, b)} para una @math{c} dada.
La estrategia es global adaptativa, utilizando la integración de 
Clenshaw-Curtis modificada en los subintervalos que contienen a @math{x = c}.

La función @code{quad_qawc} calcula el valor principal de Cauchy de

@ifhtml
@math{integrate (f(x)/(x - c), x, a, b)}
@end ifhtml
@ifinfo
@math{integrate (f(x)/(x - c), x, a, b)}
@end ifinfo
@tex
$$\int_{a}^{b}{{{f\left(x\right)}\over{x-c}}\>dx}$$
@end tex

utilizando la rutina QAWC de Quadpack.  La función a integrar es
@code{@var{f(x)}/(@var{x} - @var{c})}, con variable independiente @var{x}, siendo el intervalo de integración el comprendido entre @var{a} y @var{b}.

El integrando se puede especificar con el nombre de una función u operador de Maxima 
o de Lisp, como una expresión lambda o como una expresión general de Maxima.

Los argumentos opcionales pueden especificarse en cualquier orden. 
Todos ellos toman la forma @code{key=val}. Tales argumentos son:

@table @code
@item epsrel
Error relativo deseado de la aproximación. El valor por defecto es 1d-8.
@item epsabs
Error absoluto deseado de la aproximación. El valor por defecto es 0.
@item limit
Tamaño del array interno utilizado para realizar la cuadratura. 
@var{limit} es el número máximo de subintervalos
a utilizar. El valor por defecto es 200.
@end table

@code{quad_qawc} returns a list of four elements:

@itemize
@item
la aproximación a la integral,
@item
el error absoluto estimado de la aproximación, 
@item
el número de evaluaciones del integrando,
@item
un código de error.
@end itemize

El código de error (el cuarto elemento del resultado) puede tener los siguientes valores:

@table @code
@item 0
si no ha habido problemas; 
@item 1
si se utilizaron demasiados intervalos;
@item 2
si se encontró un número excesivo de errores de redondeo;
@item 3
si el integrando ha tenido un comportamiento extraño frente a la integración;
@item 6
si los argumentos de entrada no son válidos.
@end table

Ejemplos:

@example
(%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                 'epsrel=1d-7);
(%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
(%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
                 x, 0, 5);
Principal Value
        alpha        9 4                 9
       4      log(-------------- + --------------)
                   alpha + 3        alpha + 3
                  4          + 4   4          + 4
(%o2) (-------------------------------------------
                         alpha
                      2 4      + 2
    3 alpha                   3 alpha
    -------                   -------
       2          alpha/2        2              alpha/2
   4        atan(4       )   4        atan(- 4 4       )
 - ----------------------- + ---------------------------)
          alpha                       alpha
         4      + 1                  4      + 1
  alpha
/2
(%i3) ev (%, alpha=5, numer);
(%o3)                    - 3.130120337415917
@end example

@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Función} quad_qawf (@var{f(x)}, @var{x}, @var{a}, @var{omega}, @var{trig}, [@var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])
@deffnx {Función} quad_qawf (@var{f}, @var{x}, @var{a}, @var{omega}, @var{trig}, [@var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])
Calcula la transformada seno o coseno de Fourier en un intervalo semi-infinito.
Se aplica el mismo método que en @code{quad_qawo} a sucesivos intervalos
finitos, acelerando la convergencia mediante el algoritmo Epsilon (Wynn, 1956).

La función @code{quad_qawf} calcula la integral

@ifhtml
@math{integrate (f(x)*w(x), x, a, inf)}
@end ifhtml
@ifinfo
@math{integrate (f(x)*w(x), x, a, inf)}
@end ifinfo
@tex
$$\int_a^\infty f(x) w(x) dx$$
@end tex

La función peso @math{w} se selecciona mediante @var{trig}:

@table @code
@item cos
@math{w(x) = cos (omega x)}
@item sin
@math{w(x) = sin (omega x)}
@end table


El integrando se puede especificar con el nombre de una función u operador de Maxima 
o de Lisp, como una expresión lambda o como una expresión general de Maxima

Los argumentos opcionales pueden especificarse en cualquier orden. 
Todos ellos toman la forma @code{key=val}. Tales argumentos son:

@table @code
@item epsabs
El error absoluto deseado para la aproximación. El valor por defecto es 1d-10.
@item limit
Tamaño del arreglo interno de trabajo.  (@var{limit} - @var{limlst})/2 es el número máximo de subintervalos para la partición. El valor por defecto es 200.
@item maxp1
Número máximo de momentos de Chebyshev. Debe ser mayor que 0.  El valor por defecto es 100.
@item limlst
Cota superior del número de ciclos. Debe ser mayor o igual que 3.  El valor por defecto es 10.
@end table

@code{quad_qawf} returns a list of four elements:

@itemize
@item
la aproximación a la integral,
@item
el error absoluto estimado de la aproximación, 
@item
el número de evaluaciones del integrando,
@item
un código de error.
@end itemize

El código de error (el cuarto elemento del resultado) puede tener los siguientes valores:

@table @code
@item 0
si no ha habido problemas; 
@item 1
si se utilizaron demasiados intervalos;
@item 2
si se encontró un número excesivo de errores de redondeo;
@item 3
si el integrando ha tenido un comportamiento extraño frente a la integración;
@item 6
si los argumentos de entrada no son válidos.
@end table

Ejemplos:

@example
(%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
(%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
(%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                          - 1/4
                        %e      sqrt(%pi)
(%o2)                   -----------------
                                2
(%i3) ev (%, numer);
(%o3)                   .6901942235215714
@end example

@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Función} quad_qawo (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, [@var{epsrel}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])
@deffnx {Función} quad_qawo (@var{f}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, [@var{epsrel}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])
Integración de @math{cos(omega x) f(x)} o @math{sin(omega x) f(x)} en un
intervalo finito, siendo @math{omega} una constante. La regla de 
evaluación se basa en la técnica modificada de Clenshaw-Curtis.
La función @code{quad_qawo} aplica la subdivisión adaptativa con extrapolación, 
de forma similar a @code{quad_qags}.

La función @code{quad_qawo} realiza la integración utilizando la rutina QAWO de Quadpack:

@ifhtml
@math{integrate (f(x)*w(x), x, a, b)}
@end ifhtml
@ifinfo
@math{integrate (f(x)*w(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b f(x) w(x) dx$$
@end tex

La función peso @math{w} se selecciona mediante @var{trig}:

@table @code
@item cos
@math{w(x) = cos (omega x)}
@item sin
@math{w(x) = sin (omega x)}
@end table

El integrando se puede especificar con el nombre de una función u operador de Maxima 
o de Lisp, como una expresión lambda o como una expresión general de Maxima

Los argumentos opcionales pueden especificarse en cualquier orden. 
Todos ellos toman la forma @code{key=val}. Tales argumentos son:

@table @code
@item epsrel
El error absoluto deseado para la aproximación. El valor por defecto es 1d-8.
@item epsabs
Error absoluto deseado de la aproximación. El valor por defecto es 0.
@item limit
Tamaño del arreglo interno de trabajo. @var{limit}/2 es el número máximo de subintervalos para la partición. El valor por defecto es 200.
@item maxp1
Número máximo de momentos de Chebyshev. Debe ser mayor que 0.  El valor por defecto es 100.
@item limlst
Cota superior del número de ciclos. Debe ser mayor o igual que 3.  El valor por defecto es 10.
@end table

@code{quad_qawo} returns a list of four elements:

@itemize
@item
la aproximación a la integral,
@item
el error absoluto estimado de la aproximación, 
@item
el número de evaluaciones del integrando,
@item
un código de error.
@end itemize

El código de error (el cuarto elemento del resultado) puede tener los siguientes valores:

@table @code
@item 0
si no ha habido problemas; 
@item 1
si se utilizaron demasiados intervalos;
@item 2
si se encontró un número excesivo de errores de redondeo;
@item 3
si el integrando ha tenido un comportamiento extraño frente a la integración;
@item 6
si los argumentos de entrada no son válidos.
@end table

Ejemplos:

@example
(%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
(%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
(%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
                           x, 0, inf));
                   alpha/2 - 1/2            2 alpha
        sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
(%o2)   -----------------------------------------------------
                               2 alpha
                         sqrt(2        + 1)
(%i3) ev (%, alpha=2, numer);
(%o3)                     1.376043390090716
@end example

@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Función} quad_qaws (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Función} quad_qaws (@var{f}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, [@var{epsrel}, @var{epsabs}, @var{limit}])
Integración de @math{w(x) f(x)} en un intervalo finito @math{[a, b]},
siendo @math{w} una función de la forma @math{(x - a)^alpha (b - x)^beta v(x)},
con  @math{v(x)} igual a 1, a @math{log(x - a)}, a @math{log(b - x)} o a
@math{log(x - a) log(b - x)} y con @math{alpha > -1}, y @math{beta > -1}.
Se aplica una estrategia de subdivisión adaptativa global,
con integración de Clenshaw-Curtis modificada en los subintervalos que
contienen a @math{a} y a @math{b}.

La función @code{quad_qaws} realiza la integración utizando la rutina QAWS de Quadpack:

@ifhtml
@math{integrate (f(x)*w(x), x, a, b)}
@end ifhtml
@ifinfo
@math{integrate (f(x)*w(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b f(x) w(x) dx$$
@end tex

La función peso @math{w} se selecciona mediante @var{wfun}:

@table @code
@item 1
@math{w(x) = (x - a)^alfa (b - x)^beta}
@item 2
@math{w(x) = (x - a)^alfa (b - x)^beta log(x - a)}
@item 3
@math{w(x) = (x - a)^alfa (b - x)^beta log(b - x)}
@item 4
@math{w(x) = (x - a)^alfa (b - x)^beta log(x - a) log(b - x)}
@end table

El integrando se puede especificar con el nombre de una función u operador de Maxima 
o de Lisp, como una expresión lambda o como una expresión general de Maxima

Los argumentos opcionales pueden especificarse en cualquier orden. 
Todos ellos toman la forma @code{key=val}. Tales argumentos son:

@table @code
@item epsrel
El error absoluto deseado para la aproximación. El valor por defecto es 1d-8.
@item epsabs
Error absoluto deseado de la aproximación. El valor por defecto es 0.
@item limit
Tamaño del array interno utilizado para realizar la cuadratura. 
(@var{limit} - @var{limlst})/2 es el número máximo de subintervalos
a utilizar. El valor por defecto es 200.
@end table

@code{quad_qaws} returns a list of four elements:

@itemize
@item
la aproximación a la integral,
@item
el error absoluto estimado de la aproximación, 
@item
el número de evaluaciones del integrando,
@item
un código de error.
@end itemize

El código de error (el cuarto elemento del resultado) puede tener los siguientes valores:

@table @code
@item 0
si no ha habido problemas; 
@item 1
si se utilizaron demasiados intervalos;
@item 2
si se encontró un número excesivo de errores de redondeo;
@item 3
si el integrando ha tenido un comportamiento extraño frente a la integración;
@item 6
si los argumentos de entrada no son válidos.
@end table

Ejemplos:

@example
(%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                 'epsabs=1d-9);
(%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
(%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
       alpha
Is  4 2      - 1  positive, negative, or zero?

pos;
                          alpha         alpha
                   2 %pi 2      sqrt(2 2      + 1)
(%o2)              -------------------------------
                               alpha
                            4 2      + 2
(%i3) ev (%, alpha=4, numer);
(%o3)                     8.750097361672829
@end example

@end deffn


@deffn  {Fución} quad_qagp (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{points}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Fución} quad_qagp (@var{f}, @var{x}, @var{a}, @var{b}, @var{points}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Integra una función general sobre un intervalo acotado. La función
@code{quad_qagp} implementa un método adaptativo global de subdivisión
del intervalo con extrapolación (de Doncker, 1978) basado en el algoritmo
Epsilon (Wynn, 1956).

@code{quad_qagp} calcula la integral

@ifnottex
@math{integrate (f(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b {f(x) \, dx}$$
@end tex

La función a integrar es @var{f(x)}, con variable independiente
@var{x}, en el intervalo limitado por @var{a} y @var{b}.

El integrando puede especificarse mediante el nombre de una función de
Maxima o de Lisp o un operador, como una expresión lambda de Maxima, o
como una expresión general de Maxima.

Para ayudar al integrador, el usuario debe aportar una lista de puntos 
donde el integrando es singular o discontinuo.

Las opciones se suministran como argumentos y se pueden escribir en
cualquier orden. Deben tomar la forma @code{opción=valor}. Las 
opciones son:

@table @code
@item epsrel
Error relativo de aproximación deseado. Valor por defecto es 1d-8.
@item epsabs
Error absoluto de aproximación deseado. Valor por defecto es 0.
@item limit
Tamaño del array interno de trabajo. @var{limit} es el máximo
número de subintervalos a utilizar. Valor por defecto es 200.
@end table

@code{quad_qagp} devuelve una lista con cuatro elementos:

@itemize
@item
una aproximación a la integral,
@item
el error absoluto estimado de la aproximación,
@item
el número de evaluaciones del integrando,
@item
un código de error.
@end itemize

El código de error (cuarto elemento de la lista devuelta) puede tener los
siguientes valores:

@table @code
@item 0
no se encontraron errores;
@item 1
se han hecho demasiados subintervalos;
@item 2
se detectó un error de redondeo muy grande;
@item 3
se ha observado un comportamiento del integrando extremadamente malo;
@item 4
fallo de convergencia;
@item 5
la integral es probablemente divergengente o converge muy lentamente;
@item 6
entrada inválida.
@end table

Ejemplos:

@example
@group
(%i1) quad_qagp(x^3*log(abs((x^2-1)*(x^2-2))),x,0,3,[1,sqrt(2)]);
(%o1)   [52.74074838347143, 2.6247632689546663e-7, 1029, 0]
@end group
@group
(%i2) quad_qags(x^3*log(abs((x^2-1)*(x^2-2))), x, 0, 3);
(%o2)   [52.74074847951494, 4.088443219529836e-7, 1869, 0]
@end group
@end example

El integrando tiene singularidades en @code{1} y @code{sqrt(2)}, de manera que
suministramos estos puntos a @code{quad_qagp}. También se observa que @code{quad_qagp}
es más exacto y eficiente que @code{quad_qags}.
@end deffn



@deffn  {Fución} quad_control (@var{parameter}, [@var{value}])

Controla la gestión de los errores de @code{QUADPACK}. El parámetro debe
ser uno de los siguientes símbolos:

@table @code
@item current_error
El número de error actual.
@item control
Controla si los mensajes se imprimen o no. Si el valor es cero o menor,
los mensajes se suprimen.
@item max_message
El máximo número de veces que se imprime cualquier mensaje.
@end table

Si no se da @var{value}, entonces se devuelve el valor actual asociado a
@var{parameter}. En cambio, si se da @var{value}, se hace la asignación
correspondiente a @var{parameter}, adquiriendo este nuevo valor.
@end deffn


