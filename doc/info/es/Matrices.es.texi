@c English version 2011-09-03
@menu
* Introducción a las matrices y el álgebra lineal::
* Funciones y variables para las matrices y el álgebra lineal::
@end menu

@node Introducción a las matrices y el álgebra lineal, Funciones y variables para las matrices y el álgebra lineal, Matrices y Álgebra Lineal, Matrices y Álgebra Lineal
@section Introducción a las matrices y el álgebra lineal

@menu
* Operador punto::                         
* Vectores::                     
* Paquete eigen::
@end menu

@node Operador punto, Vectores, Introducción a las matrices y el álgebra lineal, Introducción a las matrices y el álgebra lineal
@subsection Operador punto
El operador  @code{.} realiza la multiplicación matricial y el producto escalar.
Cuando los operandos son dos matrices columna o matrices fila @code{a} y @code{b},
la expresión @code{a.b} es equivalente a @code{sum (a[i]*b[i], i, 1, length(a))}.
Si @code{a} y @code{b} no son complejos, estamos en el caso del producto escalar.
En caso de ser @code{a} y @code{b} vectores en el campo complejo, el producto 
escalar se define como @code{conjugate(a).b}; la función @code{innerproduct} del
paquete @code{eigen} realiza el producto escalar complejo.

Cuando los operandos son matrices de índole más general,
el resultado que se obtiene es el producto matricial de @code{a} por @code{b}.
El número de filas de @code{b} debe ser igual al número de columnas de @code{a},
y el resultado tiene un número de filas igual al de @code{a} y un número de
columnas igual al de @code{b}.

Al objeto de distinguir @code{.} como operador aritmético del punto decimal
de la notación en coma flotante, puede ser necesario dejar espacios a ambos lados.
Por ejemplo, @code{5.e3} es @code{5000.0} pero @code{5 . e3} es @code{5} por @code{e3}.

Hay algunas variables globales que controlan la simplificación de expresiones que
contengan al operador @code{.}, a saber,
@code{dot}, @code{dot0nscsimp}, @code{dot0simp}, @code{dot1simp}, @code{dotassoc}, 
@code{dotconstrules}, @code{dotdistrib}, @code{dotexptsimp}, @code{dotident},
y @code{dotscrules}.

@node Vectores, Paquete eigen, Operador punto, Introducción a las matrices y el álgebra lineal
@subsection Vectores
El paquete @code{vect} define funciones para análisis vectorial. Para cargar el paquete en memoria se debe hacer
@code{load ("vect")}  y con @code{demo ("vect")} se presenta una demostración sobre las funciones del paquete.
@c find maxima -name \*orth\* YIELDS NOTHING; ARE THESE FUNCTIONS IN ANOTHER FILE NOW ??
@c and SHARE;VECT ORTH contains definitions of various orthogonal curvilinear coordinate systems.

El paquete de análisis vectorial puede combinar y simplificar expresiones
simbólicas que incluyan productos escalares y vectoriales, junto con los operadores
de gradiente, divergencia, rotacional y laplaciano. La distribución de estos operadores
sobre sumas o productos se gobierna por ciertas variables, al igual que otras transformaciones,
incluida la expansión en componentes en cualquier sistema de coordenadas especificado. 
También hay funciones para obtener el potencial escalar o vectorial de un campo.

El paquete @code{vect} contiene las siguientes funciones:
@code{vectorsimp}, @code{scalefactors},
@code{express}, @code{potential} y @code{vectorpotential}.
@c REVIEW vect.usg TO ENSURE THAT TEXINFO HAS WHATEVER IS THERE
@c PRINTFILE(VECT,USAGE,SHARE); for details.

Por defecto, el paquete @code{vect} no declara el operador @code{.} como conmutativo.
Para transformarlo en conmutativo, se debe ejecutar previamente la instrucción
@code{declare(".", commutative)}.

@node Paquete eigen, , Vectores, Introducción a las matrices y el álgebra lineal
@subsection Paquete eigen

El paquete @code{eigen} contiene funciones para el cálculo 
simbólico de valores y vectores propios. Maxima carga el paquete
automáticamente si se hace una llamada a cualquiera de las dos funciones
@code{eigenvalues} o @code{eigenvectors}. El paquete se puede cargar de
forma explícita mediante @code{load ("eigen")}.

La instrucción @code{demo ("eigen")} hace una demostración de las funciones de este paquete;
@code{batch ("eigen")} realiza la misma demostración pero sin pausas entre los
sucesivos cálculos.

Las funciones del paquete @code{eigen} son
@code{innerproduct}, @code{unitvector}, @code{columnvector},
@code{gramschmidt}, @code{eigenvalues}, @code{eigenvectors}, @code{uniteigenvectors}
y @code{similaritytransform}.

@c end concepts Matrices and Linear Algebra
@node Funciones y variables para las matrices y el álgebra lineal,  , Introducción a las matrices y el álgebra lineal, Matrices y Álgebra Lineal
@section Funciones y variables para las matrices y el álgebra lineal

@deffn {Función} addcol (@var{M}, @var{lista_1}, ..., @var{lista_n})
Añade la/s columna/s dada/s por la/s lista/s (o matrices) a la matriz @var{M}.

@end deffn

@deffn {Función} addrow (@var{M}, @var{lista_1}, ..., @var{lista_n})
Añade la/s fila/s dada/s por la/s lista/s (o matrices) a la matriz @var{M}.

@end deffn

@deffn {Función} adjoint (@var{M})
Devuelve el adjunto de la matriz @var{M}.
La matriz adjunta es la transpuesta de la matriz de cofactores de @var{M}.

@end deffn

@deffn {Función} augcoefmatrix ([@var{eqn_1}, ..., @var{eqn_m}], [@var{x_1}, ..., @var{x_n}])
Devuelve la matriz aumentada de coeficientes del sistema de ecuaciones lineales 
@var{eqn_1}, ..., @var{eqn_m} de variables @var{x_1}, ..., @var{x_n}. Se trata de la
matriz de coeficientes con una columna adicional para los términos constantes de cada
ecuación, es decir, aquellos términos que no dependen de las variables
@var{x_1}, ..., @var{x_n}.

@example
(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
@end example

@end deffn



@deffn  {Función} cauchy_matrix ([@var{x_1},@var{x_2}, ..., @var{x_m}], [@var{y_1},@var{y_2}, ..., @var{y_n}])
@deffnx {Función} cauchy_matrix ([@var{x_1},@var{x_2}, ..., @var{x_n}])

Devuelve una matriz de Cauchy @var{n} by @var{m} de elementos
@var{a[i,j]} = 1/(@var{x_i}+@var{y_i}).
El segundo elemento de @code{cauchy_matrix} es opcional, y en caso
de no estar presente, los elementos serán de la forma
@var{a[i,j]} = 1/(@var{x_i}+@var{x_j}).

Observación: en la literatura, la matriz de Cauchy se define a veces
con sus elementos de la forma @var{a[i,j]} = 1/(@var{x_i}-@var{y_i}).

Ejemplos:

@c ===beg===
@c cauchy_matrix([x1,x2],[y1,y2]);
@c cauchy_matrix([x1,x2]);
@c ===end===
@example
(%i1) cauchy_matrix([x1,x2],[y1,y2]);
                      [    1        1    ]
                      [ -------  ------- ]
                      [ y1 + x1  y2 + x1 ]
(%o1)                 [                  ]
                      [    1        1    ]
                      [ -------  ------- ]
                      [ y1 + x2  y2 + x2 ]

(%i2) cauchy_matrix([x1,x2]);
                      [   1         1    ]
                      [  ----    ------- ]
                      [  2 x1    x2 + x1 ]
(%o2)                 [                  ]
                      [    1       1     ]
                      [ -------   ----   ]
                      [ x2 + x1   2 x2   ]
@end example
@end deffn



@deffn {Función} charpoly (@var{M}, @var{x})
Calcula el polinomio característico de la matriz @var{M}
respecto de la variable @var{x}. Esto es, 
@code{determinant (@var{M} - diagmatrix (length (@var{M}), @var{x}))}.

@example
(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
@end example

@end deffn

@deffn {Función} coefmatrix ([@var{eqn_1}, ..., @var{eqn_m}], [@var{x_1}, ..., @var{x_n}])
Devuelve la matriz de coeficientes para las variables @var{x_1}, ..., @var{x_n}
del sistema de ecuaciones lineales @var{eqn_1}, ..., @var{eqn_m}.

@example
(%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                 [ 2  1 - a ]
(%o1)                            [          ]
                                 [ a    b   ]
@end example

@end deffn

@deffn {Función} col (@var{M}, @var{i})
Devuelve la @var{i}-ésima columna de la matriz @var{M}.
El resultado es una matriz de una sola columna.
@c EXAMPLE HERE

@end deffn

@deffn {Función} columnvector (@var{L})
@deffnx {Función} covect (@var{L})
Devuelve una matriz con una columna  y @code{length (@var{L})} filas,
conteniendo los elementos de la lista @var{L}.

La llamada @code{covect} es un sinónimo de @code{columnvector}.

Es necesario cargar la función haciendo @code{load ("eigen")}.


Ejemplo:

@c HMM, SPURIOUS "redefining the Macsyma function".
@c LEAVE IT HERE SINCE THAT'S WHAT A USER ACTUALLY SEES.
@example
(%i1) load ("eigen")$
Warning - you are redefining the Macsyma function eigenvalues
Warning - you are redefining the Macsyma function eigenvectors
(%i2) columnvector ([aa, bb, cc, dd]);
                             [ aa ]
                             [    ]
                             [ bb ]
(%o2)                        [    ]
                             [ cc ]
                             [    ]
                             [ dd ]
@end example

@end deffn


@deffn {Función} copymatrix (@var{M})
Devuelve una copia de la matriz @var{M}. Esta es la única
manera de obtener una réplica de @var{M} además de la de
copiar elemento a elemento.

Nótese que una asignación de una matriz a otra, como en @code{m2: m1},
no hace una copia de @code{m1}. Asignaciones del tipo @code{m2 [i,j]: x} o
@code{setelmx (x, i, j, m2} también modifica @code{m1 [i,j]}. Si se crea una copia 
con @code{copymatrix} y luego se hacen asignaciones se tendrá una copia separada y
modificada.

@c NEED EXAMPLE HERE
@end deffn

@deffn {Función} determinant (@var{M})
Calcula el determinante de  @var{M} por un método similar al
de eliminación de Gauss

@c JUST HOW DOES ratmx AFFECT THE RESULT ??
La forma del resultado depende del valor asignado
a @code{ratmx}.

@c IS A SPARSE DETERMINANT SOMETHING OTHER THAN THE DETERMINANT OF A SPARSE MATRIX ??
Existe una rutina especial para calcular determinantes de matrices con elementos dispersas, la cual
será invocada cuando las variables @code{ratmx} y @code{sparse} valgan ambas
@code{true}.

@c EXAMPLES NEEDED HERE
@end deffn

@defvr {Variable opcional} detout
Valor por defecto: @code{false}

Cuando @code{detout} vale @code{true}, el determinante de la matriz 
cuya inversa se calcula aparece como un factor fuera de la matriz.

Para que esta variable surta efecto, @code{doallmxops} y @code{doscmxops} deberían tener
el valor @code{false} (véanse sus descripciones). Alternativamente, esta 
variable puede ser suministrada a @code{ev}.

Ejemplo:

@example
(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
@end example
@c THERE'S MORE TO THIS STORY: detout: false$ invert (m); RETURNS THE SAME THING.
@c IT APPEARS THAT doallmxops IS CRUCIAL HERE.

@end defvr

@deffn {Función} diagmatrix (@var{n}, @var{x})
Devuelve una matriz diagonal de orden @var{n} 
con los elementos de la diagonal todos ellos iguales a @var{x}. La llamada
@code{diagmatrix (@var{n}, 1)} devuelve una matriz identidad
(igual que @code{ident (@var{n})}).

La variable @var{n} debe ser un número entero, en caso contrario @code{diagmatrix} envía un mensaje de error.

@var{x} puede ser cualquier tipo de expresión, incluso otra matriz.
Si @var{x} es una matriz, no se copia; todos los elementos de la diagonal son iguales a @var{x}.

@c NEED EXAMPLE HERE
@end deffn

@defvr {Variable opcional} doallmxops
Valor por defecto: @code{true}

Cuando @code{doallmxops} vale @code{true},
todas las operaciones relacionadas con matrices son
llevadas a cabo. Cuando es @code{false}, entonces las
selecciones para @code{dot} controlan las operaciones a ejecutar.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Variable opcional} domxexpt
Valor por defecto: @code{true}

Cuando @code{domxexpt} vale @code{true},
un exponente matricial, como @code{exp (@var{M})} donde @var{M} es
una matriz, se interpreta como una matriz cuyo elemento @code{[i,j} es
igual a @code{exp (m[i,j])}. En otro caso, @code{exp (@var{M})} se
evalúa como @code{exp (ev(@var{M}))}.

La variable @code{domxexpt} afecta a todas las expresiones de la forma @code{@var{base}^@var{exponente}}
donde @var{base} es una expresión escalar o constante y @var{exponente} es una
lista o matriz.

Ejemplo:

@example
(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
@end example

@end defvr

@defvr {Variable opcional} domxmxops
Valor por defecto: @code{true}

Cuando @code{domxmxops} vale @code{true}, se realizan todas las operaciones entre
matrices o entre matrices y listas (pero no las operaciones 
entre matrices y escalares); si esta variable es @code{false} tales
operaciones no se realizan.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Variable opcional} domxnctimes
Valor por defecto: @code{false}

Cuando @code{domxnctimes} vale @code{true}, se calculan los productos
no conmutativos entre matrices.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Variable opcional} dontfactor
Valor por defecto: @code{[]}

En @code{dontfactor} puede guardarse una lista de variables respecto de
las cuales no se realizarán factorizaciones. Inicialmente, la lista
está vacía.

@end defvr

@defvr {Variable opcional} doscmxops
Valor por defecto: @code{false}

Cuando @code{doscmxops} vale @code{true}, se realizan las operaciones entre escalares y 
matrices.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Variable opcional} doscmxplus
Valor por defecto: @code{false}

Cuando @code{doscmxplus} vale @code{true}, las operaciones entre
escalares y matrices dan como resultado una matriz.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Variable opcional} dot0nscsimp
Valor por defecto: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
(Esta descripción no está clara en la versión inglesa original.)

@c NEED EXAMPLE HERE
@end defvr


@c AQUI FALTA DEFINICION DE dot0simp

@c AQUI FALTA DEFINICION DE dot1simp

@defvr {Variable opcional} dotassoc
Valor por defecto: @code{true}

Cuando @code{dotassoc} vale @code{true}, una expresión como @code{(A.B).C} se transforma en
@code{A.(B.C)}.
@c "." MEANS NONCOMMUTATIVE MULTIPLICATION RIGHT ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Variable opcional} dotconstrules
Valor por defecto: @code{true}

Cuando @code{dotconstrules} vale @code{true}, un producto no conmutativo de una
constante con otro término se transforma en un producto conmutativo.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Variable opcional} dotdistrib
Valor por defecto: @code{false}

Cuando @code{dotdistrib} vale @code{true}, una expresión como @code{A.(B + C)} se transforma en @code{A.B + A.C}.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Variable opcional} dotexptsimp
Valor por defecto: @code{true}

Cuando @code{dotexptsimp} vale @code{true}, una expresión como @code{A.A} se transforma en @code{A^^2}.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Variable opcional} dotident
Valor por defecto: 1

El valor de la variable @code{dotident} es el resultado devuelto por @code{X^^0}.
@c "RETURNED" ?? IS THIS A SIMPLIFICATION OR AN EVALUATION ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Variable opcional} dotscrules
Valor por defecto: @code{false}

Cuando @code{dotscrules} vale @code{true}, una expresión como @code{A.SC} o @code{SC.A} se transforma 
en @code{SC*A} y @code{A.(SC*B)} en @code{SC*(A.B)}.
@c HMM, DOES "SC" MEAN "SCALAR" HERE ?? CLARIFY

@c NEED EXAMPLE HERE
@end defvr

@deffn {Función} echelon (@var{M})
Devuelve la forma escalonada de la matriz @var{M}, obtenida por eliminación gaussiana.
La forma escalonada se calcula a partir de @var{M} mediante operaciones elementales con sus filas,
de tal manera que el primer elemento no nulo de cada fila en la matriz 
resultado es la unidad y que cada elemento de la columna por debajo del primer uno de cada
fila sean todos ceros.

La función @code{triangularize} también lleva a cabo la eliminación gaussiana, pero no 
normaliza el primer elemento no nulo de cada fila.

Otras funciones, como @code{lu_factor} y @code{cholesky}, también dan como resultados
matrices triangularizadas.

@c ===beg===
@c M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
@c echelon (M);
@c ===end===
@example
(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) echelon (M);
                  [ 1  - 8  - 5      - 2     ]
                  [                          ]
                  [         28       11      ]
                  [ 0   1   --       --      ]
(%o2)             [         37       37      ]
                  [                          ]
                  [              37 bb - 119 ]
                  [ 0   0    1   ----------- ]
                  [              37 aa - 313 ]
@end example

@end deffn

@deffn {Función} eigenvalues (@var{M})
@deffnx {Función} eivals (@var{M})
@c eigen.mac IS AUTOLOADED IF eigenvalues OR eigenvectors IS REFERENCED; EXTEND THAT TO ALL FUNCTIONS ??
@c EACH FUNCTION INTENDED FOR EXTERNAL USE SHOULD HAVE ITS OWN DOCUMENTATION ITEM
Devuelve una lista con dos sublistas. La primera sublista la forman los
valores propios de la matriz @var{M} y la segunda sus multiplicidades correspondientes.

El nombre @code{eivals} es un sinónimo de @code{eigenvalues}.

La función @code{eigenvalues} llama a la función @code{solve} para calcular las raíces
del polinomio característico de la matriz. En ocasiones, @code{solve} no
podrá encontrar dichas raíces, en cuyo caso otras funciones de este paquete
no trabajarán correctamente, a excepción de @code{innerproduct},
@code{unitvector}, @code{columnvector} y @code{gramschmidt}.
@c WHICH ONES ARE THE FUNCTIONS WHICH DON'T WORK ??
@c ACTUALLY IT'S MORE IMPORTANT TO LIST THE ONES WHICH DON'T WORK HERE
@c WHAT DOES "will not work" MEAN, ANYWAY ??

En algunos casos los valores propios encontrados por @code{solve} serán
expresiones complicadas, las cuales se podrán simplificar haciendo uso
de otras funciones.
@c WHAT ARE THOSE OTHER FUNCTIONS ??

El paquete @code{eigen.mac} se carga en memoria de forma automática cuando
se invocan @code{eigenvalues} o @code{eigenvectors}. Si @code{eigen.mac} no
está ya cargado, @code{load ("eigen")} lo carga. Tras la carga, todas las
funciones y variables del paquete estarán activas.
@c REFER TO OVERVIEW OF PACKAGE (INCLUDING LIST OF FUNCTIONS) HERE

@c NEED EXAMPLES HERE
@end deffn

@deffn {Función} eigenvectors (@var{M})
@deffnx {Función} eivects (@var{M})

Calcula los vectores propios de la matriz @var{M}.
El resultado devuelto es una lista con dos elementos;
el primero está formado por dos listas, la primera con los valores propios
de @var{M} y la segunda con sus respectivas multiplicidades, el segundo
elemento es una lista de listas de vectores propios, una por
cada valor propio, pudiendo haber uno o más vectores propios en cada lista.

Tomando la matriz @var{M} como argumento, devuelve una lista de listas,
la primera de las cuales es la salida de @code{eigenvalues} y las 
siguientes son los vectorios propios de la matriz asociados a los
valores propios correspondientes. Los vectores propios calculados son los 
vectores propios por la derecha.

El nombre @code{eivects} es un sinónimo de @code{eigenvectors}.

El paquete @code{eigen.mac} se carga en memoria de forma automática cuando
se invocan @code{eigenvalues} o @code{eigenvectors}. Si @code{eigen.mac} no
está ya cargado, @code{load ("eigen")} lo carga. Tras la carga, todas las
funciones y variables del paquete estarán activas.

Las variables que afectan a esta función son: 

@code{nondiagonalizable} toma el valor @code{true} o @code{false} dependiendo
de si la matriz no es diagonalizable o diagonalizable tras la ejecución de
@code{eigenvectors}.

@code{hermitianmatrix}, si vale @code{true}, entonces los vectores propios 
degenerados de la matriz hermítica son ortogonalizados mediante el
algoritmo de Gram-Schmidt.

@code{knowneigvals}, si vale @code{true}, entonces el paquete @code{eigen} da por
sentado que los valores propios de la matriz son conocidos por el usuario y 
almacenados en la variable global @code{listeigvals}.  @code{listeigvals} debería
ser similar a la salida de @code{eigenvalues}.

La función @code{algsys} se utiliza aquí para calcular los vectores propios. A
veces, @code{algsys} no podrá calcular una solución. En algunos casos, será posible
simplificar los valores propios calculándolos en primer lugar con @code{eigenvalues} y
luego utilizando otras funciones para simplificarlos. Tras la simplificación, 
@code{eigenvectors} podrá ser llamada otra vez con la variable @code{knowneigvals}
ajustada al valor @code{true}.

Véase también @code{eigenvalues}.

Ejemplos:

Una matriz con un único vector propio por cada valor propio.

@c ===beg===
@c M1 : matrix ([11, -1], [1, 7]);
@c [vals, vecs] : eigenvectors (M1);
@c for i thru length (vals[1]) do disp (val[i] = vals[1][i],
@c   mult[i] = vals[2][i], vec[i] = vecs[i]);
@c ===end===
@example
(%i1) M1 : matrix ([11, -1], [1, 7]);
                           [ 11  - 1 ]
(%o1)                      [         ]
                           [ 1    7  ]
(%i2) [vals, vecs] : eigenvectors (M1);
(%o2) [[[9 - sqrt(3), sqrt(3) + 9], [1, 1]], 
                        [[[1, sqrt(3) + 2]], [[1, 2 - sqrt(3)]]]]
(%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
  mult[i] = vals[2][i], vec[i] = vecs[i]);
                       val  = 9 - sqrt(3)
                          1

                            mult  = 1
                                1

                    vec  = [[1, sqrt(3) + 2]]
                       1

                       val  = sqrt(3) + 9
                          2

                            mult  = 1
                                2

                    vec  = [[1, 2 - sqrt(3)]]
                       2

(%o3)                         done
@end example

Una matriz con dos vectores propios para uno de los valores propios.

@c ===beg===
@c M1 : matrix ([0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0], [0, 0, 0, 2]);
@c [vals, vecs] : eigenvectors (M1);
@c for i thru length (vals[1]) do disp (val[i] = vals[1][i],
@c   mult[i] = vals[2][i], vec[i] = vecs[i]);
@c ===end===
@example
(%i1) M1 : matrix ([0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0], [0, 0, 0, 2]);
                         [ 0  1  0  0 ]
                         [            ]
                         [ 0  0  0  0 ]
(%o1)                    [            ]
                         [ 0  0  2  0 ]
                         [            ]
                         [ 0  0  0  2 ]
(%i2) [vals, vecs] : eigenvectors (M1);
(%o2) [[[0, 2], [2, 2]], [[[1, 0, 0, 0]],
                                   [[0, 0, 1, 0], [0, 0, 0, 1]]]]
(%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
  mult[i] = vals[2][i], vec[i] = vecs[i]);
                            val  = 0
                               1

                            mult  = 2
                                1

                      vec  = [[1, 0, 0, 0]]
                         1

                            val  = 2
                               2

                            mult  = 2
                                2

               vec  = [[0, 0, 1, 0], [0, 0, 0, 1]]
                  2

(%o3)                         done
@end example

@end deffn



@deffn {Función} ematrix (@var{m}, @var{n}, @var{x}, @var{i}, @var{j})
Devuelve una matriz de orden @var{m} por @var{n}, con todos sus elementos 
nulos, excepto el que ocupa la posición @code{[@var{i}, @var{j}]}, que
es igual a @var{x}.

@end deffn

@deffn {Función} entermatrix (@var{m}, @var{n})
Devuelve una matriz de orden @var{m} por @var{n}, cuyos elementos
son leidos de forma interactiva.

Si @var{n} es igual a @var{m}, Maxima pregunta por el tipo de
matriz (diagonal, simétrica, antisimétrica o general) y luego por
cada elemento. Cada respuesta introducida por el usuario debe terminar
con un punto y coma @code{;} o con un signo de dólar @code{$}.

Si @var{n} y @var{m} no son iguales, Maxima pregunta
por el valor de cada elemento.

Los elementos de la matriz pueden ser cualquier tipo de 
expresión, que en todo caso será evaluada.
@code{entermatrix} evalúa sus argumentos.

@example
(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  
   4. General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matrix entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
@end example

@end deffn


@deffn {Función} genmatrix (@var{a}, @var{i_2}, @var{j_2}, @var{i_1}, @var{j_1})
@deffnx {Función} genmatrix (@var{a}, @var{i_2}, @var{j_2}, @var{i_1})
@deffnx {Función} genmatrix (@var{a}, @var{i_2}, @var{j_2})
Devuelve una matriz generada a partir de @var{a}, siendo @code{@var{a}[@var{i_1},@var{j_1}]} el elemento superior izquierdo y @code{@var{a}[@var{i_2},@var{j_2}]} el inferior derecho de la matriz. 
Aquí @var{a} se declara como una arreglo (creado por @code{array},
pero no por @code{make_array}), o un array no declarado, o una función array, o una
expresión lambda de dos argumentos.
(An array function is created like other functions with @code{:=} or @code{define},
but arguments are enclosed in square brackets instead of parentheses.)

Si se omite @var{j_1}, entonces se le asigna el valor @var{i_1}. Si tanto @var{j_1} como @var{i_1} se omiten, a las dos variables se le asigna el valor 1.

Si un elemento @code{i,j} del arreglo no está definido, se le asignará el elemento simbólico @code{@var{a}[i,j]}.

@c ===beg===
@c h [i, j] := 1 / (i + j - 1);
@c genmatrix (h, 3, 3);
@c array (a, fixnum, 2, 2);
@c a [1, 1] : %e;
@c a [2, 2] : %pi;
@c genmatrix (a, 2, 2);
@c genmatrix (lambda ([i, j], j - i), 3, 3);
@c genmatrix (B, 2, 2);
@c ===end===
@example
(%i1) h [i, j] := 1 / (i + j - 1);
                                    1
(%o1)                  h     := ---------
                        i, j    i + j - 1
(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2);
(%o3)                           a
(%i4) a [1, 1] : %e;
(%o4)                          %e
(%i5) a [2, 2] : %pi;
(%o5)                          %pi
(%i6) genmatrix (a, 2, 2);
                           [ %e   0  ]
(%o6)                      [         ]
                           [ 0   %pi ]
(%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                         [  0    1   2 ]
                         [             ]
(%o7)                    [ - 1   0   1 ]
                         [             ]
                         [ - 2  - 1  0 ]
(%i8) genmatrix (B, 2, 2);
                        [ B      B     ]
                        [  1, 1   1, 2 ]
(%o8)                   [              ]
                        [ B      B     ]
                        [  2, 1   2, 2 ]
@end example

@end deffn

@deffn {Función} gramschmidt (@var{x})
@deffnx {Función} gramschmidt (@var{x}, @var{F})

Ejecuta el algoritmo de ortogonalización de Gram-Schmidt sobre @var{x},
que puede ser una matriz o una lista de listas. La función 
@code{gramschmidt} no altera el valor de @var{x}.
El producto interno por defecto empleado en @code{gramschmidt} es
@code{innerproduct}, o @var{F}, si se ha hecho uso de esta opción.

Si @var{x} es una matriz, el algoritmo se aplica a las filas de @var{x}. Si
@var{x} es una lista de listas, el algoritmo se aplica a las sublistas,
las cuales deben tener el mismo número de miembros. En cualquier caso,
el valor devuelto es una lista de listas, cuyas sublistas son ortogonales.
@c Falta completar este p'arrafo

La función @code{factor} es invocada  en cada paso del algoritmo para 
simplificar resultados intermedios. Como consecuencia, el valor retornado 
puede contener enteros factorizados.

El nombre @code{gschmit} es sinónimo de @code{gramschmidt}.

Es necesario cargar la función haciendo @code{load ("eigen")}.

Ejemplo:

Algoritmo de Gram-Schmidt utilizando el producto interno por defecto.

@c ===beg===
@c load (eigen)$
@c x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
@c y: gramschmidt (x);
@c map (innerproduct, [y[1], y[2], y[3]], [y[2], y[3], y[1]]);
@c ===end===
@example
(%i1) load (eigen)$
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) map (innerproduct, [y[1], y[2], y[3]], [y[2], y[3], y[1]]);
(%o4)                       [0, 0, 0]
@end example

Algoritmo de Gram-Schmidt utilizando un producto interno especificado
por el usuario.

@c ===beg===
@c load (eigen)$
@c ip (f, g) := integrate (f * g, u, a, b);
@c y : gramschmidt ([1, sin(u), cos(u)], ip), a= -%pi/2, b=%pi/2;
@c map (ip, [y[1], y[2], y[3]], [y[2], y[3], y[1]]), a= -%pi/2, b=%pi/2;
@c ===end===
@example
(%i1) load (eigen)$
(%i2) ip (f, g) := integrate (f * g, u, a, b);
(%o2)          ip(f, g) := integrate(f g, u, a, b)
(%i3) y : gramschmidt ([1, sin(u), cos(u)], ip), a= -%pi/2, b=%pi/2;
                               %pi cos(u) - 2
(%o3)              [1, sin(u), --------------]
                                    %pi
(%i4) map (ip, [y[1], y[2], y[3]], [y[2], y[3], y[1]]), a= -%pi/2, b=%pi/2;
(%o4)                       [0, 0, 0]
@end example

@end deffn


@deffn {Función} ident (@var{n})
Devuelve la matriz identidad de orden @var{n}.

@end deffn

@deffn {Función} innerproduct (@var{x}, @var{y})
@deffnx {Función} inprod (@var{x}, @var{y})
Devuelve el producto interior o escalar de @var{x} por @var{y}, que deben ser listas de igual longitud, o ambas matrices columa o fila de igual longitud. El valor devuelto es @code{conjugate (x) . y}, donde @code{.} es el operador de multiplicación no conmutativa.

Es necesario cargar la función haciendo @code{load ("eigen")}.

El nombre @code{inprod} es sinónimo de @code{innerproduct}.

@c NEED EXAMPLE HERE
@end deffn

@c THIS DESCRIPTION NEEDS WORK
@deffn {Función} invert (@var{M})
Devuelve la inversa de la matriz @var{M}, calculada por el método del adjunto.

La implementación actual no es eficiente para matrices de orden grande.

Cuando @code{detout} vale @code{true}, el determinante se deja
 fuera de la inversa a modo de factor escalar.

Los elementos de la matriz inversa no se expanden. Si @var{M} tiene elementos
polinómicos, se puede mejorar el aspecto del resultado haciendo 
@code{expand (invert (m)), detout}.

Véase la descripción de @code{^^} (exponente no conmutativo) para 
información sobre otro método para invertir matrices.

@end deffn


@deffn {Función} list_matrix_entries (@var{M})
Devuelve una lista con todos los elementos de la matriz @var{M}.

Ejemplo:

@c ===beg===
@c list_matrix_entries(matrix([a,b],[c,d]));
@c ===end===
@example
(%i1) list_matrix_entries(matrix([a,b],[c,d]));
(%o1)                     [a, b, c, d]
@end example

@end deffn


@defvr {Variable opcional} lmxchar
Valor por defecto: @code{[}

La variable @code{lmxchar} guarda el carácter a mostrar como delimitador izquierdo de la matriz.
Véase también @code{rmxchar}.

Ejemplo:

@example
(%i1) lmxchar: "|"$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
@end example

@end defvr

@deffn {Función} matrix (@var{fila_1}, ..., @var{fila_n})
Devuelve una matriz rectangular con las filas  @var{fila_1}, ..., @var{fila_n}. Cada fila es una lista de expresiones. Todas las filas deben tener el mismo número de miembros.

Las operaciones @code{+} (suma), @code{-} (resta), @code{*} (multiplicación) y @code{/} (división), se llevan a cabo elemento a elemento cuando los operandos son dos matrices, un escalar y una matriz o una matriz con un escalar. La operación @code{^} (exponenciación, equivalente a @code{**}) se lleva cabo también elemento a elemento si los operandos son un escalr y una matriz o uma matriz y un escalar, pero no si los operandos son dos matrices.

El producto matricial se representa con el operador de multiplicación no conmutativa @code{.}. El correspondiente operador de exponenciación no conmutativa es @code{^^}. Dada la matriz @code{@var{A}}, @code{@var{A}.@var{A} = @var{A}^^2} y @code{@var{A}^^-1} es la inversa de @var{A}, si existe.

Algunas variables controlan la simplificación de expresiones que incluyan estas operaciones: @code{doallmxops}, @code{domxexpt}, @code{domxmxops}, @code{doscmxops} y @code{doscmxplus}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Hay otras opciones adicionales relacionadas con matrices:
@code{lmxchar}, @code{rmxchar}, @code{ratmx}, @code{listarith}, @code{detout},
@code{scalarmatrix} y @code{sparse}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Hay también algunas funciones que admiten matrices como argumentos o que devuelven resultados matriciales: @code{eigenvalues}, @code{eigenvectors},
@code{determinant},
@code{charpoly}, @code{genmatrix}, @code{addcol}, @code{addrow}, 
@code{copymatrix}, @code{transpose}, @code{echelon} y @code{rank}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Ejemplos:

@itemize @bullet
@item
Construcción de matrices a partir de listas.
@end itemize
@example
(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
@end example
@itemize @bullet
@item
Suma elemento a elemento.
@end itemize
@example
(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
@end example
@itemize @bullet
@item
Resta elemento a elemento.
@end itemize
@example
(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
@end example
@itemize @bullet
@item
Multiplicación elemento a elemento.
@end itemize
@example
(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
@end example
@itemize @bullet
@item
División elemento a elemento.
@end itemize
@example
(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
@end example
@itemize @bullet
@item
Matriz elevada a un exponente escalar, operación elemento a elemento.
@end itemize
@example
(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
@end example
@itemize @bullet
@item
Base escalar y exponente matricial, operación elemento a elemento.
@end itemize
@example
(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
@end example
@itemize @bullet
@item
Base y exponente matriciales. Esta operación no se realiza elemento a elemento.
@c WHAT IS THIS ??
@end itemize
@example
(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
@end example
@itemize @bullet
@item
Multiplicación matricial no conmutativa.
@end itemize
@example
(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
@end example
@itemize @bullet
@item
Exponenciación matricial no conmutativa. Una base escalar @var{b} elevada a un exponente matricial @var{M} se lleva a cabo elemento a elemento y por lo tanto @code{b^^m} equivale a @code{b^m}.
@end itemize
@example
(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
@end example
@itemize @bullet
@item
Una matriz elevada al exponente -1 con el operador de exponenciación no conmutativa equivale a la matriz inversa, si existe.
@end itemize
@example
(%i14) x ^^ -1;
                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
@end example

@end deffn

@deffn {Función} matrixmap (@var{f}, @var{M})
Devuelve una matriz con el elemento @code{i,j} igual a @code{@var{f}(@var{M}[i,j])}.

Véanse también @code{map}, @code{fullmap}, @code{fullmapl} y @code{apply}.

@c NEED EXAMPLE HERE
@end deffn

@deffn {Función} matrixp (@var{expr})
Devuelve @code{true} si @var{expr} es una matriz, en caso contrario @code{false}.

@end deffn

@defvr {Variable opcional} matrix_element_add
Valor por defecto: @code{+}

La variable @code{matrix_element_add} guarda el símbolo del operador a ejecutar en lugar de la suma en el producto matricial; a @code{matrix_element_add} se le puede asignar cualquier operador n-ario (esto es, una función que admite cualquier número de argumentos). El valor asignado puede ser el nombre de un operador encerrado entre apóstrofos, el nombre de una función o una expresión lambda.

Véanse también @code{matrix_element_mult} y @code{matrix_element_transpose}.

Ejemplo:

@example
(%i1) matrix_element_add: "*"$
(%i2) matrix_element_mult: "^"$
(%i3) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o3)                      [         ]
                           [ d  e  f ]
(%i4) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o4)                      [         ]
                           [ x  y  z ]
(%i5) aa . transpose (bb);
                     [  u  v  w   x  y  z ]
                     [ a  b  c   a  b  c  ]
(%o5)                [                    ]
                     [  u  v  w   x  y  z ]
                     [ d  e  f   d  e  f  ]
@end example

@end defvr


@defvr {Variable opcional} matrix_element_mult
Valor por defecto: @code{*}

La variable @code{matrix_element_mult} guarda el símbolo del operador a ejecutar en lugar de la multiplicación en el producto matricial; a @code{matrix_element_mult} se le puede asignar cualquier operador binario. El valor asignado puede ser el nombre de un operador encerrado entre apóstrofos, el nombre de una función o una expresión lambda.

El operador @code{.} puede ser una opción útil en determinados contextos.

Véanse también @code{matrix_element_add} y @code{matrix_element_transpose}.

Ejemplo:

@example
(%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
(%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
(%i3) [a, b, c] . [x, y, z];
                          2          2          2
(%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
(%i4) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o4)                      [         ]
                           [ d  e  f ]
(%i5) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o5)                      [         ]
                           [ x  y  z ]
(%i6) aa . transpose (bb);
               [             2          2          2  ]
               [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
(%o6)  Col 1 = [                                      ]
               [             2          2          2  ]
               [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                         [             2          2          2  ]
                         [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                 Col 2 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - z)  + (e - y)  + (d - x) ) ]
@end example

@end defvr

@defvr {Variable opcional} matrix_element_transpose
Valor por defecto: @code{false}

La variable @code{matrix_element_transpose} es una operación que se aplica a cada elemento de una matriz a la que se le calcula la transpuesta. A @code{matrix_element_mult} se le puede asignar cualquier operador unitario. El valor asignado puede ser el nombre de un operador encerrador entre apóstrofos, el nombre de una función o una expresión lambda.

Cuando @code{matrix_element_transpose} es igual a @code{transpose}, la función @code{transpose} se aplica a cada elemento. Cuando  @code{matrix_element_transpose} es igual  a @code{nonscalars}, la función @code{transpose} se aplica a todos los elementos no escalares. Si alguno de los elementos es un átomo, la opción @code{nonscalars} se aplica 
@code{transpose} sólo si el átomo se declara no escalar, mientras que la opción @code{transpose} siempre aplica  @code{transpose}.

La opción por defecto, @code{false}, significa que no se aplica ninguna operación.

Véanse también @code{matrix_element_add} y @code{matrix_element_mult}.

Ejemplos:

@example
(%i1) declare (a, nonscalar)$
(%i2) transpose ([a, b]);
                        [ transpose(a) ]
(%o2)                   [              ]
                        [      b       ]
(%i3) matrix_element_transpose: nonscalars$
(%i4) transpose ([a, b]);
                        [ transpose(a) ]
(%o4)                   [              ]
                        [      b       ]
(%i5) matrix_element_transpose: transpose$
(%i6) transpose ([a, b]);
                        [ transpose(a) ]
(%o6)                   [              ]
                        [ transpose(b) ]
(%i7) matrix_element_transpose: 
           lambda ([x], realpart(x) - %i*imagpart(x))$
(%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                     [ 5 %i + 1  3 - 2 %i ]
(%o8)                [                    ]
                     [   7 %i       11    ]
(%i9) transpose (m);
                      [ 1 - 5 %i  - 7 %i ]
(%o9)                 [                  ]
                      [ 2 %i + 3    11   ]
@end example

@end defvr


@c IS THIS THE ONLY MATRIX TRACE FUNCTION ??
@deffn {Función} mattrace (@var{M})
Devuelve la traza (esto es, la suma de los elementos de la diagonal principal) de la matriz cuadrada @var{M}.  

Para disponer de esta función es necesario cargar el paquete haciendo @code{load ("nchrpl")}.

@end deffn

@deffn {Función} minor (@var{M}, @var{i}, @var{j})
Devuelve el menor @code{(@var{i}, @var{j})} de la matriz @var{M}.  Esto es, la propia matriz @var{M}, una vez extraídas la fila @var{i} y la columna @var{j}.

@end deffn



@deffn {Función} ncharpoly (@var{M}, @var{x})
Devuelve el polinomio característico de la matriz @var{M} respecto de la variable @var{x}. Es una alternativa a la función @code{charpoly} de Maxima.

La función @code{ncharpoly} opera calculando trazas de las potencias de la matriz dada, que son iguales a las sumas de las potencias de las raíces del polinomio característico. A partir de estas cantidades se pueden calcular las funciones simétricas de las raíces, que no son otra cosa sino los coeficientes del polinomio característico. La función   @code{charpoly} opera calculando el determinante de  by @code{@var{x} * ident [n] - a}. La función @code{ncharpoly} es m'as eficiente en el caso de matrices grandes y densas.

Para disponer de esta función es necesario cargar el paquete haciendo @code{load ("nchrpl")}.

@end deffn

@deffn {Función} newdet (@var{M})
Calcula el determinante de la matriz @var{M} por el algoritmo del árbol menor
de Johnson-Gentleman. El resultado devuelto por @code{newdet} tiene formato CRE.
@end deffn



@deffn {Función} permanent (@var{M})
Calcula la permanente de la matriz @var{M} por el algoritmo del árbol menor de
Johnson-Gentleman. La permanente es como un determinante pero sin cambios de signo.
El resultado devuelto por @code{permanent} tiene formato CRE.

Véase también @code{newdet}.

@end deffn

@deffn {Función} rank (@var{M})
Calcula el rango de la matriz @var{M}.  Esto es, el orden del mayor subdeterminante no singular de @var{M}.

@c STATEMENT NEEDS CLARIFICATION
La función @var{rango} puede retornar una respuesta errónea si no detecta que un elemento de la matriz equivalente a cero lo es.

@end deffn

@defvr {Variable opcional} ratmx
Valor por defecto: @code{false}

Si @code{ratmx} vale @code{false}, el determinante y la suma, resta y producto matriciales se calculan cuando las matrices se expresan en términos de sus elementos, pero no se calcula la inversión matricial en su representación general.

Si @code{ratmx} vale @code{true}, las cuatro operaciones citadas más arriba se calculan en el formato CRE y el resultado de la matriz inversa también se da en formato CRE. Esto puede hacer que se expandan los elementos de la matriz, dependiendo del valor de @code{ratfac}, lo que quizás no sea siempre deseable.

@end defvr

@deffn {Función} row (@var{M}, @var{i})
Devuelve la @var{i}-ésima fila de la matriz @var{M}. El valor que devuelve tiene formato de matriz.

@end deffn



@defvr {Variable opcional} rmxchar
Valor por defecto: @code{]}

La variable @code{rmxchar} es el carácter que se dibuja al lado derecho de una matriz.

Véase también @code{lmxchar}.

@end defvr



@defvr {Variable opcional} scalarmatrixp
Valor por defecto: @code{true}

Si @code{scalarmatrixp} vale @code{true}, entonces siempre que una matriz 1 x 1 se produce como resultado del cálculo del producto no conmutativo de matrices se cambia al formato escalar.

Si @code{scalarmatrixp} vale @code{all}, entonces todas las matrices 1 x 1 se simplifican a escalares.

Si @code{scalarmatrixp} vale @code{false}, las matrices 1 x 1 no se convierten en escalares.

@end defvr

@c FALTA AQUI DEFINICION DE scalefactors.

@deffn {Función} setelmx (@var{x}, @var{i}, @var{j}, @var{M})
Asigna el valor @var{x} al (@var{i}, @var{j})-ésimo elemento de la matriz @var{M} y devuelve la matriz actualizada.

La llamada @code{@var{M} [@var{i}, @var{j}]: @var{x}} hace lo mismo, pero devuelve  @var{x} en lugar de @var{M}.

@end deffn

@deffn {Función} similaritytransform (@var{M})
@deffnx {Función} simtran (@var{M})
La función @code{similaritytransform} calcula la transformada de similitud de la matriz @code{M}. Devuelve una lista que es la salida de la instrucción @code{uniteigenvectors}. Además, si la variable @code{nondiagonalizable} vale @code{false} entonces se calculan dos matrices globales @code{leftmatrix} y @code{rightmatrix}. Estas matrices tienen la propiedad de que @code{leftmatrix . @var{M} . rightmatrix} es una matriz diagonal con los valores propios de @var{M} en su diagonal.  Si @code{nondiagonalizable} vale @code{true} entonces no se calculan estas matrices.

Si la variable @code{hermitianmatrix} vale @code{true} entonces @code{leftmatrix} es el conjugado complejo de la transpuesta de @code{rightmatrix}.  En otro caso @code{leftmatrix} es la inversa de @code{rightmatrix}.

Las columnas de la matriz @code{rightmatrix} son los vectores propios de @var{M}.  Las otras variables (véanse @code{eigenvalues} y @code{eigenvectors}) tienen el mismo efecto, puesto que @code{similaritytransform} llama a las otras funciones del paquete para poder formar @code{rightmatrix}.

Estas funciones se cargan con @code{load ("eigen")}.

El nombre @code{simtran} es sinónimo de @code{similaritytransform}.

@end deffn

@defvr {Variable opcional} sparse
Valor por defecto: @code{false}

Si @code{sparse} vale @code{true} y si @code{ratmx} vale @code{true}, entonces @code{determinant}
utilizará rutinas especiales para calcular determinantes dispersos.

@end defvr

@deffn {Función} submatrix (@var{i_1}, ..., @var{i_m}, @var{M}, @var{j_1}, ..., @var{j_n})
@deffnx {Función} submatrix (@var{i_1}, ..., @var{i_m}, @var{M})
@deffnx {Función} submatrix (@var{M}, @var{j_1}, ..., @var{j_n})
Devuelve una nueva matriz formada a partir de la matriz @var{M} pero cuyas filas @var{i_1}, ..., @var{i_m} y columnas  @var{j_1}, ..., @var{j_n} han sido eliminadas.

@end deffn

@deffn {Función} transpose (@var{M})
Calcula la transpuesta de @var{M}.

Si @var{M} es una matriz, el valor devuelto es otra matriz @var{N} tal que @code{N[i,j] = M[j,i]}.

Si @var{M} es una lista, el valor devuelto es una matriz @var{N} de @code{length (m)} filas y 1 columna, tal que @code{N[i,1] = M[i]}.

En caso de no ser @var{M} ni matriz ni lista, se devuelve la
expresión nominal @code{'transpose (@var{M})}.
@end deffn

@deffn {Función} triangularize (@var{M})
Devuelve la forma triangular superior de la matriz @code{M}, obtenida por eliminación gaussiana.
El resultado es el mismo que el devuelto por @code{echelon}, con la salvedad de que el primer elemento no nulo de cada fila no se normaliza a 1.

Las funciones @code{lu_factor} y @code{cholesky} también triangularizan matrices.

@c ===beg===
@c M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
@c triangularize (M);
@c ===end===
@example
(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) triangularize (M);
             [ - 1   8         5            2      ]
             [                                     ]
(%o2)        [  0   - 74     - 56         - 22     ]
             [                                     ]
             [  0    0    626 - 74 aa  238 - 74 bb ]
@end example

@end deffn

@deffn {Función} uniteigenvectors (@var{M})
@deffnx {Función} ueivects (@var{M})
Calcula los vectores propios unitarios de la matriz @var{M}. El valor que devuelve es una lista de listas, la primera de las cuales es la salida de la función @code{eigenvalues} y el resto de sublistas son los vectores propios unitarios de la matriz correspondiente a esos valores propios, respectivamente.

Las variables citadas en la descripción de la función @code{eigenvectors} tienen los mismos efectos en @code{uniteigenvectors}.

Si @code{knowneigvects} vale @code{true}, el paquete @code{eigen} da por supuesto que el usuario conoce los vectores propios de la matriz y que están guardados en la variable global @code{listeigvects}, en tal caso el contenido de  @code{listeigvects} debe ser una lista de estructura similar a la que devuelve la función @code{eigenvectors}.

@c FOLLOWING PARAGRAPH IS IN NEED OF SERIOUS CLARIFICATION
Si @code{knowneigvects} vale @code{true} y la lista de vectores propios está en la variable @code{listeigvects}, el valor de la variable @code{nondiagonalizable} puede que no sea el correcto. Si tal es el caso, debe asignarsele el valor correcto. @c FALTA TERMINAR ESTE PARRAFO

Para utilizar esta fucnión es necesario cargarla haciendo @code{load ("eigen")}.

El nombre @code{ueivects} es sinónimo de @code{uniteigenvectors}.

@end deffn

@deffn {Función} unitvector (@var{x})
@deffnx {Función} uvect (@var{x})
Devuelve @math{@var{x}/norm(@var{x})}, esto es, el vector unitario de igual dirección y sentido que @var{x}.

@code{load ("eigen")} loads this function.

Para utilizar esta fucnión es necesario cargarla haciendo @code{load ("eigen")}.

El nombre @code{uvect} es sinónimo de @code{unitvector}.

@end deffn




@deffn {Función} vectorpotential (@var{givencurl})
Devuelve el vector potencial de un vector rotacional en el sistema
de coordenadas actual. 
@code{potentialzeroloc} tiene un rol similar al de @code{potential}, 
pero el orden del miembro izquierdo de las ecuaciones debe ser una
permutación cíclica de las coordenadas. 

@end deffn




@c NEEDS A LOT OF WORK: MAKE SURE THAT ALL VECTOR SIMPLIFICATION FLAGS HAVE A DESCRIPTION HERE
@deffn {Función} vectorsimp (@var{expr})
Realiza simplificaciones y expansiones de acuerdo con los valores de las siguientes variables globales:

@code{expandall}, @code{expanddot}, @code{expanddotplus}, @code{expandcross}, @code{expandcrossplus},
@code{expandcrosscross}, @code{expandgrad}, @code{expandgradplus}, @code{expandgradprod},
@code{expanddiv}, @code{expanddivplus}, @code{expanddivprod}, @code{expandcurl}, @code{expandcurlplus},
@code{expandcurlcurl}, @code{expandlaplacian}, @code{expandlaplacianplus} y @code{expandlaplacianprod}.

Todas estas variables tienen por defecto el valor @code{false}. El sufijo @code{plus} se refiere al uso de la suma o la distributividad.  El sufijo @code{prod} se refiere a la expansión de operadores que realizan cualquier tipo de producto.

@table @code
@item expandcrosscross
Simplifica @math{p ~ (q ~ r)} en @math{(p . r)*q - (p . q)*r}.
@item expandcurlcurl
Simplifica @math{curl curl p} en @math{grad div p + div grad p}.
@item expandlaplaciantodivgrad
Simplifica @math{laplacian p} en @math{div grad p}.
@item expandcross
Activa @code{expandcrossplus} y @code{expandcrosscross}.
@item expandplus
Activa @code{expanddotplus}, @code{expandcrossplus}, @code{expandgradplus},
@code{expanddivplus}, @code{expandcurlplus} y @code{expandlaplacianplus}.
@item expandprod
Activa @code{expandgradprod}, @code{expanddivprod} y @code{expandlaplacianprod}.
@end table

@c EXPLAIN THE IMPORT OF THIS STATEMENT
Estas variables están declaradas como @code{evflag}.

@c SEEMS SOME TEXT HAS GONE MISSING HERE; COMMENT OUT FRAGMENT PENDING
@c RECOVERY AND/OR RECONSTRUCTION OF THIS PARAGRAPH
@c For orthogonal curvilinear coordinates, the global variables
@c COORDINATES[[X,Y,Z]], DIMENSION[3], SF[[1,1,1]], and SFPROD[1] are set
@c by the function invocation

@end deffn


@c AQUI FALTA LA DEFINICION DE LA VARIABLE vect_cross


@deffn {Función} zeromatrix (@var{m}, @var{n})
Devuelve una matriz rectangular @var{m} por @var{n} con todos sus elementos iguales a cero.

@end deffn

@defvr {Símbolo especial} [
@defvrx {Símbolo especial} [
@ifinfo
@fnindex Delimitadores de listas
@fnindex Operador de subíndice
@end ifinfo
Los símbolos @code{[} y @code{]} marcan el comienzo y final, respectivamente, de una lista.

Los símbolos @code{[} y @code{]} también se utilizan para indicar los subíndices de los elementos de una lista, arreglo o función arreglo.

Ejemplos:

@example
(%i1) x: [a, b, c];
(%o1)                       [a, b, c]
(%i2) x[3];
(%o2)                           c
(%i3) array (y, fixnum, 3);
(%o3)                           y
(%i4) y[2]: %pi;
(%o4)                          %pi
(%i5) y[2];
(%o5)                          %pi
(%i6) z['foo]: 'bar;
(%o6)                          bar
(%i7) z['foo];
(%o7)                          bar
(%i8) g[k] := 1/(k^2+1);
                                  1
(%o8)                     g  := ------
                           k     2
                                k  + 1
(%i9) g[10];
                                1
(%o9)                          ---
                               101
@end example

@end defvr

