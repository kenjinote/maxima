@c English version: 1.17
@menu
* Introdução a Conjuntos::       
* Definições para Conjuntos::       
@end menu

@node Introdução a Conjuntos, Definições para Conjuntos, Conjuntos, Conjuntos
@section Introdução a Conjuntos

Maxima fornece funções de conjunto, tais como
intersecção e união, para conjuntos finitos que são
definidos por enumeração explícita.
Maxima trata listas e conjuntos como objectos distintos. Este recurso
torna possível trabalhar com conjuntos que possuem
elementos que são ou listas ou conjuntos.

Adicionalmente, para funções de conjuntos finitos,
Maxima fornece algumas funções relacionadas com
análise combinatória: números de Stirling de primeiro e de segundo
tipo, números de Bell, coeficientes multinomiais e
partições de inteiros não negativos, entre
outras. Maxima também define a função delta de
Kronecker.

@subsection Utilização

Para construir um conjunto com elementos @code{a_1, ..., a_n}, escreva
@code{set(a_1, ..., a_n)} ou @code{@{a_1, ..., a_n@}}; para construir o
conjunto vazio, escreva @code{set()} ou @code{@{@}}.  Para
inserção de dados, @code{set(...)} e @code{@{ ... @}}
são equivalentes. Os conjuntos são sempre mostrados entre chaves
(@code{@{ ... @}}).

Se um elemento é listado mais de uma vez, o simplificador do Maxima
elimina o elemento redundante.

@c ===beg===
@c set();
@c set(a, b, a);
@c set(a, set(b));
@c set(a, [b]);
@c {};
@c {a, b, a};
@c {a, {b}};
@c {a, [b]};
@c ===end===
@example
(%i1) set();
(%o1)                          @{@}
(%i2) set(a, b, a);
(%o2)                        @{a, b@}
(%i3) set(a, set(b));
(%o3)                       @{a, @{b@}@}
(%i4) set(a, [b]);
(%o4)                       @{a, [b]@}
(%i5) @{@};
(%o5)                          @{@}
(%i6) @{a, b, a@};
(%o6)                        @{a, b@}
(%i7) @{a, @{b@}@};
(%o7)                       @{a, @{b@}@}
(%i8) @{a, [b]@};
(%o8)                       @{a, [b]@}
@end example

Dois elementos @var{x} e @var{y} são redundantes (nomeadamente,
considerados o mesmo para propósito de construção de
conjuntos) se e somente se @code{is(@var{x} = @var{y})} retornar
@code{true}.
@c THAT IS BECAUSE THE SET SIMPLIFICATION CODE CALLS THE LISP FUNCTION LIKE,
@c AND SO DOES THE CODE TO EVALUATE IS (X = Y).
Note que @code{is(equal(@var{x}, @var{y}))} pode retornar @code{true}
enquanto @code{is(@var{x} = @var{y})} retorna @code{false}; nesse caso
os elementos @var{x} e @var{y} são considerados distintos.

@c ===beg===
@c x: a/c + b/c;
@c y: a/c + b/c;
@c z: (a + b)/c;
@c is (x = y);
@c is (y = z);
@c is (equal (y, z));
@c y - z;
@c ratsimp (%);
@c {x, y, z};
@c ===end===
@example
(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
                              b   a
(%o2)                         - + -
                              c   c
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) @{x, y, z@};
                          b + a  b   a
(%o9)                    @{-----, - + -@}
                            c    c   c
@end example

Para construir um conjunto dos elementos de uma lista, use @code{setify}.

@c ===beg===
@c setify ([b, a]);
@c ===end===
@example
(%i1) setify ([b, a]);
(%o1)                        @{a, b@}
@end example

Os elementos de conjunto @code{x} e @code{y} serão considerados iguais
se @code{is(x = y)} for avaliando para @code{true}. Dessa forma,
@code{rat(x)} e @code{x} são iguais como elementos de conjunto;
consequentemente,

@c ===beg===
@c {x, rat(x)};
@c ===end===
@example
(%i1) @{x, rat(x)@};
(%o1)                          @{x@}
@end example

Adicionalmente, uma vez que @code{is((x - 1)*(x + 1) = x^2 - 1)} avalia
para @code{false}, @code{(x - 1)*(x + 1)} e @code{x^2 - 1} são
considerados elementos de conjunto diferentes; dessa forma

@c ===beg===
@c {(x - 1)*(x + 1), x^2 - 1};
@c ===end===
@example
(%i1) @{(x - 1)*(x + 1), x^2 - 1@};
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
@end example

Para reduzir esse conjunto a um conjunto simples, apliquemos @code{rat}
a cada elemento do conjunto

@c ===beg===
@c {(x - 1)*(x + 1), x^2 - 1};
@c map (rat, %);
@c ===end===
@example
(%i1) @{(x - 1)*(x + 1), x^2 - 1@};
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
(%i2) map (rat, %);
                              2
(%o2)/R/                    @{x  - 1@}
@end example

Para remover redundâncias em outros conjuntos, poderá ter que usar
outras funções de simplificação. Aqui
está um exemplo que usa @code{trigsimp}:

@c ===beg===
@c {1, cos(x)^2 + sin(x)^2};
@c map (trigsimp, %);
@c ===end===
@example
(%i1) @{1, cos(x)^2 + sin(x)^2@};
                            2         2
(%o1)                @{1, sin (x) + cos (x)@}
(%i2) map (trigsimp, %);
(%o2)                          @{1@}
@end example

Um conjunto está simplificado quando os seus elementos não são
redundantes e o conjunto está ordenado. A versão actual das
funções de conjunto usam a função
@code{orderlessp} do Maxima para ordenar conjuntos; contudo,
@emph{versões futuras das funções de conjunto poderão
vir a usar uma função de ordenação
diferente}.

Algumas operações sobre conjuntos, tais como
substituições, forçam automaticamente a
uma re-simplificação; por exemplo,

@c ===beg===
@c s: {a, b, c}$
@c subst (c=a, s);
@c subst ([a=x, b=x, c=x], s);
@c map (lambda ([x], x^2), set (-1, 0, 1));
@c ===end===
@example
(%i1) s: @{a, b, c@}$
(%i2) subst (c=a, s);
(%o2)                        @{a, b@}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          @{x@}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        @{0, 1@}
@end example

Maxima trata listas e conjuntos como objectos distintos;
funções tais como @code{union} e @code{intersection}
produzem um erro se qualquer argumento não for um conjunto. se
precisar aplicar uma função de conjunto a uma lista, use
a função @code{setify} para converter essa lista num
conjunto. Dessa forma

@c ===beg===
@c union ([1, 2], {a, b});
@c union (setify ([1, 2]), {a, b});
@c ===end===
@example
(%i1) union ([1, 2], @{a, b@});
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), @{a, b@});
(%o2)                     @{1, 2, a, b@}
@end example

Para extrair todos os elementos de um conjunto @code{s} que satisfazem
um predicado @code{f}, use @code{subset(s, f)}. (Um @i{predicado} é um
uma função que avalia para os valores booleanos
@code{true}/@code{false}.) Por exemplo, para encontrar as
equações num dado conjunto que não depende de uma
variável @code{z}, use

@c ===beg===
@c subset ({x + y + z, x - y + 4, x + y - 5}, lambda ([e], freeof (z, e)));
@c ===end===
@example
(%i1) subset (@{x + y + z, x - y + 4, x + y - 5@}, lambda ([e], freeof (z, e)));
(%o1)               @{- y + x + 4, y + x - 5@}
@end example

A secção @emph{Definições para
Conjuntos} possui uma lista completa das funções de
conjunto no Maxima.

@subsection Iterações entre Elementos de Conjuntos

Existem duas formas de fazer iterações sobre elementos
de conjuntos. Uma forma é usar @code{map}; por exemplo:

@c ===beg===
@c map (f, {a, b, c});
@c ===end===
@example
(%i1) map (f, @{a, b, c@});
(%o1)                  @{f(a), f(b), f(c)@}
@end example

A outra forma consiste em usar @code{for @var{x} in @var{s} do}

@c ===beg===
@c s: {a, b, c};
@c for si in s do print (concat (si, 1));
@c ===end===
@example
(%i1) s: @{a, b, c@};
(%o1)                       @{a, b, c@}
(%i2) for si in s do print (concat (si, 1));
a1 
b1 
c1 
(%o2)                         done
@end example

As funções @code{first} e @code{rest} do Maxima
trabalham actualmente sobre conjuntos. Aplicada a um conjunto,
@code{first} retorna o primeiro elemento mostrado de um conjunto; qual o
élemento que será mostrado dependerá da
implementação. Se @code{s} for um conjunto, então
@code{rest(s)} é equivalente a @code{disjoin(first(s), s)}.
Actualmente, existem outras funções do Maxima que
trabalham correctamente sobre conjuntos. Em versões futuras das
funções de conjunto, @code{first} e @code{rest} podem
vir a funcionar diferentemente ou deixar de funcionar.

@subsection Erros

As funções de conjunto usam a função
@code{orderlessp} do Maxima para organizar os elementos dum conjunto e a
função (a nível do Lisp) @code{like} para
testar a igualdade entre elementos de conjuntos. Ambas essas
funções possuem falhas conhecidas que podem se
manifestar quando tentar usar conjuntos com elementos que são listas
ou matrizes que contenham expressões na forma racional canónica
(CRE). Um exemplo é

@c ===beg===
@c {[x], [rat (x)]};
@c ===end===
@example
(%i1) @{[x], [rat (x)]@};
Maxima encountered a Lisp error:

  The value #:X1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

Essa expressão faz com que o Maxima produza um erro (a mensagem de
erro dependerá da versão do Lisp que o Maxima estiver a
utilizar). Outro exemplo é

@c ===beg===
@c setify ([[rat(a)], [rat(b)]]);
@c ===end===
@example
(%i1) setify ([[rat(a)], [rat(b)]]);
Maxima encountered a Lisp error:

  The value #:A1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

Essas falhas são causadas por falhas em @code{orderlessp} e
@code{like}, e não por falhas nas funções de
conjunto. Para ilustrar, experimente as expressões

@c ===beg===
@c orderlessp ([rat(a)], [rat(b)]);
@c is ([rat(a)] = [rat(a)]);
@c ===end===
@example
(%i1) orderlessp ([rat(a)], [rat(b)]);
Maxima encountered a Lisp error:

  The value #:B1441 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i2) is ([rat(a)] = [rat(a)]);
(%o2)                         false
@end example

Até que essas falhas forem corrigidas, não construa conjuntos com
elementos que sejam listas ou matrizes contendo expressões na forma
racional canónica (CRE); um conjunto com um elemento na forma CRE,
contudo, pode não ser um problema:

@c ===beg===
@c {x, rat (x)};
@c ===end===
@example
(%i1) @{x, rat (x)@};
(%o1)                          @{x@}
@end example

A @code{orderlessp} do Maxima possui outra falha que pode causar
problemas com funções de conjunto; nomeadamente, o
predicado de ordenação @code{orderlessp} não é
transitivo. O mais simples exemplo conhecido que mostra isso é

@c ===beg===
@c q: x^2$
@c r: (x + 1)^2$
@c s: x*(x + 2)$
@c orderlessp (q, r);
@c orderlessp (r, s);
@c orderlessp (q, s);
@c ===end===
@example
(%i1) q: x^2$
(%i2) r: (x + 1)^2$
(%i3) s: x*(x + 2)$
(%i4) orderlessp (q, r);
(%o4)                         true
(%i5) orderlessp (r, s);
(%o5)                         true
(%i6) orderlessp (q, s);
(%o6)                         false
@end example

Essa falha pode causar problemas com todas as funções de
conjunto bem como com funções do Maxima em geral. É
provável, mas não certo, que essa falha possa ser evitada se todos
os elementos do conjunto estiverem ou na forma CRE ou tiverem sido
simplificados usando @code{ratsimp}.

@c WHAT EXACTLY IS THE EFFECT OF ordergreat AND orderless ON THE SET FUNCTIONS ??
Os mecanismos @code{orderless} e @code{ordergreat} do Maxima são
incompatíveis com as funções de
conjunto. Se precisar usar @code{orderless} ou @code{ordergrreat}, chame
todas essas funções antes de construir quaisquer
conjuntos, e não use @code{unorder}.

@c APPARENTLY THIS NEXT BIT REFERS TO BUG REPORT 798571
@c EXAMPLE WITH kron_delta (1/sqrt(2), sqrt(2)/2); NOW WORKS AS EXPECTED
@c COMMENT OUT PENDING CONSTRUCTION OF ANOTHER EXAMPLE WHICH TRIGGERS THE BUG
@c
@c Maxima's sign function has a bug that may cause the Kronecker
@c delta function to misbehave; for example:
@c 
@c @c ===beg===
@c @c kron_delta (1/sqrt(2), sqrt(2)/2);
@c @c ===end===
@c @example
@c (%i1) kron_delta (1/sqrt(2), sqrt(2)/2);
@c (%o1)                           0
@c @end example
@c 
@c The correct value is 1; the bug is related to the @code{sign} bug
@c 
@c @c ===beg===
@c @c sign (1/sqrt(2) - sqrt(2)/2);
@c @c ===end===
@c @example
@c (%i1) sign (1/sqrt(2) - sqrt(2)/2);
@c (%o1)                          pos
@c @end example

Se encontrar alguma coisa que pense ser uma falha em alguma
funçõ de conjunto, por favor relate isso para a base de
dados de falhas do Maxima. Veja @code{bug_report}.

@subsection Autores

Stavros Macrakis de Cambridge, Massachusetts e Barton Willis da
Universidade de Nebraska e Kearney (UNK) escreveram as
fnções de conjunto do Maxima e sua
documentação.

@node Definições para Conjuntos,  , Introdução a Conjuntos, Conjuntos
@section Definições para Conjuntos

@anchor{adjoin}
@deffn {Função} adjoin (@var{x}, @var{a}) 

Calcula a união do conjunto @var{a} com @code{@{@var{x}@}}.

@code{adjoin} falha se @var{a} não for um conjunto literal.

@code{adjoin(@var{x}, @var{a})} e @code{union(set(@var{x}), @var{a})}
são equivalentes; contudo, @code{adjoin} pode ser um pouco mais
rápida que @code{union}.

Veja também @code{disjoin}.

Exemplos:

@c ===beg===
@c adjoin (c, {a, b});
@c adjoin (a, {a, b});
@c ===end===
@example
(%i1) adjoin (c, @{a, b@});
(%o1)                       @{a, b, c@}
(%i2) adjoin (a, @{a, b@});
(%o2)                        @{a, b@}
@end example

@end deffn

@anchor{belln}
@deffn {Função} belln (@var{n})

Representa o @math{n}-ésimo número de Bell.  @code{belln(n)} é o
número de partições de um conjunto de @var{n}
elementos.

Para inteiros não negativos @var{n}, @code{belln(@var{n})} simplifica
para o @math{n}-ésimo número de Bell.  @code{belln} não simplifica
para qualquer outro tipo de argumento.

@code{belln}, aplicada a equações, listas, matrizes
e conjuntos, é calculada em forma distributiva.

Exemplos:

@code{belln} aplicado a inteiros não negativos.

@c ===beg===
@c makelist (belln (i), i, 0, 6);
@c is (cardinality (set_partitions ({})) = belln (0));
@c is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) = belln (6));
@c ===end===
@example
(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions (@{@})) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions (@{1, 2, 3, 4, 5, 6@})) = belln (6));
(%o3)                         true
@end example

@code{belln} aplicado a argumentos que não são inteiros não negativos.

@c ===beg===
@c [belln (x), belln (sqrt(3)), belln (-9)];
@c ===end===
@example
(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
@end example

@end deffn

@anchor{cardinality}
@deffn {Função} cardinality (@var{a})

Calcula o número de elementos distintos do conjunto @var{a}.

@code{cardinality} ignora elementos redundantes mesmo quando a
simplificação não estiver habilitada.

Exemplos:

@c ===beg===
@c cardinality ({});
@c cardinality ({a, a, b, c});
@c simp : false;
@c cardinality ({a, a, b, c});
@c ===end===
@example
(%i1) cardinality (@{@});
(%o1)                           0
(%i2) cardinality (@{a, a, b, c@});
(%o2)                           3
(%i3) simp : false;
(%o3)                         false
(%i4) cardinality (@{a, a, b, c@});
(%o4)                           3
@end example

@end deffn

@anchor{cartesian_product}
@deffn {Função} cartesian_product (@var{b_1}, ... , @var{b_n})
Retorna um conjunto de listas da forma @code{[@var{x_1}, ...,
@var{x_n}]}, onde @var{x_1}, ..., @var{x_n} são elementos dos
conjuntos @var{b_1}, ... , @var{b_n}, respectivamente.

@code{cartesian_product} falha se qualquer argumento não for um
conjunto literal.

Exemplos:

@c ===beg===
@c cartesian_product ({0, 1});
@c cartesian_product ({0, 1}, {0, 1});
@c cartesian_product ({x}, {y}, {z});
@c cartesian_product ({x}, {-1, 0, 1});
@c ===end===
@example
(%i1) cartesian_product (@{0, 1@});
(%o1)                      @{[0], [1]@}
(%i2) cartesian_product (@{0, 1@}, @{0, 1@});
(%o2)           @{[0, 0], [0, 1], [1, 0], [1, 1]@}
(%i3) cartesian_product (@{x@}, @{y@}, @{z@});
(%o3)                      @{[x, y, z]@}
(%i4) cartesian_product (@{x@}, @{-1, 0, 1@});
(%o4)              @{[x, - 1], [x, 0], [x, 1]@}
@end example
@end deffn


@anchor{disjoin}
@deffn {Função} disjoin (@var{x}, @var{a})
Retorna o conjunto @var{a} sem o elemento @var{x}.  Se @var{x} não for
um elemento de @var{a}, retorna @var{a} sem
modificações.

@code{disjoin} reclama se @var{a} não for um conjunto literal.

@code{disjoin(@var{x}, @var{a})}, @code{delete(@var{x}, @var{a})}, e
@code{setdifference(@var{a}, set(@var{x}))} são todos equivalentes.
Desses, @code{disjoin} é geralmente mais rápido que os outros.

Exemplos:

@c ===beg===
@c disjoin (a, {a, b, c, d});
@c disjoin (a + b, {5, z, a + b, %pi});
@c disjoin (a - b, {5, z, a + b, %pi});
@c ===end===
@example
(%i1) disjoin (a, @{a, b, c, d@});
(%o1)                       @{b, c, d@}
(%i2) disjoin (a + b, @{5, z, a + b, %pi@});
(%o2)                      @{5, %pi, z@}
(%i3) disjoin (a - b, @{5, z, a + b, %pi@});
(%o3)                  @{5, %pi, b + a, z@}
@end example

@end deffn

@anchor{disjointp}
@deffn {Função} disjointp (@var{a}, @var{b}) 
Retorna @code{true} se e somente se os conjuntos @var{a} e @var{b} forem
disjuntos.

@code{disjointp} falha se ou @var{a} ou @var{b} não forem conjuntos
literais.

Exemplos:

@c ===beg===
@c disjointp ({a, b, c}, {1, 2, 3});
@c disjointp ({a, b, 3}, {1, 2, 3});
@c ===end===
@example
(%i1) disjointp (@{a, b, c@}, @{1, 2, 3@});
(%o1)                         true
(%i2) disjointp (@{a, b, 3@}, @{1, 2, 3@});
(%o2)                         false
@end example

@end deffn

@anchor{divisors}
@deffn {Função} divisors (@var{n})

Representa o conjunto dos divisores de @var{n}.

@code{divisors(@var{n})} produz um conjunto de divisores inteiros quando
@var{n} for um inteiro não nulo. O conjunto dos divisores inclui os
elementos 1 e @var{n}. Os divisores de um inteiro negativo são os
divisores do seu valor absoluto.

@code{divisors}, aplicada a equações, listas, matrizes
e conjuntos, é calculada em forma distributiva.

Exemplos:

Podemos verificar que 28 é um número perfeito: a
adição dos seus divisores (excepto o próprio 28) é
28.

@c ===beg===
@c s: divisors(28);
@c lreduce ("+", args(s)) - 28;
@c ===end===
@example
(%i1) s: divisors(28);
(%o1)                 @{1, 2, 4, 7, 14, 28@}
(%i2) lreduce ("+", args(s)) - 28;
(%o2)                          28
@end example

@code{divisors} é uma função de
simplificação.  Substituindo 8 por @code{a} em
@code{divisors(a)} calcula os divisores sem ser preciso pedir que
@code{divisors(8)} seja reavaliada.

@c ===beg===
@c divisors (a);
@c subst (8, a, %);
@c ===end===
@example
(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     @{1, 2, 4, 8@}
@end example

@code{divisors}, aplicada a equações, listas, matrizes
e conjuntos, é calculada em forma distributiva.

@c ===beg===
@c divisors (a = b);
@c divisors ([a, b, c]);
@c divisors (matrix ([a, b], [c, d]));
@c divisors ({a, b, c});
@c ===end===
@example
(%i1) divisors (a = b);
(%o1)               divisors(a) = divisors(b)
(%i2) divisors ([a, b, c]);
(%o2)        [divisors(a), divisors(b), divisors(c)]
(%i3) divisors (matrix ([a, b], [c, d]));
                  [ divisors(a)  divisors(b) ]
(%o3)             [                          ]
                  [ divisors(c)  divisors(d) ]
(%i4) divisors (@{a, b, c@});
(%o4)        @{divisors(a), divisors(b), divisors(c)@}
@end example
@end deffn

@anchor{elementp}
@deffn {Função} elementp (@var{x}, @var{a})
Retorna @code{true} se e somente se @var{x} for um elemento do conjunto
@var{a}.

@code{elementp} falha se @var{a} não for um conjunto literal.

Exemplos:

@c ===beg===
@c elementp (sin(1), {sin(1), sin(2), sin(3)});
@c elementp (sin(1), {cos(1), cos(2), cos(3)});
@c ===end===
@example
(%i1) elementp (sin(1), @{sin(1), sin(2), sin(3)@});
(%o1)                         true
(%i2) elementp (sin(1), @{cos(1), cos(2), cos(3)@});
(%o2)                         false
@end example

@end deffn

@anchor{emptyp}
@deffn {Função} emptyp (@var{a})
Retorna @code{true} se e somente se @var{a} for o conjunto vazio ou uma
lista vazia.

Exemplos:

@c ===beg===
@c map (emptyp, [{}, []]);
@c map (emptyp, [a + b, {{}}, %pi]);
@c ===end===
@example
(%i1) map (emptyp, [@{@}, []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, @{@{@}@}, %pi]);
(%o2)                 [false, false, false]
@end example
@end deffn
       
@anchor{equiv_classes}
@deffn {Função} equiv_classes (@var{s}, @var{F})
Retorna um conjunto das classes de equivalências do conjunto @var{s}
com relação à relação de
equivalência @var{F}.

@var{F} é uma função de duas variáveis definida
sobre o produto cartesiano @var{s} por @var{s}.  O valor de retorno de
@var{F} é ou @code{true} ou @code{false}, ou uma expressão
@var{expr} tal que @code{is(@var{expr})} é ou @code{true} ou
@code{false}.

Quando @var{F} nõ for uma relação de equivalência,
@code{equiv_classes} aceita-a sem reclamação,
mas o resultado é geralmente incorrecto nesse caso.

@c EXCESSIVE DETAIL HERE. PROBABLY JUST CUT THIS
@c @var{F} may be a relational operator (built-in or user-defined),
@c an ordinary Maxima function, a Lisp function, a lambda expression,
@c a macro, or a subscripted function.

Exemplos:

A relação de equivalência é uma expressão lambda a
qual retorna @code{true} ou @code{false}.

@c ===beg===
@c equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, lambda ([x, y], is (equal (x, y))));
@c ===end===
@example
(%i1) equiv_classes (@{1, 1.0, 2, 2.0, 3, 3.0@}, lambda ([x, y], is (equal (x, y))));
(%o1)            @{@{1, 1.0@}, @{2, 2.0@}, @{3, 3.0@}@}
@end example

A relação de equivalência é o nome de uma
função relacional que avalia para @code{true} ou
@code{false}.

@c ===beg===
@c equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
@c ===end===
@example
(%i1) equiv_classes (@{1, 1.0, 2, 2.0, 3, 3.0@}, equal);
(%o1)            @{@{1, 1.0@}, @{2, 2.0@}, @{3, 3.0@}@}
@end example

As classes de equivalência são números que diferem por um múltiplo
de 3.

@c ===beg===
@c equiv_classes ({1, 2, 3, 4, 5, 6, 7}, lambda ([x, y], remainder (x - y, 3) = 0));
@c ===end===
@example
(%i1) equiv_classes (@{1, 2, 3, 4, 5, 6, 7@}, lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              @{@{1, 4, 7@}, @{2, 5@}, @{3, 6@}@}
@end example
@end deffn

@anchor{every}
@deffn {Função} every (@var{f}, @var{s})
@deffnx {Função} every (@var{f}, @var{L_1}, ..., @var{L_n})

Retorna @code{true} se o predicado @var{f} for @code{true} para todos os
argumentos fornecidos.

Dado um conjunto como segundo argumento, @code{every(@var{f}, @var{s})}
retorna @code{true} se @code{is(@var{f}(@var{a_i}))} retornar
@code{true} para todos os @var{a_i} em @var{s}.  @code{every} pode ou
não avaliar @var{f} para todos os @var{a_i} em @var{s}. Uma vez que
os conjuntos são desordenados, @code{every} pode avaliar
@code{@var{f}(@var{a_i})} em qualquer ordem.

Dada uma ou mais listas como argumentos, @code{every(@var{f}, @var{L_1},
..., @var{L_n})} retorna @code{true} se @code{is(@var{f}(@var{x_1}, ...,
@var{x_n}))} retornar @code{true} para todos os @var{x_1}, ...,
@var{x_n} em @var{L_1}, ..., @var{L_n}, respectivamente. @code{every}
pode ou não avaliar @var{f} para toda combinação
@var{x_1}, ..., @var{x_n}.  @code{every} avalia listas na ordem de
incremento do índice.

Dado um conjunto vazio @code{@{@}} ou uma lista vazia @code{[]} como
argumentos, @code{every} retorna @code{false}.

Quando o sinalizador global @code{maperror} for @code{true}, todas as
listas @var{L_1}, ..., @var{L_n} deverão ter o mesmo comprimento.
Quando @code{maperror} for falso, as listas dadas como argumentos
serão efectivamente truncadas para o comprimento da menor lista.

Os resultados do predicado @var{f} que avaliarem (via @code{is}) para
algo diferente de @code{true} ou @code{false} são governados através
da variável global @code{prederror}. Quando @code{prederror} for
@code{true}, tais valores são tratados como @code{false}, e o valor de
retorno de @code{every} é @code{false}.  Quando @code{prederror} for
@code{false}, tais valores são tratados como @code{unknown}, e o valor
de retorno de @code{every} é @code{unknown}.

Exemplos:

@code{every} aplicada a um conjunto simples. O predicado é uma
função de um argumento.

@c ===beg===
@c every (integerp, {1, 2, 3, 4, 5, 6});
@c every (atom, {1, 2, sin(3), 4, 5 + y, 6});
@c ===end===
@example
(%i1) every (integerp, @{1, 2, 3, 4, 5, 6@});
(%o1)                         true
(%i2) every (atom, @{1, 2, sin(3), 4, 5 + y, 6@});
(%o2)                         false
@end example

@code{every} aplicada a duas listas. O predicado é uma
função de dois argumentos.

@c ===beg===
@c every ("=", [a, b, c], [a, b, c]);
@c every ("#", [a, b, c], [a, b, c]);
@c ===end===
@example
(%i1) every ("=", [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) every ("#", [a, b, c], [a, b, c]);
(%o2)                         false
@end example

Predicado @var{f} que produz resultados diferentes de @code{true} ou
@code{false}, governados por meio da variável global @code{prederror}.

@c ===beg===
@c prederror : false;
@c map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
@c every ("<", [x, y, z], [x^2, y^2, z^2]);
@c prederror : true;
@c every ("<", [x, y, z], [x^2, y^2, z^2]);
@c ===end===
@example
(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) prederror : true;
(%o4)                         true
(%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
(%o5)                         false
@end example

@end deffn
 
@anchor{extremal_subset}
@deffn {Função} extremal_subset (@var{s}, @var{f}, max)
@deffnx {Função} extremal_subset (@var{s}, @var{f}, min)

Encontra o subconjunto de @var{s} para o qual a função
@var{f} toma valores máximos ou mínimos.

@code{extremal_subset(@var{s}, @var{f}, max)} encontra o subconjunto do
conjunto ou lista @var{s} para os quais a função real
@var{f} assume um valor máximo.

@code{extremal_subset(@var{s}, @var{f}, min)} encontra o subconjunto do
conjunto ou lista @var{s} para a qual a função real
@var{f} assume um valor mínimo.

Exemplos:

@c ===beg===
@c extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
@c extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
@c ===end===
@example
(%i1) extremal_subset (@{-2, -1, 0, 1, 2@}, abs, max);
(%o1)                       @{- 2, 2@}
(%i2) extremal_subset (@{sqrt(2), 1.57, %pi/2@}, sin, min);
(%o2)                       @{sqrt(2)@}
@end example
@end deffn

@anchor{flatten}
@deffn {Função} flatten (@var{expr})

Colecta argumentos de subexpressões que possuem o mesmo operador que
@var{expr} e constrói uma expressão a partir desses argumentos
colectados.

Subexpressões nas quais o operador é diferente do operador principal
de @code{expr} são copiadas sem modificação, mesmo se
tiverem subexpressões com o mesmo operador que @code{expr}.

É possível que @code{flatten} construia expressões nas
quais o número de argumentos difira dos argumentos declarados para um
operador; isso pode provocar uma mensagem de erro do simplificador ou do
avaliador.  @code{flatten} não tenta detectar tais
situações.

Expressões com representações especiais, por exemplo,
expressões racionais canónicas (CRE), não podem usar a
função @code{flatten}; nesses casos, @code{flatten}
retorna os seus argumentos sem modificação.

Exemplos:

Aplicado a uma lista, @code{flatten} reúne todos os elementos da
lista que sejam listas.

@c ===beg===
@c flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
@c ===end===
@example
(%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
(%o1)            [a, b, c, d, e, f, g, h, i, j]
@end example

Aplicado a um conjunto, @code{flatten} reúne todos os elementos do
conjunto que sejam conjuntos.

@c ===beg===
@c flatten ({a, {b}, {{c}}});
@c flatten ({a, {[a], {a}}});
@c ===end===
@example
(%i1) flatten (@{a, @{b@}, @{@{c@}@}@});
(%o1)                       @{a, b, c@}
(%i2) flatten (@{a, @{[a], @{a@}@}@});
(%o2)                       @{a, [a]@}
@end example

o efeito de @code{flatten} é similar a declarar o operador principal
para ser enário. No entanto, @code{flatten} não faz efeito sobre
subexpressões que possuem um operador diferente do operador principal,
enquanto uma declaração enária faz efeito.

@c ===beg===
@c expr: flatten (f (g (f (f (x)))));
@c declare (f, nary);
@c ev (expr);
@c ===end===
@example
(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
@end example

@code{flatten} trata funções subscritas da mesma forma
que qualquer outro operador.

@c ===beg===
@c flatten (f[5] (f[5] (x, y), z));
@c ===end===
@example
(%i1) flatten (f[5] (f[5] (x, y), z));
(%o1)                      f (x, y, z)
                            5
@end example

É possível que @code{flatten} construa expressões nas
quais o número de argumentos difira dos argumentos declarados para um
operador;

@c ===beg===
@c 'mod (5, 'mod (7, 4));
@c flatten (%);
@c ''%, nouns;
@c ===end===
@example
(%i1) 'mod (5, 'mod (7, 4));
(%o1)                   mod(5, mod(7, 4))
(%i2) flatten (%);
(%o2)                     mod(5, 7, 4)
(%i3) ''%, nouns;
Wrong number of arguments to mod
 -- an error.  Quitting.  To debug this try debugmode(true);
@end example
@end deffn

@anchor{full_listify}
@deffn {Função} full_listify (@var{a})
Substitui todo operador de conjunto em @var{a} por um operador de lista,
e retorna o resultado. @code{fullt_listify} substitui operadores de
conjunto em subexpressões aninhadas, mesmo se o operador principal
não for (@code{set}).

@code{listify} substitui unicamente o operador principal.

Exemplos:

@c ===beg===
@c full_listify ({a, b, {c, {d, e, f}, g}});
@c full_listify (F (G ({a, b, H({c, d, e})})));
@c ===end===
@example
(%i1) full_listify (@{a, b, @{c, @{d, e, f@}, g@}@});
(%o1)               [a, b, [c, [d, e, f], g]]
(%i2) full_listify (F (G (@{a, b, H(@{c, d, e@})@})));
(%o2)              F(G([a, b, H([c, d, e])]))
@end example

@end deffn

@anchor{fullsetify}
@deffn {Função} fullsetify (@var{a})
Quando @var{a} for uma lista, substitui o operador de lista por um
operador de conjunto, e aplica @code{fullsetify} a cada elemento que for
um conjunto.  Quando @var{a} não for uma lista, o resultado é
@var{a} na sua forma original e sem modificações.

@code{setify} substitui unicamente o operador principal.

Exemplos:

Na linha (%o2), o argumento de @code{f} não é convertido para um
conjunto porque o operador principal de @code{f([b])} não é uma
lista.

@c ===beg===
@c fullsetify ([a, [a]]);
@c fullsetify ([a, f([b])]);
@c ===end===
@example
(%i1) fullsetify ([a, [a]]);
(%o1)                       @{a, @{a@}@}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      @{a, f([b])@}
@end example

@end deffn

@anchor{identity}
@deffn {Função} identity (@var{x})

Retorna @var{x} para qualquer argumento @var{x}.

Exemplos:

@code{identity} pode ser usado como um predicado quando os argumentos
forem valores Booleanos.

@c ===beg===
@c every (identity, [true, true]);
@c ===end===
@example
(%i1) every (identity, [true, true]);
(%o1)                         true
@end example
@end deffn

@anchor{integer_partitions}
@deffn {Função} integer_partitions (@var{n})
@deffnx {Função} integer_partitions (@var{n}, @var{len})

Calcula partições inteiras de @var{n}, isto é, listas
de inteiros cuja soma dos elementos de cada lista é @var{n}.

@code{integer_partitions(@var{n})} encontra o conjunto de todas as
partições do inteiro @var{n}. Cada
partição é uma lista ordenada do maior para o menor.

@code{integer_partitions(@var{n}, @var{len})} encontra todas as
partições com comprimento @var{len} ou menor; nesse
caso, serão adicionados zeros ao final de cada
partição de comprimento menor que @var{len}, para fazer
com que todas as partições tenham exactamente @var{len} termos.
Cada partição é uma lista ordenada do maior para o
menor.

Uma lista @math{[a_1, ..., a_m]} é uma partição de um
inteiro não negativo @math{n} quando: (1) cada @math{a_i} é um
inteiro não nulo, e (2) @math{a_1 + ... + a_m = n.} Dessa forma, 0
não tem partições.

Exemplos:

@c ===beg===
@c integer_partitions (3);
@c s: integer_partitions (25)$
@c cardinality (s);
@c map (lambda ([x], apply ("+", x)), s);
@c integer_partitions (5, 3);
@c integer_partitions (5, 2);
@c ===end===
@example
(%i1) integer_partitions (3);
(%o1)               @{[1, 1, 1], [2, 1], [3]@}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply ("+", x)), s);
(%o4)                         @{25@}
(%i5) integer_partitions (5, 3);
(%o5) @{[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]@}
(%i6) integer_partitions (5, 2);
(%o6)               @{[3, 2], [4, 1], [5, 0]@}
@end example

Para encontrar todas as partições que satisfazem uma
condição, use a função @code{subset};
aqui está um exemplo que encontra todas as partições
de 10 cujos elementos da lista são números primos.

@c ===beg===
@c s: integer_partitions (10)$
@c cardinality (s);
@c xprimep(x) := integerp(x) and (x > 1) and primep(x)$
@c subset (s, lambda ([x], every (xprimep, x)));
@c ===end===
@example
(%i1) s: integer_partitions (10)$
(%i2) cardinality (s);
(%o2)                          42
(%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
(%i4) subset (s, lambda ([x], every (xprimep, x)));
(%o4) @{[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]@}
@end example

@end deffn

@anchor{intersect}
@deffn {Função} intersect (@var{a_1}, ..., @var{a_n})

@code{intersect} é o mesmo que @code{intersection}, como veremos.

@end deffn

@anchor{intersection}
@deffn {Função} intersection (@var{a_1}, ..., @var{a_n})
Retorna um conjunto contendo os elementos que são comuns aos conjuntos
@var{a_1} até @var{a_n}.

@code{intersection} falha se qualquer dos argumentos não for um
conjunto literal.

Exemplos:

@c ===beg===
@c S_1 : {a, b, c, d};
@c S_2 : {d, e, f, g};
@c S_3 : {c, d, e, f};
@c S_4 : {u, v, w};
@c intersection (S_1, S_2);
@c intersection (S_2, S_3);
@c intersection (S_1, S_2, S_3);
@c intersection (S_1, S_2, S_3, S_4);
@c ===end===
@example
(%i1) S_1 : @{a, b, c, d@};
(%o1)                     @{a, b, c, d@}
(%i2) S_2 : @{d, e, f, g@};
(%o2)                     @{d, e, f, g@}
(%i3) S_3 : @{c, d, e, f@};
(%o3)                     @{c, d, e, f@}
(%i4) S_4 : @{u, v, w@};
(%o4)                       @{u, v, w@}
(%i5) intersection (S_1, S_2);
(%o5)                          @{d@}
(%i6) intersection (S_2, S_3);
(%o6)                       @{d, e, f@}
(%i7) intersection (S_1, S_2, S_3);
(%o7)                          @{d@}
(%i8) intersection (S_1, S_2, S_3, S_4);
(%o8)                          @{@}
@end example

@end deffn

@deffn {Função} kron_delta (@var{x}, @var{y})

Representa a função delta de Kronecker.

@code{kron_delta} simplifica para 1 quando @var{x} e @var{y} forem
idênticos ou equivalentes, e simplifica para 0 quando @var{x} e
@var{y} não forem equivalentes. De outra forma, se não for certo que
@var{x} e @var{y} são equivalentes, @code{kron_delta} simplificará
para uma expressão substantiva. @code{kron_delta} implementa uma
política de segurança para expressões em
ponto flutuante: se a diferença @code{@var{x} - @var{y}}
for um número em ponto flutuante, @code{kron_delta} simplifica para
uma expressão substantiva quando @var{x} for aparentemente equivalente
a @var{y}.

Especificamente, @code{kron_delta(@var{x}, @var{y})} simplifica para 1
quando @code{is(x = y)} for @code{true}. @code{kron_delta} também
simplifica para 1 quando @code{sign(abs(@var{x} - @var{y}))} for
@code{zero} e @code{@var{x} - @var{y}} não for um número em ponto
flutuante (e também não for um número de precisão simples em
ponto flutuante nem um número de precisão dupla em poto flutuante,
isto é, não for um bigfloat). @code{kron_delta} simplifica para 0
quando @code{sign(abs(@var{x} - @var{y}))} for @code{pos}.

Caso contrário, @code{sign(abs(@var{x} - @var{y}))} é diferente de
@code{pos} ou @code{zero}, ou é @code{zero} e @code{@var{x} - @var{y}}
é um número em ponto flutuante. Nesses casos, @code{kron_delta}
retorna um expressão substantiva.

@code{kron_delta} é declarada como sendo simétrica. Isto é,
@code{kron_delta(@var{x}, @var{y})} é igual a
@code{kron_delta(@var{y}, @var{x})}.

Exemplos:

Os argumentos de @code{kron_delta} são idênticos. @code{kron_delta}
simplifica para 1.

@c ===beg===
@c kron_delta (a, a);
@c kron_delta (x^2 - y^2, x^2 - y^2);
@c float (kron_delta (1/10, 0.1));
@c ===end===
@example
(%i1) kron_delta (a, a);
(%o1)                           1
(%i2) kron_delta (x^2 - y^2, x^2 - y^2);
(%o2)                           1
(%i3) float (kron_delta (1/10, 0.1));
(%o3)                           1
@end example

Os argumentos de @code{kron_delta} são equivalentes, e a
diferença entre eles não é um número em ponto
flutuante.  @code{kron_delta} simplifica para 1.

@c ===beg===
@c assume (equal (x, y));
@c kron_delta (x, y);
@c ===end===
@example
(%i1) assume (equal (x, y));
(%o1)                     [equal(x, y)]
(%i2) kron_delta (x, y);
(%o2)                           1
@end example

Os argumentos de @code{kron_delta} não são equivalentes.
@code{kron_delta} simplifica para 0.

@c ===beg===
@c kron_delta (a + 1, a);
@c assume (a > b)$
@c kron_delta (a, b);
@c kron_delta (1/5, 0.7);
@c ===end===
@example
(%i1) kron_delta (a + 1, a);
(%o1)                           0
(%i2) assume (a > b)$
(%i3) kron_delta (a, b);
(%o3)                           0
(%i4) kron_delta (1/5, 0.7);
(%o4)                           0
@end example

Os argumentos de @code{kron_delta} podem ou não ser equivalentes.
@code{kron_delta} simplifica para uma expressão substantiva.

@c ===beg===
@c kron_delta (a, b);
@c assume(x >= y)$
@c kron_delta (x, y);
@c ===end===
@example
(%i1) kron_delta (a, b);
(%o1)                   kron_delta(a, b)
(%i2) assume(x >= y)$
(%i3) kron_delta (x, y);
(%o3)                   kron_delta(x, y)
@end example

Os argumentos de @code{kron_delta} são equivalentes, mas a
diferença entre eles é um número em ponto flutuante.
@code{kron_delta} simplifica para uma expressão substantiva.

@c ===beg===
@c 1/4 - 0.25;
@c 1/10 - 0.1;
@c 0.25 - 0.25b0;
@c kron_delta (1/4, 0.25);
@c kron_delta (1/10, 0.1);
@c kron_delta (0.25, 0.25b0);
@c ===end===
@example
(%i1) 1/4 - 0.25;
(%o1)                          0.0
(%i2) 1/10 - 0.1;
(%o2)                          0.0
(%i3) 0.25 - 0.25b0;
Warning:  Float to bigfloat conversion of 0.25
(%o3)                         0.0b0
(%i4) kron_delta (1/4, 0.25);
                                  1
(%o4)                  kron_delta(-, 0.25)
                                  4
(%i5) kron_delta (1/10, 0.1);
                                  1
(%o5)                  kron_delta(--, 0.1)
                                  10
(%i6) kron_delta (0.25, 0.25b0);
Warning:  Float to bigfloat conversion of 0.25
(%o6)               kron_delta(0.25, 2.5b-1)
@end example

@code{kron_delta} é simétrica.

@c ===beg===
@c kron_delta (x, y);
@c kron_delta (y, x);
@c kron_delta (x, y) - kron_delta (y, x);
@c is (equal (kron_delta (x, y), kron_delta (y, x)));
@c is (kron_delta (x, y) = kron_delta (y, x));
@c ===end===
@example
(%i1) kron_delta (x, y);
(%o1)                   kron_delta(x, y)
(%i2) kron_delta (y, x);
(%o2)                   kron_delta(x, y)
(%i3) kron_delta (x, y) - kron_delta (y, x);
(%o3)                           0
(%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
(%o4)                         true
(%i5) is (kron_delta (x, y) = kron_delta (y, x));
(%o5)                         true
@end example

@end deffn

@anchor{listify}
@deffn {Função} listify (@var{a})

Retorna uma lista contendo os elementos de @var{a} quando @var{a} for um
conjunto. De outra forma, @code{listify} retorna @var{a}.

@code{full_listify} substitui todos os operadores de conjunto em @var{a}
por operadores de lista.

Exemplos:

@c ===beg===
@c listify ({a, b, c, d});
@c listify (F ({a, b, c, d}));
@c ===end===
@example
(%i1) listify (@{a, b, c, d@});
(%o1)                     [a, b, c, d]
(%i2) listify (F (@{a, b, c, d@}));
(%o2)                    F(@{a, b, c, d@})
@end example

@end deffn

@anchor{lreduce}
@deffn {Função} lreduce (@var{F}, @var{s})
@deffnx {Função} lreduce (@var{F}, @var{s}, @var{s_0})

Extende a função de dois argumentos @var{F} para uma
função de @code{n} argumentos, usando
composição, onde @var{s} é uma lista.

@code{lreduce(@var{F}, @var{s})} retorna @code{F(... F(F(s_1, s_2),
s_3), ... s_n)}.  Quando o argumento opcional @var{s_0} estiver
presente, o resultado é equivalente a @code{lreduce(@var{F},
cons(@var{s_0}, @var{s}))}.

A função @var{F} é aplicada primeiro aos elementos
mais à @emph{esquerda} de lista; daí o nome "lreduce".

Veja também @code{rreduce}, @code{xreduce}, e @code{tree_reduce}.

Exemplos:

@code{lreduce} sem o argumento opcional.

@c ===beg===
@c lreduce (f, [1, 2, 3]);
@c lreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
@end example

@code{lreduce} com o argumento opcional.

@c ===beg===
@c lreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
@end example

@code{lreduce} aplicada a operadores binários internos do Maxima
@code{/} é o operador de divisão.

@c ===beg===
@c lreduce ("^", args ({a, b, c, d}));
@c lreduce ("/", args ({a, b, c, d}));
@c ===end===
@example
(%i1) lreduce ("^", args (@{a, b, c, d@}));
                               b c d
(%o1)                       ((a ) )
(%i2) lreduce ("/", args (@{a, b, c, d@}));
                                a
(%o2)                         -----
                              b c d
@end example

@end deffn

@anchor{makeset}
@deffn {Função} makeset (@var{expr}, @var{x}, @var{s})

Retorna um conjunto com elementos gerados a partir da expressão
@var{expr}, onde @var{x} é uma lista de variáveis em @var{expr}, e
@var{s}é um conjunto ou lista de listas.  Para gerar cada elemento do
conjunto, @var{expr} é avaliada com as variáveis @var{x}
substituídas, em paralelo, por elementos de @var{s}.

Cada elemento de @var{s} deve ter o mesmo comprimento que @var{x}.  A
lista de variáveis @var{x} deve ser uma lista de
símbolos, sem índices.  Mesmo se existir
somente um símbolo, @var{x} deve ser uma lista de um
elemento, e cada elemento de @var{s} deve ser uma lista de um elemento.

@c FOLLOWING EQUIVALENT EXPRESSION IS REALLY TOO COMPLICATED, JUST SKIP IT FOR NOW
@c @code{makeset(@var{expr}, @var{x}, @var{s})} returns the same result as
@c @code{setify(map(lambda([L], sublis(map("=", ''@var{x}, L), ''@var{expr})), args(@var{s})))}.

Veja também @code{makelist}.

Exemplos:

@c ===beg===
@c makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
@c S : {x, y, z}$
@c S3 : cartesian_product (S, S, S);
@c makeset (i + j + k, [i, j, k], S3);
@c makeset (sin(x), [x], {[1], [2], [3]});
@c ===end===
@example
(%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                           1  2  3  4
(%o1)                     @{-, -, -, -@}
                           a  b  c  d
(%i2) S : @{x, y, z@}$
(%i3) S3 : cartesian_product (S, S, S);
(%o3) @{[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y], 
[x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x], 
[y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z], 
[y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y], 
[z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x], 
[z, z, y], [z, z, z]@}
(%i4) makeset (i + j + k, [i, j, k], S3);
(%o4) @{3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x, 
                                       z + 2 y, 2 z + x, 2 z + y@}
(%i5) makeset (sin(x), [x], @{[1], [2], [3]@});
(%o5)               @{sin(1), sin(2), sin(3)@}
@end example
@end deffn

@anchor{moebius}
@deffn {Função} moebius (@var{n})

Representa a função de Moebius.

Quando @var{n} for o produto de @math{k} primos distintos,
@code{moebius(@var{n})} simplifica para @math{(-1)^k}; quando
@math{@var{n} = 1}, simplifica para 1; e simplifica para 0 para todos os
outros inteiros positivos.

@code{moebius}, aplicada a equações, listas, matrizes
e conjuntos, é calculada em forma distributiva.

Exemplos:

@c ===beg===
@c moebius (1);
@c moebius (2 * 3 * 5);
@c moebius (11 * 17 * 29 * 31);
@c moebius (2^32);
@c moebius (n);
@c moebius (n = 12);
@c moebius ([11, 11 * 13, 11 * 13 * 15]);
@c moebius (matrix ([11, 12], [13, 14]));
@c moebius ({21, 22, 23, 24});
@c ===end===
@example
(%i1) moebius (1);
(%o1)                           1
(%i2) moebius (2 * 3 * 5);
(%o2)                          - 1
(%i3) moebius (11 * 17 * 29 * 31);
(%o3)                           1
(%i4) moebius (2^32);
(%o4)                           0
(%i5) moebius (n);
(%o5)                      moebius(n)
(%i6) moebius (n = 12);
(%o6)                    moebius(n) = 0
(%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
(%o7)                      [- 1, 1, 1]
(%i8) moebius (matrix ([11, 12], [13, 14]));
                           [ - 1  0 ]
(%o8)                      [        ]
                           [ - 1  1 ]
(%i9) moebius (@{21, 22, 23, 24@});
(%o9)                      @{- 1, 0, 1@}
@end example

@end deffn
 
@anchor{multinomial_coeff}
@deffn {Função} multinomial_coeff (@var{a_1}, ..., @var{a_n})
@deffnx {Função} multinomial_coeff ()

Calcula o coeficiente multinomial.

Quando cada @var{a_k} for um inteiro não negativo, o coeficiente
multinomial indica o número de formas possíveis de
colocar @code{@var{a_1} + ... + @var{a_n}} objectos distintos em
@math{n} caixas com @var{a_k} elementos na @math{k}'ésima caixa. Em
geral, @code{multinomial_coeff (@var{a_1}, ..., @var{a_n})} calcula
@code{(@var{a_1} + ... + @var{a_n})!/(@var{a_1}! ... @var{a_n}!)}.

@code{multinomial_coeff()} (sem argumentos) produz 1.

@code{minfactorial} poderá conseguir simplificar o valor calculado por
@code{multinomial_coeff}.

Exemplos:

@c ===beg===
@c multinomial_coeff (1, 2, x);
@c minfactorial (%);
@c multinomial_coeff (-6, 2);
@c minfactorial (%);
@c ===end===
@example
(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
@end example
@end deffn

@anchor{num_distinct_partitions}
@deffn {Função} num_distinct_partitions (@var{n})
@deffnx {Função} num_distinct_partitions (@var{n}, list)

Calcula o n;umero de partições de inteiros distintos de @var{n}
quando @var{n} for um inteiro não negativo.
De outra forma, @code{num_distinct_partitions} retorna uma expressão substantiva.

@code{num_distinct_partitions(@var{n}, list)} retorna uma 
lista do número de partições distintas de 1, 2, 3, ..., @var{n}. 

Uma partição distinta de @var{n} é
uma lista de inteiros positivos distintos @math{k_1}, ..., @math{k_m}
tais que @math{@var{n} = k_1 + ... + k_m}.

Exemplos:

@c ===beg===
@c num_distinct_partitions (12);
@c num_distinct_partitions (12, list);
@c num_distinct_partitions (n);
@c ===end===
@example
(%i1) num_distinct_partitions (12);
(%o1)                          15
(%i2) num_distinct_partitions (12, list);
(%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
(%i3) num_distinct_partitions (n);
(%o3)              num_distinct_partitions(n)
@end example

@end deffn

@anchor{num_partitions}
@deffn {Função} num_partitions (@var{n})
@deffnx {Função} num_partitions (@var{n}, list)

Calcula o número das partições inteiras de @var{n}
quando @var{n} for um inteiro não negativo.  De outra forma,
@code{num_partitions} retorna uma expressão substantiva.

@code{num_partitions(@var{n}, list)} retorna uma
lista do número de partições inteiras de 1, 2, 3, ..., @var{n}.

Para um inteiro não negativo @var{n}, @code{num_partitions(@var{n})} é igual a
@code{cardinality(integer_partitions(@var{n}))}; todavia, @code{num_partitions} 
não constrói actualmente o conjunto das partições, nesse sentido @code{num_partitions} é mais rápida.

Exemplos:

@c ===beg===
@c num_partitions (5) = cardinality (integer_partitions (5));
@c num_partitions (8, list);
@c num_partitions (n);
@c ===end===
@example
(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
@end example

@end deffn



@anchor{partition_set}
@deffn {Função} partition_set (@var{a}, @var{f})

Partições do conjunto @var{a} que satisfazem o predicado @var{f}.

@code{partition_set} retorna uma lista de dois conjuntos.
O primeiro conjunto compreende os elementos de @var{a} para os quais @var{f} avalia para @code{false},
e o segundo conjunto compreende quaisquer outros elementos de @var{a}.
@code{partition_set} não aplica @code{is} ao valor de retorno de @var{f}.

@code{partition_set} reclama se @var{a} não for um conjunto literal.

Veja também @code{subset}.

Exemplos:

@c ===beg===
@c partition_set ({2, 7, 1, 8, 2, 8}, evenp);
@c partition_set ({x, rat(y), rat(y) + z, 1}, lambda ([x], ratp(x)));
@c ===end===
@example
(%i1) partition_set (@{2, 7, 1, 8, 2, 8@}, evenp);
(%o1)                   [@{1, 7@}, @{2, 8@}]
(%i2) partition_set (@{x, rat(y), rat(y) + z, 1@}, lambda ([x], ratp(x)));
(%o2)/R/              [@{1, x@}, @{y, y + z@}]
@end example
@end deffn

@anchor{permutations}
@deffn {Função} permutations (@var{a})

Retorna um conjunto todas as permutações distintas dos elementos da 
lista ou do conjunto @var{a}. Cada permutação é uma lista, não um conjunto. 

Quando @var{a} for uma lista, elementos duplicados de @var{a} são incluídos
nas permutações.

@code{permutations} reclama se @var{a} não for um conjunto literal ou uma lista literal.

Exemplos:

@c ===beg===
@c permutations ([a, a]);
@c permutations ([a, a, b]);
@c ===end===
@example
(%i1) permutations ([a, a]);
(%o1)                       @{[a, a]@}
(%i2) permutations ([a, a, b]);
(%o2)           @{[a, a, b], [a, b, a], [b, a, a]@}
@end example

@end deffn

@anchor{powerset}
@deffn {Função} powerset (@var{a})
@deffnx {Função} powerset (@var{a}, @var{n})

Retorna o conjunto de todos os dubconjuntos de @var{a}, ou um subconjunto de @var{a}.

@code{powerset(@var{a})} retorna o conjunto de todos os subconjuntos do conjunto @var{a}.
@code{powerset(@var{a})} tem @code{2^cardinality(@var{a})} elementos.

@code{powerset(@var{a}, @var{n})} retorna o conjunto de todos os subconjuntos de @var{a} que possuem 
cardinalidade @var{n}.

@code{powerset} reclama se @var{a} não for um conjunto literal,
ou se @var{n} não for um inteiro não negativo.

Exemplos:

@c ===beg===
@c powerset ({a, b, c});
@c powerset ({w, x, y, z}, 4);
@c powerset ({w, x, y, z}, 3);
@c powerset ({w, x, y, z}, 2);
@c powerset ({w, x, y, z}, 1);
@c powerset ({w, x, y, z}, 0);
@c ===end===
@example
(%i1) powerset (@{a, b, c@});
(%o1) @{@{@}, @{a@}, @{a, b@}, @{a, b, c@}, @{a, c@}, @{b@}, @{b, c@}, @{c@}@}
(%i2) powerset (@{w, x, y, z@}, 4);
(%o2)                    @{@{w, x, y, z@}@}
(%i3) powerset (@{w, x, y, z@}, 3);
(%o3)     @{@{w, x, y@}, @{w, x, z@}, @{w, y, z@}, @{x, y, z@}@}
(%i4) powerset (@{w, x, y, z@}, 2);
(%o4)   @{@{w, x@}, @{w, y@}, @{w, z@}, @{x, y@}, @{x, z@}, @{y, z@}@}
(%i5) powerset (@{w, x, y, z@}, 1);
(%o5)                 @{@{w@}, @{x@}, @{y@}, @{z@}@}
(%i6) powerset (@{w, x, y, z@}, 0);
(%o6)                         @{@{@}@}
@end example

@end deffn

@anchor{rreduce}
@deffn {Função} rreduce (@var{F}, @var{s})
@deffnx {Função} rreduce (@var{F}, @var{s}, @var{s_@{n + 1@}})

Extende a função de dois argumentos @var{F} para uma função de @var{n} argumentos usando composição de funções,
onde @var{s} é uma lista.

@code{rreduce(@var{F}, @var{s})} retorna @code{F(s_1, ... F(s_@{n - 2@}, F(s_@{n - 1@}, s_n)))}.
Quando o argumento opcional @var{s_@{n + 1@}} estiver presente,
o resultado é equivalente a @code{rreduce(@var{F}, endcons(@var{s_@{n + 1@}}, @var{s}))}.

A função @var{F} é primeiro aplicada à
lista de elementos @i{mais à direita - rightmost}, daí o nome "rreduce". 

Veja também @code{lreduce}, @code{tree_reduce}, e @code{xreduce}.

Exemplos:

@code{rreduce} sem o argumento opcional.

@c ===beg===
@c rreduce (f, [1, 2, 3]);
@c rreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
@end example

@code{rreduce} com o argumento opcional.

@c ===beg===
@c rreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
@end example

@code{rreduce} aplicada a operadores de dois argumentos internos ( definidos por padrão) ao Maxima.
@code{/} é o operadro de divisão.

@c ===beg===
@c rreduce ("^", args ({a, b, c, d}));
@c rreduce ("/", args ({a, b, c, d}));
@c ===end===
@example
(%i1) rreduce ("^", args (@{a, b, c, d@}));
                                 d
                                c
                               b
(%o1)                         a
(%i2) rreduce ("/", args (@{a, b, c, d@}));
                               a c
(%o2)                          ---
                               b d
@end example

@end deffn

@anchor{setdifference}
@deffn {Função}  setdifference (@var{a}, @var{b})

Retorna um conjunto contendo os elementos no conjunto @var{a} que
não estãono conjunto @var{b}.

@code{setdifference} reclama se ou @var{a} ou @var{b} não for um conjunto literal.

Exemplos:

@c ===beg===
@c S_1 : {a, b, c, x, y, z};
@c S_2 : {aa, bb, c, x, y, zz};
@c setdifference (S_1, S_2);
@c setdifference (S_2, S_1);
@c setdifference (S_1, S_1);
@c setdifference (S_1, {});
@c setdifference ({}, S_1);
@c ===end===
@example
(%i1) S_1 : @{a, b, c, x, y, z@};
(%o1)                  @{a, b, c, x, y, z@}
(%i2) S_2 : @{aa, bb, c, x, y, zz@};
(%o2)                 @{aa, bb, c, x, y, zz@}
(%i3) setdifference (S_1, S_2);
(%o3)                       @{a, b, z@}
(%i4) setdifference (S_2, S_1);
(%o4)                     @{aa, bb, zz@}
(%i5) setdifference (S_1, S_1);
(%o5)                          @{@}
(%i6) setdifference (S_1, @{@});
(%o6)                  @{a, b, c, x, y, z@}
(%i7) setdifference (@{@}, S_1);
(%o7)                          @{@}
@end example

@end deffn

@anchor{setequalp}
@deffn {Função} setequalp (@var{a}, @var{b})

Retorna @code{true} se os conjuntos @var{a} e @var{b} possuirem o mesmo número de elementos
@c $SETEQUALP CALLS THE LISP FUNCTION LIKE,
@c AND SO DOES THE CODE TO EVALUATE IS (X = Y).
e @code{is(@var{x} = @var{y})} for @code{true}
para @code{x} nos elementos de @var{a}
e @code{y} nos elementos de @var{b},
considerados na ordem determinada por @code{listify}.
De outra forma, @code{setequalp} retorna @code{false}.

Exemplos:

@c ===beg===
@c setequalp ({1, 2, 3}, {1, 2, 3});
@c setequalp ({a, b, c}, {1, 2, 3});
@c setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
@c ===end===
@example
(%i1) setequalp (@{1, 2, 3@}, @{1, 2, 3@});
(%o1)                         true
(%i2) setequalp (@{a, b, c@}, @{1, 2, 3@});
(%o2)                         false
(%i3) setequalp (@{x^2 - y^2@}, @{(x + y) * (x - y)@});
(%o3)                         false
@end example

@end deffn

@anchor{setify}
@deffn {Função} setify (@var{a})

Constrói um conjunto de elementos a partir da lista @var{a}. Elementos
duplicados da lista @var{a} são apagados e os elementos
são ordenados de acordo com o predicado @code{orderlessp}.

@code{setify} reclama se @var{a} não for uma lista literal.

Exemplos:

@c ===beg===
@c setify ([1, 2, 3, a, b, c]);
@c setify ([a, b, c, a, b, c]);
@c setify ([7, 13, 11, 1, 3, 9, 5]);
@c ===end===
@example
(%i1) setify ([1, 2, 3, a, b, c]);
(%o1)                  @{1, 2, 3, a, b, c@}
(%i2) setify ([a, b, c, a, b, c]);
(%o2)                       @{a, b, c@}
(%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
(%o3)                @{1, 3, 5, 7, 9, 11, 13@}
@end example

@end deffn

@anchor{setp}
@deffn {Função} setp (@var{a})

Retorna @code{true} se e somente se @var{a} for um conjunto na interpretação do Maxima.

@code{setp} retorna @code{true} para conjuntos não simplificados (isto é, conjuntos com elementos redundantes)
e também para conjuntos simplificados.

@c NOT SURE WE NEED TO MENTION THIS. OK FOR NOW
@code{setp} é equivalente à função do Maxima
@code{setp(a) := not atom(a) and op(a) = 'set}.

Exemplos:

@c ===beg===
@c simp : false;
@c {a, a, a};
@c setp (%);
@c ===end===
@example
(%i1) simp : false;
(%o1)                         false
(%i2) @{a, a, a@};
(%o2)                       @{a, a, a@}
(%i3) setp (%);
(%o3)                         true
@end example

@end deffn

@anchor{set_partitions}
@deffn {Função} set_partitions (@var{a})
@deffnx {Função} set_partitions (@var{a}, @var{n})

Retorna o conjunto de todas as partições de @var{a}, ou um subconjunto daquele conjunto de partições.

@code{set_partitions(@var{a}, @var{n})} retorna um conjunto de todas as
decomposições de @var{a} em @var{n} subconjutnos disjuntos não vazios.

@code{set_partitions(@var{a})} retorna o conjunto de todas as partições.

@code{stirling2} retorna a cardinalidade de um conjuntode partições de um conjunto.

Um conjunto de conjuntos @math{P} é uma partição de um conjunto @math{S} quando

@enumerate
@item
cada elemento de @math{P} é um conjunto não vazio,
@item
elementos distintos de @math{P} são disjuntos,
@item
a união dos elementos de @math{P} é igual a @math{S}.
@end enumerate

Exemplos:

O conjunto vazio é uma partição de si mesmo, as ondições 1 e 2 são "vaziamente" verdadeiras.

@c ===beg===
@c set_partitions ({});
@c ===end===
@example
(%i1) set_partitions (@{@});
(%o1)                         @{@{@}@}
@end example

A cardinalidade do conjunto de partições de um conjunto pode ser encontrada usando @code{stirling2}.

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c cardinality(p) = stirling2 (6, 3);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) cardinality(p) = stirling2 (6, 3);
(%o3)                        90 = 90
@end example

Cada elemento de @code{p} pode ter @var{n} = 3 elementos; vamos verificar.

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c map (cardinality, p);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (cardinality, p);
(%o3)                          @{3@}
@end example

Finalmente, para cada elementos de @code{p}, a união de seus elementos possivelmente será 
igua a @code{s}; novamente vamos comprovar.

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c map (lambda ([x], apply (union, listify (x))), p);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (lambda ([x], apply (union, listify (x))), p);
(%o3)                 @{@{0, 1, 2, 3, 4, 5@}@}
@end example
@end deffn

@anchor{some}
@deffn {Função} some (@var{f}, @var{a})
@deffnx {Função} some (@var{f}, @var{L_1}, ..., @var{L_n})

Retorna @code{true} se o predicado @var{f} for @code{true} para um ou mais argumentos dados.

Given one set as the second argument, 
@code{some(@var{f}, @var{s})} returns @code{true}
if @code{is(@var{f}(@var{a_i}))} returns @code{true} for one or more @var{a_i} in @var{s}.
@code{some} may or may not evaluate @var{f} for all @var{a_i} in @var{s}.
Since sets are unordered,
@code{some} may evaluate @code{@var{f}(@var{a_i})} in any order.

Dadas uma ou mais listas como argumentos,
@code{some(@var{f}, @var{L_1}, ..., @var{L_n})} retorna @code{true}
se @code{is(@var{f}(@var{x_1}, ..., @var{x_n}))} retornar @code{true} 
para um ou mais @var{x_1}, ..., @var{x_n} em @var{L_1}, ..., @var{L_n}, respectivamente.
@code{some} pode ou não avaliar 
@var{f} para algumas combinações @var{x_1}, ..., @var{x_n}.
@code{some} avalia listas na ordem do índice de incremento.

Dado um conjunto vazio @code{@{@}} ou uma lista vazia @code{[]} como argumentos,
@code{some} retorna @code{false}.

Quando o sinalizador global @code{maperror} for @code{true}, todas as listas
@var{L_1}, ..., @var{L_n} devem ter obrigatóriamente comprimentos iguais.
Quando @code{maperror} for @code{false}, argumentos do tipo lista são
efectivamente truncados para o comprimento da menor lista. 

Retorna o valor de um predicado @var{f} o qual avalia (por meio de @code{is})
para alguma coisa outra que não @code{true} ou @code{false}
e são governados pelo sinalizador global @code{prederror}.
Quando @code{prederror} for @code{true},
tais valores são tratados como @code{false}.
Quando @code{prederror} for @code{false},
tais valores são tratados como @code{unknown} (desconhecidos).

Exemplos:

@code{some} aplicado a um conjunto simples.
O predicado é uma função de um argumento.

@c ===beg===
@c some (integerp, {1, 2, 3, 4, 5, 6});
@c some (atom, {1, 2, sin(3), 4, 5 + y, 6});
@c ===end===
@example
(%i1) some (integerp, @{1, 2, 3, 4, 5, 6@});
(%o1)                         true
(%i2) some (atom, @{1, 2, sin(3), 4, 5 + y, 6@});
(%o2)                         true
@end example

@code{some} aplicada a duas listas.
O predicado é uma função de dois argumentos.

@c ===beg===
@c some ("=", [a, b, c], [a, b, c]);
@c some ("#", [a, b, c], [a, b, c]);
@c ===end===
@example
(%i1) some ("=", [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) some ("#", [a, b, c], [a, b, c]);
(%o2)                         false
@end example

Retorna o valor do predicado @var{f} o qual avalia
para alguma coisa que não @code{true} ou @code{false}
e são governados através do sinalizador global @code{prederror}.

@c ===beg===
@c prederror : false;
@c map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z + 1]);
@c prederror : true;
@c some ("<", [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z + 1]);
@c ===end===
@example
(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
(%o4)                         true
(%i5) prederror : true;
(%o5)                         true
(%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
(%o6)                         false
(%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
(%o7)                         true
@end example
@end deffn

@anchor{stirling1}
@deffn {Função} stirling1 (@var{n}, @var{m})

Representa o número de Stirling de primeiro tipo.

Quando @var{n} e @var{m} forem não negativos 
inteiros, a magnitude de @code{stirling1 (@var{n}, @var{m})} é o número de 
permutações de um conjunto com @var{n} elementos que possui @var{m} ciclos.
Para detalhes, veja Graham, Knuth e Patashnik @i{Concrete Mathematics}.
Maxima utiliza uma relação recursiva para definir @code{stirling1 (@var{n}, @var{m})} para
@var{m} menor que 0; @code{stirling1} não é definida para @var{n} menor que 0 e para argumentos
não inteiros.

@code{stirling1} é uma função de simplificação.
Maxima conhece as seguintes identidades:

@c COPIED VERBATIM FROM SRC/NSET.LISP
@enumerate
@item
@math{stirling1(0, n) = kron_delta(0, n)} (Ref. [1])
@item
@math{stirling1(n, n) = 1} (Ref. [1])
@item
@math{stirling1(n, n - 1) = binomial(n, 2)} (Ref. [1])
@item
@math{stirling1(n + 1, 0) = 0} (Ref. [1])
@item
@math{stirling1(n + 1, 1) = n!} (Ref. [1])
@item
@math{stirling1(n + 1, 2) = 2^n  - 1} (Ref. [1])
@end enumerate

Essas identidades são aplicadas quando os argumentos forem inteiros literais
ou símbolos declarados como inteiros, e o primeiro argumento for não negativo.
@code{stirling1} não simplififca para argumentos não inteiros.

Referências:

[1] Donald Knuth, @i{The Art of Computer Programming,}
terceira edição, Volume 1, Seção 1.2.6, Equações 48, 49, e 50.

Exemplos:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
@end example

@code{stirling1} não simplifica para argumentos não inteiros.

@c ===beg===
@c stirling1 (sqrt(2), sqrt(2));
@c ===end===
@example
(%i1) stirling1 (sqrt(2), sqrt(2));
(%o1)              stirling1(sqrt(2), sqrt(2))
@end example

Maxima aplica identidades a @code{stirling1}.

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n + 1, n);
@c stirling1 (n + 1, 1);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n + 1, n);
                            n (n + 1)
(%o3)                       ---------
                                2
(%i4) stirling1 (n + 1, 1);
(%o4)                          n!
@end example
@end deffn

@anchor{stirling2}
@deffn {Função} stirling2 (@var{n}, @var{m})

Representa o número de Stirling de segundo tipo.

Quando @var{n} e @var{m} forem inteiros
não negativos, @code{stirling2 (@var{n}, @var{m})} é o número de maneiras através dos quais um conjunto com
cardinalidade @var{n} pode ser particionado em @var{m} subconjuntos disjuntos.
Maxima utiliza uma relação recursiva para definir @code{stirling2 (@var{n}, @var{m})} para
@var{m} menor que 0; @code{stirling2} é indefinida para @var{n} menor que 0 e para argumentos
não inteiros.

@code{stirling2} é uma função de simplificação.
Maxima conhece as seguintes identidades.

@c COPIED VERBATIM FROM SRC/NSET.LISP
@enumerate
@item
@math{stirling2(0, n) = kron_delta(0, n)} (Ref. [1])
@item
@math{stirling2(n, n) = 1} (Ref. [1])
@item
@math{stirling2(n, n - 1) = binomial(n, 2)} (Ref. [1])
@item
@math{stirling2(n + 1, 1) = 1} (Ref. [1])
@item
@math{stirling2(n + 1, 2) = 2^n  - 1} (Ref. [1])
@item
@math{stirling2(n, 0) = kron_delta(n, 0)} (Ref. [2])
@item
@math{stirling2(n, m) = 0} when @math{m > n} (Ref. [2])
@item
@math{stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) / m!}
onde @math{m} e @math{n} são inteiros, e @math{n} é não negativo. (Ref. [3])
@end enumerate

Essas identidades são aplicadas quando os argumentos forem inteiros literais
ou símbolos declarados como inteiros, e o primeiro argumento for não negativo.
@code{stirling2} não simplifica para argumentos não inteiros.

Referências:

[1] Donald Knuth. @i{The Art of Computer Programming},
terceira edição, Volume 1, Seção 1.2.6, Equações 48, 49, e 50.

[2] Graham, Knuth, e Patashnik. @i{Concrete Mathematics}, Tabela 264.

[3] Abramowitz e Stegun. @i{Handbook of Mathematical Functions}, Seção 24.1.4.

Exemplos:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
@end example

@code{stirling2} não simplifica para argumentos não inteiros.

@c ===beg===
@c stirling2 (%pi, %pi);
@c ===end===
@example
(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
@end example

Maxima aplica identidades a @code{stirling2}.

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n + 9, n + 8);
@c stirling2 (n + 1, 2);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n + 9, n + 8);
                         (n + 8) (n + 9)
(%o3)                    ---------------
                                2
(%i4) stirling2 (n + 1, 2);
                              n
(%o4)                        2  - 1
@end example
@end deffn

@anchor{subset}
@deffn {Função} subset (@var{a}, @var{f})

Retorna o subconjuntode um conjunto @var{a} que satisfaz o predicado @var{f}. 

@code{subset} returns um conjunto which comprises the elements of @var{a}
for which @var{f} returns anything other than @code{false}.
@code{subset} does not apply @code{is} to the return value of @var{f}.

@code{subset} reclama se @var{a} não for um conjunto literal.

See also @code{partition_set}.

Exemplos:

@c ===beg===
@c subset ({1, 2, x, x + y, z, x + y + z}, atom);
@c subset ({1, 2, 7, 8, 9, 14}, evenp);
@c ===end===
@example
(%i1) subset (@{1, 2, x, x + y, z, x + y + z@}, atom);
(%o1)                     @{1, 2, x, z@}
(%i2) subset (@{1, 2, 7, 8, 9, 14@}, evenp);
(%o2)                      @{2, 8, 14@}
@end example

@end deffn

@anchor{subsetp}
@deffn {Função} subsetp (@var{a}, @var{b})

Retorna @code{true} se e somente se o conjunto @var{a} for um subconjunto de @var{b}.

@code{subsetp} reclama se ou @var{a} ou @var{b} não forem um conjunto literal.

Exemplos:

@c ===beg===
@c subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
@c subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
@c ===end===
@example
(%i1) subsetp (@{1, 2, 3@}, @{a, 1, b, 2, c, 3@});
(%o1)                         true
(%i2) subsetp (@{a, 1, b, 2, c, 3@}, @{1, 2, 3@});
(%o2)                         false
@end example

@end deffn

@anchor{symmdifference}
@deffn {Função} symmdifference (@var{a_1}, ..., @var{a_n})

Retorna a diferença simétrica, isto é,
o conjunto dos elemetnos que ocorrem em exactamente um conjunto @var{a_k}.

Given two arguments, @code{symmdifference(@var{a}, @var{b})} is
the same as @code{union(setdifference(@var{a}, @var{b}), setdifference(@var{b}, @var{a}))}.

@code{symmdifference} reclama se any argument não for um conjunto literal.

Exemplos:

@c ===beg===
@c S_1 : {a, b, c};
@c S_2 : {1, b, c};
@c S_3 : {a, b, z};
@c symmdifference ();
@c symmdifference (S_1);
@c symmdifference (S_1, S_2);
@c symmdifference (S_1, S_2, S_3);
@c symmdifference ({}, S_1, S_2, S_3);
@c ===end===
@example
(%i1) S_1 : @{a, b, c@};
(%o1)                       @{a, b, c@}
(%i2) S_2 : @{1, b, c@};
(%o2)                       @{1, b, c@}
(%i3) S_3 : @{a, b, z@};
(%o3)                       @{a, b, z@}
(%i4) symmdifference ();
(%o4)                          @{@}
(%i5) symmdifference (S_1);
(%o5)                       @{a, b, c@}
(%i6) symmdifference (S_1, S_2);
(%o6)                        @{1, a@}
(%i7) symmdifference (S_1, S_2, S_3);
(%o7)                        @{1, z@}
(%i8) symmdifference (@{@}, S_1, S_2, S_3);
(%o8)                        @{1, z@}
@end example

@end deffn

@c TREE_REDUCE ACCEPTS A SET OR LIST AS AN ARGUMENT, BUT RREDUCE AND LREDUCE WANT ONLY LISTS; STRANGE
@anchor{tree_reduce}
@deffn {Função} tree_reduce (@var{F}, @var{s})
@deffnx {Função} tree_reduce (@var{F}, @var{s}, @var{s_0})

Extende a função binária @var{F} a uma função enária através de composição,
onde @var{s} é um conjunto ou uma lista.

@code{tree_reduce} é equivalente ao seguinte:
Aplicar @var{F} a sucessivos pares de elementos
para formar uma nova lista @code{[@var{F}(@var{s_1}, @var{s_2}), @var{F}(@var{s_3}, @var{s_4}), ...]},
mantendo o elemento final inalterado caso haja um número ímpar de elementos.
Repetindo então o processo até que a lista esteja reduzida a um elemento simples, o qual é o valor de retorno da função.

Quando o argumento opcional @var{s_0} estiver presente,
o resultado é equivalente a @code{tree_reduce(@var{F}, cons(@var{s_0}, @var{s})}.

Para adições em ponto flutuante,
@code{tree_reduce} pode retornar uma soma que possui um menor ero de arredondamento
que @code{rreduce} ou @code{lreduce}.

Os elementos da lista @var{s} e os resultados parciais podem ser arranjados em uma árvore binária de profundidade mínima,
daí o nome "tree_reduce".

Exemplos:

@code{tree_reduce} aplicada a uma lista com um número par de elementos.

@c ===beg===
@c tree_reduce (f, [a, b, c, d]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
@end example

@code{tree_reduce} aplicada a uma lista com um número ímpar de elementos.

@c ===beg===
@c tree_reduce (f, [a, b, c, d, e]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
@end example

@end deffn

@anchor{union}
@deffn {Função} union (@var{a_1}, ..., @var{a_n})
Retorna a união dos conjuntos de @var{a_1} a @var{a_n}. 

@code{union()} (sem argumentos) retorna o conjunto vazio.

@code{union} reclama se qualquer argumento não for um conjunto literal.

Exemplos:

@c ===beg===
@c S_1 : {a, b, c + d, %e};
@c S_2 : {%pi, %i, %e, c + d};
@c S_3 : {17, 29, 1729, %pi, %i};
@c union ();
@c union (S_1);
@c union (S_1, S_2);
@c union (S_1, S_2, S_3);
@c union ({}, S_1, S_2, S_3);
@c ===end===
@example
(%i1) S_1 : @{a, b, c + d, %e@};
(%o1)                   @{%e, a, b, d + c@}
(%i2) S_2 : @{%pi, %i, %e, c + d@};
(%o2)                 @{%e, %i, %pi, d + c@}
(%i3) S_3 : @{17, 29, 1729, %pi, %i@};
(%o3)                @{17, 29, 1729, %i, %pi@}
(%i4) union ();
(%o4)                          @{@}
(%i5) union (S_1);
(%o5)                   @{%e, a, b, d + c@}
(%i6) union (S_1, S_2);
(%o6)              @{%e, %i, %pi, a, b, d + c@}
(%i7) union (S_1, S_2, S_3);
(%o7)       @{17, 29, 1729, %e, %i, %pi, a, b, d + c@}
(%i8) union (@{@}, S_1, S_2, S_3);
(%o8)       @{17, 29, 1729, %e, %i, %pi, a, b, d + c@}
@end example

@end deffn

@c XREDUCE ACCEPTS A SET OR LIST AS AN ARGUMENT, BUT RREDUCE AND LREDUCE WANT ONLY LISTS; STRANGE
@anchor{xreduce}
@deffn {Função} xreduce (@var{F}, @var{s})
@deffnx {Função} xreduce (@var{F}, @var{s}, @var{s_0})

Extendendo a função @var{F} para uma função enária por composição,
ou, se @var{F} já for enária, aplica-se @var{F} a @var{s}.
Quando @var{F} não for enária, @code{xreduce} funciona da mesma forma que @code{lreduce}.
O argumento @var{s} é uma lista.

Funções sabidamente enárias inclui
adição @code{+}, multiplicação @code{*}, @code{and}, @code{or}, @code{max},
@code{min}, e @code{append}.
Funções podem também serem declaradas enárias por meio de @code{declare(@var{F}, nary)}.
Para essas funções,
é esperado que @code{xreduce} seja mais rápida que ou @code{rreduce} ou @code{lreduce}.

Quando o argumento opcional @var{s_0} estiver presente,
o resultado é equivalente a @code{xreduce(@var{s}, cons(@var{s_0}, @var{s}))}.

@c NOT SURE WHAT IS THE RELEVANCE OF THE FOLLOWING COMMENT
@c MAXIMA IS NEVER SO CAREFUL ABOUT FLOATING POINT ASSOCIATIVITY SO FAR AS I KNOW
Adições em ponto flutuante não são exactamente associativas; quando a associatividade ocorrer,
@code{xreduce} aplica a adição enária do Maxima quando @var{s} contiver números em ponto flutuante.

Exemplos:

@code{xreduce} aplicada a uma função sabidamente enária.
@code{F} é chamada uma vez, com todos os argumentos.

@c ===beg===
@c declare (F, nary);
@c F ([L]) := L;
@c xreduce (F, [a, b, c, d, e]);
@c ===end===
@example
(%i1) declare (F, nary);
(%o1)                         done
(%i2) F ([L]) := L;
(%o2)                      F([L]) := L
(%i3) xreduce (F, [a, b, c, d, e]);
(%o3)         [[[[[("[", simp), a], b], c], d], e]
@end example

@code{xreduce} aplicada a uma função não sabidamente enária.
@code{G} é chamada muitas vezes, com dois argumentos de cada vez.

@c ===beg===
@c G ([L]) := L;
@c xreduce (G, [a, b, c, d, e]);
@c lreduce (G, [a, b, c, d, e]);
@c ===end===
@example
(%i1) G ([L]) := L;
(%o1)                      G([L]) := L
(%i2) xreduce (G, [a, b, c, d, e]);
(%o2)         [[[[[("[", simp), a], b], c], d], e]
(%i3) lreduce (G, [a, b, c, d, e]);
(%o3)                 [[[[a, b], c], d], e]
@end example

@end deffn

