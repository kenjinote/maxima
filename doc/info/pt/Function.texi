@c /Function.texi/1.46/Fri Mar  2 00:44:37 2007/-ko/
@menu
* Introdução a Definição de Função::  
* Função::                    
* Macros::                      
* Definições para Definição de Função::  
@end menu

@node Introdução a Definição de Função, Função, Definição de Função, Definição de Função
@section Introdução a Definição de Função

@node Função, Macros, Introdução a Definição de Função, Definição de Função
@c NEEDS WORK, THIS TOPIC IS IMPORTANT
@c MENTION DYNAMIC SCOPE (VS LEXICAL SCOPE)
@section Função
@subsection Ordinary functions

Para definir uma função no Maxima usa-se o operador :=.
Por exemplo,

@example
f(x) := sin(x)
@end example

@noindent
define uma função @code{f}.
Funções an@^onimas podem também serem criadas usando @code{lambda}.
Por exemplo

@example
lambda ([i, j], ...)
@end example

@noindent
pode ser usada em lugar de @code{f}
onde

@example
f(i,j) := block ([], ...);
map (lambda ([i], i+1), l)
@end example

@noindent
retornará uma lista com 1 adicionado a cada termo.

Pode também definir uma função com um número
variável de argumentos, usando um argumento final que seja uma lista,
na qual serão inseridos todos os argumentos adicionais:

@example
(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
@end example

O lado direito na definição de uma
função é uma expressão. Assim, quando quiser que a
definição seja uma sequência de expressões, poderá
usar a forma
@example
f(x) := (expr1, expr2, ...., exprn);
@end example

e o valor de @var{exprn} é que é retornado pela função.

Se quiser introduzir um ponto de @code{retorno} em alguma expressão dentro da
função, deverá usar @code{block} e @code{return}.

@example
block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)
@end example

é em si mesma uma expressão, e então poderá ocupar o lugar do
lado direito de uma definição de função.  Aqui pode acontecer
que o retorno aconteça mais facilmente que no exemplo anterior a essa última expressão.

@c COPY THIS STUFF TO @defun block AS NEEDED
@c ESPECIALLY STUFF ABOUT LOCAL VARIABLES
O primeiro @code{[]} no bloco, pode conter uma lista de variáveis e
atribuições de variáveis, tais como @code{[a: 3, b, c:
[]]}, que farão com que as três variáveis @code{a},@code{b},e
@code{c} não se refiram a seus valores globais, mas ao contrário
tenham esses valores especiais enquanto o código estiver executando a
parte dentro do bloco @code{block}, ou dentro da funções
chamadas de dentro do bloco @code{block}.  Isso é chamado
associação @i{dynamic}, uma vez que as variáveis
permanecem do início do bloco pelo tempo que ele
existir. Quando regressar do bloco @code{block}, ou o descartar, os
valores antigos (quaisquer que sejam) das variáveis serão
restaurados.  É certamente uma boa idéia para proteger as suas
variáveis nesse caminho.  Note que as atribuições em
variáveis do bloco, são realizadas em paralelo.  Isso
significa, que se tivesse usado @code{c: a} acima, o valor de @code{c}
seria o valor que @code{a} tinha antes do bloco, antes de ter obtido o
seu novo valor atribuído no bloco.  Dessa forma fazendo alguma
coisa como

@example
block ([a: a], expr1, ...  a: a+3, ..., exprn)
@end example

protegerá o valor externo de @code{a} de ser alterado, mas impedirá
aceder ao valor antigo. Assim, o lado direito de
atribuições, é avaliado no contexto inserido, antes
que qualquer avaliação ocorra.  Usando apenas
@code{block ([x], ...} faremos com que o @code{x} tenho como valor a si
próprio; esse é o mesmo valor que teria no início de
uma sessão do @b{Maxima}.

Os actuais argumentos para uma função são tratados exactamente da mesma que
as variáveis em um bloco.  Dessa forma em

@example
f(x) := (expr1, ..., exprn);
@end example

e

@example
f(1);
@end example

teremos um contexto similar para avaliação de expressões
como se tivéssemos concluído

@example
block ([x: 1], expr1, ..., exprn)
@end example

Dentro de funções, quando o lado direito de uma definição,
pode ser calculado em tempo de execução, isso é úti para usar @code{define} e
possivelmente @code{buildq}.  

@subsection Função de Array

Uma função de Array armazena o valor da função na primeira vez que ela for chamada com um argumento dado,
e retorna o valor armazenado, sem recalcular esse valor, quando o mesmo argumento for fornecido.
De modo que uma função é muitas vezes chamada uma @i{função de memorização}.

Nomes de funções de Array são anexados ao final da lista global @code{arrays}
(não na lista global @code{functions}).
O comando @code{arrayinfo} retorna a lista de argumentos para os quais exite valores armazenados,
e @code{listarray} retorna os valores armazenados. 
Os comandos @code{dispfun} e @code{fundef} retornam a definição da função de array.

O comando @code{arraymake} contrói uma chamada de função de array,
análogamente a @code{funmake} para funções comuns.
O comando @code{arrayapply} aplica uma função de array a seus argmentos,
análogamente a @code{apply} para funções comuns.
Não existe nada exactamente análogo a @code{map} para funções de array,
embora @code{map(lambda([@var{x}], @var{a}[@var{x}]), @var{L})} ou
@code{makelist(@var{a}[@var{x}], @var{x}, @var{L})}, onde @var{L} é uma lista,
não estejam tão longe disso.

O comando @code{remarray} remove uma definição de função de array (incluindo qualquer valor armazenado pela função removida),
análogo a @code{remfunction} para funções comuns.

o comando @code{kill(@var{a}[@var{x}])} remove o valor da função de array @var{a}
armazenado para o argumento @var{x};
a próxima vez que @var{a} foor chamada com o argumento @var{x},
o valor da função é recomputado.
Todavia, não exite caminho para remover todos os valores armazenados de uma vez,
excepto para @code{kill(@var{a})} ou @code{remarray(@var{a})},
o qual remove também remove a definição da função de array.

@node Macros, Definições para Definição de Função, Função, Definição de Função
@section Macros

@deffn {Função} buildq (@var{L}, @var{expr})
Substitue variáveis nomeadas pela lista @var{L} dentro da expressão @var{expr},
paralelamente,
sem avaliar @var{expr}.
A expressão resultante é simplificada,
mas não avaliada,
após @code{buildq} realizar a substituição.

Os elementos de @var{L} são símbolos ou expressões de atribuição @code{@var{símbolo}: @var{valor}},
avaliadas paralelamente.
Isto é, a associação de uma variável sobre o lado direito de uma atribuição
é a associação daquela variável no contexto do qual @code{buildq} for chamada,
não a associação daquela variável na lista @var{L} de variáveis.
Se alguma variável em @var{L} não dada como uma atribuição explícita,
sua associação em @code{buildq} é a mesma que no contexto no qual @code{buildq} for chamada.

Então as variáveis nomeadas em @var{L} são substituidas em @var{expr} paralelamente.
Isto é, a substituição para cada variável é determinada antes que qualquer substituição seja feita,
então a substituição para uma variável não tem efeito sobre qualquer outra.

Se qualquer variável @var{x} aparecer como @code{splice (@var{x})} em @var{expr},
então @var{x} deve estar associada para uma lista,
e a lista recebe uma aplicação da função @code{splice} (é interpolada) na @var{expr} em lugar de substituída.

Quaisquer variáveis em @var{expr} não aparecendo em @var{L} são levados no resultado tal como foram escritos,
mesmo se elas tiverem associações no contexto do qual @code{buildq} tiver sido chamada.

Exemplos

@code{a} é explicitamente associada a @code{x},
enquanto @code{b} tem a mesma associação (nomeadamente 29) como no contexto chamado,
e @code{c} é levada do começo ao fim da forma como foi escrita.
A expressão resultante não é avaliada até a avaliação explícita ( com duplo apóstrofo - não com aspas - @code{''%}.

@c ===beg===
@c (a: 17, b: 29, c: 1729)$
@c buildq ([a: x, b], a + b + c);
@c ''%;
@c ===end===
@example
(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
@end example

@code{e} está associado a uma lista, a qual aparece também como tal nos argumentos de @code{foo},
e interpolada nos argumentos de @code{bar}.

@c ===beg===
@c buildq ([e: [a, b, c]], foo (x, e, y));
@c buildq ([e: [a, b, c]], bar (x, splice (e), y));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
@end example

O resultado é simplificado após substituição.
Se a simplificação for aplicada antes da substituição, esses dois resultados podem ser iguais.
@c ===beg===
@c buildq ([e: [a, b, c]], splice (e) + splice (e));
@c buildq ([e: [a, b, c]], 2 * splice (e));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
@end example

As variáveis em @var{L} são associadas em paralelo; se associadas sequêncialmente,
o primeiro resultado pode ser @code{foo (b, b)}.
Substituições são realizadas em paralelo;
compare o segundo resultado com o resultado de @code{subst},
que realiza substituições sequêncialmente.

@c ===beg===
@c buildq ([a: b, b: a], foo (a, b));
@c buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
@c subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
@c ===end===
@example
(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
@end example

Constrói uma lista de euqções com algumas variáveis ou expressões sobre o lado esquerdo
e seus valores sobre o lado direito.
@code{macroexpand} mostra a expressão retornada por @code{show_values}.

@c ===beg===
@c show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
@c (a: 17, b: 29, c: 1729)$
@c macroexpand (show_values (a, b, c - a - b));
@c show_values (a, b, c - a - b);
@c ===end===
@example
(%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
(%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)              [a = 17, b = 29, c = 1729]
@end example

@end deffn

@deffn {Função} macroexpand (@var{expr})
Retorna a expansão da macro de @var{expr} sem avaliar a expressão,
quando @code{expr} for uma chamada de função de macro.
De outra forma, @code{macroexpand} retorna @var{expr}.

Se a expansão de @var{expr} retorna outra chamada de função de macro,
aquela chamada de função de macro é também expandida.

@code{macroexpand} coloca apóstrofo em seus argumentos, isto é, não os avalia.
Todavia, se a expansão de uma chamada de função de macro tiver algum efeito,
esse efeito colateral é executado.

Veja também @code{::=}, @code{macros}, e @code{macroexpand1}.

Exemplos

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@end deffn

@deffn {Função} macroexpand1 (@var{expr})
Retorna a expansão de macro de @var{expr} sem avaliar a expressão,
quando @code{expr} for uma chamada de função de macro.
De outra forma, @code{macroexpand1} retorna @var{expr}.

@code{macroexpand1} não avalia seus argumentos.
Todavia, se a expansão de uma chamada de função de macro tiver algum efeito,
esse efeito colateral é executado.

Se a expansão de @var{expr} retornar outra chamada de função de macro,
aquela chamada de função de macro não é expandida.

Veja também @code{::=}, @code{macros}, e @code{macroexpand}.

Examples

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand1 (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@end deffn

@defvr {Global variable} macros
Default value: @code{[]}

@code{macros} é a lista de funções de macro definidas pelo utilizador.
O operador de definição de função de macro @code{::=} coloca uma nova função de macro nessa lista,
e @code{kill}, @code{remove}, e @code{remfunction} removem funções de macro da lista.

Veja também @code{infolists}.

@end defvr

@deffn {Função} splice (@var{a})
Une como se fosse um elo de ligação (interpola) a lista nomeada através do átomo @var{a} em uma expressão,
mas somente se @code{splice} aparecer dentro de @code{buildq};
de outra forma, @code{splice} é tratada como uma função indefinida.
Se aparecer dentro de @code{buildq} com @var{a} sozinho (sem @code{splice}),
@var{a} é substituido (não interpolado) como uma lista no resultado.
O argumento de @code{splice} pode somente ser um átomo;
não pode ser uma lista lateral ou uma expressão que retorna uma lista.

Tipicamente @code{splice} fornece os argumentos para uma função ou operador.
Para uma função @code{f}, a expressão @code{f (splice (@var{a}))} dentro de @code{buildq}
expande para @code{f (@var{a}[1], @var{a}[2], @var{a}[3], ...)}.
Para um operador @code{o}, a expressão @code{"o" (splice (@var{a})} dentro de @code{buildq}
expande para @code{"o" (@var{a}[1], @var{a}[2], @var{a}[3], ...)},
onde @code{o} pode ser qualquer tipo de operador (tipicamente um que toma múltiplos argumentos).
Note que o operador deve ser contido dentro de aspas duplas @code{"}.

Exemplos

@c ===beg===
@c buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
@c buildq ([x: [1, %pi]], "/" (splice (x)));
@c matchfix ("<>", "<>");
@c buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
@c ===end===
@example
(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix ("<>", "<>");
(%o3)                          <>
(%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
(%o4)                   <>1, %pi, z - y<>
@end example

@end deffn

@c end concepts Definição de Função
@node Definições para Definição de Função,  , Macros, Definição de Função
@section Definições para Definição de Função

@deffn {Função} apply (@var{F}, [@var{x_1}, ..., @var{x_n}])
Constrói e avalia uma expressãp @code{@var{F}(@var{arg_1}, ..., @var{arg_n})}.

@code{apply} não tenta distinguir funções de array de funções comuns;
quando @var{F} for o nome de uma função de array,
@code{apply} avalia @code{@var{F}(...)}
(isto é, uma chamada de função com parêntesis em lugar de colchêtes).
@code{arrayapply} avalia uma chamada de função com colchêtes nesse caso.

Exemplos:

@code{apply} avalia seus argumentos.
Nesse exemplo, @code{min} é aplicado a @code{L}.

@c ===beg===
@c L : [1, 5, -10.2, 4, 3];
@c apply (min, L);
@c ===end===
@example
(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
@end example

@code{apply} avalia argumentos, mesmo se a função @var{F} disser que os argumentos não devem ser avaliados.

@c ===beg===
@c F (x) := x / 1729;
@c fname : F;
@c dispfun (F);
@c dispfun (fname);
@c apply (dispfun, [fname]);
@c ===end===
@example
(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
@end example

@code{apply} avalia o nome de função @var{F}.
Apóstrofo @code{'} evita avaliação.
@code{demoivre} é o nome de uma variável global e também de uma função.

@c ===beg===
@c demoivre;
@c demoivre (exp (%i * x));
@c apply (demoivre, [exp (%i * x)]);
@c apply ('demoivre, [exp (%i * x)]);
@c ===end===
@example
(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
@end example

@end deffn


@deffn {Função} block ([@var{v_1}, ..., @var{v_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Função} block (@var{expr_1}, ..., @var{expr_n})
@code{block} avalia @var{expr_1}, ..., @var{expr_n} em sequência
e retorna o valor da última expressão avaliada.
A sequência pode ser modificada pelas funções @code{go}, @code{throw}, e @code{return}.
A última expressão é @var{expr_n} a menos que @code{return} ou uma expressão contendo @code{throw}
seja avaliada.
Algumas variáveis @var{v_1}, ..., @var{v_m} podem ser declaradas locais para o bloco;
essas são distinguidas das variáveis globais dos mesmos nomes.
Se variáveis não forem declaradas locais então a lista pode ser omitida.
Dentro do bloco,
qualquer variável que não @var{v_1}, ..., @var{v_m} é uma variável global.

@code{block} salva os valores correntes das variáveis @var{v_1}, ..., @var{v_m} (quaisquer valores)
na hora da entrada para o bloco,
então libera as variáveis dessa forma eles avaliam para si mesmos.
As variáveis locais podem ser associadas a valores arbitrários dentro do bloco mas quando o
bloco é encerrado o valores salvos são restaurados,
e os valores atribuídos dentro do bloco são perdidos.

@code{block} pode aparecer dentro de outro @code{block}.
Variáveis locais são estabelecidas cada vez que um novo @code{block} é avaliado.
Variáveis locais parecem ser globais para quaisquer blocos fechados.
Se uma variável é não local em um bloco,
seu valor é o valor mais recentemente atribuído por um bloco fechado, quaisquer que sejam,
de outra forma, seu valor é o valor da variável no ambiente global.
Essa política pode coincidir com o entendimento usual de "escopo dinâmico".

Se isso for desejado para salvar e restaurar outras propriedades locais
ao lado de @code{value}, por exemplo @code{array} (excepto para arrays completos),
@code{function}, @code{dependencies}, @code{atvalue}, @code{matchdeclare}, @code{atomgrad}, @code{constant}, e
@code{nonscalar} então a função @code{local} pode ser usada dentro do bloco
com argumentos sendo o nome das variáveis.

O valor do bloco é o valor da última declaração ou o
valor do argumento para a função @code{return} que pode ser usada para sair
explicitamente do bloco.  A função @code{go} pode ser usada para transferir o
controle para a declaração do bloco que é identificada com o argumento
para @code{go}.  Para identificar uma declaração, coloca-se antes dela um argumento at@^omico como
outra declaração no bloco.  Por exemplo:
@code{block ([x], x:1, loop, x: x+1, ..., go(loop), ...)}.  O argumento para @code{go} deve
ser o nome de um identificador que aparece dentro do bloco.  Não se deve usar @code{go} para
transferir para um identificador em um outro bloco a não ser esse que contém o @code{go}.

Blocos tipicamente aparecem do lado direito de uma definição de função
mas podem ser usados em outros lugares também.

@end deffn

@c REPHRASE, NEEDS EXAMPLE
@deffn {Função} break (@var{expr_1}, ..., @var{expr_n})
Avalia e imprime @var{expr_1}, ..., @var{expr_n} e então
causa uma parada do Maxima nesse ponto e o utilizador pode examinar e alterar
seu ambiente.  Nessa situação digite @code{exit;} para que o cálculo seja retomado.

@end deffn

@c FOR SOME REASON throw IS IN SOME OTHER FILE.  MOVE throw INTO THIS FILE.
@c NEEDS CLARIFICATION
@deffn {Função} catch (@var{expr_1}, ..., @var{expr_n})
Avalia @var{expr_1}, ..., @var{expr_n} uma por uma; se qualquer avaliação
levar a uma avaliação de uma expressão da
forma @code{throw (arg)}, então o valor de @code{catch} é o valor de
@code{throw (arg)}, e expressões adicionais não são avaliadas.
Esse "retorno não local" atravessa assim qualquer profundidade de
aninhar para o mais próximo contendo @code{catch}.
Se não existe nenhum @code{catch} contendo um @code{throw}, uma mensagem de erro é impressa.

Se a avaliação de argumentos não leva para a avaliação de qualquer @code{throw}
então o valor de @code{catch} é o valor de @var{expr_n}.

@example
(%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
@end example

@c REWORD THIS PART.
A função @code{g} retorna uma lista de @code{f} de cada elemento de @code{l} se @code{l}
consiste somente de números não negativos; de outra forma, @code{g} "captura" o
primeiro elemento negativo de @code{l} e "arremessa-o".

@end deffn

@deffn {Função} compfile (@var{nomeficheiro}, @var{f_1}, ..., @var{f_n})
@deffnx {Função} compfile (@var{nomeficheiro}, funções)
@deffnx {Função} compfile (@var{nomeficheiro}, all)

Traduz fuções Maxima para Lisp 
e escreve o código traduzido no ficheiro @var{nomeficheiro}.

@code{compfile(@var{nomeficheiro}, @var{f_1}, ..., @var{f_n})} traduz as
funções especificadas.
@code{compfile(@var{nomeficheiro}, functions)} e @code{compfile(@var{nomeficheiro}, all)}
traduz todas as funções definidas pelo utilizador.

As traduções Lisp não são avaliadas, nem é o ficheiro de saída processado pelo compilador Lisp.
@c SO LET'S CONSIDER GIVING THIS FUNCTION A MORE ACCURATE NAME.
@code{translate} cria e avalia traduções Lisp.
@code{compile_file} traduz Maxima para Lisp, e então executa o compilador Lisp.  

Veja também @code{translate}, @code{translate_file}, e @code{compile_file}.

@end deffn

@c THIS VARIABLE IS OBSOLETE: ASSIGNING compgrind: true CAUSES compfile
@c TO EVENTUALLY CALL AN OBSOLETE FUNCTION SPRIN1.
@c RECOMMENDATION IS TO CUT THIS ITEM, AND CUT $compgrind FROM src/transs.lisp
@c @defvar compgrind
@c Default value: @code{false}
@c 
@c When @code{compgrind} é @code{true}, function definitions printed by
@c @code{compfile} are pretty-printed.
@c 
@c @end defvar

@deffn {Função} compile (@var{f_1}, ..., @var{f_n})
@deffnx {Função} compile (funções)
@deffnx {Função} compile (all)
Traduz funções Maxima @var{f_1}, ..., @var{f_n} para Lisp, avalia a tradução Lisp,
e chama a função Lisp @code{COMPILE} sobre cada função traduzida.
@code{compile} retorna uma lista de nomes de funções compiladas.

@code{compile (all)} ou @code{compile (funções)} compila todas as funções definidas pelo utilizador.

@code{compile} não avalia seus argumentos; 
o operador apóstrofo-apóstrofo @code{'@w{}'} faz com que ocorra avaliação sobrepondo-se ao apóstrofo.

@end deffn

@deffn {Função} define (@var{f}(@var{x_1}, ..., @var{x_n}), @var{expr})
@deffnx {Função} define (@var{f}[@var{x_1}, ..., @var{x_n}], @var{expr})
@deffnx {Função} define (funmake (@var{f}, [@var{x_1}, ..., @var{x_n}]), @var{expr})
@deffnx {Função} define (arraymake (@var{f}, [@var{x_1}, ..., @var{x_n}]), @var{expr})
@deffnx {Função} define (ev (@var{expr_1}), @var{expr_2})

Define uma função chamada @var{f} com argumentos @var{x_1}, ..., @var{x_n} e corpo da função @var{expr}.
@code{define} sempre avalia seu segundo argumento (a menos que explícitamente receba um apostrofo de forma a evitar a avaliação).
A função então definida pode ser uma função comum do Maxima (com argumentos contidos entre parêtesis)
ou uma função de array (com argumentos contidos entre colchêtes).

Quando o último ou único argumento da função @var{x_n} for uma lista de um elemento,
a função definida por @code{define} aceita um número variável de argumentos.
Os argumentos actuais são atribuídos um a um a argumentos formais @var{x_1}, ..., @var{x_(n - 1)},
e quaisquer argumentos adicionais actuais, se estiverem presentes, são atribuídos a @var{x_n} como uma lista.

Quando o primeiro argumento de @code{define} for uma expressão da forma
@code{@var{f}(@var{x_1}, ..., @var{x_n})} or @code{@var{f}[@var{x_1}, ..., @var{x_n}]},
os argumentos são avaliados mas @var{f} não é avaliada,
mesmo se já existe anteriormente uma função ou variável com aquele nome.
Quando o primeiro argumento for uma expressão com operador @code{funmake}, @code{arraymake}, ou @code{ev},
o primeiro argumento será avaliado;
isso permite para o nome da função seja calculado, também como o corpo.

Todas as definições de função aparecem no mesmo nível de escopo e visibilidade;
definindo uma função @code{f} dentro de outra função @code{g}
não limita o escopo de @code{f} a @code{g}.

Se algum argumento formal @var{x_k} for um símbolo com apóstrofo (após ter sido feita uma avaliação),
a função definida por @code{define} não avalia o correspondente actual argumento.
de outra forma todos os argumentos actuais são avaliados.

Veja também @code{:=} and @code{::=}.

Exemplos:

@code{define} sempre avalia seu segundo argumento (a menos que explícitamente receba um apostrofo de forma a evitar a avaliação).

@c ===beg===
@c expr : cos(y) - sin(x);
@c define (F1 (x, y), expr);
@c F1 (a, b);
@c F2 (x, y) := expr;
@c F2 (a, b);
@c ===end===
@example
(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
@end example

A função definida por @code{define} pode ser uma função comum do Maxima ou uma função de array.

@c ===beg===
@c define (G1 (x, y), x.y - y.x);
@c define (G2 [x, y], x.y - y.x);
@c ===end===
@example
(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
@end example

Quando o último ou único argumento da função @var{x_n} for uma lista de um único elemento,
a função definida por @code{define} aceita um número variável de argumentos.

@c ===beg===
@c define (H ([L]), '(apply ("+", L)));
@c H (a, b, c);
@c ===end===
@example
(%i1) define (H ([L]), '(apply ("+", L)));
(%o1)                H([L]) := apply("+", L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
@end example

When the first argument is an expression with operator @code{funmake}, @code{arraymake}, or @code{ev},
the first argument is evaluated.

@c ===beg===
@c [F : I, u : x];
@c funmake (F, [u]);
@c define (funmake (F, [u]), cos(u) + 1);
@c define (arraymake (F, [u]), cos(u) + 1);
@c define (foo (x, y), bar (y, x));
@c define (ev (foo (x, y)), sin(x) - cos(y));
@c ===end===
@example
(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
@end example

@end deffn

@c SEE NOTE BELOW ABOUT THE DOCUMENTATION STRING
@c @deffn {Função} define_variable (@var{name}, @var{default_value}, @var{mode}, @var{documentation})
@deffn {Função} define_variable (@var{name}, @var{default_value}, @var{mode})

Introduz uma variável global dentro do ambiente Maxima.
@c IMPORT OF FOLLOWING STATEMENT UNCLEAR: IN WHAT WAY IS define_variable MORE USEFUL IN TRANSLATED CODE ??
@code{define_variable} é útil em pacotes escritos pelo utilizador, que são muitas vezes traduzidos ou compilados.

@code{define_variable} realiza os seguintes passos:

@enumerate
@item
@code{mode_declare (@var{name}, @var{mode})} declara o modo de @var{name} para o tradutor.
Veja @code{mode_declare} para uma lista dos modos possíveis.

@item
Se a variável é não associada, @var{default_value} é atribuído para @var{name}.

@item
@code{declare (@var{name}, special)} declara essa variável especial.
@c CLARIFY THE MEANING OF SPECIAL FOR THE BENEFIT OF READERS OTHER THAN LISP PROGRAMMERS

@item
Associa @var{name} com uma função de teste
para garantir que a @var{name} seja somente atribuído valores do modo declarado.
@end enumerate


@c FOLLOWING STATEMENT APPEARS TO BE OUT OF DATE.
@c EXAMINING DEFMSPEC $DEFINE_VARIABLE AND DEF%TR $DEFINE_VARIABLE IN src/trmode.lisp,
@c IT APPEARS THAT THE 4TH ARGUMENT IS NEVER REFERRED TO.
@c EXECUTING translate_file ON A MAXIMA BATCH FILE WHICH CONTAINS
@c define_variable (foo, 2222, integer, "THIS IS FOO");
@c DOES NOT PUT "THIS IS FOO" INTO THE LISP FILE NOR THE UNLISP FILE.
@c The optional 4th argumento é a documentation string.  When
@c @code{translate_file} é used on a package which includes documentation
@c strings, a second file é output in addition to the Lisp file which
@c will contain the documentation strings, formatted suitably for use in
@c manuals, usage files, or (for instance) @code{describe}.

A propriedade @code{value_check} pode ser atribuída a qualquer variável que tenha sido definida
via @code{define_variable} com um outro modo que não @code{any}.
A propriedade @code{value_check} é uma expressão lambda ou o nome de uma função de uma variável,
que é chamada quando uma tentativa é feita para atribuir um valor a uma variável.
O argumento da  função @code{value_check} é o valor que será atribuído.

@code{define_variable} avalia @code{default_value}, e não avalia @code{name} e @code{mode}.
@code{define_variable} retorna o valor corrente de @code{name},
que é @code{default_value} se @code{name} não tiver sido associada antes,
e de outra forma isso é o valor prévio de @code{name}.

Exemplos:

@code{foo} é uma variável Booleana, com o valor inicial @code{true}.
@c GENERATED FROM:
@c define_variable (foo, true, boolean);
@c foo;
@c foo: false;
@c foo: %pi;
@c foo;

@example
(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
@end example

@code{bar} é uma variável inteira, que deve ser um número primo.
@c GENERATED FROM:
@c define_variable (bar, 2, integer);
@c qput (bar, prime_test, value_check);
@c prime_test (y) := if not primep(y) then error (y, "is not prime.");
@c bar: 1439;
@c bar: 1440;
@c bar;

@example
(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, "is not prime.")
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 é not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
@end example

@code{baz_quux} é uma variável que não pode receber a atribuição de um valor.
O modo @code{any_check} é como @code{any}, 
mas @code{any_check} habilita o mecanismo @code{value_check}, e @code{any} não habilita.
@c GENERATED FROM:
@c define_variable (baz_quux, 'baz_quux, any_check);
@c F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
@c qput (baz_quux, ''F, value_check);
@c baz_quux: 'baz_quux;
@c baz_quux: sqrt(2);
@c baz_quux;

@example
(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
@end example

@end deffn

@deffn {Função} dispfun (@var{f_1}, ..., @var{f_n})
@deffnx {Função} dispfun (all)
Mostra a definição de funções definidas pelo utilizador @var{f_1}, ..., @var{f_n}.
Cada argumento pode ser o nome de uma macro (definida com @code{::=}),
uma função comum (definida com @code{:=} ou @code{define}),
uma função array (definida com @code{:=} ou com @code{define},
mas contendo argumentos entre colchêtes @code{[ ]}),
uma função subscrita, (definida com @code{:=} ou @code{define},
mas contendo alguns argumentos entre colchêtes e outros entre parêntesis @code{( )})
uma da família de funções subscritas seleccionadas por um valor subscrito particular,
ou uma função subscrita definida com uma constante subscrita.

@code{dispfun (all)} mostra todas as funções definidas pelo utilizador como
dadas pelas @code{functions}, @code{arrays}, e listas de @code{macros},
omitindo funções subscritas definidas com constantes subscritas.

@code{dispfun} cria um Rótulo de expressão intermédia
(@code{%t1}, @code{%t2}, etc.)
para cada função mostrada, e atribui a definição de função para o rótulo.
Em contraste, @code{fundef} retorna a definição de função.

@code{dispfun} não avalia seus argumentos; 
O operador apóstrofo-apóstrofo @code{'@w{}'} faz com que ocorra avaliação.

@code{dispfun} retorna a lista de rótulos de expressões intermédias correspondendo às funções mostradas.

Exemplos:


@c ===beg===
@c m(x, y) ::= x^(-y);
@c f(x, y) :=  x^(-y);
@c g[x, y] :=  x^(-y);
@c h[x](y) :=  x^(-y);
@c i[8](y) :=  8^(-y);
@c dispfun (m, f, g, h, h[5], h[10], i[8]);
@c ''%;
@c ===end===
@example
(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10

@end example

@end deffn

@defvr {Variável de sistema} functions
Valor por omissão: @code{[]}

@code{functions} é uma lista de todas as funções comuns do Maxima
na sessão corrente.
Uma função comum é uma função construída através de
@code{define} ou de @code{:=} e chamada com parêntesis @code{()}.
Uma função pode ser definida pela linha de comando do Maxima de forma interativa com o utilizador
ou em um ficheiro Maxima chamado por @code{load} ou @code{batch}.

Funções de array (chamadas com colchêtes, e.g., @code{F[x]})
e funções com subscritos (chamadas com colchêtes e parêntesis, e.g., @code{F[x](y)})
são lsitados através da variável global @code{arrays}, e não por meio de @code{functions}.

Funções Lisp não são mantidas em nenhuma lista.

Exemplos:

@c ===beg===
@c F_1 (x) := x - 100;
@c F_2 (x, y) := x / y;
@c define (F_3 (x), sqrt (x));
@c G_1 [x] := x - 100;
@c G_2 [x, y] := x / y;
@c define (G_3 [x], sqrt (x));
@c H_1 [x] (y) := x^y;
@c functions;
@c arrays;
@c ===end===
@example
(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
@end example

@end defvr

@deffn {Função} fundef (@var{f})
Retorna a definição da função @var{f}.

@c PROBABLY THIS WOULD BE CLEARER AS A BULLET LIST
O argumento pode ser o nome de uma macro (definida com @code{::=}),
uma função comum (definida com @code{:=} ou @code{define}),
uma função array (definida com @code{:=} ou @code{define},
mas contendo argumentos entre colchêtes @code{[ ]}),
Uma função subscrita, (definida com @code{:=} ou @code{define},
mas contendo alguns argumentos entre colchêtes e parêntesis @code{( )})
uma da família de funções subscritas seleccionada por um valor particular subscrito,
ou uma função subscrita definida com uma constante subscrita.

@code{fundef} não avalia seu argumento;
o operador apóstrofo-apóstrofo @code{'@w{}'} faz com que ocorra avaliação.

@code{fundef (@var{f})} retorna a definição de @var{f}.
Em contraste, @code{dispfun (@var{f})} cria um rótulo de expressão intermédia
e atribui a definição para o rótulo.

@c PROBABLY NEED SOME EXAMPLES HERE
@end deffn

@deffn {Função} funmake (@var{F}, [@var{arg_1}, ..., @var{arg_n}])
Retorna uma expressão @code{@var{F}(@var{arg_1}, ..., @var{arg_n})}.
O valor de retorno é simplificado, mas não avaliado,
então a função @var{F} não é chamada, mesmo se essa função @var{F} existir.

@code{funmake} não tenta distinguir funções de array de funções comuns;
quando @var{F} for o nome de uma função de array,
@code{funmake} retorna @code{@var{F}(...)}
(isto é, uma chamada de função com parêntesis em lugar de colchêtes).
@code{arraymake} retorna uma chamada de função com colchêtes nesse caso.

@code{funmake} avalia seus argumentos.

Exemplos:

@code{funmake} aplicada a uma função comum do Maxima.

@c ===beg===
@c F (x, y) := y^2 - x^2;
@c funmake (F, [a + 1, b + 1]);
@c ''%;
@c ===end===
@example
(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
@end example

@code{funmake} aplicada a uma macro.

@c ===beg===
@c G (x) ::= (x - 1)/2;
@c funmake (G, [u]);
@c ''%;
@c ===end===
@example
(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
@end example

@code{funmake} aplicada a uma função subscrita.

@c ===beg===
@c H [a] (x) := (x - 1)^a;
@c funmake (H [n], [%e]);
@c ''%;
@c funmake ('(H [n]), [%e]);
@c ''%;
@c ===end===
@example
(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
@end example

@code{funmake} aplicada a um símbolo que não é uma função definida de qualquer tipo.

@c ===beg===
@c funmake (A, [u]);
@c ''%;
@c ===end===
@example
(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
@end example

 @code{funmake} avalia seus argumentos, mas não o valor de retorno.

@c ===beg===
@c det(a,b,c) := b^2 -4*a*c;
@c (x : 8, y : 10, z : 12);
@c f : det;
@c funmake (f, [x, y, z]);
@c ''%;
@c ===end===
@example
(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
@end example
Maxima simplifica o valor de retorno de @code{funmake}.

@c ===beg===
@c funmake (sin, [%pi / 2]);
@c ===end===
@example
(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
@end example

@end deffn

@deffn {Função} lambda ([@var{x_1}, ..., @var{x_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Função} lambda ([[@var{L}]], @var{expr_1}, ..., @var{expr_n})
@deffnx {Função} lambda ([@var{x_1}, ..., @var{x_m}, [@var{L}]], @var{expr_1}, ..., @var{expr_n})
Define e retorna uma expressão lambda (que é, uma função an@^onima)
A função pode ter argumentos que sejam necessários @var{x_1}, ..., @var{x_m}
e/ou argumentos opcionais @var{L}, os quais aparecem dentro do corpo da função como uma lista.
O valor de retorno da função é @var{expr_n}.
Uma expressão lambda pode ser atribuída para uma variável e avaliada como uma função comum.
Uma expressão lambda pode aparecer em alguns contextos nos quais um nome de função é esperado.

Quando a função é avaliada,
variáveis locais não associadas @var{x_1}, ..., @var{x_m} são criadas.
@code{lambda} pode aparecer dentro de @code{block} ou outra função @code{lambda};
variáveis locais são estabelecidas cada vez que outro @code{block} ou função @code{lambda} é avaliada.
Variáveis locais parecem ser globais para qualquer coisa contendo @code{block} ou @code{lambda}.
Se uma variável é não local,
seu valor é o valor mais recentemente atribuído em alguma coisa contendo @code{block} ou @code{lambda}, qualquer que seja,
de outra forma, seu valor é o valor da variável no ambiente global.
Essa política pode coincidir com o entendimento usual de "escopo dinâmico".

Após variáveis locais serem estabelecidas,
@var{expr_1} até @var{expr_n} são avaliadas novamente.
a variável especial @code{%%}, representando o valor da expressão precedente,
é reconhecida.
@code{throw} e @code{catch} pode também aparecer na lista de expressões.

@code{return} não pode aparecer em uma expressão lambda a menos que contendo @code{block},
nesse caso @code{return} define o valor de retorno do  bloco e não da
expressão lambda,
a menos que o bloco seja @var{expr_n}.
Da mesma forma, @code{go} não pode aparecer em uma expressão lambda a menos que contendo @code{block}.

@code{lambda} não avalia seus argumentos; 
o operador apóstrofo-apóstrofo @code{'@w{}'} faz com que ocorra avaliação.

Exemplos:

@itemize @bullet
@item
A expressão lambda pode ser atribuída para uma variável e avaliada como uma função comum.
@end itemize
@c ===beg===
@c f: lambda ([x], x^2);
@c f(a);
@c ===end===
@example
(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
@end example
@itemize @bullet
@item
Uma expressão lambda pode aparecer em contextos nos quais uma avaliação de função é esperada como resposta.
@end itemize
@c ===beg===
@c lambda ([x], x^2) (a);
@c apply (lambda ([x], x^2), [a]);
@c map (lambda ([x], x^2), [a, b, c, d, e]);
@c ===end===
@example
(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
@end example
@itemize @bullet
@item
Variáveis argumento são variáveis locais.
Outras variáveis aparecem para serem variáveis globais.
Variáveis globais são avaliadas ao mesmo tempo em que a expressão lambda é avaliada,
a menos que alguma avaliação especial seja forçada por alguns meios, tais como @code{'@w{}'}.
@end itemize
@c ===beg===
@c a: %pi$
@c b: %e$
@c g: lambda ([a], a*b);
@c b: %gamma$
@c g(1/2);
@c g2: lambda ([a], a*''b);
@c b: %e$
@c g2(1/2);
@c ===end===
@example
(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
@end example
@itemize @bullet
@item
Expressões lambda podem ser aninhadas.
Variáveis locais dentro de outra expressão lambda parece ser global para a expressão interna
a menos que mascarada por variáveis locais de mesmos nomes.
@end itemize
@c ===beg===
@c h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
@c h(%pi, %gamma);
@c ===end===
@example
(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
@end example
@itemize @bullet
@item
Uma vez que @code{lambda} não avalia seus argumentos, a expressão lambda @code{i} abaixo
não define uma função "multiplicação por @code{a}".
Tanto uma função pode ser definida via @code{buildq}, como na expressão lambda @code{i2} abaixo.
@end itemize
@c ===beg===
@c i: lambda ([a], lambda ([x], a*x));
@c i(1/2);
@c i2: lambda([a], buildq([a: a], lambda([x], a*x)));
@c i2(1/2);
@c i2(1/2)(%pi);
@c ===end===
@example
(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
@end example
@itemize @bullet
@item
Uma expressão lambda pode receber um número variável de argumentos,
os quais são indicados por meio de @code{[@var{L}]} como o argumento único ou argumento final.
Os argumentos aparecem dentro do corpo da função como uma lista.
@end itemize
@c ===beg===
@c f : lambda ([aa, bb, [cc]], aa * cc + bb);
@c f (foo, %i, 17, 29, 256);
@c g : lambda ([[aa]], apply ("+", aa));
@c g (17, 29, x, y, z, %e);
@c ===end===
@example
(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply ("+", aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
@end example
@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Função} local (@var{v_1}, ..., @var{v_n})
Declara as variáveis @var{v_1}, ..., @var{v_n} para serem locais com
relação a todas as propriedades na declaração na qual essa função
é usada.

@code{local} não avalia seus argumentos.
@code{local} retorna @code{done}.

@code{local} pode somente ser usada em @code{block}, no corpo de definições
de função ou expressões @code{lambda}, ou na função @code{ev}, e somente uma
ocorrêcia é permitida em cada.

@code{local} é independente de @code{context}.

@end deffn

@defvr {Variável de opção} macroexpansion
Valor por omissão: @code{false}

@code{macroexpansion} controla recursos avançados que
afectam a eficiência de macros.  Escolhas possíveis:

@itemize @bullet
@item
@code{false} -- Macros expandem normalmente cada vez que são chamadas.
@item
@code{expand} -- A primeira vez de uma chamada particular é avaliada, a
expansão é lembrada internamente, dessa forma não tem como ser
recalculada em chamadas subsequênte rapidamente.  A
macro chama ainda chamadas @code{grind} e @code{display} normalmente.  Todavia, memória extra é
requerida para lembrar todas as expansões.
@item
@code{displace} -- A primeira vez de uma chamada particular é avaliada, a
expansão é substituída pela chamada.  Isso requer levemente menos
armazenagem que quando @code{macroexpansion} é escolhida para @code{expand} e é razoávelmente rápido,
mas tem a desvantagem de a macro original ser lentamente
lembrada e daí a expansão será vista se @code{display} ou @code{grind} for
chamada.  Veja a documentação para @code{translate} e @code{macros} para maiores detalhes.
@end itemize
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Variável de opção} mode_checkp
Valor por omissão: @code{true}

@c WHAT DOES THIS MEAN ??
Quando @code{mode_checkp} é @code{true}, @code{mode_declare} verifica os modos
de associação de variáveis.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Variável de opção} mode_check_errorp
Valor por omissão: @code{false}

@c WHAT DOES THIS MEAN ??
Quando @code{mode_check_errorp} é @code{true}, @code{mode_declare} chama
a função "error".
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Variável de opção} mode_check_warnp
Valor por omissão: @code{true}

@c WHAT DOES THIS MEAN ??
Quando @code{mode_check_warnp} é @code{true}, modo "errors" são
descritos.
@c NEED SOME EXAMPLES HERE.

@end defvr

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Função} mode_declare (@var{y_1}, @var{mode_1}, ..., @var{y_n}, @var{mode_n})
@code{mode_declare} é usado para declarar os modos de variáveis e
funções para subsequênte tradução ou compilação das funções.
@code{mode_declare} é tipicamente colocada no início de uma definição de
função, no início de um script Maxima, ou executado através da linha de comando de forma interativa.

Os argumentos de @code{mode_declare} são pares consistindo de  uma variável e o modo que é
um de @code{boolean}, @code{fixnum}, @code{number}, @code{rational}, ou @code{float}.
Cada variável pode também
ser uma lista de variáveis todas as quais são declaradas para ter o mesmo modo.

@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Se uma variável é um array, e se todo elemento do array que é
referenciado tiver um valor então @code{array (yi, complete, dim1, dim2, ...)}
em lugar de 
@example
array(yi, dim1, dim2, ...)
@end example
deverá ser usado primeiro
declarando as associações do array.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Se todos os elementos do array
estão no modo @code{fixnum} (@code{float}), use @code{fixnum} (@code{float}) em lugar de @code{complete}.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Também se todo elemento do array está no mesmo modo, digamos @code{m}, então

@example
mode_declare (completearray (yi), m))
@end example

deverá ser usado para uma tradução
eficiente.

Código numéricos usando arrays podem rodar mais rápidamente
se for decladado o tamanho esperado do array, como em:

@example
mode_declare (completearray (a [10, 10]), float)
@end example

para um array numérico em ponto flutuante que é 10 x 10.

Pode-se declarar o modo do resultado de uma função
usando @code{function (f_1, f_2, ...)} como um argumento;
aqui @code{f_1}, @code{f_2}, ...  são nomes
de funções.  Por exemplo a expressão,

@example
mode_declare ([function (f_1, f_2, ...)], fixnum)
@end example

declara que os valores retornados por @code{f_1}, @code{f_2}, ...  são inteiros palavra simples.

@code{modedeclare} é um sin@^onimo para @code{mode_declare}.

@end deffn

@c WHAT IS THIS ABOUT ??
@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Função} mode_identity (@var{arg_1}, @var{arg_2})
Uma forma especial usada com @code{mode_declare} e @code{macros} para
declarar, e.g., uma lista de listas de números em ponto flutuante ou
outros objectos de dados.  O primeiro argumento para
@code{mode_identity} é um valor primitivo nome de modo como dado para
@code{mode_declare} (i.e., um de @code{float}, @code{fixnum},
@code{number}, @code{list}, ou @code{any}), e o segundo argumento é
uma expressão que é avaliada e retornada com o valor de
@code{mode_identity}. No entanto, se o valor de retorno não é
permitido pelo modo declarado no primeiro argumento, um erro ou alerta
é sinalizado.  Um ponto importante é que o modo da expressão como
determinado pelo Maxima para o tradutor Lisp, será aquele dado como o
primeiro argumento, independente de qualquer coisa que vá no segundo
argumento.  E.g., @code{x: 3.3; mode_identity (fixnum, x);} retorna um
erro.  @code{mode_identity (flonum, x)} returns 3.3 .  Isto tem
númerosas utilidades, por exemplo, se souber que @code{first (l)}
retornou um número então poderá escrever @code{mode_identity
(number, first (l))}. No entanto, um caminho mais eficiente para fazer a
mesma coisa é definir uma nova primitiva,

@example
firstnumb (x) ::= buildq ([x], mode_identity (number, first(x)));
@end example

e usar @code{firstnumb} sempre que obtiver o primeiro de uma lista de
números.

@end deffn

@c IS THERE ANY REASON TO SET transcompile: false ??
@c MAYBE THIS VARIABLE COULD BE PERMANENTLY SET TO true AND STRUCK FROM THE DOCUMENTATION.
@defvr {Variável de opção} transcompile
Valor por omissão: @code{true}

Quando @code{transcompile} é @code{true}, @code{translate} e @code{translate_file} geram
declarações para fazer o código traduzido mais adequado para compilação.
@c BUT THE DECLARATIONS DON'T SEEM TO BE NECESSARY, SO WHAT'S THE POINT AGAIN ??

@code{compfile} escolhe @code{transcompile: true} para a duração.

@end defvr

@deffn {Função} translate (@var{f_1}, ..., @var{f_n})
@deffnx {Função} translate (funções)
@deffnx {Função} translate (all)
Traduz funções definidas pelo utilizador
@var{f_1}, ..., @var{f_n} da linguagem de Maxima para Lisp
e avalia a tradução Lisp.
Tipicamente as funções traduzidas executam mais rápido que as originais.

@code{translate (all)} ou @code{translate (funções)} traduz todas as funções definidas pelo utilizador.

Funções a serem traduzidas incluir~ao uma chamada para @code{mode_declare} no
início quando possível com o objectivo de produzir um código mais eficiente.  Por
exemplo:

@example
f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)
@end example

@noindent

quando @var{x_1}, @var{x_2}, ...  são parâmetros para a função e
@var{v_1}, @var{v_2}, ...  são variáveis locais.

Os nomes de funções traduzidas
são removidos da lista @code{functions} se @code{savedef} é @code{false} (veja abaixo)
e são adicionados nas listas @code{props}.

Funções não poderão ser traduzidas
a menos que elas sejam totalmente depuradas.

Expressões são assumidas simplificadas; se não forem, um código correcto será gerado mas não será um código
óptimo.  Dessa forma, o utilizador não poderá escolher o comutador @code{simp} para @code{false}
o qual inibe simplificação de expressões a serem traduzidas.

O comutador @code{translate}, se @code{true}, causa tradução
automatica de uma função de utilizador para Lisp.

Note que funções
traduzidas podem não executar identicamente para o caminho que elas faziam antes da
tradução como certas incompatabilidades podem existir entre o Lisp
e versões do Maxima.  Principalmente, a função  @code{rat} com mais de
um argumento e a função @code{ratvars} não poderá ser usada se quaisquer
variáveis são declaradas com @code{mode_declare} como sendo expressões rotacionais canónicas(CRE).
Também a escolha @code{prederror: false}
não traduzirá.
@c WHAT ABOUT % AND %% ???

@code{savedef} - se @code{true} fará com que a versão Maxima de uma função
 utilizador permaneça quando a função é traduzida com @code{translate}.  Isso permite a
que definição seja mostrada por @code{dispfun} e autoriza a função a ser
editada.

@code{transrun} - se @code{false} fará com que a versão interpretada de todas as
funções sejam executadas (desde que estejam ainda disponíveis) em lugar da
versão traduzida.

O resultado retornado por @code{translate} é uma lista de nomes de
funções traduzidas.

@end deffn

@deffn {Função} translate_file (@var{maxima_nomeficheiro})
@deffnx {Função} translate_file (@var{maxima_nomeficheiro}, @var{lisp_nomeficheiro})
Traduz um ficheiro com código Maxima para um ficheiro com código Lisp.
@code{translate_file} retorna uma lista de três nomes de ficheiro:
O nome do ficheiro Maxima, o nome do ficheiro Lisp, e o nome do ficheiro
contendo informações adicionais sobre a tradução.
@code{translate_file} avalia seus argumentos.

@code{translate_file ("foo.mac"); load("foo.LISP")} é o mesmo que
@code{batch ("foo.mac")} excepto por certas restrições,
o uso de @code{'@w{}'} e @code{%}, por exemplo.
@c FIGURE OUT WHAT THE RESTRICTIONS ARE AND STATE THEM

@code{translate_file (@var{maxima_nomeficheiro})} traduz um ficheiro Maxima @var{maxima_nomeficheiro}
para um similarmente chamado ficheiro Lisp.
Por exemplo, @code{foo.mac} é traduzido em @code{foo.LISP}.
O nome de ficheiro Maxima pod incluir nome ou nomes de directório(s),
nesse caso o ficheiro de saída Lisp é escrito
para o mesmo directório que a entrada Maxima.

@code{translate_file (@var{maxima_nomeficheiro}, @var{lisp_nomeficheiro})} traduz
um ficheiro Maxima @var{maxima_nomeficheiro} em um ficheiro Lisp @var{lisp_nomeficheiro}.
@code{translate_file} ignora a extensão do nome do ficheiro, se qualquer, de @code{lisp_nomeficheiro};
a extensão do ficheiro de saída Lisp é sempre @code{LISP}.
O nome de ficheiro Lisp pode incluir um nome ou nomes de directórios),
nesse caso o ficheiro de saída Lisp é escrito para o directório especificado.

@code{translate_file} também escreve um ficheiro de mensagens de alerta
do tradutor em vários graus de severidade.
A extensão do nome de ficheiro desse ficheiro é @code{UNLISP}.
Esse ficheiro pode conter informação valiosa, apesar de possivelmente obscura,
para rastrear erros no código traduzido.
O ficheiro @code{UNLISP} é sempre escrito
para o mesmo directório que a entrada Maxima.

@code{translate_file} emite código Lisp o qual faz com que
algumas definições tenham efeito tão logo
o código Lisp é compilado.
Veja @code{compile_file} para mais sobre esse tópico.

@c CHECK ALL THESE AND SEE WHICH ONES ARE OBSOLETE
Veja também @code{tr_array_as_ref},
@c tr_bind_mode_hook EXISTS BUT IT APPEARS TO BE A GROTESQUE UNDOCUMENTED HACK
@c WE DON'T WANT TO MENTION IT
@c @code{tr_bind_mode_hook}, 
@code{tr_bound_function_applyp},
@c tr_exponent EXISTS AND WORKS AS ADVERTISED IN src/troper.lisp
@c NOT OTHERWISE DOCUMENTED; ITS EFFECT SEEMS TOO WEAK TO MENTION
@code{tr_exponent},
@code{tr_file_tty_messagesp}, 
@code{tr_float_can_branch_complex},
@code{tr_function_call_default}, 
@code{tr_numer},
@code{tr_optimize_max_loop}, 
@code{tr_semicompile},
@code{tr_state_vars}, 
@code{tr_warnings_get},
@code{tr_warn_bad_function_calls},
@code{tr_warn_fexpr}, 
@code{tr_warn_meval},
@code{tr_warn_mode},
@code{tr_warn_undeclared},
e @code{tr_warn_undefined_variable}.

@end deffn

@defvr {Variável de opção} transrun
Valor por omissão: @code{true}

Quando @code{transrun} é @code{false} fará com que a versão
interpretada de todas as funções sejam executadas (desde que estejam ainda disponíveis)
em lugar de versão traduzidas.

@end defvr

@c IN WHAT CONTEXT IS tr_array_as_ref: false APPROPRIATE ??? NOT SEEING THE USEFULNESS HERE.
@c ALSO, I GUESS WE SHOULD HAVE AN ITEM FOR translate_fast_arrays, ANOTHER CONFUSING FLAG ...
@defvr {Variável de opção} tr_array_as_ref
Valor por omissão: @code{true}

Se @code{translate_fast_arrays} for @code{false}, referências a arrays no
Código Lisp emitidas por @code{translate_file} são afectadas por @code{tr_array_as_ref}.
Quando @code{tr_array_as_ref} é @code{true},
nomes de arrays são avaliados,
de outra forma nomes de arrays aparecem como símbolos literais no código traduzido.

@code{tr_array_as_ref} não terão efeito se @code{translate_fast_arrays} for @code{true}.

@end defvr

@c WHY IS THIS FLAG NEEDED ??? UNDER WHAT CIRCUMSTANCES CAN TRANSLATION
@c OF A BOUND VARIABLE USED AS A FUNCTION GO WRONG ???
@defvr {Variável de opção} tr_bound_function_applyp
Valor por omissão: @code{true}

Quando @code{tr_bound_function_applyp} for @code{true}, Maxima emite um alerta se uma associação
de variável (tal como um argumento de função) é achada sendo usada como uma função.
@code{tr_bound_function_applyp} não afecta o código gerado em tais casos.

Por exemplo, uma expressão tal como @code{g (f, x) := f (x+1)} irá disparar
a mensagem de alerta.

@end defvr

@defvr {Variável de opção} tr_file_tty_messagesp
Valor por omissão: @code{false}

Quando @code{tr_file_tty_messagesp} é @code{true},
messagens geradas por @code{translate_file} durante a tradução de um ficheiro são mostradas
sobre o console e inseridas dentro do ficheiro UNLISP.  
Quando @code{false}, messagens sobre traduções de
ficheiros são somente inseridas dentro do ficheiro UNLISP.

@end defvr

@c THIS FLAG APPEARS TO HAVE NO EFFECT.  SHOULD CUT OUT THIS ITEM AND RELATED CODE.
@c NOTE THAT THERE IS CODE IN src/transf.lisp WHICH USES THIS FLAG BUT THE MODE
@c FLAG IS LOST SOMEWHERE ALONG THE WAY TO THE LISP OUTPUT FILE.
@defvr {Variável de opção} tr_float_can_branch_complex
Valor por omissão: @code{true}

Diz ao tradutor Maxima-para-Lisp assumir que as funções 
@code{acos}, @code{asin}, @code{asec}, e @code{acsc} podem retornar resultados complexos.

O efeito ostensivo de @code{tr_float_can_branch_complex} é mostrado adiante.
Todavia, parece que esse sinalizador não tem efeito sobre a saída do tradutor.

Quando isso for @code{true} então @code{acos(x)} será do modo @code{any}
sempre que @code{x} for do modo @code{float} (como escolhido por @code{mode_declare}).
Quando @code{false} então @code{acos(x)} será do modo
@code{float} se e somente se @code{x} for do modo @code{float}.

@end defvr

@defvr {Variável de opção} tr_function_call_default
Valor por omissão: @code{general}

@code{false} significa abandonando e
chamando @code{meval}, @code{expr} significa que Lisp assume função de argumento fixado.  @code{general}, o
código padrão dado como sendo bom para @code{mexprs} e @code{mlexprs} mas não @code{macros}.
@code{general} garante que associações de variável são correctas em códigos compilados.  No
modo @code{general}, quando traduzindo F(X), se F for uma variável associada, então isso
assumirá que @code{apply (f, [x])} é significativo, e traduz como tal, com
o alerta apropriado.  Não é necessário desabilitar isso.  Com as
escolhas padrão, sem mensagens de alerta implica compatibilidade total do
código traduzido e compilado com o interpretador Maxima.

@end defvr

@defvr {Variável de opção} tr_numer
Valor por omissão: @code{false}

Quando @code{tr_numer} for @code{true} propriedades @code{numer} são usadas para
átomos que possuem essa propriedade, e.g. @code{%pi}.

@end defvr

@defvr {Variável de opção} tr_optimize_max_loop
Valor por omissão: 100

@code{tr_optimize_max_loop} é número máximo de vezes do
passo de macro-expansão e optimização que o tradutor irá executar
considerando uma forma.  Isso é para capturar erros de expansão de macro, e
propriedades de optimização não terminadas.

@end defvr

@defvr {Variável de opção} tr_semicompile
Valor por omissão: @code{false}

Quando @code{tr_semicompile} for @code{true}, as formas de saída de @code{translate_file}
e @code{compfile} serão macroexpandidas mas não compiladas em código
de máquina pelo compilador Lisp.

@end defvr

@c ARE ANY OF THESE OBSOLETE ??
@defvr {Variável de sistema} tr_state_vars
Valor por omissão:
@example
[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
@end example

A lista de comutadores que afectam a forma de saída da
tradução.
@c DOES THE GENERAL USER REALLY CARE ABOUT DEBUGGING THE TRANSLATOR ???
Essa informação é útil para sistemas populares quando
tentam depurar o tradutor.  Comparando o produto traduzido
para o qual pode ter sido produzido por um dado estado, isso é possível para
rastrear erros.

@end defvr

@c tr_warnings_get EXISTS AND FUNCTIONS AS ADVERTISED (SORT OF) -- RETURNS *tr-runtime-warned*
@c WHICH HAS ONLY A FEW KINDS OF WARNINGS PUSHED ONTO IT; IT'S CERTAINLY NOT COMPREHENSIVE
@c DO WE REALLY NEED THIS SLIGHTLY WORKING FUNCTION ??
@deffn {Função} tr_warnings_get ()
Imprime uma lista de alertas que podem ter sido dadas pelo
tradutor durante a tradução corrente.

@end deffn

@defvr {Variável de opção} tr_warn_bad_function_calls
Valor por omissão: @code{true}

- Emite um alerta quando
chamadas de função estão sendo feitas por um caminho que pode não ser correcto devido
a declarações impróprias que foram feitas em tempo de tradução.

@end defvr

@defvr {Variável de opção} tr_warn_fexpr
Valor por omissão: @code{compfile}

- Emite um alerta se quaisquer FEXPRs forem
encontradas.  FEXPRs não poderão normalmente ser saída em código traduzido,
todas as formas de programa especial legítimo são traduzidas.

@end defvr

@defvr {Variável} tr_warn_meval
Valor por omissão: @code{compfile}

- Emite um alerta se a função
@code{meval} recebe chamadas.  Se @code{meval} é chamada isso indica problemas na
tradução.

@end defvr

@defvr {Variável} tr_warn_mode
Valor por omissão: @code{all}

- Emite um alerta quando a variáveis forem
atribuídos valores inapropriados para seu modo.

@end defvr

@defvr {Variável de opção} tr_warn_undeclared
Valor por omissão: @code{compile}

- Determina quando enviar
alertas sobre variáveis não declaradas para o TTY.

@end defvr

@defvr {Variável de opção} tr_warn_undefined_variable
Valor por omissão: @code{all}

- Emite um alerta quando
variáveis globais indefinidas forem vistas.

@end defvr

@deffn {Função} compile_file (@var{nomeficheiro})
@deffnx {Função} compile_file (@var{nomeficheiro}, @var{nomeficheiro_compilado})
@deffnx {Função} compile_file (@var{nomeficheiro}, @var{nomeficheiro_compilado}, @var{lisp_nomeficheiro})
Traduz o ficheiro Maxima @var{nomeficheiro} para Lisp,
executa o compilador Lisp,
e, se a tradução e a compilação obtiverem sucesso, chama o código compilado dentro do Maxima.

@code{compile_file} retorna uma lista dos nomes de quatro ficheiros:
o ficheiro original do Maxima, o nome da tradução Lisp, uma ficheiro de notas sobre a tradução, e o nome do ficheiro que contém o código compilado.
Se a compilação falhar,
o quarto item é @code{false}.

Algumas declarações e definições passam a ter efeito tão logo
o código Lisp seja compilado (sem que seja necessário chamar o código compilado).
Isso inclui funções definidas com o operador @code{:=},
macros definidas com o operador @code{::=}, @c HEDGE -- DON'T KNOW IF THERE IS ANOTHER WAY
@code{alias}, @code{declare},
@code{define_variable},  @code{mode_declare},
e 
@code{infix}, @code{matchfix},
@code{nofix}, @code{postfix}, @code{prefix},
e @code{compfile}.

Atribuições e chamadas de função não serão avaliadas até que o código compilado seja carregado.
Em particular, dentro do ficheiro Maxima,
atribuições para sinalizadores traduzidos (@code{tr_numer}, etc.) não têm efeito sobre a tradução.

@c @code{compile_file} may mistake warnings for errors and
@c return @code{false} as the name of the compiled code when, in fact,
@c the compilation succeeded.  This é a bug.  
@c REPORTED AS SOURCEFORGE BUG # 1103722.

@var{nomeficheiro} pode não conter declarações @code{:lisp}.

@code{compile_file} avalia seus argumentos.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Função} declare_translated (@var{f_1}, @var{f_2}, ...)
Quando traduzindo um ficheiro do código Maxima
para Lisp, é importante para o programa tradutor saber quais funções
no ficheiro são para serem chamadas como funções traduzidas ou compiladas,
e quais outras são apenas funções Maxima ou indefinidas.  Colocando essa
declaração no topo do ficheiro, faremos conhecido que embora um símbolo
diga que não temos ainda um valor de função Lisp, teremos uma em
tempo de chamada.  @code{(MFUNCTION-CALL fn arg1 arg2 ...)} é gerado quando
o tradutor n~ao sabe que @code{fn} está sendo compilada para ser uma função Lisp.

@end deffn


