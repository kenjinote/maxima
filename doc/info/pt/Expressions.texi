@c /Expressions.texi/1.52/Sun Mar 11 02:32:14 2007/-ko/
@menu
* Introdução a Expressões::  
* Complexo::                     
* Substantivos e Verbos::
* Identificadores::
* Sequências de caracteres::
* Desigualdade::                  
* Sintaxe::                      
* Definições para Expressões::  
@end menu

@node Introdução a Expressões, Complexo, Expressões, Expressões
@section Introdução a Expressões

Existe um conjunto de palavras reservadas que não pode ser usado como
nome de variável.   Seu uso pode causar um possível erro crítico de sintaxe.

@example
integrate            next           from                 diff            
in                   at             limit                sum             
for                  and            elseif               then            
else                 do             or                   if              
unless               product        while                thru            
step                                                                     
@end example

Muitas coisas em Maxima são expressões.   Uma sequência de expressões
pode ser feita dentro de uma expressão maior através da separação dessas através de vírgulas e
colocando parêntesis em torno dela.   Isso é similar ao @b{C}
@i{expressão com vírgula}.

@example
(%i1) x: 3$
(%i2) (x: x+1, x: x^2);
(%o2)                          16
(%i3) (if (x > 17) then 2 else 4);
(%o3)                           4
(%i4) (if (x > 17) then x: 2 else y: 4, y+x);
(%o4)                          20
@end example

Mesmo ciclos em Maxima são expressões, embora o valor de retorno desses
ciclos não seja muito útil (eles retornam sempre @code{done}).

@example
(%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
(%i2) y;
(%o2)                         done
@end example

enquanto que o que realmente queira seja provavelmente incluir um
terceiro termo na @i{expressão com vírgula} que fornece
de volta o valor actualizado.

@example
(%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
(%i4) y;
(%o4)                        3628800
@end example



@c THIS REALLY NEEDS EXPANSION
@node Complexo, Substantivos e Verbos, Introdução a Expressões, Expressões
@section Complexo
Uma expressão complexa é especificada no Maxima através da adição da
parte real da expressão a @code{%i} vezes a parte imaginária.  Dessa forma as
raízes da equação @code{x^2 - 4*x + 13 = 0} são @code{2 + 3*%i} e @code{2 - 3*%i}.  Note que
produtos de simplificação de expressões complexas podem ser efetuadas através da
expansão do produto.  Simplificação de quocientes, raízes, e outras
funções de expressões complexas podem usualmente serem realizadas através do uso
das funções @code{realpart}, @code{imagpart}, @code{rectform}, @code{polarform}, @code{abs}, @code{carg}.

@node Substantivos e Verbos, Identificadores, Complexo, Expressões
@section Substantivos e Verbos
Maxima distingue entre operadores que são "substantivos" e operadores que são "verbos".
Um verbo é um operador que pode ser executado.
Um substantivo é um operador que aparece como um símbolo em uma expressão, sem ser executado.
Por padrão, nomes de função são verbos.
Um verbo pode ser mudado em um substantivo através da adição de um apóstrofo no início do nome da função
ou aplicando a função @code{nounify}.
Um substantivo pode ser mudado em um verbo através da aplicação da função @code{verbify}.
O sinalizador de avaliação @code{nouns} faz com que @code{ev} avalie substantivos em uma expressão.

A forma verbal é distinguida através de
um sinal de dólar @code{$} no início do símbolo Lisp correspondente.
De forma oposta,
a forma substantiva é distinguida através de 
um sinal de @code{%} no início do símbolo Lisp correspondente.
Alguns substantivos possuem propriedades especiais de exibição, tais como @code{'integrate} e @code{'derivative}
(retornado por @code{diff}), mas muitos não.
Por padrão, as formas substantiva e verbal de uma função são idênticas quando mostradas.
O sinalizador global @code{noundisp} faz com que Maxima mostre substantivos com um apóstrofo no início @code{'}.

Veja também @code{noun}, @code{nouns}, @code{nounify}, e @code{verbify}.

Exemplos:

@c ===beg===
@c foo (x) := x^2;
@c foo (42);
@c 'foo (42);
@c 'foo (42), nouns;
@c declare (bar, noun);
@c bar (x) := x/17;
@c bar (52);
@c bar (52), nouns;
@c integrate (1/x, x, 1, 42);
@c 'integrate (1/x, x, 1, 42);
@c ev (%, nouns);
@c ===end===
@example
(%i1) foo (x) := x^2;
                                     2
(%o1)                     foo(x) := x
(%i2) foo (42);
(%o2)                         1764
(%i3) 'foo (42);
(%o3)                        foo(42)
(%i4) 'foo (42), nouns;
(%o4)                         1764
(%i5) declare (bar, noun);
(%o5)                         done
(%i6) bar (x) := x/17;
                                     x
(%o6)                    ''bar(x) := --
                                     17
(%i7) bar (52);
(%o7)                        bar(52)
(%i8) bar (52), nouns;
                               52
(%o8)                          --
                               17
(%i9) integrate (1/x, x, 1, 42);
(%o9)                        log(42)
(%i10) 'integrate (1/x, x, 1, 42);
                             42
                            /
                            [   1
(%o10)                      I   - dx
                            ]   x
                            /
                             1
(%i11) ev (%, nouns);
(%o11)                       log(42)
@end example

@node Identificadores, Sequências de caracteres, Substantivos e Verbos, Expressões
@section Identificadores
Identificadores do Maxima podem compreender caracteres alfabéticos,
mais os numerais de 0 a 9,
mais qualquer caractere especial precedido por um caractere contra-barra @code{\}.

Um numeral pode ser o primeiro caractere de um identificador
se esse numeral for precedido por uma contra-barra.
Numerais que forem o segundo ou o último caractere não precisam ser precedidos por uma contra barra.

Caracteres podem ser declarados para serem alfabéticos por meio da função @code{declare}.
Se então declarados alfabéticos, eles não precisam serem precedidos de uma contrabarra em um identificador.
Os caracteres alfabéticos vão inicialmente 
de @code{A} a @code{Z}, de @code{a} a @code{z}, @code{%}, e @code{_}.

Maxima é sensível à caixa . Os identificadores @code{algumacoisa}, @code{ALGUMACOISA}, e @code{Algumacoisa} são distintos.
Veja @emph{Lisp e Maxima} para mais sobre esse ponto.

Um identificador Maxima é um símbolo Lisp que começa com um sinal de dólar @code{$}.
Qualquer outro símbolo Lisp é precedido por um ponto de interrogação @code{?} quando aparecer no Maxima.
Veja @emph{Lisp e Maxima} para maiores detalhes sobre esse ponto.

Exemplos:

@c ===beg===
@c %an_ordinary_identifier42;
@c embedded\ spaces\ in\ an\ identifier;
@c symbolp (%);
@c [foo+bar, foo\+bar];
@c [1729, \1729];
@c [symbolp (foo\+bar), symbolp (\1729)];
@c [is (foo\+bar = foo+bar), is (\1729 = 1729)];
@c baz\~quux;
@c declare ("~", alphabetic);
@c baz~quux;
@c [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
@c :lisp (defvar *my-lisp-variable* '$foo)
@c ?\*my\-lisp\-variable\*;
@c ===end===

@example
(%i1) %an_ordinary_identifier42;
(%o1)               %an_ordinary_identifier42
(%i2) embedded\ spaces\ in\ an\ identifier;
(%o2)           embedded spaces in an identifier
(%i3) symbolp (%);
(%o3)                         true
(%i4) [foo+bar, foo\+bar];
(%o4)                 [foo + bar, foo+bar]
(%i5) [1729, \1729];
(%o5)                     [1729, 1729]
(%i6) [symbolp (foo\+bar), symbolp (\1729)];
(%o6)                     [true, true]
(%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
(%o7)                    [false, false]
(%i8) baz\~quux;
(%o8)                       baz~quux
(%i9) declare ("~", alphabetic);
(%o9)                         done
(%i10) baz~quux;
(%o10)                      baz~quux
(%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
(%o11)                [false, false, false]
(%i12) :lisp (defvar *my-lisp-variable* '$foo)
*MY-LISP-VARIABLE*
(%i12) ?\*my\-lisp\-variable\*;
(%o12)                         foo
@end example

@node Sequências de caracteres, Desigualdade, Identificadores, Expressões
@section Sequências de caracteres

Strings (sequências de caracteres) são contidas entre aspas duplas @code{"} em entradas de dados usados pelo Maxima,
e mostradas com ou sem as aspas duplas, 
dependendo do valor escolhido para a variável global @code{stringdisp}.

Sequências de caracteres podem conter quaisquer caracteres,
incluindo tabulações (tab), nova linha (ou fim de linha), e caracteres de retorno da cabeça de impressão (carriage return).
A sequência @code{\"} é reconhecida com uma aspa dupla literal,
e @code{\\} como uma contrabarra literal.
Quando a contrabarra aparecer no final de uma linha,
a contrabarra e a terminação de linha
(ou nova linha ou retorno de carro e nova linha)
são ignorados,
de forma que a sequência de caracteres continue na próxima linha.
Nenhuma outra combinação especial de contrabarra com outro caractere é reconhecida;
quando a contrabarra aparecer antes de qualquer outro caractere que não seja @code{"}, @code{\},
ou um fim de linha, a contrabarra é ignorada.
Não exite caminho para representar um caractere especial
(tal como uma tabulação, nova linha, ou retorno da cabeça de impressão)
excepto através de encaixar o caractere literal na sequência de caracteres.

Não existe tipo de caractere no Maxima;
um caractere simples é representado como uma sequência de caracteres de um único caractere.

Sequências de caracteres no Maxima são implementadas como símbolos do Lisp, não como sequencias de caracteres do not Lisp;
o que pode mudar em futuras versões do Maxima.
Maxima pode mostrar sequências de caracteres do Lisp e caracteres do Lisp,
embora algumas outras operações (por exemplo, testes de igualdade) possam falhar.
@c DISCOMFORT WITH LISP STRINGS AND CHARACTERS IS A BUG.

O pacote adicional @code{stringproc} contém muitas funções que trabalham com sequências de caracteres.

Exemplos:

@c ===beg===
@c s_1 : "Isso é uma sequência de caracteres  do Maxima.";
@c s_2 : "Caracteres \"aspas duplas\" e contrabarras \\ encaixados em uma sequência de caracteres.";
@c s_3 : "Caractere de fim de linha encaixado
@c nessa sequência de caracteres.";
@c s_4 : "Ignore o \
@c caractere de \
@c fim de linha nessa \
@c sequência de caracteres.";
@c stringdisp : false;
@c s_1;
@c stringdisp : true;
@c s_1;
@c ===end===
@example
(%i1) s_1 : "Isso é uma sequência de caracteres  do Maxima.";
(%o1)               Isso é uma sequência de caracteres  do Maxima.
(%i2) s_2 : "Caracteres \"aspas duplas\" e contrabarras \\ encaixados em uma sequência de caracteres.";
(%o2) Caracteres "aspas duplas" e contrabarra \ encaixados em uma sequência de caracteres.
(%i3) s_3 : "Caractere de fim de linha encaixado
nessa sequência de caracteres.";
(%o3) Caractere de fim de linha encaixado
nessa sequência de caracteres.
(%i4) s_4 : "Ignore o \
caractere de \
fim de linha nessa \
sequência de caracteres.";
(%o4) Ignore o caractere de fim de linha nessa sequência de caracteres.
(%i5) stringdisp : false;
(%o5)                         false
(%i6) s_1;
(%o6)               Isso é uma sequência de caracteres  do Maxima.
(%i7) stringdisp : true;
(%o7)                         true
(%i8) s_1;
(%o8)              "Isso é uma sequência de caracteres  do Maxima."
@end example

@node Desigualdade, Sintaxe, Sequências de caracteres, Expressões
@section Desigualdade
Maxima tem os operadores de desigualdade @code{<}, @code{<=}, @code{>=}, @code{>}, @code{#}, e @code{notequal}.
Veja @code{if} para uma descrição de expressões condicionais.

@node Sintaxe, Definições para Expressões, Desigualdade, Expressões
@section Sintaxe
É possível definir novos operadores com precedência especificada,
remover a definição de operadores existentes,
ou redefinir a precedência de operadores existentes.  
Um operador pode ser unário prefixado ou unário pósfixado, binario infixado, n-ário infixado, matchfix, ou nofix.
"Matchfix" significa um par de símbolos que abraçam seu argumento ou seus argumentos,
e "nofix" significa um operador que não precisa de argumentos.
Como exemplos dos diferentes tipos de operadores, existe o seguinte.

@table @asis
@item unário prefixado
negação @code{- a}
@item unário posfixado
factorial @code{a!}
@item binário infixado
exponenciação @code{a^b}
@item n-ário infixado
adição @code{a + b}
@item matchfix
construção de lista @code{[a, b]}
@end table

(Não existe operadores internos nofix;
para um exemplo de tal operador, veja @code{nofix}.)

O mecanismo para definir um novo operador é directo.
Somente é necessário declarar uma função como um operador;
a função operador pode ou não estar definida previamente.

Um exemplo de operadores definidos pelo utilizador é o seguinte.
Note que a chamada explícita de função @code{"dd" (a)} é equivalente a @code{dd a},
da mesma forma @code{"<-" (a, b)} é equivalente a @code{a <- b}.
Note também que as funções @code{"dd"} e @code{"<-"} são indefinidas nesse exemplo.

@c ===beg===
@c prefix ("dd");
@c dd a;
@c "dd" (a);
@c infix ("<-");
@c a <- dd b;
@c "<-" (a, "dd" (b));
@c ===end===
@example
(%i1) prefix ("dd");
(%o1)                          dd
(%i2) dd a;
(%o2)                         dd a
(%i3) "dd" (a);
(%o3)                         dd a
(%i4) infix ("<-");
(%o4)                          <-
(%i5) a <- dd b;
(%o5)                      a <- dd b
(%i6) "<-" (a, "dd" (b));
(%o6)                      a <- dd b
@end example

As funções máxima que definem novos operadores estão sumarizadas nessa tabela,
equilibrando expoente associado esquerdo (padrão) e o expoente associado direito ("eae" e "ead", respectivamente).
@c REWORK FOLLOWING COMMENT. IT'S NOT CLEAR ENOUGH, GIVEN THAT IT'S FAIRLY IMPORTANT
(Associação de expoentes determina a precedência do operador. todavia, uma vez que os expoentes
esquerdo e direito podem ser diferentes, associação de expoentes é até certo ponto mais complicado que precedência.)
Alguma das funções de definição de operações tomam argumentos adicionais;
veja as descrições de função para maiores detalhes.

@c MAKE ANCHORS FOR ALL 6 FUNCTIONS AND CHANGE @code TO @emph ACCORDINGLY
@table @code
@item prefixado
ead=180
@item posfixado
eae=180
@item infixado
eae=180, ead=180
@item nário
eae=180, ead=180
@item matchfix
(associação de expoentes não é aplicável)
@item nofix
(associação de expoentes não é aplicável)
@end table

Para comparação,
aqui está alguns operadores internos e seus expoentes associados esquerdo e direito.

@example
Operador   eae     ead

  :        180     20 
  ::       180     20 
  :=       180     20 
  ::=      180     20 
  !        160
  !!       160
  ^        140     139 
  .        130     129 
  *        120
  /        120     120 
  +        100     100 
  -        100     134 
  =        80      80 
  #        80      80 
  >        80      80 
  >=       80      80 
  <        80      80 
  <=       80      80 
  not              70 
  and      65
  or       60
  ,        10
  $        -1
  ;        -1
@end example

@code{remove} e @code{kill} removem propriedades de operador de um átomo.
@code{remove ("@var{a}", op)} remove somente as propriedades de operador de @var{a}.
@code{kill ("@var{a}")} remove todas as propriedades de @var{a}, incluindo as propriedades de operador.
Note que o nome do operador dever estar abraçado por aspas duplas.

@c MAYBE COPY THIS EXAMPLE TO remove AND/OR kill
@c ===beg===
@c infix ("##");
@c "##" (a, b) := a^b;
@c 5 ## 3;
@c remove ("##", op);
@c 5 ## 3;
@c "##" (5, 3);
@c infix ("##");
@c 5 ## 3;
@c kill ("##");
@c 5 ## 3;
@c "##" (5, 3);
@c ===end===
@example
(%i1) infix ("##");
(%o1)                          ##
(%i2) "##" (a, b) := a^b;
                                     b
(%o2)                     a ## b := a
(%i3) 5 ## 3;
(%o3)                          125
(%i4) remove ("##", op);
(%o4)                         done
(%i5) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i5) "##" (5, 3);
(%o5)                          125
(%i6) infix ("##");
(%o6)                          ##
(%i7) 5 ## 3;
(%o7)                          125
(%i8) kill ("##");
(%o8)                         done
(%i9) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i9) "##" (5, 3);
(%o9)                       ##(5, 3)
@end example

@node Definições para Expressões,  , Sintaxe, Expressões
@section Definições para Expressões

@deffn {Função} at (@var{expr}, [@var{eqn_1}, ..., @var{eqn_n}])
@deffnx {Função} at (@var{expr}, @var{eqn})
Avalia a expressão @var{expr} com
as variáveis assumindo os valores como especificado para elas na lista de
equações @code{[@var{eqn_1}, ..., @var{eqn_n}]} ou a equação simples @var{eqn}.

Se uma subexpressão depender de qualquer das variáveis para a qual um valor foi especificado
mas não existe @code{atvalue} especificado e essa subexpressão não pode ser avaliada de outra forma,
então uma forma substantiva de @code{at} é retornada que mostra em uma forma bidimensional.

@code{at} realiza múltiplas substituições em série, não em paralelo.

Veja também @code{atvalue}.
Para outras funções que realizam substituições,
veja também @code{subst} e @code{ev}.

Exemplos:
@c COPIED FROM example(at)

@c ===beg===
@c atvalue (f(x,y), [x = 0, y = 1], a^2);
@c atvalue ('diff (f(x,y), x), x = 0, 1 + y);
@c printprops (all, atvalue);
@c diff (4*f(x, y)^2 - u(x, y)^2, x);
@c at (%, [x = 0, y = 1]);
@c ===end===
@example
(%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                2
(%o1)                          a
(%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
(%o2)                        @@2 + 1
(%i3) printprops (all, atvalue);
                                !
                  d             !
                 --- (f(@@1, @@2))!       = @@2 + 1
                 d@@1            !
                                !@@1 = 0

                                     2
                          f(0, 1) = a

(%o3)                         done
(%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                  d                          d
(%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                  dx                         dx
(%i5) at (%, [x = 0, y = 1]);
                                         !
              2              d           !
(%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                             dx          !
                                         !x = 0, y = 1
@end example

@end deffn

@deffn {Função} box (@var{expr})
@deffnx {Função} box (@var{expr}, @var{a})
Retorna @var{expr} dentro de uma caixa.
O valor de retorno é uma expressão com @code{box} como o operador e @var{expr} como o argumento.
Uma caixa é desenhada sobre a tela quando @code{display2d} for @code{true}.

@code{box (@var{expr}, @var{a})}
Empacota @var{expr} em uma caixa rotulada pelo símbolo @var{a}.
O rótulo é truncado se for maior que a largura da caixa.

@code{box} avalia seu argumento.
Todavia, uma expressão dentro de uma caixa não avalia para seu conteúdo,
então expressões dentro de caixas são efectivamente excluídas de cálculos.

@code{boxchar} é o caractere usado para desenhar a caixa em @code{box}
e nas funções @code{dpart} e @code{lpart}.

Exemplos:

@c ===beg===
@c box (a^2 + b^2);
@c a : 1234;
@c b : c - d;
@c box (a^2 + b^2);
@c box (a^2 + b^2, term_1);
@c 1729 - box (1729);
@c boxchar: "-";
@c box (sin(x) + cos(y));
@c ===end===
@example
(%i1) box (a^2 + b^2);
                            """""""""
                            " 2    2"
(%o1)                       "b  + a "
                            """""""""
(%i2) a : 1234;
(%o2)                         1234
(%i3) b : c - d;
(%o3)                         c - d
(%i4) box (a^2 + b^2);
                      """"""""""""""""""""
                      "       2          "
(%o4)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i5) box (a^2 + b^2, term_1);
                      term_1""""""""""""""
                      "       2          "
(%o5)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i6) 1729 - box (1729);
                                 """"""
(%o6)                     1729 - "1729"
                                 """"""
(%i7) boxchar: "-";
(%o7)                           -
(%i8) box (sin(x) + cos(y));
                        -----------------
(%o8)                   -cos(y) + sin(x)-
                        -----------------
@end example

@end deffn

@defvr {Variável de opção} boxchar
Valor por omissão: @code{"}

@code{boxchar} é o caractere usado para desenhar a caixa por @code{box}
e nas funções @code{dpart} e @code{lpart}.

Todas as caixas em uma expressão são desenhadas com o valor actual
de @code{boxchar}; o caractere de desenho não é armazenado com a
expressão de caixa. Isso quer dizer que se desenhar uma caixa e em
seguida mudar o caracter de desenho a caixa anteriormente desenhada
será redesenhada com o caracter mudado caso isso seja solicitado.

@end defvr

@deffn {Função} carg (@var{z})
Retorna o argumento complexo de @var{z}.
O argumento complexo é um ângulo @code{theta} no intervalo de @code{(-%pi, %pi]}
tal que @code{r exp (theta %i) = @var{z}} onde @code{r} é o módulo de @var{z}.
@c ACTUALLY carg DOESN'T ALWAYS RETURN A VALUE IN (-%pi, %pi]; SEE SF BUG REPORT # 816166

@code{carg} é uma função computacional,
não uma função de simplificação.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

@code{carg} ignora a declaração @code{declare (@var{x}, complex)},
e trata @var{x} como uma variável real.
Isso é um erro. @c SEE SF BUG REPORT # 620246

Veja também @code{abs} (módulo de número complexo), @code{polarform}, @code{rectform},
@code{realpart}, e @code{imagpart}.

Exemplos:

@c ===beg===
@c carg (1);
@c carg (1 + %i);
@c carg (exp (%i));
@c carg (exp (%pi * %i));
@c carg (exp (3/2 * %pi * %i));
@c carg (17 * exp (2 * %i));
@c ===end===

@example
(%i1) carg (1);
(%o1)                           0
(%i2) carg (1 + %i);
                               %pi
(%o2)                          ---
                                4
(%i3) carg (exp (%i));
(%o3)                           1
(%i4) carg (exp (%pi * %i));
(%o4)                          %pi
(%i5) carg (exp (3/2 * %pi * %i));
                                %pi
(%o5)                         - ---
                                 2
(%i6) carg (17 * exp (2 * %i));
(%o6)                           2
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c CROSS REF declare, properties, ETC
@deffn {Opereador especial} constant
@code{declare (@var{a}, constant)} declara @var{a} para ser uma constante.
Veja @code{declare}.
@c WHAT EXACTLY ARE THE CONSEQUENCES OF DECLARING AN ATOM TO BE CONSTANT ??

@end deffn

@deffn {Função} constantp (@var{expr})
Retorna @code{true} se @var{expr} for uma expressão constante,
de outra forma retorna @code{false}.
@c WHAT DOES MAXIMA KNOW ABOUT CONSTANT EXPRESSIONS ??

Uma expressão é considerada uma expressão constante se seus argumentos forem
números (incluindo números racionais, como mostrado com @code{/R/}),
constantes simbólicas como @code{%pi}, @code{%e}, e @code{%i},
variáveis associadas a uma constante ou constante declarada através de @code{declare},
ou funções cujos argumentos forem constantes.

@code{constantp} avalia seus argumentos.

Exemplos:

@c ===beg===
@c constantp (7 * sin(2));
@c constantp (rat (17/29));
@c constantp (%pi * sin(%e));
@c constantp (exp (x));
@c declare (x, constant);
@c constantp (exp (x));
@c constantp (foo (x) + bar (%e) + baz (2));
@c ===end===

@example
(%i1) constantp (7 * sin(2));
(%o1)                                true
(%i2) constantp (rat (17/29));
(%o2)                                true
(%i3) constantp (%pi * sin(%e));
(%o3)                                true
(%i4) constantp (exp (x));
(%o4)                                false
(%i5) declare (x, constant);
(%o5)                                done
(%i6) constantp (exp (x));
(%o6)                                true
(%i7) constantp (foo (x) + bar (%e) + baz (2));
(%o7)                                false
(%i8) 
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c THIS ITEM IS EXTREMELY IMPORTANT
@c ENSURE THAT ALL KEYWORDS RECOGNIZED BY declare HAVE THEIR OWN DOCUMENTATION ITEMS !!
@c ALSO: HOW TO FIND THE LIST OF ALL SYMBOLS WHICH HAVE A GIVEN PROPERTY ??
@deffn {Função} declare (@var{a_1}, @var{p_1}, @var{a_2}, @var{p_2}, ...)
Atribui aos átomos ou lista de átomos @var{a_i} a propriedade ou lista de propriedades @var{p_i}.
Quando @var{a_i} e/ou @var{p_i} forem listas,
cada um dos átomos recebe todas as propriedades.

@code{declare} não avalia seus argumentos.
@code{declare} sempre retorna @code{done}.

Como colocado na descrição para cada sinalizador de declaração,
para alguns sinalizadores
@code{featurep(@var{objecto}, @var{recurso})}
retorna @code{true} se @var{objecto} tiver sido declarado para ter @var{recurso}.
Todavia, @code{featurep} não reconhece alguns sinalizadores; isso é um erro.

Veja também @code{features}.

@code{declare} reconhece as seguintes propriedades:

@table @asis
@item @code{evfun}
Torna @var{a_i} conhecido para @code{ev} de forma que a função nomeada por @var{a_i}
é aplicada quando @var{a_i} aparece como um sinalizador argumento de @code{ev}.
Veja @code{evfun}.

@item @code{evflag}
Torna @var{a_i} conhecido para a função @code{ev} de forma que @var{a_i} é associado a @code{true}
durante a execução de @code{ev} quando @var{a_i} aparece como um sinalizador argumento de @code{ev}.
Veja @code{evflag}.

@c OBSOLETE @code{special} (RECONHECIDA POR DECLARE MAS NUNCA USADA EM LUGAR ALGUM)
 
@c OBSOLETE @code{nonarray} (RECONHECIDA POR DECLARE MAS NUNCA USADA EM LUGAR ALGUM)

@item @code{bindtest}
Diz ao Maxima para disparar um erro quando @var{a_i} for avaliado como sendo livre de associação.

@item @code{noun}
Diz ao Maxima para passar @var{a_i} como um substantivo. 
O efeito disso é substituir intâncias de @var{a_i} com @code{'@var{a_i}}
ou @code{nounify(@var{a_i})}, ependendo do contexto.

@item @code{constant}
Diz ao Maxima para considerar @var{a_i} uma constante simbólica.
@c WHAT MAXIMA KNOWS ABOUT SYMBOLIC CONSTANTS IS PRETTY LIMITED
@c DUNNO IF WE WANT TO GET INTO DETAILS HERE. 
@c MAYBE IN THE DOCUMENTATION FOR CONSTANT (IF THERE IS SUCH)

@item @code{scalar}
Diz ao Maxima para considerar @var{a_i} uma variável escalar.

@item @code{nonscalar}
Diz ao Maxima para considerar @var{a_i} uma variável não escalar.
The usual application is to declare a variable as a symbolic vector or matrix.

@item @code{mainvar}
Diz ao Maxima para considerar @var{a_i} uma "variável principal" (@code{mainvar}).
@code{ordergreatp} determina a ordenação de átomos como segue:

(variáveis principais) > (outras variáveis) > (variáveis escalares) > (constantes) > (números)

@item @code{alphabetic}
Diz ao Maxima para reconhecer todos os caracteres em @var{a_i} (que deve ser uma sequência de caracteres) como caractere alfabético.

@item @code{feature}
Diz ao Maxima para reconhecer @var{a_i} como nome de um recurso.
Other atoms may then be declared to have the @var{a_i} property.

@item @code{rassociative}, @code{lassociative}
Diz ao Maxima para reconhecer @var{a_i} como uma funcão associativa a direita ou associativa a esquerda.

@item @code{nary}
Diz ao Maxima para reconhecer @var{a_i} como uma função n-ária (com muitos argumentos).

A declaração @code{nary} não tem o mesmo objectivo que uma chamada à função @code{nary}.
O único efeito de @code{declare(foo, nary)} é para instruir o simplificador do Maxima
a melhorar as próximas expressões,
por exemplo, para simplificar @code{foo(x, foo(y, z))} para @code{foo(x, y, z)}.

@item @code{symmetric}, @code{antisymmetric}, @code{commutative}
Diz ao Maxima para reconhecer @var{a_i} como uma função simétrica ou antisimétrica.
@code{commutative} é o mesmo que @code{symmetric}.

@item @code{oddfun}, @code{evenfun}
Diz ao Maxima para reconhecer @var{a_i} como uma função par ou uma função ímpar.
 
@item @code{outative}
Diz ao Maxima para simplificar expressões @var{a_i}
colocando factores constantes em evidência no primeiro argumento.

Quando @var{a_i} tiver um argumento,
um factor é onsiderado constante se for um literal ou se for declarado como sendo constante.

Quando @var{a_i} tiver dois ou mais argumentos,
um factor é considerado constante
se o segundo argumento for um símbolo
e o factor estiver livre do segundo argumento.

@item @code{multiplicative}
Diz ao Maxima para simplificar expressões do tipo @var{a_i}
através da substituição @code{@var{a_i}(x * y * z * ...)} @code{-->}
@code{@var{a_i}(x) * @var{a_i}(y) * @var{a_i}(z) * ...}.
A substituição é realizada no primeiro argumento somente.

@item @code{additive}
Diz ao Maxima para simplificar expressões do tipo @var{a_i}
através da substituição @code{@var{a_i}(x + y + z + ...)} @code{-->}
@code{@var{a_i}(x) + @var{a_i}(y) + @var{a_i}(z) + ...}.
A substituição é realizada no primeiro argumento somente.

@item @code{linear}
Equivalente a declarar @var{a_i} ao mesmo tempo @code{outative} e @code{additive}.

@c OBSOLETE @code{analytic} (RECOGNIZED BY DECLARE BUT NEVER USED ANYWHERE)
 
@item @code{integer}, @code{noninteger}
Diz ao Maxima para reconhecer @var{a_i} como como uma variável inteira ou como uma variável não inteira.
 
Maxima reconhece os seguintes recursos de objectos:

@item @code{even}, @code{odd}
Diz ao Maxima para reconhecer @var{a_i} como uma variável inteira par ou como uma variável inteira ímpar.

@item @code{rational}, @code{irrational}
Diz ao Maxima para reconhecer @var{a_i} como uma variável real e racional ou como uma variável real e irracional.

@item @code{real}, @code{imaginary}, @code{complex}
Dia ao Maxima para reconhecer @var{a_i} como uma variável real, imaginária pura ou complexa.
 
@item @code{increasing}, @code{decreasing}
Dia ao Maxima para reconhecer @var{a_i} como uma função de incremento ou decremento.
@c MAXIMA FAILS TO DEDUCE F(2) > F(1) FOR INCREASING FUNCTION F
@c AND FAILS TO DEDUCE ANYTHING AT ALL ABOUT DECREASING FUNCTIONS
@c REPORTED AS SF BUG # 1483194

@item @code{posfun}
Diz ao Maxima para reconhecer @var{a_i} como uma função positiva.

@item @code{integervalued}
Diz ao Maxima para reconhecer @var{a_i} como uma função de valores inteiros.

@end table

Exemplos:

Declarações @code{evfun} e @code{evflag}.
@c ===beg===
@c declare (expand, evfun);
@c (a + b)^3;
@c (a + b)^3, expand;
@c declare (demoivre, evflag);
@c exp (a + b*%i);
@c exp (a + b*%i), demoivre;
@c ===end===
@example
(%i1) declare (expand, evfun);
(%o1)                         done
(%i2) (a + b)^3;
                                   3
(%o2)                       (b + a)
(%i3) (a + b)^3, expand;
                     3        2      2      3
(%o3)               b  + 3 a b  + 3 a  b + a
(%i4) declare (demoivre, evflag);
(%o4)                         done
(%i5) exp (a + b*%i);
                             %i b + a
(%o5)                      %e
(%i6) exp (a + b*%i), demoivre;
                      a
(%o6)               %e  (%i sin(b) + cos(b))
@end example

Declaração @code{bindtest}.
@c ===beg===
@c aa + bb;
@c declare (aa, bindtest);
@c aa + bb;
@c aa : 1234;
@c aa + bb;
@c ===end===
@example
(%i1) aa + bb;
(%o1)                        bb + aa
(%i2) declare (aa, bindtest);
(%o2)                         done
(%i3) aa + bb;
aa unbound variable
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) aa : 1234;
(%o4)                         1234
(%i5) aa + bb;
(%o5)                       bb + 1234
@end example

Declaração @code{noun}.
@c ===beg===
@c factor (12345678);
@c declare (factor, noun);
@c factor (12345678);
@c ''%, nouns;
@c ===end===
@example
(%i1) factor (12345678);
                             2
(%o1)                     2 3  47 14593
(%i2) declare (factor, noun);
(%o2)                         done
(%i3) factor (12345678);
(%o3)                   factor(12345678)
(%i4) ''%, nouns;
                             2
(%o4)                     2 3  47 14593
@end example

Declarações @code{constant}, @code{scalar}, @code{nonscalar}, e @code{mainvar}.
@c ===beg===
@c declare (bb, constant);
@c declare (cc, scalar);
@c declare (dd, nonscalar);
@c declare (ee, mainvar);
@c ===end===
@example
@end example

Declaração @code{alphabetic}.
@c ===beg===
@c xx\~yy\`\@ : 1729;
@c declare ("~`@", alphabetic);
@c xx~yy`@ + @yy`xx + `xx@@yy~;
@c listofvars (%);
@c ===end===
@example
(%i1) xx\~yy\`\@@ : 1729;
(%o1)                         1729
(%i2) declare ("~`@@", alphabetic);
(%o2)                         done
(%i3) xx~yy`@@ + @@yy`xx + `xx@@@@yy~;
(%o3)               `xx@@@@yy~ + @@yy`xx + 1729
(%i4) listofvars (%);
(%o4)                  [@@yy`xx, `xx@@@@yy~]
@end example

Declaração @code{feature}.
@c ===beg===
@c declare (FOO, feature);
@c declare (x, FOO);
@c featurep (x, FOO);
@c ===end===
@example
(%i1) declare (FOO, feature);
(%o1)                         done
(%i2) declare (x, FOO);
(%o2)                         done
(%i3) featurep (x, FOO);
(%o3)                         true
@end example

Declarações @code{rassociative} e @code{lassociative}.
@c ===beg===
@c declare (F, rassociative);
@c declare (G, lassociative);
@c ===end===
@example
@end example

Declaração @code{nary}.
@c ===beg===
@c H (H (a, b), H (c, H (d, e)));
@c declare (H, nary);
@c H (H (a, b), H (c, H (d, e)));
@c ===end===
@example
(%i1) H (H (a, b), H (c, H (d, e)));
(%o1)               H(H(a, b), H(c, H(d, e)))
(%i2) declare (H, nary);
(%o2)                         done
(%i3) H (H (a, b), H (c, H (d, e)));
(%o3)                   H(a, b, c, d, e)
@end example

Declarações @code{symmetric} e @code{antisymmetric}.
@c ===beg===
@c S (b, a);
@c declare (S, symmetric);
@c S (b, a);
@c S (a, c, e, d, b);
@c T (b, a);
@c declare (T, antisymmetric);
@c T (b, a);
@c T (a, c, e, d, b);
@c ===end===
@example
(%i1) S (b, a);
(%o1)                        S(b, a)
(%i2) declare (S, symmetric);
(%o2)                         done
(%i3) S (b, a);
(%o3)                        S(a, b)
(%i4) S (a, c, e, d, b);
(%o4)                   S(a, b, c, d, e)
(%i5) T (b, a);
(%o5)                        T(b, a)
(%i6) declare (T, antisymmetric);
(%o6)                         done
(%i7) T (b, a);
(%o7)                       - T(a, b)
(%i8) T (a, c, e, d, b);
(%o8)                   T(a, b, c, d, e)
@end example

Declarações @code{oddfun} e @code{evenfun}.
@c ===beg===
@c o (- u) + o (u);
@c declare (o, oddfun);
@c o (- u) + o (u);
@c e (- u) - e (u);
@c declare (e, evenfun);
@c e (- u) - e (u);
@c ===end===
@example
(%i1) o (- u) + o (u);
(%o1)                     o(u) + o(- u)
(%i2) declare (o, oddfun);
(%o2)                         done
(%i3) o (- u) + o (u);
(%o3)                           0
(%i4) e (- u) - e (u);
(%o4)                     e(- u) - e(u)
(%i5) declare (e, evenfun);
(%o5)                         done
(%i6) e (- u) - e (u);
(%o6)                           0
@end example

Declaração @code{outative}.
@c ===beg===
@c F1 (100 * x);
@c declare (F1, outative);
@c F1 (100 * x);
@c declare (zz, constant);
@c F1 (zz * y);
@c ===end===
@example
(%i1) F1 (100 * x);
(%o1)                       F1(100 x)
(%i2) declare (F1, outative);
(%o2)                         done
(%i3) F1 (100 * x);
(%o3)                       100 F1(x)
(%i4) declare (zz, constant);
(%o4)                         done
(%i5) F1 (zz * y);
(%o5)                       zz F1(y)
@end example

Declaração @code{multiplicative}.
@c ===beg===
@c F2 (a * b * c);
@c declare (F2, multiplicative);
@c F2 (a * b * c);
@c ===end===
@example
(%i1) F2 (a * b * c);
(%o1)                       F2(a b c)
(%i2) declare (F2, multiplicative);
(%o2)                         done
(%i3) F2 (a * b * c);
(%o3)                   F2(a) F2(b) F2(c)
@end example

Declaração @code{additive}.
@c ===beg===
@c F3 (a + b + c);
@c declare (F3, additive);
@c F3 (a + b + c);
@c ===end===
@example
(%i1) F3 (a + b + c);
(%o1)                     F3(c + b + a)
(%i2) declare (F3, additive);
(%o2)                         done
(%i3) F3 (a + b + c);
(%o3)                 F3(c) + F3(b) + F3(a)
@end example

Declaração @code{linear}.
@c ===beg===
@c 'sum (F(k) + G(k), k, 1, inf);
@c declare (nounify (sum), linear);
@c 'sum (F(k) + G(k), k, 1, inf);
@c ===end===
@example
(%i1) 'sum (F(k) + G(k), k, 1, inf);
                       inf
                       ====
                       \
(%o1)                   >    (G(k) + F(k))
                       /
                       ====
                       k = 1
(%i2) declare (nounify (sum), linear);
(%o2)                         done
(%i3) 'sum (F(k) + G(k), k, 1, inf);
                     inf          inf
                     ====         ====
                     \            \
(%o3)                 >    G(k) +  >    F(k)
                     /            /
                     ====         ====
                     k = 1        k = 1
@end example

@end deffn

@c NEEDS WORK
@deffn {Função} disolate (@var{expr}, @var{x_1}, ..., @var{x_n})
é similar a @code{isolate (@var{expr}, @var{x})}
excepto que essa função habilita ao utilizador isolar
mais que uma variável simultâneamente.  Isso pode ser útil, por
exemplo, se se tiver tentado mudar variáveis em uma integração
múltipla, e em mudança de variável envolvendo duas ou mais das
variáveis de integração.  Essa função é chamada automaticamente de
@file{simplification/disol.mac}.  Uma demostração está disponível através de
@code{demo("disol")$}.

@end deffn

@c NEEDS WORK
@deffn {Função} dispform (@var{expr})
Retorna a representação externa de @var{expr} com relação a seu
principal operador.  Isso pode ser útil em conjunção com @code{part} que
também lida com a representação externa.  Suponha que @var{expr} seja -A .
Então a representação interna de @var{expr} é  "*"(-1,A), enquanto que
a representação externa é "-"(A). @code{dispform (@var{expr}, all)} converte a
expressão inteira (não apenas o nível mais alto) para o formato externo.  Por
exemplo, se @code{expr: sin (sqrt (x))}, então @code{freeof (sqrt, expr)} e
@code{freeof (sqrt, dispform (expr))} fornece @code{true}, enquanto
@code{freeof (sqrt, dispform (expr, all))} fornece @code{false}.

@end deffn

@c NEEDS WORK
@deffn {Função} distrib (@var{expr})
Distribue adições sobre produtos.  @code{distrib} difere de @code{expand}
no facto de que @code{distrib} trabalha em somente no nível mais alto de uma expressão, i.e., @code{distrib} não
é recursiva e @code{distrib} é mais rápida que @code{expand}.  @code{distrib} difere de @code{multthru} no
que @code{distrib} expande todas as adições naquele nível.

Exemplos:

@example
(%i1) distrib ((a+b) * (c+d));
(%o1)                 b d + a d + b c + a c
(%i2) multthru ((a+b) * (c+d));
(%o2)                 (b + a) d + (b + a) c
(%i3) distrib (1/((a+b) * (c+d)));
                                1
(%o3)                    ---------------
                         (b + a) (d + c)
(%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                1
(%o4)                 ---------------------
                      b d + a d + b c + a c
@end example

@end deffn

@c NEEDS WORK
@deffn {Função} dpart (@var{expr}, @var{n_1}, ..., @var{n_k})
Selecciona a mesma subexpressão que @code{part}, mas
em lugar de apenas retornar aquela subexpressão como seu valor, isso retorna
a expressão completa com a subexpressão seleccionada mostrada dentro
de uma caixa.  A caixa é actualmente parte da expressão.

@example
(%i1) dpart (x+y/z^2, 1, 2, 1);
                             y
(%o1)                       ---- + x
                               2
                            """
                            "z"
                            """
@end example

@end deffn

@c PROBABLY MORE TO BE SAID HERE
@deffn {Função} exp (@var{x})
Representa função exponencial.  
Instâncias de @code{exp (@var{x})} em uma entrada são simplificadas para @code{%e^@var{x}};
@code{exp} não aparece em expressões simplificadas.

@code{demoivre} se @code{true} faz com que @code{%e^(a + b %i)} simplificar para
@code{%e^(a (cos(b) + %i sin(b)))} se @code{b} for livre de @code{%i}. veja @code{demoivre}.

@code{%emode}, quando @code{true}, 
faz com que @code{%e^(%pi %i x)} seja simplificado. Veja @code{%emode}.

@code{%enumer}, quando @code{true} faz com que @code{%e} seja substituído por
2.718...  quando @code{numer} for @code{true}. Veja @code{%enumer}.

@c NEED EXAMPLES HERE
@end deffn

@defvr {Variável de opção} %emode
Valor por omissão: @code{true}

Quando @code{%emode} for @code{true},
@code{%e^(%pi %i x)} é simplificado como
segue.

@code{%e^(%pi %i x)} simplifica para @code{cos (%pi x) + %i sin (%pi x)} se @code{x} for um inteiro ou
um múltiplo de 1/2, 1/3, 1/4, ou 1/6, e então é adicionalmente simplificado.

Para outro @code{x} numérico,
@code{%e^(%pi %i x)} simplifica para @code{%e^(%pi %i y)} onde @code{y} é @code{x - 2 k}
para algum inteiro @code{k} tal que @code{abs(y) < 1}.  

Quando @code{%emode} for @code{false}, nenhuma
simplificação adicional de @code{%e^(%pi %i x)} é realizada.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Variável de opção} %enumer
Valor por omissão: @code{false}

Quando @code{%enumer} for @code{true},
@code{%e} é substituido por seu valor numérico
2.718...  mesmo que @code{numer} seja @code{true}. 

Quando @code{%enumer} for @code{false}, essa substituição é realizada
somente se o expoente em @code{%e^x} avaliar para um número.

Veja também @code{ev} e @code{numer}.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Variável de opção} exptisolate
Valor por omissão: @code{false}

@c WHAT DOES THIS MEAN EXACTLY ??
@code{exptisolate}, quando @code{true}, faz com que @code{isolate (expr, var)}
examine expoentes de átomos (tais como @code{%e}) que contenham @code{var}.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Variável de opção} exptsubst
Valor por omissão: @code{false}

@code{exptsubst}, quando @code{true}, permite substituições tais como @code{y}
para @code{%e^x} em @code{%e^(a x)}.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Função} freeof (@var{x_1}, ..., @var{x_n}, @var{expr})
@code{freeof (@var{x_1}, @var{expr})}
Retorna @code{true}
se nenhuma subexpressão de @var{expr} for igual a @var{x_1}
ou se @var{x_1} ocorrer somente uma variável que não tenha associação fora da expressão @var{expr},
e retorna @code{false} de outra forma.

@code{freeof (@var{x_1}, ..., @var{x_n}, @var{expr})}
é equivalente a @code{freeof (@var{x_1}, @var{expr}) and ... and freeof (@var{x_n}, @var{expr})}.

Os argumentos @var{x_1}, ..., @var{x_n} 
podem ser nomes de funções e variáveis, nomes subscritos,
operadores (empacotados em aspas duplas), ou expressões gerais.
@code{freeof} avalia seus argumentos.

@code{freeof} opera somente sobre @var{expr} como isso representa (após simplificação e avaliação) e
não tenta determinar se alguma expressão equivalente pode fornecer um resultado diferente.
Em particular, simplificação pode retornar uma expressão equivalente mas diferente que compreende
alguns diferentes elementos da forma original de @var{expr}.

Uma variável é uma variável dummy em uma expressão se não tiver associação fora da expressão.
Variáveis dummy recoreconhecidas através de @code{freeof} são
o índice de um somatório ou produtório, o limite da variável em @code{limit},
a variável de integração na forma de integral definida de @code{integrate},
a variável original em @code{laplace},
variáveis formais em expressoes @code{at},
e argumentos em expressões @code{lambda}.
Variáveis locais em @code{block} não são reconhecidas por @code{freeof} como variáveis dummy;
isso é um bug.

A forma indefinida de @code{integrate} @i{not} é livre de suas variáveis de integração.

@itemize @bullet
@item
Argumentos são nomes de funções, variáveis, nomes subscritos, operadores, e expressões.
@code{freeof (a, b, expr)} é equivalente a
@code{freeof (a, expr) and freeof (b, expr)}.

@example
(%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                 d + c  3
(%o1)                   cos(a ) b      z
                             1
(%i2) freeof (z, expr);
(%o2)                         false
(%i3) freeof (cos, expr);
(%o3)                         false
(%i4) freeof (a[1], expr);
(%o4)                         false
(%i5) freeof (cos (a[1]), expr);
(%o5)                         false
(%i6) freeof (b^(c+d), expr);
(%o6)                         false
(%i7) freeof ("^", expr);
(%o7)                         false
(%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
(%o8)                         true
@end example

@item
@code{freeof} avalia seus argumentos.

@example
(%i1) expr: (a+b)^5$
(%i2) c: a$
(%i3) freeof (c, expr);
(%o3)                         false
@end example

@item
@code{freeof} não considera expressões equivalentes.
Simplificação pode retornar uma expressão equivalente mas diferente.

@example
(%i1) expr: (a+b)^5$
(%i2) expand (expr);
          5        4       2  3       3  2      4      5
(%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
(%i3) freeof (a+b, %);
(%o3)                         true
(%i4) freeof (a+b, expr);
(%o4)                         false
(%i5) exp (x);
                                 x
(%o5)                          %e
(%i6) freeof (exp, exp (x));
(%o6)                         true
@end example

@item Um somatório ou uma integral definida está livre de uma variável dummy.
Uma integral indefinida não é livre de suas variáveis de integração.

@example
(%i1) freeof (i, 'sum (f(i), i, 0, n));
(%o1)                         true
(%i2) freeof (x, 'integrate (x^2, x, 0, 1));
(%o2)                         true
(%i3) freeof (x, 'integrate (x^2, x));
(%o3)                         false
@end example
@end itemize

@end deffn

@c IS THIS DEFINITION CORRECT ??
@deffn {Função} genfact (@var{x}, @var{y}, @var{z})
Retorna o factorial generalizado, definido como
@code{x (x-z) (x - 2 z) ... (x - (y - 1) z)}.  Dessa forma, para integral @var{x},
@code{genfact (x, x, 1) = x!} e @code{genfact (x, x/2, 2) = x!!}.

@end deffn

@deffn {Função} imagpart (@var{expr})
Retorna a parte imaginária da expressão @var{expr}.

@code{imagpart} é uma função computacional,
não uma função de simplificação.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

Veja também @code{abs}, @code{carg}, @code{polarform}, @code{rectform},
e @code{realpart}.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Função} infix (@var{op})
@deffnx {Função} infix (@var{op}, @var{lbp}, @var{rbp})
@deffnx {Função} infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})
Declara @var{op} para ser um operador infixo.
Um operador infixo é uma função de dois argumentos,
com o nome da função escrito entre os argumentos.
Por exemplo, o operador de subtração @code{-} é um operador infixo.

@code{infix (@var{op})} declara @var{op} para ser um operador infixo
com expoentes associados padrão (esquerdo e direito ambos iguais a 180)
e podendo ser qualquer entre prefixado, infixado, posfixado, nário, 
matchfix e nofix (esquerdo e direito ambos iguais a @code{any}).
@c HOW IS pos DIFFERENT FROM lpos AND rpos ??

@code{infix (@var{op}, @var{lbp}, @var{rbp})} declara @var{op} para ser um operador infixo
com expoentes associados esquerdo e directio equilibrados
e podendo ser qualquer entre prefixado, infixado, posfixado, nário, 
matchfix e nofix (esquerdo e direito ambos iguais a @code{any}).

@code{infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})}
declara @var{op} para ser um operdor infixo
com expoentes associados padrão e podendo ser um entre 
prefixado, infixado, posfixado, nário, matchfix e nofix.

A precedência de @var{op} com relação a outros operadores
derivam dos expoentes associados directiro e esquerdo dos operadores em questão.
Se os expoentes associados esquerdo e direito de @var{op} forem ambos maiores
que o expoente associado esquerdo e o direito de algum outro operador,
então @var{op} tem prededência sobre o outro operador.
Se os expoentes associados não forem ambos maior ou menor,
alguma relação mais complicada ocorre.

A associatividade de @var{op} depende de seus expoentes associados.
Maior expoente associado esquerdo (@var{eae}) implica uma instância de
@var{op} é avaliadas antes de outros operadores para sua esquerda em uma expressão,
enquanto maior expoente associado direito (@var{ead}) implica uma instância de
@var{op} é avaliada antes de outros operadores para sua direita em uma expressão.
Dessa forma maior @var{eae} torna @var{op} associativo à direita,
enquanto maior @var{ead} torna @var{op} associativa à esquerda.
Se @var{eae} for igual a @var{ead}, @var{op} é associativa à esquerda.

Veja também @code{Syntax}.

Exemplos:

Se os expoentes associados esquerdo e direito de @var{op} forem ambos maiores
que os expoentes associados à direita e à esquerda de algum outro operador,
então @var{op} tem precedência sobre o outro operador.

@c ===beg===
@c :lisp (get '$+ 'lbp)
@c :lisp (get '$+ 'rbp)
@c infix ("##", 101, 101);
@c "##"(a, b) := sconcat("(", a, ",", b, ")");
@c 1 + a ## b + 2;
@c infix ("##", 99, 99);
@c 1 + a ## b + 2;
@c ===end===
@example
(%i1) :lisp (get '$+ 'lbp)
100
(%i1) :lisp (get '$+ 'rbp)
100
(%i1) infix ("##", 101, 101);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
(%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
(%i3) 1 + a ## b + 2;
(%o3)                       (a,b) + 3
(%i4) infix ("##", 99, 99);
(%o4)                          ##
(%i5) 1 + a ## b + 2;
(%o5)                       (a+1,b+2)
@end example

grande @var{eae} torna @var{op} associativa à direita,
enquanto grande @var{ead} torna @var{op} associativa à esquerda.

@c ===beg===
@c infix ("##", 100, 99);
@c "##"(a, b) := sconcat("(", a, ",", b, ")")$
@c foo ## bar ## baz;
@c infix ("##", 100, 101);
@c foo ## bar ## baz;
@c ===end===
@example
(%i1) infix ("##", 100, 99);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
(%i3) foo ## bar ## baz;
(%o3)                    (foo,(bar,baz))
(%i4) infix ("##", 100, 101);
(%o4)                          ##
(%i5) foo ## bar ## baz;
(%o5)                    ((foo,bar),baz)
@end example

@end deffn

@defvr {Variável de opção} inflag
Velor padrão: @code{false}

Quando @code{inflag} for @code{true}, funções para extração de
partes inspecionam a forma interna de @code{expr}.

Note que o simplificador re-organiza expressões.
Dessa forma @code{first (x + y)} retorna @code{x} se @code{inflag}
for @code{true} e @code{y} se @code{inflag} for @code{false}.
(@code{first (y + x)} fornece os mesmos resultados.)

Também, escolhendo @code{inflag} para @code{true} e chamando @code{part} ou @code{substpart} é
o mesmo que chamar @code{inpart} ou @code{substinpart}.

As funções afectadas pela posição do sinalizador @code{inflag} são:
@code{part}, @code{substpart}, @code{first}, @code{rest}, @code{last}, @code{length},
a estrutura @code{for} ... @code{in},
@code{map}, @code{fullmap}, @code{maplist}, @code{reveal} e @code{pickapart}.

@c NEED EXAMPLES HERE
@end defvr

@c NEEDS WORK
@deffn {Função} inpart (@var{expr}, @var{n_1}, ..., @var{n_k})
É similar a @code{part} mas trabalha sobre a representação
interna da expressão em lugar da forma de exibição e
dessa forma pode ser mais rápida uma vez que nenhuma formatação é realizada.  Cuidado deve ser tomado
com relação à ordem de subexpressões em adições e produtos
(uma vez que a ordem das variáveis na forma interna é muitas vezes diferente
daquela na forma mostrada) e no manuseio com menos unário,
subtração, e divisão (uma vez que esses operadores são removidos da
expressão). @code{part (x+y, 0)} ou @code{inpart (x+y, 0)} retorna @code{+}, embora com o objectivo de
referirse ao operador isso deva ser abraçado por aspas duplas.  Por exemplo
@code{... if inpart (%o9,0) = "+" then ...}.

Exemplos:

@example
(%i1) x + y + w*z;
(%o1)                      w z + y + x
(%i2) inpart (%, 3, 2);
(%o2)                           z
(%i3) part (%th (2), 1, 2);
(%o3)                           z
(%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                  g(x + 1)
(%o4)                 limit   f(x)
                      x -> 0-
(%i5) inpart (%, 1, 2);
(%o5)                       g(x + 1)
@end example

@end deffn

@c NEEDS WORK
@deffn {Função} isolate (@var{expr}, @var{x})
Retorna @var{expr} com subexpressões que são adições e
que não possuem @var{x} substituido por rótulos de expressão intermédia
(esses sendo símbolos at@^omicos como @code{%t1}, @code{%t2}, ...).  Isso é muitas vezes útil
para evitar expansões desnecessárias de subexpressões que não possuam
a variável de interesse.  Uma vez que os rótulos intermédios são associados às
subexpressões eles podem todos ser substituídos de volta por avaliação da
expressão em que ocorrerem.

@code{exptisolate} (valor padrão: @code{false}) se @code{true} fará com que @code{isolate} examine expoentes de
átomos (como @code{%e}) que contenham @var{x}.

@code{isolate_wrt_times} se @code{true}, então @code{isolate} irá também isolar com relação a 
produtos. Veja @code{isolate_wrt_times}.

Faça @code{example (isolate)} para exemplos.

@end deffn

@c NEEDS WORK
@defvr {Variável de opção} isolate_wrt_times
Valor por omissão: @code{false}

Quando @code{isolate_wrt_times} for @code{true}, @code{isolate}
irá também isolar com relação a produtos.  E.g. compare ambas as escolhas do
comutador em

@example
(%i1) isolate_wrt_times: true$
(%i2) isolate (expand ((a+b+c)^2), c);

(%t2)                          2 a


(%t3)                          2 b


                          2            2
(%t4)                    b  + 2 a b + a

                     2
(%o4)               c  + %t3 c + %t2 c + %t4
(%i4) isolate_wrt_times: false$
(%i5) isolate (expand ((a+b+c)^2), c);
                     2
(%o5)               c  + 2 b c + 2 a c + %t4
@end example

@end defvr

@c NEEDS EXAMPLES
@defvr {Variável de opção} listconstvars
Valor por omissão: @code{false}

Quando @code{listconstvars} for @code{true}, isso fará com que @code{listofvars}
inclua @code{%e}, @code{%pi}, @code{%i}, e quaisquer variáveis declaradas contantes na lista
seja retornado se aparecer na expressão que chamar @code{listofvars}.
O comportamento padrão é omitir isso.

@end defvr

@defvr {Variável de opção} listdummyvars
Valor por omissão: @code{true}

Quando @code{listdummyvars} for @code{false}, "variáveis dummy" na
expressão não serão incluídas na lista retornada por @code{listofvars}.
(O significado de "variável dummy" é o mesmo que em @code{freeof}.
"Variáveis dummy" são conceitos matemáticos como o índice de um somatório ou
produtório, a variável limite, e a variável da integral definida.)
Exemplo:

@example
(%i1) listdummyvars: true$
(%i2) listofvars ('sum(f(i), i, 0, n));
(%o2)                        [i, n]
(%i3) listdummyvars: false$
(%i4) listofvars ('sum(f(i), i, 0, n));
(%o4)                          [n]
@end example

@end defvr

@c NEEDS WORK
@deffn {Função} listofvars (@var{expr})
Retorna uma lista de variáveis em @var{expr}.

@code{listconstvars} se @code{true} faz com que @code{listofvars} inclua @code{%e}, @code{%pi},
@code{%i}, e quaisquer variáveis declaradas constantes na lista é retornada se
aparecer em @var{expr}.  O comportamento padrão é omitir isso.

@example
(%i1) listofvars (f (x[1]+y) / g^(2+a));
(%o1)                     [g, a, x , y]
                                  1
@end example

@end deffn

@c NEEDS WORK
@deffn {Função} lfreeof (@var{lista}, @var{expr})
Para cada um dos membros @var{m} de lista, chama @code{freeof (@var{m}, @var{expr})}.
Retorna @code{false} se qualquer chamada a @code{freeof} for feita e @code{true} de outra forma.
@end deffn

@deffn {Função} lopow (@var{expr}, @var{x})
Retorna o menor expoente de @var{x} que explicitamente aparecer em
@var{expr}.  Dessa forma

@example
(%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
(%o1)                       min(a, 2)
@end example

@end deffn

@c NEEDS WORK
@deffn {Função} lpart (@var{rótulo}, @var{expr}, @var{n_1}, ..., @var{n_k})
é similar a @code{dpart} mas usa uma caixa rotulada. Uma caixa
rotulada é similar à que é produzida por @code{dpart} mas a
produzida por @code{lpart} tem o nome na linha do topo.

@end deffn

@c NEEDS WORK
@deffn {Função} multthru (@var{expr})
@deffnx {Função} multthru (@var{expr_1}, @var{expr_2})
Multiplica um factor (que pode ser uma adição) de @var{expr} pelos
outros factores de @var{expr}.  Isto é, @var{expr} é @code{@var{f_1} @var{f_2} ... @var{f_n}}
onde ao menos
um factor, digamos @var{f_i}, é uma soma de termos.  Cada termo naquela soma é
multiplicado por outros factores no produto.  (A saber todos os
factores excepto @var{f_i}).  @code{multthru} não expande somas exponenciais.
Essa função é o caminho mais rápido para distribuir produtos (comutativos
ou não) sobre adições.  Uma vez que quocientes são representados como
produtos @code{multthru} podem ser usados para dividir adições por produtos também.

@code{multthru (@var{expr_1}, @var{expr_2})} multiplica cada termo em @var{expr_2} (que pode ser uma
adição ou uma equção) por @var{expr_1}.  Se @var{expr_1} não for por si mesmo uma adição então essa
forma é equivalente a @code{multthru (@var{expr_1}*@var{expr_2})}.

@example
(%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                      1        x         f(x)
(%o1)             - ----- + -------- - --------
                    x - y          2          3
                            (x - y)    (x - y)
(%i2) multthru ((x-y)^3, %);
                           2
(%o2)             - (x - y)  + x (x - y) - f(x)
(%i3) ratexpand (%);
                           2
(%o3)                   - y  + x y - f(x)
(%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                        10  2              2  2
                 (b + a)   s  + 2 a b s + a  b
(%o4)            ------------------------------
                                  2
                             a b s
(%i5) multthru (%);  /* note que isso não expande (b+a)^10 */
                                        10
                       2   a b   (b + a)
(%o5)                  - + --- + ---------
                       s    2       a b
                           s
(%i6) multthru (a.(b+c.(d+e)+f));
(%o6)            a . f + a . c . (e + d) + a . b
(%i7) expand (a.(b+c.(d+e)+f));
(%o7)         a . f + a . c . e + a . c . d + a . b
@end example

@end deffn

@c NEEDS WORK
@deffn {Função} nounify (@var{f})
Retorna a forma substantiva do nome da função @var{f}.  Isso é
necessário se se quer referir ao nome de uma função verbo como se esse nome
fosse um substantivo.  Note que algumas funções verbos irão retornar sua forma
substantiva senão puderem ser avaliadas para certos argumentos.  A forma substantiva é também
a forma retornada se uma chamada de função é precedida por um apóstrofo.

@end deffn

@c NEEDS WORK
@deffn {Função} nterms (@var{expr})
Retorna o número de termos que @var{expr} pode ter se for
completamente expandida e nenhum cancelamento ou combinação de termos
acontecer.
Note expressões como @code{sin (@var{expr})}, @code{sqrt (@var{expr})}, @code{exp (@var{expr})}, etc.
contam como apenas um termo independentemente de quantos termos @var{expr} tenha (se @var{expr} for uma
adição).

@end deffn

@c NEEDS WORK
@deffn {Função} op (@var{expr})
Retorna o operador principal da expressão @var{expr}.
@code{op (@var{expr})} é equivalente a @code{part (@var{expr}, 0)}. 

@code{op} retorna uma sequência de caracteres se o operador principal for uma
operador interno ou definido pelo utilizador como
prefixado, binário ou n-ário infixo, posfixado, matchfix ou nofix.
De outra forma, se @var{expr} for uma expressão de função subscrita,
@code{op} retorna uma função subscrita;
nesse caso o valor de retorno não é um átomo.
De outro modo, @var{expr} é uma função de array ou uma expressão de função comum,
e @code{op} retorna um símbolo.

@code{op} observa o valor do sinalizador global @code{inflag}.

@code{op} avalia seus argumentos.

Veja também @code{args}.

Exemplos:

@c ===beg===
@c stringdisp: true$
@c op (a * b * c);
@c op (a * b + c);
@c op ('sin (a + b));
@c op (a!);
@c op (-a);
@c op ([a, b, c]);
@c op ('(if a > b then c else d));
@c op ('foo (a));
@c prefix (foo);
@c op (foo a);
@c op (F [x, y] (a, b, c));
@c op (G [u, v, w]);
@c ===end===

@example
(%i1) stringdisp: true$
(%i2) op (a * b * c);
(%o2)                          "*"
(%i3) op (a * b + c);
(%o3)                          "+"
(%i4) op ('sin (a + b));
(%o4)                          sin
(%i5) op (a!);
(%o5)                          "!"
(%i6) op (-a);
(%o6)                          "-"
(%i7) op ([a, b, c]);
(%o7)                          "["
(%i8) op ('(if a > b then c else d));
(%o8)                         "if"
(%i9) op ('foo (a));
(%o9)                          foo
(%i10) prefix (foo);
(%o10)                        "foo"
(%i11) op (foo a);
(%o11)                        "foo"
(%i12) op (F [x, y] (a, b, c));
(%o12)                        F
                               x, y
(%i13) op (G [u, v, w]);
(%o13)                          G
@end example

@end deffn

@c NEEDS WORK
@deffn {Função} operatorp (@var{expr}, @var{op})
@deffnx {Função} operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])

@code{operatorp (@var{expr}, @var{op})} retorna @code{true}
se @var{op} for igual ao operador de @var{expr}.

@code{operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])} retorna @code{true}
se algum elementos de @var{op_1}, ..., @var{op_n} for igual ao operador de @var{expr}.

@end deffn

@c NEEDS WORK
@deffn {Função} optimize (@var{expr})
Retorna uma expressão que produz o mesmo valor e
efeito que @var{expr} mas faz de forma mais eficientemente por evitar a
recomputação de subexpressões comuns.  @code{optimize} também tem o mesmo
efeito de "colapsar" seus argumentos de forma que todas as subexpressões comuns
são compartilhadas.
Faça @code{example (optimize)} para exemplos.

@end deffn

@defvr {Variável de opção} optimprefix
Valor por omissão: @code{%}

@code{optimprefix} é o prefixo usado para símbolos gerados pelo
comando @code{optimize}.

@end defvr

@c NEEDS WORK
@c WHAT DOES ">" MEAN IN THIS CONTEXT ??
@deffn {Função} ordergreat (@var{v_1}, ..., @var{v_n})
Escolhe aliases para as variáveis @var{v_1}, ..., @var{v_n}
tais que @var{v_1} > @var{v_2} > ...  > @var{v_n},
e @var{v_n} > qualquer outra variável não mencionada como um
argumento.

Veja também @code{orderless}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "PRECEDES" MEAN IN THIS CONTEXT ??
@deffn {Função} ordergreatp (@var{expr_1}, @var{expr_2})
Retorna @code{true} se @var{expr_2} precede @var{expr_1} na
ordenação escolhida com a função @code{ordergreat}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "<" MEAN IN THIS CONTEXT ??
@deffn {Função} orderless (@var{v_1}, ..., @var{v_n})
Escolhe aliases para as variáveis @var{v_1}, ..., @var{v_n}
tais que @var{v_1} < @var{v_2} < ...  < @var{v_n},
and @var{v_n} < qualquer outra variável não mencionada como um
argumento.

@c EXPRESS THIS ORDER IN A MORE COMPREHENSIBLE FASHION
Dessa forma a escala de ordenação completa é: constantes numéricas <
constantes declaradas < escalares declarados < primeiro argumento para @code{orderless} <
...  < último argumento para @code{orderless} < variáveis que começam com A < ...
< variáveis que começam com Z < último argumento para @code{ordergreat} <
 ... < primeiro argumento para @code{ordergreat} < @code{mainvar}s - variáveis principais declaradas.

Veja também @code{ordergreat} e @code{mainvar}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "PRECEDES" MEAN IN THIS CONTEXT ??
@deffn {Função} orderlessp (@var{expr_1}, @var{expr_2})
Retorna @code{true} se @var{expr_1} precede @var{expr_2} na
ordenação escolhida pelo comando @code{orderless}.

@end deffn

@c NEEDS WORK
@deffn {Função} part (@var{expr}, @var{n_1}, ..., @var{n_k})
Retorna partes da forma exibida de @code{expr}. Essa função
obtém a parte de @code{expr} como especificado pelos índices @var{n_1}, ..., @var{n_k}.  A primeira
parte @var{n_1} de @code{expr} é obtida, então a parte @var{n_2} daquela  é obtida, etc.  O resultado é
parte @var{n_k} de ... parte @var{n_2} da parte @var{n_1} da @code{expr}.

@code{part} pode ser usada para obter um elemento de uma lista, uma linha de uma matriz, etc.

@c "If the last argument to a part function" => FOLLOWING APPLIES TO OTHER FUNCTIONS ??
@c ATTEMPT TO VERIFY; IF SO, COPY THIS COMMENTARY TO DESCRIPTIONS OF OTHER FUNCTIONS
Se o último argumento para uma função @code{part} for uma lista de índices então
muitas subexpressões serão pinçadas, cada uma correspondendo a um
índice da lista.  Dessa forma @code{part (x + y + z, [1, 3])} é @code{z+x}.

@code{piece} mantém a última expressão seleccionada quando usando as funções
@code{part}.  Isso é escolhido durante a execução da função e dessa forma
pode referir-se à função em si mesma como mostrado abaixo.

Se @code{partswitch} for escolhido para @code{true} então @code{end} é retornado quando uma
parte seleccionada de uma expressão não existir, de outra forma uma mensagem de
erro é forncecida.

@c NEED "SEE ALSO" POINTING TO ALL OTHER PART FUNCTIONS

Exemplo: @code{part (z+2*y, 2, 1)} retorna 2.

@c MERGE IN example (part) OUTPUT HERE
@code{example (part)} mostra exemplos adicionais.

@end deffn

@c NEEDS WORK
@deffn {Função} partition (@var{expr}, @var{x})
Retorna uma lista de duas expressões.  Elas são (1)
os factores de @var{expr} (se essa expressão for um produto), os termos de @var{expr} (se isso for uma
adição), ou a lista (se isso for uma lsita) que não contiver @code{var} e, (2)
os factores, termos, ou lista que faz.

@example
(%i1) partition (2*a*x*f(x), x);
(%o1)                     [2 a, x f(x)]
(%i2) partition (a+b, x);
(%o2)                      [b + a, 0]
(%i3) partition ([a, b, f(a), c], a); 
(%o3)                  [[b, c], [a, f(a)]]
@end example

@end deffn

@c NEEDS EXAMPLE
@defvr {Variável de opção} partswitch
Valor por omissão: @code{false}

Quando @code{partswitch} for @code{true}, @code{end} é retornado
quando uma parte seleccionada de uma expressão não existir, de outra forma uma
mensagem de erro é fornecida.

@end defvr

@deffn {Função} pickapart (@var{expr}, @var{n})
Atribui rótulos de expressão intermédia a subexpressões de
@var{expr} de comprimento @var{n}, um inteiro.
A subexpressões maiores ou menores não são atribuidos rótulos.
@code{pickapart} retorna uma expressão em termos de expressões intermédias
equivalentes à expressão original @var{expr}.

Veja também @code{part}, @code{dpart}, @code{lpart}, @code{inpart}, e @code{reveal}.

Exemplos:

@example
(%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                          2
                                     sin(x )   b + a
(%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2
(%i2) pickapart (expr, 0);

                                          2
                                     sin(x )   b + a
(%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2

(%o2)                          %t2
(%i3) pickapart (expr, 1);

(%t3)                - log(sqrt(x + 1) + 1)


                                  2
                             sin(x )
(%t4)                        -------
                                3


                              b + a
(%t5)                         -----
                                2

(%o5)                    %t5 + %t4 + %t3
(%i5) pickapart (expr, 2);

(%t6)                 log(sqrt(x + 1) + 1)


                                  2
(%t7)                        sin(x )


(%t8)                         b + a

                         %t8   %t7
(%o8)                    --- + --- - %t6
                          2     3
(%i8) pickapart (expr, 3);

(%t9)                    sqrt(x + 1) + 1


                                2
(%t10)                         x

                  b + a              sin(%t10)
(%o10)            ----- - log(%t9) + ---------
                    2                    3
(%i10) pickapart (expr, 4);

(%t11)                     sqrt(x + 1)

                      2
                 sin(x )   b + a
(%o11)           ------- + ----- - log(%t11 + 1)
                    3        2
(%i11) pickapart (expr, 5);

(%t12)                        x + 1

                   2
              sin(x )   b + a
(%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                 3        2
(%i12) pickapart (expr, 6);
                  2
             sin(x )   b + a
(%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                3        2
@end example

@end deffn

@c NEEDS WORK
@defvr {Variável de sistema} piece
Mantém a ultima expressão seleccionada quando usando funções
@code{part}.
@c WHAT DOES THIS MEAN EXACTLY ??
Isso é escolhido durante a execução da função e dessa forma
pode referir-se à função em si mesma.

@c NEED "SEE ALSO" TO POINT TO LIST OF ALL RELEVANT FUNCTIONS

@end defvr

@c NEEDS EXAMPLES
@deffn {Função} polarform (@var{expr})
Retorna uma expressão @code{r %e^(%i theta)} equivalente a @var{expr},
tal que @code{r} e @code{theta} sejam puramente reais.

@end deffn

@c ISN'T THERE AN EQUIVALENT FUNCTION SOMEWHERE ??
@c NEEDS WORK (IF KEPT)
@deffn {Função} powers (@var{expr}, @var{x})
Fornece os expoentes de @var{x} que ocorrem em expressão @var{expr}.

@code{load (powers)} chama essa função.
@c HMM, THERE'S A BUNCH OF MAXIMA FUNCTIONS IN src/powers.lisp ...
@c FOR SOME REASON src/powers.lisp IS NOT PART OF THE USUAL BUILD -- STRANGE

@c HERE IS THE TEXT FROM archive/share/unknown/powers.usg -- MERGE !!!
@c THIS FUNCTION IS A GENERALISATION OF "HIPOW" AND "LOPOW"
@c IN THAT IT RETURNS A LIST OF ALL THE POWERS OF VAR OCCURING
@c IN EXPR. IT IS STILL NECESSARY TO EXPAND EXPR BEFORE APPLYING
@c POWERS (ON PAIN OF GETTING THE WRONG ANSWER).
@c 
@c THIS FUNCTION HAS MANY USES, E.G. IF YOU WANT TO FIND ALL
@c THE COEFFICIENTS OF X IN A POLYNOMIAL POLY YOU CAN USE
@c MAP(LAMBDA([POW],COEFF(POLY,X,POW)),POWERS(POLY,X));
@c AND MANY OTHER SIMILAR USEFUL HACKS.

@end deffn

@c NEEDS WORK
@deffn {Função} product (@var{expr}, @var{i}, @var{i_0}, @var{i_1})
Representa um produto dos velores de @code{expr} com
o índice @var{i} variando de @var{i_0} a @var{i_1}.
A forma substantiva @code{'product} é mostrada como um pi maiísculo.

@code{product} avalia @var{expr} e os limites inferior e superior @var{i_0} e @var{i_1},
@code{product} coloca um apóstrofo (não avalia) o índice @var{i}.

Se os limites superiores e inferiores diferirem por um inteiro,
@var{expr} é avaliada para cada valor do índice @var{i},
e o resultado  um produto explícito.

de outra forma, o intervalo do índice é indefinido.
Algumas regras são aplicads para simplificar o produto.
Quando a variável global @code{simpproduct} for @code{true}, regras adicionais são aplicadas.
Em alguns casos, simplificação um resultado que não é um produto;
de outra forma, o resultado é uma forma substantiva @code{'product}.

Veja também @code{nouns} e @code{evflag}.

Exemplos:

@c ===beg===
@c product (x + i*(i+1)/2, i, 1, 4);
@c product (i^2, i, 1, 7);
@c product (a[i], i, 1, 7);
@c product (a(i), i, 1, 7);
@c product (a(i), i, 1, n);
@c product (k, k, 1, n);
@c product (k, k, 1, n), simpproduct;
@c product (integrate (x^k, x, 0, 1), k, 1, n);
@c product (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===

@example
(%i1) product (x + i*(i+1)/2, i, 1, 4);
(%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
(%i2) product (i^2, i, 1, 7);
(%o2)                       25401600
(%i3) product (a[i], i, 1, 7);
(%o3)                 a  a  a  a  a  a  a
                       1  2  3  4  5  6  7
(%i4) product (a(i), i, 1, 7);
(%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
(%i5) product (a(i), i, 1, n);
                             n
                           /===\
                            ! !
(%o5)                       ! !  a(i)
                            ! !
                           i = 1
(%i6) product (k, k, 1, n);
                               n
                             /===\
                              ! !
(%o6)                         ! !  k
                              ! !
                             k = 1
(%i7) product (k, k, 1, n), simpproduct;
(%o7)                          n!
(%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                             n
                           /===\
                            ! !    1
(%o8)                       ! !  -----
                            ! !  k + 1
                           k = 1
(%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                              15  40
(%o9)                        a   b
@end example

@end deffn

@c NEEDS EXAMPLES
@deffn {Função} realpart (@var{expr})
Retorna a parte real de @var{expr}. @code{realpart} e @code{imagpart} irão
trabalhar sobre expressões envolvendo funções trigonométricas e hiperbólicas,
bem como raízes quadradas, logaritmos, e exponenciação.

@end deffn

@c NEEDS EXAMPLES
@deffn {Função} rectform (@var{expr})
Retorna uma expressão @code{a + b %i} equivalente a @var{expr},
tal que @var{a} e @var{b} sejam puramente reais.

@end deffn

@deffn {Função} rembox (@var{expr}, unlabelled)
@deffnx {Função} rembox (@var{expr}, @var{rótulo})
@deffnx {Função} rembox (@var{expr})
Remove caixas de @var{expr}.

@code{rembox (@var{expr}, unlabelled)} remove todas as caixas sem rótulos de @var{expr}.

@code{rembox (@var{expr}, @var{rótulo})} remove somente caixas contendo @var{rótulo}.

@code{rembox (@var{expr})} remove todas as caixas, rotuladas e nã rotuladas.

Caixas são desenhadas pelas funções @code{box}, @code{dpart}, e @code{lpart}.

Exemplos:

@c ===beg===
@c expr: (a*d - b*c)/h^2 + sin(%pi*x);
@c dpart (dpart (expr, 1, 1), 2, 2);
@c expr2: lpart (BAR, lpart (FOO, %, 1), 2);
@c rembox (expr2, unlabelled);
@c rembox (expr2, FOO);
@c rembox (expr2, BAR);
@c rembox (expr2);
@c ===end===
@example
(%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                  a d - b c
(%o1)                sin(%pi x) + ---------
                                      2
                                     h
(%i2) dpart (dpart (expr, 1, 1), 2, 2);
                        """""""    a d - b c
(%o2)               sin("%pi x") + ---------
                        """""""      """"
                                     " 2"
                                     "h "
                                     """"
(%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                  FOO"""""""""""   BAR""""""""
                  "    """"""" "   "a d - b c"
(%o3)             "sin("%pi x")" + "---------"
                  "    """"""" "   "  """"   "
                  """"""""""""""   "  " 2"   "
                                   "  "h "   "
                                   "  """"   "
                                   """""""""""
(%i4) rembox (expr2, unlabelled);
                                  BAR""""""""
                   FOO"""""""""   "a d - b c"
(%o4)              "sin(%pi x)" + "---------"
                   """"""""""""   "    2    "
                                  "   h     "
                                  """""""""""
(%i5) rembox (expr2, FOO);
                                  BAR""""""""
                       """""""    "a d - b c"
(%o5)              sin("%pi x") + "---------"
                       """""""    "  """"   "
                                  "  " 2"   "
                                  "  "h "   "
                                  "  """"   "
                                  """""""""""
(%i6) rembox (expr2, BAR);
                   FOO"""""""""""
                   "    """"""" "   a d - b c
(%o6)              "sin("%pi x")" + ---------
                   "    """"""" "     """"
                   """"""""""""""     " 2"
                                      "h "
                                      """"
(%i7) rembox (expr2);
                                  a d - b c
(%o7)                sin(%pi x) + ---------
                                      2
                                     h
@end example

@end deffn

@deffn {Função} sum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})
Representa um somatório dos valores de @var{expr} com
o índice @var{i} variando de @var{i_0} a @var{i_1}.
A forma substantiva @code{'sum} é mostrada com uma letra sigma maiúscula.
@code{sum} avalia seu somando @var{expr} e limites inferior e superior @var{i_0} e @var{i_1},
@code{sum} coloca apóstrofo (não avalia) o índice @var{i}.

Se os limites superiores e inferiores diferirem de um número inteiro,
o somatoriando @var{expr} é avaliado para cada valor do índice do somatório @var{i},
e o resultado é uma adição explícita.

De outra forma, o intervalo dos índices é indefinido.
Algumas regras são aplicadas para simplificar o somatório.
Quando a variável global @code{simpsum} for @code{true}, regras adicionais são aplicadas.
Em alguns casos, simplificações retornam um resultado que não é um somatório;
de outra forma, o resultado é uma forma substantiva @code{'sum}.

Quando o @code{evflag} (sinalizador de avaliação) @code{cauchysum} for @code{true},
um produto de somatórios é mostrado como um produto de Cauchy,
no qual o índice do somatório mais interno é uma função de
índice de um nível acima, em lugar de variar independentemente.

A variável global @code{genindex} é o prefixo alfabético usado para gerar o próximo índice do somatório,
quando um índice automaticamente gerado for necessário.

@code{gensumnum} é o sufixo numérico usando para gerar o próximo índice do somatório,
quando um índice gerado automaticamente for necessário.
Quando @code{gensumnum} for @code{false}, um índice gerado automaticamente é somente
@code{genindex} sem sufixo numérico.

Veja também @code{sumcontract}, @code{intosum},
@code{bashindices}, @code{niceindices},
@code{nouns}, @code{evflag}, e @code{zeilberger}.

Exemplos:

@c ===beg===
@c sum (i^2, i, 1, 7);
@c sum (a[i], i, 1, 7);
@c sum (a(i), i, 1, 7);
@c sum (a(i), i, 1, n);
@c sum (2^i + i^2, i, 0, n);
@c sum (2^i + i^2, i, 0, n), simpsum;
@c sum (1/3^i, i, 1, inf);
@c sum (1/3^i, i, 1, inf), simpsum;
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
@c sum (integrate (x^k, x, 0, 1), k, 1, n);
@c sum (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===

@example
(%i1) sum (i^2, i, 1, 7);
(%o1)                          140
(%i2) sum (a[i], i, 1, 7);
(%o2)           a  + a  + a  + a  + a  + a  + a
                 7    6    5    4    3    2    1
(%i3) sum (a(i), i, 1, 7);
(%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
(%i4) sum (a(i), i, 1, n);
                            n
                           ====
                           \
(%o4)                       >    a(i)
                           /
                           ====
                           i = 1
(%i5) sum (2^i + i^2, i, 0, n);
                          n
                         ====
                         \       i    2
(%o5)                     >    (2  + i )
                         /
                         ====
                         i = 0
(%i6) sum (2^i + i^2, i, 0, n), simpsum;
                              3      2
                   n + 1   2 n  + 3 n  + n
(%o6)             2      + --------------- - 1
                                  6
(%i7) sum (1/3^i, i, 1, inf);
                            inf
                            ====
                            \     1
(%o7)                        >    --
                            /      i
                            ====  3
                            i = 1
(%i8) sum (1/3^i, i, 1, inf), simpsum;
                                1
(%o8)                           -
                                2
(%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                              inf
                              ====
                              \     1
(%o9)                      30  >    --
                              /      2
                              ====  i
                              i = 1
(%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                  2
(%o10)                       5 %pi
(%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                            n
                           ====
                           \       1
(%o11)                      >    -----
                           /     k + 1
                           ====
                           k = 1
(%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10));
Incorrect syntax: Too many )'s
else b^k, k, 1, 10))
                  ^
(%i12) linenum:11;
(%o11)                         11
(%i12) sum (integrate (x^k, x, 0, 1), k, 1, n);
                            n
                           ====
                           \       1
(%o12)                      >    -----
                           /     k + 1
                           ====
                           k = 1
(%i13) sum (if k <= 5 then a^k else b^k, k, 1, 10);
          10    9    8    7    6    5    4    3    2
(%o13)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a
@end example

@end deffn

@deffn {Função} lsum (@var{expr}, @var{x}, @var{L})
Representas a adição de @var{expr} a cada elemento @var{x} em @var{L}.

Uma forma substantiva @code{'lsum} é retornada
se o argumento @var{L} não avaliar para uma lista.

Exemplos:

@c ===beg===
@c lsum (x^i, i, [1, 2, 7]);
@c lsum (i^2, i, rootsof (x^3 - 1, x));
@c ===end===
@example
(%i1) lsum (x^i, i, [1, 2, 7]);
                            7    2
(%o1)                      x  + x  + x
(%i2) lsum (i^2, i, rootsof (x^3 - 1, x));
                     ====
                     \      2
(%o2)                 >    i
                     /
                     ====
                                   3
                     i in rootsof(x  - 1, x)
@end example

@end deffn

@deffn {Função} verbify (@var{f})
Retorna a forma verbal da função chamada @var{f}.

Veja também @code{verb}, @code{noun}, e @code{nounify}.

Exemplos:

@c ===beg===
@c verbify ('foo);
@c :lisp $%
@c nounify (foo);
@c :lisp $%
@c ===end===
@example
(%i1) verbify ('foo);
(%o1)                          foo
(%i2) :lisp $%
$FOO
(%i2) nounify (foo);
(%o2)                          foo
(%i3) :lisp $%
%FOO
@end example

@end deffn

