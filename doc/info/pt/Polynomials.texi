@c /Polynomials.texi/1.22/Sun May 21 07:18:29 2006/-ko/
@c FOR THE FUNCTIONS WHICH RETURN A CRE, BE SURE TO MENTION THAT
@menu
* Introdução a Polinómios::  
* Definições para Polinómios::  
@end menu

@node Introdução a Polinómios, Definições para Polinómios, Polinómios, Polinómios
@section Introdução a Polinómios

Polinómios são armazenados no Maxima ou na forma geral ou na
forma de Expressões Racionais Canónicas (CRE).  Essa última é uma forma
padrão, e é usada internamente por operações tais como @code{factor}, @code{ratsimp}, e
assim por diante.

Expressões Racionais Canónicas constituem um tipo de representação
que é especialmente adequado para polinómios expandidos e funções
racionais (também para polinómios parcialmente factorizados e funções
racionais quando RATFAC for escolhida para @code{true}).  Nessa forma CRE uma
ordenação de variáveis (da mais para a menos importante) é assumida para cada
expressão.  Polinómios são representados recursivamente por uma lista
consistindo da variável principal seguida por uma série de pares de
expressões, uma para cada termo do polinómio.  O primeiro membro de
cada par é o expoente da variável principal naquele termo e o
segundo membro é o coeficiente daquele termo que pode ser um número ou
um polinómio em outra variável novamente respresentado nessa forma.  Sendo assim
a parte principal da forma CRE de 3*X^2-1 é (X 2 3 0 -1) e que a parte principal da
forma CRE de 2*X*Y+X-3 é (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assumindo Y como sendo a
variável principal, e é (X 1 (Y 1 2 0 1) 0 -3) assumindo X como sendo a
variável principal. A variável principal é usualmente determineda pela ordem alfabética
reversa.  As "variáveis" de uma expressão CRE não necessariamente devem ser at@^omicas.  De facto
qualquer subexpressão cujo principal operador não for + - * / or ^ com expoente
inteiro será considerado uma "variável" da expressão (na forma CRE) na
qual essa ocorrer.  Por exemplo as variáveis CRE da expressão
X+SIN(X+1)+2*SQRT(X)+1 são X, SQRT(X), e SIN(X+1).  Se o utilizador
não especifica uma ordem de variáveis pelo uso da função RATVARS
Maxima escolherá a alfabética por conta própria.  Em geral, CREs representam
expressões racionais, isto é, razões de polinómios, onde o
numerador e o denominador não possuem factores comuns, e o denominador for
positivo.  A forma interna é essencialmente um par de polinómios (o
numerador e o denominador) precedidos pela lista de ordenação de variável.  Se
uma expressão a ser mostrada estiver na forma CRE ou se contiver quaisquer
subexpressões na forma CRE, o símbolo /R/ seguirá o rótulo da linha.
Veja a função RAT para saber como converter uma expressão para a forma CRE.  Uma
forma CRE extendida é usada para a representação de séries de Taylor.  A
noção de uma expressão racional é extendida de modo que os expoentes das
variáveis podem ser números racionais positivos ou negativos em lugar de apenas
inteiros positivos e os coeficientes podem eles mesmos serem expressões
racionais como descrito acima em lugar de apenas polinómios.  Estes são
representados internamente por uma forma polinomial recursiva que é similar
à forma CRE e é a generalização dessa mesma forma CRE, mas carrega informação
adicional tal com o grau de truncação.  Do mesmo modo que na forma CRE, o
símbolo /T/ segue o rótulo de linha que contém as tais expressões.

@node Definições para Polinómios,  , Introdução a Polinómios, Polinómios
@section Definições para Polinómios

@defvr {Variável de opção} algebraic
Valor Padrão: @code{false}

@code{algebraic} deve ser escolhida para @code{true} com o objectivo de que a
simplificação de inteiros algébricos tenha efeito.

@end defvr

@defvr {Variável de opção} berlefact
Valor Padrão: @code{true}

Quando @code{berlefact} for @code{false} então o algoritmo de factorização de
Kronecker será usado.  De outra forma o algoritmo de Berlekamp, que é o
padrão, será usado.

@end defvr

@c WHAT IS THIS ABOUT EXACTLY ??
@deffn {Função} bezout (@var{p1}, @var{p2}, @var{x})
uma alternativa para o comando @code{resultant}.  Isso
retorna uma matriz.  @code{determinant} dessa matriz é o resultante desejado.

@end deffn

@c REWORD THIS ITEM -- COULD BE MORE CONCISE
@deffn {Função} bothcoef (@var{expr}, @var{x})
Retorna uma lista da qual o primeiro membro é o
coeficiente de @var{x} em @var{expr} (como achado por @code{ratcoef} se @var{expr} está na forma CRE
de outro modo por @code{coeff}) e cujo segundo membro é a parte restante de
@var{expr}.  Isto é, @code{[A, B]} onde @code{@var{expr} = A*@var{x} + B}.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c islinear (expr, x) := block ([c],
@c         c: bothcoef (rat (expr, x), x),
@c         é (freeof (x, c) and c[1] # 0))$
@c islinear ((r^2 - (x - r)^2)/x, x);

@example
(%i1) islinear (expr, x) := block ([c],
        c: bothcoef (rat (expr, x), x),
        é (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
@end example

@end deffn

@deffn {Função} coeff (@var{expr}, @var{x}, @var{n})
Retorna o coeficiente de @code{@var{x}^@var{n}} em @var{expr}.  @var{n} pode ser
omitido se for 1.  @var{x} pode ser um átomo, ou subexpressão completa de
@var{expr} e.g., @code{sin(x)}, @code{a[i+1]}, @code{x + y}, etc. (No último caso a
expressão @code{(x + y)} pode ocorrer em @var{expr}).  Algumas vezes isso pode ser necessário
para expandir ou factorizar @var{expr} com o objectivo de fazer @code{@var{x}^@var{n}} explicito.  Isso não é
realizado por @code{coeff}.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
@c coeff (y + x*%e^x + 1, x, 0);

@example
(%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
(%o1)                      2 a + 1 = 5
(%i2) coeff (y + x*%e^x + 1, x, 0);
(%o2)                         y + 1
@end example

@end deffn

@deffn {Função} combine (@var{expr})
Simplifica a adição @var{expr} por termos combinados com o mesmo
denominador dentro de um termo simples.

@c NEED EXAMPLE HERE
@end deffn

@deffn {Função} content (@var{p_1}, @var{x_1}, ..., @var{x_n})
Retorna uma lista cujo primeiro elemento é
o máximo divisor comum dos coeficientes dos termos do
polinómio @var{p_1} na variável @var{x_n} (isso é o conteúdo) e cujo
segundo elemento é o polinómio @var{p_1} dividido pelo conteúdo.
@c APPEARS TO WORK AS ADVERTISED -- ONLY x_n HAS ANY EFFECT ON THE RESULT
@c WHAT ARE THE OTHER VARIABLES x_1 THROUGH x_{n-1} FOR ??

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c content (2*x*y + 4*x^2*y^2, y);

@example
(%i1) content (2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
@end example

@end deffn

@deffn {Função} denom (@var{expr})
Retorna o denominador da expressão racional @var{expr}.

@end deffn

@deffn {Função} divide (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
calcula o quocietne e o resto
do polinómio @var{p_1} dividido pelo polinómio @var{p_2}, na variável
principal do polinómio, @var{x_n}.
@c SPELL OUT THE PURPOSE OF THE OTHER VARIABLES
As outras variáveis são como na função @code{ratvars}.
O resultado é uma lista cujo primeiro elemento é o quociente
e cujo segundo elemento é o resto.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c divide (x + y, x - y, x);
@c divide (x + y, x - y);

@example
(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
@end example

@noindent
Note que @code{y} é a variável principal no segundo exemplo.

@end deffn

@deffn {Função} eliminate ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_k}])
Elimina variáveis de
equações (ou expressões assumidas iguais a zero) obtendo resultantes
sucessivos. Isso retorna uma lista de @code{@var{n} - @var{k}} expressões com @var{k}
variáveis @var{x_1}, ..., @var{x_k} eliminadas.  Primeiro @var{x_1} é eliminado retornando @code{@var{n} - 1}
expressões, então @code{x_2} é eliminado, etc.  Se @code{@var{k} = @var{n}} então uma expressão simples em uma
lista é retornada livre das variáveis @var{x_1}, ..., @var{x_k}.  Nesse caso @code{solve}
é chamado para resolver a última resultante para a última variável.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr1: 2*x^2 + y*x + z;
@c expr2: 3*x + 5*y - z - 1;
@c expr3: z^2 + x - y^2 + 5;
@c eliminate ([expr3, expr2, expr1], [y, z]);

@example
(%i1) expr1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) expr2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) expr3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate ([expr3, expr2, expr1], [y, z]);
             8         7         6          5          4
(%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                    3         2
                            - 5154 x  - 1291 x  + 7688 x + 15376]
@end example

@end deffn

@deffn {Função} ezgcd (@var{p_1}, @var{p_2}, @var{p_3}, ...)
Retorna uma lista cujo primeiro elemento é o m.d.c. dos
polinómios @var{p_1}, @var{p_2}, @var{p_3}, ...  e cujos restantes elementos são os
polinómios divididos pelo mdc.  Isso sempre usa o algoritmo
@code{ezgcd}.

@end deffn

@defvr {Variável de opção} facexpand
Valor Padrão: @code{true}

@code{facexpand} controla se os factores irredutíveis
retornados por @code{factor} estão na forma expandida (o padrão) ou na forma recursiva
(CRE normal).

@end defvr

@deffn {Função} factcomb (@var{expr})
Tenta combinar os coeficientes de factoriais em @var{expr}
com os próprios factoriais convertendo, por exemplo, @code{(n + 1)*n!}
em @code{(n + 1)!}.

@code{sumsplitfact} se escolhida para @code{false} fará com que @code{minfactorial} seja
aplicado após um @code{factcomb}.

@c Example:
@c UH, THESE ARE THE EXPRESSIONS WHICH WERE GIVEN IN 
@c THE PREVIOUS REVISION OF THIS FILE, BUT IN THIS CASE
@c factcomb HAS NO EFFECT -- I GUESS A DIFFERENT EXAMPLE IS CALLED FOR
@c (n + 1)^b*n!^b;
@c factcomb (%);
@end deffn

@deffn {Função} factor (@var{expr})
@deffnx {Função} factor (@var{expr}, @var{p})

Factoriza a expressão @var{expr}, contendo qualquer número de
variáveis ou funções, em factores irredutíveis sobre os inteiros.
@code{factor (@var{expr}, @var{p})} factoriza @var{expr} sobre o campo dos inteiros com um elemento
adjunto cujo menor polinómio é @var{p}.

@code{factor} usa a função @code{ifactors} para factorizar inteiros.

@code{factorflag} se @code{false} suprime a factorização de factores inteiros
de expressões racionais.

@code{dontfactor} pode ser escolhida para uma lista de variáveis com relação à qual
factorização não é para ocorrer.  (Essa é inicialmente vazia).  Factorização também
não acontece com relação a quaisquer variáveis que são menos
importantes (usando a ordenação de variável assumida pela forma CRE) como
essas na lista @code{dontfactor}.

@code{savefactors} se @code{true} faz com que os factores de uma expressão que
é um produto de factores seja guardada por certas funções com o objectivo de
aumentar a velocidade de futuras factorizações de expressões contendo alguns dos
mesmos factores.

@code{berlefact} se @code{false} então o algoritmo de factorização de Kronecker será
usado de outra forma o algoritmo de Berlekamp, que é o padrão, será
usado.

@code{intfaclim} se @code{true} maxima irá interromper a factorização de
inteiros se nenhum factor for encontrado após tentar divisões e o método rho de
Pollard.  Se escolhida para @code{false} (esse é o caso quando o utilizador chama
@code{factor} explicitamente), a factorização completa do inteiro será
tentada.  A escolha do utilizador para @code{intfaclim} é usada para chamadas
internas a @code{factor}. Dessa forma, @code{intfaclim} pode ser resetada para evitar que o
Maxima gaste um tempo muito longo factorizando inteiros grandes.

Exemplos:
@c EXAMPLES BELOW ADAPTED FROM examples (factor)
@c factor (2^63 - 1);
@c factor (-8*y - 4*x + z^2*(2*y + x));
@c -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
@c block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
@c factor (1 + %e^(3*x));
@c factor (1 + x^4, a^2 - 2);
@c factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
@c (2 + x)/(3 + x)/(b + x)/(c + x)^2;
@c ratsimp (%);
@c partfrac (%, x);
@c map ('factor, %);
@c ratsimp ((x^5 - 1)/(x - 1));
@c subst (a, x, %);
@c factor (%th(2), %);
@c factor (1 + x^12);
@c factor (1 + x^99);

@example
(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
@end example

@end deffn

@defvr {Variável de opção} factorflag
Valor Padrão: @code{false}

@c WHAT IS THIS ABOUT EXACTLY ??
Quando @code{factorflag} for @code{false}, suprime a factorização de
factores inteiros em expressões racionais.

@end defvr

@deffn {Função} factorout (@var{expr}, @var{x_1}, @var{x_2}, ...)
Rearranja a adição @var{expr} em uma adição de
parcelas da forma @code{f (@var{x_1}, @var{x_2}, ...)*g} onde @code{g} é um produto de
expressões que não possuem qualquer @var{x_i} e @code{f} é factorizado.
@c NEED EXAMPLE HERE

@end deffn

@deffn {Função} factorsum (@var{expr})
Tenta agrupar parcelas em factores de @var{expr} que são adições
em grupos de parcelas tais que sua adição é factorável.  @code{factorsum} pode
recuperar o resultado de @code{expand ((x + y)^2 + (z + w)^2)} mas não pode recuperar
@code{expand ((x + 1)^2 + (x + y)^2)} porque os termos possuem variáveis em comum.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
@c factorsum (%);

@example
(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum (%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
@end example

@end deffn

@deffn {Função} fasttimes (@var{p_1}, @var{p_2})
Retorna o produto dos polinómios @var{p_1} e @var{p_2} usando um
algoritmo especial para a multiplicação de polinómios.  @code{p_1} e @code{p_2} podem ser
de várias variáveis, densos, e aproximadamente do mesmo tamanho.  A multiplicação
clássica é de ordem @code{n_1 n_2} onde
@code{n_1} é o grau de @code{p_1}
and @code{n_2} é o grau de @code{p_2}.
@code{fasttimes} é da ordem @code{max (n_1, n_2)^1.585}.

@end deffn

@deffn {Função} fullratsimp (@var{expr})
@code{fullratsimp} aplica
repetidamente @code{ratsimp} seguido por simplificação não racional a uma
expressão até que nenhuma mudança adicional ocorra,
e retorna o resultado.

Quando expressões não racionais estão envolvidas, uma chamada
a @code{ratsimp} seguida como é usual por uma simplificação não racional
("geral") pode não ser suficiente para retornar um resultado simplificado.
Algumas vezes, mais que uma tal chamada pode ser necessária. 
@code{fullratsimp} faz esse processo convenientemente.

@code{fullratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})} aceita um ou
mais argumentos similar a @code{ratsimp} e @code{rat}.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
@c ratsimp (expr);
@c fullratsimp (expr);
@c rat (expr);

@example
(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
@end example

@end deffn

@c SPELL OUT WHAT fullratsubst DOES INSTEAD OF ALLUDING TO ratsubst AND lratsubst
@c THIS ITEM NEEDS MORE WORK
@deffn {Função} fullratsubst (@var{a}, @var{b}, @var{c})
é o mesmo que @code{ratsubst} excepto que essa chama
a si mesma recursivamente sobre esse resultado até que o resultado para de mudar.
Essa função é útil quando a expressão de substituição e a
expressão substituída tenham uma ou mais variáveis em comum.

@code{fullratsubst} irá também aceitar seus argumentos no formato de
@code{lratsubst}.  Isto é, o primeiro argumento pode ser uma substituição simples
de equação ou uma lista de tais equações, enquanto o segundo argumento é a
expressão sendo processada.

@code{load ("lrats")} chama @code{fullratsubst} e @code{lratsubst}.

Exemplos:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c CAN PROBABLY CUT OUT THE lratsubst STUFF (lratsubst HAS ITS OWN DESCRIPTION)
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);
@c ratsubst (b*a, a^2, a^3);
@c fullratsubst (b*a, a^2, a^3);
@c fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
@c fullratsubst (a^2 = b*a, a^3);
@c errcatch (fullratsubst (b*a^2, a^2, a^3));

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} pode realizar multiplas substituições.
@code{lratsubst} é analogo a @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
Se somente uma substituição é desejada, então uma equação
simples pode ser dada como primeiro argumento.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example
@itemize @bullet
@item
@code{fullratsubst} é equivalente a @code{ratsubst}
excepto que essa executa recursivamente até que seu resultado para de mudar.
@end itemize
@example
(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
                                 2
(%o6)                         a b
@end example
@itemize @bullet
@item
@code{fullratsubst} também aceita uma lista de equações ou uma equação
simples como primeiro argumento.
@end itemize
@example
(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
@end example
@itemize @bullet
@item
@c REWORD THIS SENTENCE
@code{fullratsubst} pode causar uma recursão infinita.
@end itemize
@example
(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
@end example

@end deffn

@c GCD IS A VARIABLE AND A FUNCTION
@c THIS ITEM NEEDS A LOT OF WORK
@deffn {Função} gcd (@var{p_1}, @var{p_2}, @var{x_1}, ...)
Retorna o máximo divisor comum entre @var{p_1} e @var{p_2}.
O sinalizador @code{gcd} determina qual algoritmo é empregado.
Escolhendo @code{gcd} para @code{ez}, @code{subres}, @code{red}, ou @code{spmod} selecciona o algoritmo @code{ezgcd},
subresultante @code{prs}, reduzido, ou modular,
respectivamente.  Se @code{gcd} for @code{false} então @code{gcd (@var{p_1}, @var{p_2}, @var{x})} sempre retorna 1
para todo @var{x}.  Muitas funções (e.g.  @code{ratsimp}, @code{factor}, etc.) fazem com que mdc's
sejam feitos implicitamente.  Para polinómios homogêneos é recomendado
que @code{gcd} igual a @code{subres} seja usado.  Para obter o mdc quando uma expressão algébrica está
presente, e.g. @code{gcd (@var{x}^2 - 2*sqrt(2)*@var{x} + 2, @var{x} - sqrt(2))}, @code{algebraic} deve ser
@code{true} e @code{gcd} não deve ser @code{ez}.  @code{subres} é um novo algoritmo, e pessoas
que tenham estado usando a opção @code{red} podem provavelmente alterar isso para
@code{subres}.

O sinalizador @code{gcd}, padrão: @code{subres}, se @code{false} irá também evitar o máximo
divisor comum de ser usado quando expressões são convertidas para a forma de expressão racional
canónica (CRE).  Isso irá algumas vezes aumentar a velocidade dos cálculos se mdc's não são
requeridos.
@c NEEDS EXAMPLES HERE

@end deffn

@c IN NEED OF SERIOUS CLARIFICATION HERE
@deffn {Função} gcdex (@var{f}, @var{g})
@deffnx {Função} gcdex (@var{f}, @var{g}, @var{x})
Retornam uma lista @code{[@var{a}, @var{b}, @var{u}]}
onde @var{u} é o máximo divisor comum (mdc) entre @var{f} e @var{g},
e @var{u} é igual a @code{@var{a} @var{f} + @var{b} @var{g}}.
Os argumentos @var{f} e @var{g} podem ser polinómios de uma variável,
ou de outra forma polinómios em @var{x} uma @b{main}(principal) variável suprida
desde que nós precisamos estar em um domínio de ideal principal para isso trabalhar.
O mdc significa o mdc considerando @var{f} e @var{g} como polinómios de uma única variável com coeficientes
sendo funções racionais em outras variáveis.

@code{gcdex} implementa o algoritmo Euclideano,
onde temos a sequência
of @code{L[i]: [a[i], b[i], r[i]]} que são todos perpendiculares
a @code{[f, g, -1]} e o próximo se é construído como
se @code{q = quotient(r[i]/r[i+1])} então @code{L[i+2]: L[i] - q L[i+1]}, e isso
encerra em @code{L[i+1]} quando o resto @code{r[i+2]} for zero.

@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gcdex (x^2 + 1, x^3 + 4);
@c % . [x^2 + 1, x^3 + 4, -1];

@example
(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
@end example

@c SORRY FOR BEING DENSE BUT WHAT IS THIS ABOUT EXACTLY
Note que o mdc adiante é @code{1}
uma vez que trabalhamos em @code{k(y)[x]}, o @code{y+1} não pode ser esperado em @code{k[y, x]}.

@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gcdex (x*(y + 1), y^2 - 1, x);

@example
(%i1) gcdex (x*(y + 1), y^2 - 1, x);
                               1
(%o1)/R/                 [0, ------, 1]
                              2
                             y  - 1
@end example

@end deffn


@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@deffn {Função} gcfactor (@var{n})
Factoriza o inteiro Gaussiano @var{n} sobre os inteiros Gaussianos, i.e.,
números da forma @code{@var{a} + @var{b} @code{%i}} onde @var{a} e @var{b} são inteiros raconais
(i.e.,  inteiros comuns).  Factorizações são normalizadas fazendo @var{a} e @var{b}
não negativos.
@c NEED EXAMPLES HERE

@end deffn

@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@deffn {Função} gfactor (@var{expr})
Factoriza o polinómio @var{expr} sobre os inteiros de Gauss
(isto é, os inteiros com a unidade imaginária @code{%i} adjunta).
@c "This is like" -- IS IT THE SAME OR NOT ??
Isso é como @code{factor (@var{expr}, @var{a}^2+1)} trocando @var{a} por @code{%i}.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gfactor (x^4 - 1);

@example
(%i1) gfactor (x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
@end example

@end deffn

@c DESCRIBE THIS INDEPENDENTLY OF factorsum
@c THIS ITEM NEEDS MORE WORK
@deffn {Função} gfactorsum (@var{expr})
é similar a @code{factorsum} mas aplica @code{gfactor} em lugar
de @code{factor}.

@end deffn

@deffn {Função} hipow (@var{expr}, @var{x})
Retorna o maior expoente explícito de @var{x} em @var{expr}.
@var{x} pode ser uma variável ou uma expressão geral.
Se @var{x} não aparece em @var{expr},
@code{hipow} retorna @code{0}.

@code{hipow} não considera expressões equivalentes a @code{expr}.
Em particular, @code{hipow} não expande @code{expr},
então @code{hipow (@var{expr}, @var{x})} e @code{hipow (expand (@var{expr}, @var{x}))}
podem retornar diferentes resultados.

Exemplos:

@example
(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
@end example

@end deffn

@defvr {Variável de opção} intfaclim
Valor por omissão: true

Se @code{true}, maxima irá interromper a factorização de
inteiros se nenhum factor for encontrado após tentar divisões e o método rho de
Pollard e a factorização não será completada.

Quando @code{intfaclim} for @code{false} (esse é o caso quando o utilizador
chama @code{factor} explicitamente), a factorização completa será
tentada.  @code{intfaclim} é escolhida para @code{false} quando factores são
calculados em @code{divisors}, @code{divsum} e @code{totient}.
@c ANY OTHERS ??

@c WHAT ARE THESE MYSTERIOUS INTERNAL CALLS ?? (LET'S JUST LIST THE FUNCTIONS INVOLVED)
Chamadas internas a @code{factor} respeitam o valor especificado pelo utilizador para
@code{intfaclim}. Setting @code{intfaclim} to @code{true} may reduce
@code{intfaclim}.  Escolhendo @code{intfaclim} para @code{true} podemos reduzir
o tempo gasto factorizando grandes inteiros.
@c NEED EXAMPLES HERE

@end defvr

@defvr {Variável de opção} keepfloat
Valor Padrão: @code{false}

Quando @code{keepfloat} for @code{true}, evitamos que números
em ponto flutuante sejam racionalizados quando expressões que os possuem
são então convertidas para a forma de expressão racional canónica (CRE).
@c NEED EXAMPLES HERE

@end defvr

@c DESCRIBE lratsubst INDEPENDENTLY OF subst
@c THIS ITEM NEEDS MORE WORK
@deffn {Função} lratsubst (@var{L}, @var{expr})
é análogo a @code{subst (@var{L}, @var{expr})}
excepto que esse usa @code{ratsubst} em lugar de @code{subst}.

O primeiro argumento de
@code{lratsubst} é uma equação ou uma lista de equações idênticas em
formato para que sejam aceitas por @code{subst}.  As
substituições são feitas na ordem dada pela lista de equações,
isto é, da esquerda para a direita.

@code{load ("lrats")} chama @code{fullratsubst} e @code{lratsubst}.

Exemplos:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c THIS STUFF CAN PROBABLY STAND REVISION -- EXAMPLES DON'T SEEM VERY ENLIGHTENING
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} pode realizar multiplas substituições.
@code{lratsubst} é analoga a @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
Se somente uma substituição for desejada, então uma equação
simples pode ser dada como primeiro argumento.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example

@end deffn

@defvr {Variável de opção} modulus
Valor Padrão: @code{false}

Quando @code{modulus} for um número positivo @var{p},
operações sobre os números racionais (como retornado por @code{rat} e funções relacionadas)
são realizadas módulo @var{p},
usando o então chamado sistema de módulo "balanceado"
no qual @code{@var{n} módulo @var{p}} é definido como 
um inteiro @var{k} em @code{[-(@var{p}-1)/2, ..., 0, ..., (@var{p}-1)/2]}
quando @var{p} for ímpar, ou @code{[-(@var{p}/2 - 1), ..., 0, ...., @var{p}/2]} quando @var{p} for par,
tal que @code{@var{a} @var{p} + @var{k}} seja igual a @var{n} para algum inteiro @var{a}.
@c NEED EXAMPLES OF "BALANCED MODULUS" HERE

@c WHAT CAN THIS MEAN ?? IS THE MODULUS STORED WITH THE EXPRESSION ??
@c "... in order to get correct results" -- WHAT DO YOU GET IF YOU DON'T RE-RAT ??
Se @var{expr} já estiver na forma de expressão racional canónica
(CRE) quando @code{modulus} for colocado no seu valor original, então
pode precisar repetir o rat @var{expr}, e.g., @code{expr: rat (ratdisrep
(expr))}, com o objectivo de obter resultados correctos.

Tipicamente @code{modulus} é escolhido para um número primo.
Se @code{modulus} for escolhido para um inteiro não primo positivo,
essa escolha é aceita, mas uma mensagem de alerta é mostrada.
Maxima permitirá que zero ou um inteiro negativo seja atribuído a @code{modulus},
embora isso não seja limpo se aquele tiver quaisquer consequências úteis.

@c NEED EXAMPLES HERE
@end defvr

@c APPARENTLY OBSOLETE: ONLY EFFECT OF $newfac COULD BE TO CAUSE NONEXISTENT FUNCTION NMULTFACT
@c TO BE CALLED (IN FUNCTION FACTOR72 IN src/factor.lisp CIRCA LINE 1400)
@c $newfac NOT USED IN ANY OTHER CONTEXT (ASIDE FROM DECLARATIONS)
@c COMMENT IT OUT NOW, CUT IT ON THE NEXT PASS THROUGH THIS FILE
@c @defvar newfac
@c Default value: @code{false}
@c 
@c When @code{newfac} for @code{true}, @code{factor} will use the new factoring
@c routines.
@c 
@c @end defvar

@deffn {Função} num (@var{expr})
Retorna o numerador de @var{expr} se isso for uma razão.
Se @var{expr} não for uma razão, @var{expr} é retornado.

@code{num} avalia seu argumento.

@c NEED SOME EXAMPLES HERE
@end deffn

@deffn {Função} polydecomp (@var{p}, @var{x})

Decompões o polinómio @var{p} na variável  @var{x}
em uma composição funcional de polinómios em @var{x}.
@code{polydecomp} retorna uma lista @code{[@var{p_1}, ..., @var{p_n}]} tal que

@example
lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x)) ...))
@end example

seja igual a @var{p}.
O grau de @var{p_i} é maior que 1 para @var{i} menor que @var{n}.

Tal decomposição não é única.

Exemplos:

@c ===beg===
@c polydecomp (x^210, x);
@c p : expand (subst (x^3 - x - 1, x, x^2 - a));
@c polydecomp (p, x);
@c ===end===
@example
(%i1) polydecomp (x^210, x);
                          7   5   3   2
(%o1)                   [x , x , x , x ]
(%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                6      4      3    2
(%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
(%i3) polydecomp (p, x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

As seguintes funções compõem @code{L = [e_1, ..., e_n]} como funções em @code{x};
essa funçào é a inversa de @code{polydecomp}:

@c ===beg===
@c compose (L, x) :=
@c   block ([r : x], for e in L do r : subst (e, x, r), r) $
@c ===end===
@example
compose (L, x) :=
  block ([r : x], for e in L do r : subst (e, x, r), r) $
@end example

Re-exprimindo o exemplo acima usando @code{compose}:

@c ===beg===
@c polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
@c ===end===
@example
(%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

Note que apesar de @code{compose (polydecomp (@var{p}, @var{x}), @var{x})}
sempre retornar @var{p} (não expandido),
@code{polydecomp (compose ([@var{p_1}, ..., @var{p_n}], @var{x}), @var{x})} @i{não}
necessáriamente retorna @code{[@var{p_1}, ..., @var{p_n}]}:

@c ===beg===
@c polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
@c polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
@c ===end===
@example
(%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                          2       2
(%o4)                   [x  + 2, x  + 1]
(%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                      2       2
                     x  + 3  x  + 5
(%o5)               [------, ------, 2 x + 1]
                       4       2
@end example

@end deffn

@deffn {Função} quotient (@var{p_1}, @var{p_2})
@deffnx {Função} quotient (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Retorna o polinómio @var{p_1} dividido pelo polinómio @var{p_2}.
Os argumentos @var{x_1}, ..., @var{x_n} são interpretados como em @code{ratvars}.

@code{quotient} retorna o primeiro elemento de uma lista de dois elementos retornada por @code{divide}.

@c NEED SOME EXAMPLES HERE
@end deffn

@c THIS ITEM CAN PROBABLY BE IMPROVED
@deffn {Função} rat (@var{expr})
@deffnx {Função} rat (@var{expr}, @var{x_1}, ..., @var{x_n})
Converte @var{expr} para a forma de expressão racional canónica (CRE) expandindo e
combinando todos os termos sobre um denominador comum e cancelando para fora o
máximo divisor comum entre o numerador e o denominador, também
convertendo números em ponto flutuante para números racionais dentro da
tolerância de @code{ratepsilon}.
As variáveis são ordenadas de acordo com
@var{x_1}, ..., @var{x_n}, se especificado, como em @code{ratvars}.

@code{rat} geralmente não simplifica funções outras que não sejam
adição @code{+}, subtração @code{-}, multiplicação @code{*}, divisão @code{/}, e
exponenciação com expoente inteiro,
uma vez que @code{ratsimp} não manuseia esses casos.
Note que átomos (números e variáveis) na forma CRE não são os
mesmos que eles são na forma geral.
Por exemplo, @code{rat(x)- x} retorna 
@code{rat(0)} que tem uma representação interna diferente de 0.

@c WHAT'S THIS ABOUT EXACTLY ??
Quando @code{ratfac} for @code{true}, @code{rat} retorna uma forma parcialmente factorizada para CRE.
Durante operações racionais a expressão é
mantida como totalmente factorizada como possível sem uma chamada ao
pacote de factorização (@code{factor}).  Isso pode sempre economizar espaço de memória e algum tempo
em algumas computações.  O numerador e o denominador são ainda tidos como
relativamente primos
(e.g.  @code{rat ((x^2 - 1)^4/(x + 1)^2)} retorna @code{(x - 1)^4 (x + 1)^2)},
mas os factores dentro de cada parte podem não ser relativamente primos.

@code{ratprint} se @code{false} suprime a impressão de mensagens
informando o utilizador de conversões de números em ponto flutuante para
números racionais.

@code{keepfloat} se @code{true} evita que números em ponto flutuante sejam
convertidos para números racionais.

Veja também @code{ratexpand} e  @code{ratsimp}.

Exemplos:
@c FOLLOW GENERATED FROM THESE EXPRESSIONS
@c ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
@c rat (%, y, a, x);

@example
(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
@end example

@end deffn

@defvr {Variável de opção} ratalgdenom
Valor Padrão: @code{true}

Quando @code{ratalgdenom} for @code{true}, permite racionalização de
denominadores com respeito a radicais tenham efeito.
@code{ratalgdenom} tem efeito somente quando expressões racionais canónicas (CRE) forem usadas no modo algébrico.

@end defvr

@c THIS ITEM NEEDS MORE WORK
@deffn {Função} ratcoef (@var{expr}, @var{x}, @var{n})
@deffnx {Função} ratcoef (@var{expr}, @var{x})
Retorna o coeficiente da expressão @code{@var{x}^@var{n}}
dentro da expressão @var{expr}.
Se omitido, @var{n} é assumido ser 1.

O valor de retorno está livre
(excepto possivelmente em um senso não racional) das variáveis em @var{x}.
Se nenhum coeficiente desse tipo existe, 0 é retornado.

@code{ratcoef}
expande e simplifica racionalmente seu primeiro argumento e dessa forma pode
produzir respostas diferentes das de @code{coeff} que é puramente
sintática.
@c MOVE THIS TO EXAMPLES SECTION
Dessa forma @code{ratcoef ((x + 1)/y + x, x)} retorna @code{(y + 1)/y} ao passo que @code{coeff} retorna 1.

@code{ratcoef (@var{expr}, @var{x}, 0)}, visualiza @var{expr} como uma adição,
retornando uma soma desses termos que não possuem @var{x}.
@c "SHOULD NOT" -- WHAT DOES THIS MEAN ??
portanto se @var{x} ocorre para quaisquer expoentes negativos, @code{ratcoef} pode não ser usado.

@c WHAT IS THE INTENT HERE ??
Uma vez que @var{expr} é racionalmente
simplificada antes de ser examinada, coeficientes podem não aparecer inteiramente
no caminho que eles foram pensados.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c s: a*x + b*x + 5$
@c ratcoef (s, a + b);

@example
(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
@end example
@c NEED MORE EXAMPLES HERE

@end deffn

@deffn {Função} ratdenom (@var{expr})
Retorna o denominador de @var{expr},
após forçar a conversão de @var{expr} para expressão racional canónica (CRE).
O valor de retorno é a CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
@var{expr} é forçada para uma CRE por @code{rat}
se não for já uma CRE.
Essa conversão pode mudar a forma de @var{expr} colocando todos os termos
sobre um denominador comum.

@code{denom} é similar, mas retorna uma expressão comum em lugar de uma CRE.
Também, @code{denom} não tenta colocar todos os termos sobre um denominador comum,
e dessa forma algumas expressões que são consideradas razões por @code{ratdenom}
não são consideradas razões por @code{denom}.

@c NEEDS AN EXAMPLE HERE
@end deffn

@defvr {Variável de opção} ratdenomdivide
Valor Padrão: @code{true}

Quando @code{ratdenomdivide} for @code{true},
@code{ratexpand} expande uma razão cujo o numerador for uma adição 
dentro de uma soma de razões,
tendo todos um denominador comum.
De outra forma, @code{ratexpand} colapsa uma adição de razões dentro de uma razão simples,
cujo numerador seja a adição dos numeradores de cada razão.

Exemplos:

@example
(%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                            2
                           x  + x + 1
(%o1)                      ----------
                              2
                             y  + 7
(%i2) ratdenomdivide: true$
(%i3) ratexpand (expr);
                       2
                      x        x        1
(%o3)               ------ + ------ + ------
                     2        2        2
                    y  + 7   y  + 7   y  + 7
(%i4) ratdenomdivide: false$
(%i5) ratexpand (expr);
                            2
                           x  + x + 1
(%o5)                      ----------
                              2
                             y  + 7
(%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                     2
                           b        a
(%o6)                    ------ + ------
                          2        2
                         b  + 3   b  + 3
(%i7) ratexpand (expr2);
                                  2
                             b + a
(%o7)                        ------
                              2
                             b  + 3
@end example

@end defvr

@deffn {Função} ratdiff (@var{expr}, @var{x})
Realiza a derivação da expressão racional @var{expr} com relação a @var{x}.
@var{expr} deve ser uma razão de polinómios ou um polinómio em @var{x}.
O argumento @var{x} pode ser uma variável ou uma subexpressão de @var{expr}.
@c NOT CLEAR (FROM READING CODE) HOW x OTHER THAN A VARIABLE IS HANDLED --
@c LOOKS LIKE (a+b), 10*(a+b), (a+b)^2 ARE ALL TREATED LIKE (a+b);
@c HOW TO DESCRIBE THAT ??

O resultado é equivalente a @code{diff}, embora talvez em uma forma diferente.
@code{ratdiff} pode ser mais rápida que @code{diff}, para expressões racionais.

@code{ratdiff} retorna uma expressão racional canónica (CRE) se @code{expr} for uma CRE.
De outra forma, @code{ratdiff} retorna uma expressão geral.

@code{ratdiff} considera somente as dependências de @var{expr} sobre @var{x},
e ignora quaisquer dependências estabelecidas por @code{depends}.

@c WHAT THIS IS ABOUT -- ratdiff (rat (factor (expr)), x) AND ratdiff (factor (rat (expr)), x) BOTH SUCCEED
@c COMMENTING THIS OUT UNTIL SOMEONE CAN ESTABLISH SOME CRE'S FOR WHICH ratdiff FAILS
@c However, @code{ratdiff} should not be used on factored CRE forms;
@c use @code{diff} instead for such expressões.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
@c ratdiff (expr, x);
@c expr: f(x)^3 - f(x)^2 + 7;
@c ratdiff (expr, f(x));
@c expr: (a + b)^3 + (a + b)^2;
@c ratdiff (expr, a + b);

@example
(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) ratdiff (expr, x);
                    7       5       4       2
                 8 x  + 40 x  - 55 x  - 60 x  - 50
(%o2)          - ---------------------------------
                          10       5
                         x   + 10 x  + 25
(%i3) expr: f(x)^3 - f(x)^2 + 7;
                         3       2
(%o3)                   f (x) - f (x) + 7
(%i4) ratdiff (expr, f(x));
                           2
(%o4)                   3 f (x) - 2 f(x)
(%i5) expr: (a + b)^3 + (a + b)^2;
                              3          2
(%o5)                  (b + a)  + (b + a)
(%i6) ratdiff (expr, a + b);
                    2                    2
(%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a
@end example

@end deffn

@deffn {Função} ratdisrep (@var{expr})
Retorna seu argumento como uma expressão geral.
Se @var{expr} for uma expressão geral, é retornada inalterada.

Tipicamente @code{ratdisrep} é chamada para converter uma expressão racional canónica (CRE)
em uma expressão geral.
@c NOT REALLY FOND OF YOU-CAN-DO-THIS-YOU-CAN-DO-THAT STATEMENTS
Isso é algumas vezes conveniente se deseja-se parar o "contágio", ou
caso se esteja usando funções racionais em contextos não racionais.

Veja também @code{totaldisrep}.

@end deffn

@defvr {Variável de opção} ratepsilon
Valor Padrão: 2.0e-8

@code{ratepsilon} é a tolerância usada em conversões
de números em ponto flutuante para números racionais.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Função} ratexpand (@var{expr})
@deffnx {Variável de opção} ratexpand
Expande @var{expr} multiplicando para fora produtos de somas e
somas exponenciadas, combinando frações sobre um denominador comum,
cancelando o máximo divisor comum entre entre o numerador e o
denominador, então quebrando o numerador (se for uma soma) dentro de suas
respectivas parcelas divididas pelo denominador.

O valor de retorno de @code{ratexpand} é uma expressão geral,
mesmo se @var{expr} for uma expressão racional canónica (CRE).

@c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
O comutador @code{ratexpand} se @code{true} fará com que expressões
CRE sejam completamente expandidas quando forem convertidas de volta para
a forma geral ou mostradas, enquanto se for @code{false} então elas serão colocadas
na forma recursiva.
Veja também @code{ratsimp}.

Quando @code{ratdenomdivide} for @code{true},
@code{ratexpand} expande uma razão na qual o numerador é uma adição
dentro de uma adição de razões,
todas tendo um denominador comum.
De outra forma, @code{ratexpand} contrai uma soma de razões em uma razão simples,
cujo numerador é a soma dos numeradores de cada razão.

Quando @code{keepfloat} for @code{true}, evita que números
em ponto flutuante sejam racionalizados quando expressões que contenham
números em ponto flutuante forem convertidas para a forma de expressão racional canónica (CRE).

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratexpand ((2*x - 3*y)^3);
@c expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
@c expand (expr);
@c ratexpand (expr);

@example
(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
@end example

@end deffn

@defvr {Variável de opção} ratfac
Valor Padrão: @code{false}

Quando @code{ratfac} for @code{true},
expressões racionais canónicas (CRE) são manipuladas na forma parcialmente factorizada.

Durante operações racionais a
expressão é mantida como completamente factorizada como foi possível sem chamadas a @code{factor}.
Isso pode sempre economizar espaço e pode economizar tempo em algumas computações.
O numerador e o denominador são feitos relativamente primos, por exemplo
@code{rat ((x^2 - 1)^4/(x + 1)^2)} retorna @code{(x - 1)^4 (x + 1)^2)},
mas o factor dentro de cada parte pode não ser relativamente primo.

No pacote @code{ctensor} (Manipulação de componentes de tensores),
tensores de Ricci, Einstein, Riemann, e de Weyl e a curvatura escalar 
são factorizados automaticamente quando @code{ratfac} for @code{true}.
@i{@code{ratfac} pode somente ser
escolhido para casos onde as componentes tensoriais sejam sabidametne consistidas de
poucos termos.}

Os esquemas de @code{ratfac} e de @code{ratweight} são incompatíveis e não podem
ambos serem usados ao mesmo tempo.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Função} ratnumer (@var{expr})
Retorna o numerador de @var{expr},
após forçar @var{expr} para uma expressão racional canónica (CRE).
O valor de retorno é uma CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
@var{expr} é forçada para uma CRE por @code{rat}
se isso não for já uma CRE.
Essa conversão pode alterar a forma de @var{expr} pela colocação de todos os termos
sobre um denominador comum.

@code{num} é similar, mas retorna uma expressão comum em lugar de uma CRE.
Também, @code{num} não tenta colocar todos os termos sobre um denominador comum,
e dessa forma algumas expressões que são consideradas razões por @code{ratnumer}
não são consideradas razões por @code{num}.

@c NEEDS AN EXAMPLE HERE
@end deffn

@deffn {Função} ratnump (@var{expr})
Retorna @code{true} se @var{expr} for um inteiro literal ou razão de inteiros literais,
de outra forma retorna @code{false}.

@end deffn

@deffn {Função} ratp (@var{expr})
Retorna @code{true} se @var{expr} for uma expressão racional canónica (CRE) ou CRE extendida,
de outra forma retorna @code{false}.

CRE são criadas por @code{rat} e funções relacionadas.
CRE extendidas são criadas por @code{taylor} e funções relacionadas.

@end deffn

@defvr {Variável de opção} ratprint
Valor Padrão: @code{true}

Quando @code{ratprint} for @code{true},
uma mensagem informando ao utilizador da conversão de números em ponto flutuante
para números racionais é mostrada.

@end defvr

@deffn {Função} ratsimp (@var{expr})
@deffnx {Função} ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})
Simplifica a expressão @var{expr} e todas as suas subexpressões,
incluindo os argumentos para funções não racionais.
O resultado é retornado como o quociente de dois polinómios na forma recursiva,
isto é, os coeficientes de variável principal são polinómios em outras variáveis.
Variáveis podem incluir funções não racionais (e.g., @code{sin (x^2 + 1)})
e os argumentos para quaisquer tais funções são também simplificados racionalmente.

@code{ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})}
habilita simplificação racional com a
especiicação de variável ordenando como em @code{ratvars}.

Quando @code{ratsimpexpons} for @code{true},
@code{ratsimp} é aplicado para os expoentes de expressões durante a simplificação.

Veja também @code{ratexpand}.
Note que @code{ratsimp} é afectado por algum dos
sinalizadores que afectam @code{ratexpand}.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
@c ratsimp (%);
@c ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
@c ratsimp (%);
@c x^(a + 1/a), ratsimpexpons: true;

@example
(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
(%i4) ratsimp (%);
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
@end example

@end deffn

@defvr {Variável de opção} ratsimpexpons
Valor Padrão: @code{false}

Quando @code{ratsimpexpons} for @code{true},
@code{ratsimp} é aplicado para os expoentes de expressões durante uma simplificação.

@c NEED AN EXAMPLE HERE -- RECYCLE THE ratsimpexpons EXAMPLE FROM ratsimp ABOVE
@end defvr

@deffn {Função} ratsubst (@var{a}, @var{b}, @var{c})
Substitue @var{a} por @var{b} em @var{c} e retorna a expressão resultante. 
@c "ETC" SUGGESTS THE READER KNOWS WHAT ELSE GOES THERE -- NOT LIKELY THE CASE
@var{b} pode também ser uma adição, produto, expoente, etc.

@c WHAT, EXACTLY, DOES ratsubst KNOW ??
@code{ratsubst} sabe alguma coisa do significado de expressões
uma vez que @code{subst} não é uma substituição puramente sintática.
Dessa forma @code{subst (a, x + y, x + y + z)} retorna @code{x + y + z}
ao passo que @code{ratsubst} retorna @code{z + a}.

Quando @code{radsubstflag} for @code{true},
@code{ratsubst} faz substituição de radicais em expressões
que explicitamente não possuem esses radicais.

Exemplos:
@c EXAMPLES BELOW ADAPTED FROM examples (ratsubst)
@c WITH SOME ADDITIONAL STUFF
@c ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
@c cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
@c ratsubst (1 - sin(x)^2, cos(x)^2, %);
@c ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
@c radsubstflag: false$
@c ratsubst (u, sqrt(x), x);
@c radsubstflag: true$
@c ratsubst (u, sqrt(x), x);

@example
(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
(%i5) radsubstflag: false$
(%i6) ratsubst (u, sqrt(x), x);
(%o6)                           x
(%i7) radsubstflag: true$
(%i8) ratsubst (u, sqrt(x), x);
                                2
(%o8)                          u
@end example

@end deffn

@deffn {Função} ratvars (@var{x_1}, ..., @var{x_n})
@deffnx {Função} ratvars ()
@deffnx {Variável de sistema} ratvars
Declara variáveis principais @var{x_1}, ..., @var{x_n} para expressões racionais.
@var{x_n}, se presente em uma expressão racional, é considerada a variável principal.
De outra forma, @var{x_[n-1]} é considerada a variável principal se presente,
e assim por diante até as variáveis precedentes para @var{x_1},
que é considerada a variável principal somente se nenhuma das variáveis que a sucedem estiver presente.

Se uma variável em uma expressão racional não está presente na lista @code{ratvars},
a ela é dada uma prioridade menor que @var{x_1}.

Os argumentos para @code{ratvars} podem ser ou variáveis ou funções não racionais
tais como @code{sin(x)}.

A variável @code{ratvars} é uma lista de argumentos da
função @code{ratvars} quando ela foi chamada mais recentemente.
Cada chamada para a função @code{ratvars} sobre-grava a lista apagando seu conteúdo anterior.
@code{ratvars ()} limpa a lista.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Função} ratweight (@var{x_1}, @var{w_1}, ..., @var{x_n}, @var{w_n})
@deffnx {Função} ratweight ()
Atribui um peso @var{w_i} para a variável @var{x_i}.
Isso faz com que um termo seja substituído por 0 se seu peso exceder o
valor da variável @code{ratwtlvl} (o padrão retorna sem truncação).
O peso de um termo é a soma dos produtos dos
pesos de uma variável no termo vezes seu expoente.
Por exemplo, o peso de @code{3 x_1^2 x_2} é @code{2 w_1 + w_2}.
A truncação de acordo com @code{ratwtlvl} é realizada somente quando multiplicando
ou exponencializando expressões racionais canónicas (CRE).

@code{ratweight ()} retorna a lista cumulativa de atribuições de pesos.

Nota: Os esquemas de @code{ratfac} e @code{ratweight} são incompatíveis e não podem
ambo serem usados ao mesmo tempo.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratweight (a, 1, b, 1);
@c expr1: rat(a + b + 1)$
@c expr1^2;
@c ratwtlvl: 1$
@c expr1^2;

@example
(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
@end example

@end deffn

@defvr {Variável de sistema} ratweights
Valor Padrão: @code{[]}

@code{ratweights} é a lista de pesos atribuídos por @code{ratweight}.
A lista é cumulativa:
cada chamada a @code{ratweight} coloca ítens adicionais na lista.

@c DO WE REALLY NEED TO MENTION THIS ??
@code{kill (ratweights)} e @code{save (ratweights)} ambos trabalham como esperado.

@end defvr

@defvr {Variável de opção} ratwtlvl
Valor Padrão: @code{false}

@code{ratwtlvl} é usada em combinação com a função 
@code{ratweight} para controlar a truncação de expressão racionais canónicas (CRE).
Para o valor padrão @code{false}, nenhuma truncação ocorre.

@end defvr

@deffn {Função} remainder (@var{p_1}, @var{p_2})
@deffnx {Função} remainder (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Retorna o resto do polinómio @var{p_1} dividido pelo polinómio @var{p_2}.
Os argumentos @var{x_1}, ..., @var{x_n} são interpretados como em @code{ratvars}.

@code{remainder} retorna o segundo elemento
de uma lista de dois elementos retornada por @code{divide}.

@c NEED SOME EXAMPLES HERE
@end deffn

@c CAN PROBABLY BE CLARIFIED
@deffn {Função} resultant (@var{p_1}, @var{p_2}, @var{x})
@deffnx {Variável} resultant
Calcula o resultante de dois polinómios @var{p_1} e @var{p_2},
eliminando a variável @var{x}.
O resultante é um determinante dos coeficientes de @var{x}
em @var{p_1} e @var{p_2},
que é igual a zero
se e somente se @var{p_1} e @var{p_2} tiverem um factor em comum não constante.

Se @var{p_1} ou @var{p_2} puderem ser factorizados,
pode ser desejável chamar @code{factor} antes de chamar @code{resultant}.

A variável @code{resultant} controla que algoritmo será usado para calcular
o resultante.
@c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
@code{subres} para o prs subresultante,
@code{mod} para o algoritmo resultante modular,
e @code{red} para prs reduzido.
Para muitos problemas @code{subres} pode ser melhor.
Para alguns problemas com valores grandes de grau de uma única variável ou de duas variáveis @code{mod} pode ser melhor.

A função @code{bezout} aceita os mesmos argumentos que @code{resultant} e retorna
uma matriz.  O determinante do valor de retorno é o resultante desejado.

@c NEED AN EXAMPLE HERE
@end deffn

@defvr {Variável de opção} savefactors
Valor Padrão: @code{false}

@c "certain functions" -- WHICH ONES ??
Quando @code{savefactors} for @code{true}, faz com que os factores de uma
expressão que é um produto de factores sejam gravados por certas
funções com o objectivo de aumentar a velocidade em posteriores factorizações de expressões
contendo algum desses mesmos factores.

@end defvr

@c I CAN'T TELL WHAT THIS IS SUPPOSED TO BE ABOUT
@deffn {Função} sqfr (@var{expr})
é similar a @code{factor} excepto que os factores do polinómio são "livres de raízes".
Isto é, eles possuem factores somente de grau um.
Esse algoritmo, que é também usado no primeiro estágio de @code{factor}, utiliza
o facto que um polinómio tem em comum com sua n'ésima derivada todos
os seus factores de grau maior que n.  Dessa forma obtendo o maior divisor comum
com o polinómio das
derivadas com relação a cada variável no polinómio, todos
os factores de grau maior que 1 podem ser achados.

Exemplo:
@c FOLLOWING GENERATED FROM THIS EXPRESSION
@c sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);

@example
(%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                2   2
(%o1)                  (2 x + 1)  (x  - 1)
@end example

@end deffn

@c THIS ITEM STILL NEEDS WORK
@deffn {Função} tellrat (@var{p_1}, ..., @var{p_n})
@deffnx {Função} tellrat ()
Adiciona ao anel dos inteiros algébricos conhecidos do Maxima
os elementos que são as soluções dos polinómios @var{p_1}, ..., @var{p_n}.
Cada argumento @var{p_i} é um polinómio concoeficientes inteiros.

@code{tellrat (@var{x})} efectivamente significa substituir 0 por @var{x} em funções
racionais.

@code{tellrat ()} retorna uma lista das substituições correntes.

@code{algebraic} deve ser escolhida para @code{true} com o objectivo de que a simplificação de
inteiros algébricos tenha efeito.

Maxima inicialmente sabe sobre a unidade imaginária @code{%i}
e todas as raízes de inteiros.

Existe um comando @code{untellrat} que recebe núcleos e
remove propriedades @code{tellrat}.

Quando fazemos @code{tellrat} em um polinómio
de várias variáveis, e.g., @code{tellrat (x^2 - y^2)}, pode existir uma ambiguidade como para
ou substituir @code{@var{y}^2} por @code{@var{x}^2}
ou vice-versa.  
Maxima selecciona uma ordenação particular, mas se o utilizador desejar especificar qual e.g.
@code{tellrat (y^2 = x^2)} forneçe uma sintaxe que diga para substituir
@code{@var{y}^2} por @code{@var{x}^2}.

@c CAN'T TELL WHAT THIS IS ABOUT -- tellrat(w^3-1)$ algebraic:true$ rat(1/(w^2-w));
@c DOES NOT YIELD AN ERROR, SO WHAT IS THE POINT ABOUT ratalgdenom ??
@c When you @code{tellrat} reducible polinomials, you want to be careful not to
@c attempt to rationalize a denominador with a zero divisor.  E.g.
@c tellrat(w^3-1)$ algebraic:true$ rat(1/(w^2-w)); will give "quotient by
@c zero".  This error can be avoided by setting @code{ratalgdenom} to @code{false}.

Exemplos:
@c EXAMPLE ADAPTED FROM example (tellrat)
@c 10*(%i + 1)/(%i + 3^(1/3));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (1 + a + a^2);
@c 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (y^2 = x^2);

@example
(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
@end example

@end deffn

@deffn {Função} totaldisrep (@var{expr})
Converte toda subexpressão de @var{expr} da forma de expressão racionais canónicas (CRE) para
a forma geral e retorna o resultado.
Se @var{expr} é em sí mesma na forma CRE então @code{totaldisrep} é identica a
@code{ratdisrep}.

@code{totaldisrep} pode ser usada para
fazer um @code{ratdisrep} em expressões tais como equações, listas, matrizes, etc., que
tiverem algumas subexpressões na forma CRE.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Função} untellrat (@var{x_1}, ..., @var{x_n})
Remove propriedades @code{tellrat} de @var{x_1}, ..., @var{x_n}.

@c NEED EXAMPLES HERE
@end deffn

