@c /Equations.texi/1.24/Thu Nov  2 05:46:56 2006/-ko/
@c end concepts Equations
@menu
* Definições para Equações::   
@end menu

@node Definições para Equações,  , Equações, Equações
@section Definições para Equações

@c NEED A DESCRIPTION OF %rnum AS WELL
@defvr {Variável} %rnum_list
Valor por omissão: @code{[]}

@code{%rnum_list} é a lista de variáveis introduzidas em soluções
por @code{algsys}.
@code{%r} variáveis São adicionadas a @code{%rnum_list} na ordem em que
forem criadas.
Isso é conveniente para fazer substituições dentro da
solução mais tarde.
@c WHAT DOES THIS STATEMENT MEAN ??
É recomendado usar essa lista em lugar de
fazer @code{concat ('%r, j)}.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Variável} algexact
Valor por omissão: @code{false}

@code{algexact} afecta o comportamento de @code{algsys} como segue:

Se @code{algexact} é @code{true},
@code{algsys} sempre chama @code{solve} e então usa @code{realroots}
sobre falhas de @code{solve}.

Se @code{algexact} é @code{false}, @code{solve} é chamada somente se
o eliminante não for de uma variável, ou se for uma quadrática ou uma
biquadrada.

Dessa forma @code{algexact: true} não garante soluções
exactas, apenas que @code{algsys} tentará primeiro pegar
soluções exactas, e somente retorna aproximações quando tudo mais falha.

@c ABOVE DESCRIPTION NOT TOO CLEAR -- MAYBE EXAMPLES WILL HELP
@end defvr

@deffn {Função} algsys ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
@deffnx {Função} algsys ([@var{eqn_1}, ..., @var{eqn_m}], [@var{x_1}, ..., @var{x_n}])
Resolve polinómios simultâneos @var{expr_1}, ..., @var{expr_m}
ou equações polin@^omiais @var{eqn_1}, ..., @var{eqn_m}
para as variáveis @var{x_1}, ..., @var{x_n}.
Uma expressão @var{expr} é equivalente a uma equação @code{@var{expr} = 0}.
Pode existir mais equações que variáveis ou vice-versa.

@code{algsys} retorna uma lista de soluções,
com cada solução dada com uma lista de valores de estado das equações
das variáveis @var{x_1}, ..., @var{x_n} que satisfazem o sistema de equações.
Se @code{algsys} não pode achar uma solução, uma lista vazia @code{[]} é retornada.

Os símbolos @code{%r1}, @code{%r2}, ...,
são introduzidos tantos quantos forem necessários para representar parâmetros arbitrários na solução;
essas variáveis são também anexadas à lista @code{%rnum_list}.

O método usado é o seguinte:

(1) Primeiro as equações são factorizaadas e quebradas
em subsistemas.

(2) Para cada subsistema @var{S_i}, uma equação @var{E} e uma variável @var{x} são
seleccionados.
A variável é escolhida para ter o menor grau não zero.
Então a resultante de @var{E} e @var{E_j} em relação a @var{x} é calculada para cada um das
equações restantes @var{E_j} nos subsistemas @var{S_i}.
Isso retorna um novo subsistema @var{S_i'} em umas poucas variáveis, como @var{x} tenha sido eliminada.
O processo agora retorna ao passo (1).

(3) Eventualmente, um subsistema consistindo de uma equação simples é
obtido.  Se a equação é de várias variáveis e aproximações na
forma de números em ponto flutuante nã tenham sido introduzidas, então @code{solve} é
chamada para achar uma solução exacta.

Em alguns casos, @code{solve} não está habilitada a achar uma solução,
ou se isso é feito a solução pode ser uma expressão expressão muito larga.

@c REMAINDER OF (3) IS PRETTY COMPLEX.  HOW CAN IT BE CLARIFIED ??
Se a equação é de uma única variável e é ou linear, ou quadrática, ou
biquadrada, então novamente @code{solve} é chamada se aproximações não tiverem
sido introduzidas.  Se aproximações tiverem sido introduzidas ou a
equação não é de uma única variável e nem tão pouco linear, quadratica, ou
biquadrada, então o comutador @code{realonly} é @code{true}, A função
@code{realroots} é chamada para achar o valor real das soluções.  Se
@code{realonly} é @code{false}, então @code{allroots} é chamada a qual procura por
soluções reais e complexas.

Se @code{algsys} produz uma solução que tem
poucos digitos significativos que o requerido, o utilizador pode escolher o valor
de @code{algepsilon} para um valor maior.

Se @code{algexact} é escolhido para
@code{true}, @code{solve} será sempre chamada.
@c algepsilon IS IN Floating.texi -- MAY WANT TO BRING IT INTO THIS FILE

(4) Finalmente, as soluções obtidas no passo (3) são substituídas dentro
dos níveis prévios e o processo de solução retorna para (1).
@c "PREVIOUS LEVELS" -- WHAT ARE THOSE ??

Quando @code{algsys} encontrar uma equação de várias variáveis que contém
aproximações em ponto flutuante (usualmente devido a suas falhas em achar
soluções exactas por um estágio mais fácil), então não tentará
aplicar métodos exatos para tais equações e em lugar disso imprime a mensagem:
"@code{algsys} cannot solve - system too complicated."

Interações com @code{radcan} podem produzir expressões largas ou
complicadas.
Naquele caso, pode ser possível isolar partes do resultado
com @code{pickapart} ou @code{reveal}.

Ocasionalmente, @code{radcan} pode introduzir uma unidade imaginária
@code{%i} dentro de uma solução que é actualmente avaliada como real.

Exemplos:

@c ===beg===
@c e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
+@c e2: a2 - a1;
+@c e3: a1*(-y - x^2 + 1);
@c e4: a2*(y - (x - 1)^2);
@c algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
@c e1: x^2 - y^2;
@c e2: -1 - y + 2*y^2 - x + x^2;
@c algsys ([e1, e2], [x, y]);
@c ===end===
@example
(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
@end example

@end deffn

@deffn {Função} allroots (@var{expr})
@deffnx {Função} allroots (@var{eqn})
Calcula aproximações numéricas de raízes reais e complexas do
polinómio @var{expr} ou equação polin@^omial @var{eqn} de uma variável.

@c polyfactor IS NOT OTHERWISE DOCUMENTED
O sinalizador @code{polyfactor} quando @code{true} faz com que
@code{allroots} factore o polinómio sobre os números reais se o
polinómio for real, ou sobre os números complexos, se o polinómio for
complexo.

@code{allroots} pode retornar resultados imprecisos no caso de múltiplas raízes.
Se o polinómio for real, @code{allroots (%i*@var{p})}) pode retornar
aproximações mais precisas que @code{allroots (@var{p})},
como @code{allroots} invoca um algoritmo diferente naquele caso.

@code{allroots} rejeita expressoões que não sejam polinómios.
Isso requer que o numerador após a classificação
(@code{rat}'ing) poderá ser um polinómio, e isso requer que o
denominador seja quando muito um número complexo.  Com esse tipo
resultado @code{allroots} irá sempre produzir uma expressão
equivalente (mas factorizada), se @code{polyfactor} for @code{true}.

Para polinómios complexos um algoritmo por Jenkins e Traub é
usado (Algorithm 419, @i{Comm.  ACM}, vol.  15, (1972), p.  97).
Para polinómios reais o algoritmo usado é devido a Jenkins (Algorithm 493, @i{ACM TOMS},
vol.  1, (1975), p.178).

Exemplos:
@c EXAMPLES GENERATED BY THESE INPUTS:
@c eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
@c soln: allroots (eqn);
@c for e in soln
@c         do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
@c polyfactor: true$
@c allroots (eqn);

@example
(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
@end example

@end deffn

@defvr {Variável} backsubst
Valor por omissão: @code{true}

@c WHAT IS THE CONTEXT HERE ?? (TO WHICH OTHER FUNCTION DOES THIS APPLY ??)
Quando @code{backsubst} é @code{false}, evita substituições
em expressões anteriores após as equações terem sido triangularizadas.  Isso pode
ser de grande ajuda em problemas muito grandes onde substituição em expressões anteriores pode vir a causar
a geração de expressões extremamente largas.

@end defvr

@defvr {Variável} breakup
Valor por omissão: @code{true}

Quando @code{breakup} é @code{true}, @code{solve} expressa soluções
de equações cúbicas e quárticas em termos de subexpressões comuns,
que são atribuídas a rótulos de expressões intermédias (@code{%t1}, @code{%t2}, etc.).
De outra forma, subexpressões comuns não são identificadas.

@code{breakup: true} tem efeito somente quando @code{programmode} é @code{false}.

Exemplos:

@example
(%i1) programmode: false$
(%i2) breakup: true$
(%i3) solve (x^3 + x^2 - 1);

                        sqrt(23)    25 1/3
(%t3)                  (--------- + --)
                        6 sqrt(3)   54
Solution:

                                      sqrt(3) %i   1
                                      ---------- - -
                sqrt(3) %i   1            2        2   1
(%t4)    x = (- ---------- - -) %t3 + -------------- - -
                    2        2            9 %t3        3

                                      sqrt(3) %i   1
                                    - ---------- - -
              sqrt(3) %i   1              2        2   1
(%t5)    x = (---------- - -) %t3 + ---------------- - -
                  2        2             9 %t3         3

                                   1     1
(%t6)                  x = %t3 + ----- - -
                                 9 %t3   3
(%o6)                    [%t4, %t5, %t6]
(%i6) breakup: false$
(%i7) solve (x^3 + x^2 - 1);
Solution:

             sqrt(3) %i   1
             ---------- - -
                 2        2        sqrt(23)    25 1/3
(%t7) x = --------------------- + (--------- + --)
             sqrt(23)    25 1/3    6 sqrt(3)   54
          9 (--------- + --)
             6 sqrt(3)   54

                                              sqrt(3) %i   1    1
                                           (- ---------- - -) - -
                                                  2        2    3

           sqrt(23)    25 1/3  sqrt(3) %i   1
(%t8) x = (--------- + --)    (---------- - -)
           6 sqrt(3)   54          2        2

                                            sqrt(3) %i   1
                                          - ---------- - -
                                                2        2      1
                                      + --------------------- - -
                                           sqrt(23)    25 1/3   3
                                        9 (--------- + --)
                                           6 sqrt(3)   54

            sqrt(23)    25 1/3             1             1
(%t9)  x = (--------- + --)    + --------------------- - -
            6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                 9 (--------- + --)
                                    6 sqrt(3)   54
(%o9)                    [%t7, %t8, %t9]
@end example

@end defvr

@deffn {Função} dimension (@var{eqn})
@deffnx {Função} dimension (@var{eqn_1}, ..., @var{eqn_n})
@code{dimen} é um pacote de análise dimensional.
@code{load ("dimen")} chama esse pacote.
@code{demo ("dimen")} mostra uma cura demostração.
@c I GUESS THIS SHOULD BE EXPANDED TO COVER EACH FUNCTION IN THE PACKAGE

@end deffn

@defvr {Variável} dispflag
Valor por omissão: @code{true}

@c WHAT DOES THIS MEAN ??
Se escolhida para @code{false} dentro de um @code{block} inibirá
a visualização da saída gerada pelas funções solve chamadas de
dentro de @code{block}.  Terminando @code{block} com um sinal de dolar, $, escolhe
@code{dispflag} para @code{false}.

@end defvr

@c THIS COULD BENEFIT FROM REPHRASING
@deffn {Função} funcsolve (@var{eqn}, @var{g}(@var{t}))
Retorna @code{[@var{g}(@var{t}) = ...]}  ou @code{[]}, dependendo de existir
ou não uma função racional @code{@var{g}(@var{t})} satisfazendo @var{eqn},
que deve ser de primeira ordem, polinómio linear em (para esse caso) 
@code{@var{g}(@var{t})} e @code{@var{g}(@var{t}+1)}

@example
(%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                            (n + 3) f(n + 1)   n - 1
(%o1)        (n + 1) f(n) - ---------------- = -----
                                 n + 1         n + 2
(%i2) funcsolve (eqn, f(n));

Equações dependentes eliminadas:  (4 3)
                                   n
(%o2)                f(n) = ---------------
                            (n + 1) (n + 2)
@end example

Atenção: essa é uma implementação muito rudimentar -- muitas verificações de segurança
e obviamente generalizações estão ausêntes.

@end deffn

@defvr {Variável} globalsolve
Valor por omissão: @code{false}

When @code{globalsolve} for @code{true},
variáveis para as quais as equações são resolvidas são atribuidas aos valores da solução encontrados por @code{linsolve},
e por @code{solve} quando resolvendo duas ou mais equações lineares.
Quando @code{globalsolve} for @code{false},
soluções encontradas por @code{linsolve} e por @code{solve} quando resolvendo duas ou mais equações lineares
são espressas como equações,
e as variáveis para as quais a equação foi resolvida não são atribuidas.

Quando resolvendo qualquer coisa outra que não duas equações lineares ou mais,
@code{solve} ignora @code{globalsolve}.
Outras funções que resolvem equações (e.g., @code{algsys}) sempre ignoram @code{globalsolve}.
    
Exemplos:

@example
(%i1) globalsolve: true$
(%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t2)                        x : --
                                 7

                                   1
(%t3)                        y : - -
                                   7
(%o3)                     [[%t2, %t3]]
(%i3) x;
                               17
(%o3)                          --
                               7
(%i4) y;
                                 1
(%o4)                          - -
                                 7
(%i5) globalsolve: false$
(%i6) kill (x, y)$
(%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t7)                        x = --
                                 7

                                   1
(%t8)                        y = - -
                                   7
(%o8)                     [[%t7, %t8]]
(%i8) x;
(%o8)                           x
(%i9) y;
(%o9)                           y
@end example

@end defvr

@c THIS DESCRIPTION NEEDS WORK AND EXAMPLES
@c MERGE IN TEXT FROM share/integequations/inteqn.usg
@c AND EXAMPLES FROM .../intexs.mac
@deffn {Função} ieqn (@var{ie}, @var{unk}, @var{tech}, @var{n}, @var{guess})
@code{inteqn} é um pacote para resolver equações integrais.
@code{load ("inteqn")} carrega esse pacote.

@var{ie} é a equação integral; @var{unk} é a função desconhecida; @var{tech} é a
técnica a ser tentada nesses dados acima (@var{tech} = @code{first} significa: tente
a primeira técnica que achar uma solução; @var{tech} = @code{all} significa: tente todas a
técnicas aplicáveis); @var{n} é o número máximo de termos a serem usados de
@code{taylor}, @code{neumann}, @code{firstkindseries}, ou @code{fredseries} (isso é também o
número máximo de ciclos de recurssão para o método de diferenciação); @var{guess} é
o inicial suposto para @code{neumann} ou @code{firstkindseries}.

Valores padrão do segundo até o quinto parâmetro são:

@var{unk}: @code{@var{p}(@var{x})}, onde @var{p} é a primeira função encontrada em um integrando
que é desconhecida para Maxima e @var{x} é a variável que ocorre como um
argumento para a primeira ocorrência de @var{p} achada fora de uma integral no
caso de equações @code{secondkind} , ou é somente outra variável
ao lado da variável de integração em equações @code{firstkind}.  Se uma
tentativa de procurar por @var{x} falha, o utilizador será perguntado para suprir a
variável independente.

tech: @code{first}

n: 1

guess: @code{none} o que fará com que @code{neumann} e @code{firstkindseries} use
@code{@var{f}(@var{x})} como uma suposição inicial.

@end deffn

@defvr {Variável de opção} ieqnprint
Valor por omissão: @code{true}

@code{ieqnprint} governa o comportamento do resultado
retornado pelo comando @code{ieqn}.  Quando @code{ieqnprint} é
@code{false}, as listas retornadas pela função @code{ieqn} são da forma

   [@var{solução}, @var{tecnica usada}, @var{nterms}, @var{sinalizador}]

onde @var{sinalizador} é retirado se a solução for exacta.

De outra forma, isso é a
palavra @code{approximate} ou @code{incomplete} correspondendo à forma inexacta ou
forma aberta de solução, respectivamente.  Se um método de série foi usado,
@var{nterms} fornece o número de termos usados (que poderá ser menor que os n
dados para @code{ieqn} se ocorrer um erro evita a geração de termos adicionais).

@end defvr

@deffn {Função} lhs (@var{expr})
Retorna o lado esquerdo (isto é, o primeiro argumento)
da expressão @var{expr},
quando o operador de @var{expr}
for um dos operadores relacionais @code{< <= = # equal notequal >= >},
@c MENTION -> (MARROW) IN THIS LIST IF/WHEN THE PARSER RECOGNIZES IT
um dos operadores de atribuição @code{:= ::= : ::},
ou um operadro infixo definido pelo utilizador, como declarado por meio de @code{infix}.

Quando @var{expr} for um átomo ou
seu operador for alguma coisa que não esses listados acima,
@code{lhs} retorna @var{expr}.

Veja também @code{rhs}.

Exemplos:

@c ===beg===
@c e: aa + bb = cc;
@c lhs (e);
@c rhs (e);
@c [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
@c [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
@c e1: '(foo(x) := 2*x);
@c e2: '(bar(y) ::= 3*y);
@c e3: '(x : y);
@c e4: '(x :: y);
@c [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
@c infix ("][");
@c lhs (aa ][ bb);
@c ===end===
@example
(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
(%o4)                   [aa, aa, aa, aa]
(%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
(%o5)                   [aa, aa, aa, aa]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
(%o10)               [foo(x), bar(y), x, x]
(%i11) infix ("][");
(%o11)                         ][
(%i12) lhs (aa ][ bb);
(%o12)                         aa
@end example

@end deffn

@c REVISIT -- THERE'S PROBABLY MORE TO SAY HERE
@deffn {Função} linsolve ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
Resolve a lista de
equações lineares simultâneas para a lista de variáveis.  As expressões
devem ser cada uma polinómios nas variáveis e podem ser equações.

Quando @code{globalsolve} é @code{true} então variáveis que foram resolvidas
serão escolhidas para a solução do conjunto de equações simultâneas.

Quando @code{backsubst} é @code{false}, @code{linsolve}
não realiza substituição em equações anteriores após
as equações terem sido triangularizadas.  Isso pode ser necessário em problemas
muito grandes onde substituição em equações anteriores poderá causar a geração de
expressões extremamente largas.

Quando @code{linsolve_params} for @code{true},
@code{linsolve} também gera símbolos @code{%r}
usados para representar parâmetros arbitrários descritos no manual sob
@code{algsys}.
De outra forma, @code{linsolve} resolve um menor-determinado sistema de
equações com algumas variáveis expressas em termos de outras.

Quando @code{programmode} for @code{false},
@code{linsolve} mostra a solução com expressões intermédias com rótulos (@code{%t}),
e retorna a lista de rótulos.

@c ===beg===
@c e1: x + z = y;
@c e2: 2*a*x - y = 2*a^2;
@c e3: y - 2*z = 2;
@c [globalsolve: false, programmode: true];
@c linsolve ([e1, e2, e3], [x, y, z]);
@c [globalsolve: false, programmode: false];
@c linsolve ([e1, e2, e3], [x, y, z]);
@c ''%;
@c [globalsolve: true, programmode: false];
@c linsolve ([e1, e2, e3], [x, y, z]);
@c ''%;
@c [x, y, z];
@c [globalsolve: true, programmode: true];
@c linsolve ([e1, e2, e3], '[x, y, z]);
@c [x, y, z];
@c ===end===
@example
(%i1) e1: x + z = y;
(%o1)                       z + x = y
(%i2) e2: 2*a*x - y = 2*a^2;
                                       2
(%o2)                   2 a x - y = 2 a
(%i3) e3: y - 2*z = 2;
(%o3)                      y - 2 z = 2
(%i4) [globalsolve: false, programmode: true];
(%o4)                     [false, true]
(%i5) linsolve ([e1, e2, e3], [x, y, z]);
(%o5)            [x = a + 1, y = 2 a, z = a - 1]
(%i6) [globalsolve: false, programmode: false];
(%o6)                    [false, false]
(%i7) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t7)                       z = a - 1

(%t8)                        y = 2 a

(%t9)                       x = a + 1
(%o9)                    [%t7, %t8, %t9]
(%i9) ''%;
(%o9)            [z = a - 1, y = 2 a, x = a + 1]
(%i10) [globalsolve: true, programmode: false];
(%o10)                    [true, false]
(%i11) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t11)                      z : a - 1

(%t12)                       y : 2 a

(%t13)                      x : a + 1
(%o13)                 [%t11, %t12, %t13]
(%i13) ''%;
(%o13)           [z : a - 1, y : 2 a, x : a + 1]
(%i14) [x, y, z];
(%o14)                 [a + 1, 2 a, a - 1]
(%i15) [globalsolve: true, programmode: true];
(%o15)                    [true, true]
(%i16) linsolve ([e1, e2, e3], '[x, y, z]);
(%o16)           [x : a + 1, y : 2 a, z : a - 1]
(%i17) [x, y, z];
(%o17)                 [a + 1, 2 a, a - 1]
@end example

@end deffn

@c DO ANY FUNCTIONS OTHER THAN linsolve RESPECT linsolvewarn ??
@defvr {Variável} linsolvewarn
Valor por omissão: @code{true}

Quando @code{linsolvewarn} é @code{true},
@code{linsolve} imprime uma mensagem "Dependent equações eliminated".

@end defvr

@defvr {Variável} linsolve_params
Valor por omissão: @code{true}

Quando @code{linsolve_params} é @code{true}, @code{linsolve} também gera
os símbolos @code{%r} usados para representar parâmetros arbitrários descritos no
manual sob @code{algsys}.
De outra forma, @code{linsolve} resolve um menor-determinado sistema de
equações com algumas variáveis expressas em termos e outras.

@end defvr

@defvr {Variável} multiplicities
Valor por omissão: @code{not_set_yet}

@code{multiplicities} é escolhida para uma lista de
multiplicidades das soluções individuais retornadas por @code{solve} ou
@code{realroots}.
@c NEED AN EXAMPLE HERE

@end defvr

@deffn {Função} nroots (@var{p}, @var{low}, @var{high})
Retorna o número de raízes reais do polinómio 
real de uma única variável @var{p} no intervalo semi-aberto
@code{(@var{low}, @var{high}]}.
Uma extremidade do intervalo podem ser @code{minf} ou @code{inf}.
infinito e mais infinito.

@code{nroots} usa o método das sequuências de Sturm.

@example
(%i1) p: x^10 - 2*x^4 + 1/2$
(%i2) nroots (p, -6, 9.1);
(%o2)                           4
@end example

@end deffn

@c NEEDS WORK
@deffn {Função} nthroot (@var{p}, @var{n})
Onde p é um polinómio com coeficientes inteiros e
n é um inteiro positivo retorna q, um polinómio sobre os inteiros, tal
que q^n=p ou imprime uma mensagem de erro indicando que p não é uma potência n-ésima
perfeita.  Essa rotina é mais rápida que @code{factor} ou mesmo @code{sqfr}.

@end deffn

@defvr {Variável} programmode
Valor por omissão: @code{true}

Quando @code{programmode} é @code{true},
@code{solve}, @code{realroots}, @code{allroots}, e @code{linsolve}
retornam soluções como elementos em uma lista.
@c WHAT DOES BACKSUBSTITUTION HAVE TO DO WITH RETURN VALUES ??
(Exceto quando @code{backsubst} é escolhido para @code{false}, nesse caso
@code{programmode: false} é assumido.)

Quando @code{programmode} é @code{false}, @code{solve}, etc.
cria rótulos de expressões intermédias
@code{%t1}, @code{t2}, etc., e atribui as soluções para eles.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Variável} realonly
Valor por omissão: @code{false}

Quando @code{realonly} é @code{true}, @code{algsys} retorna somente
aquelas soluções que estão livres de @code{%i}.

@end defvr

@deffn {Função} realroots (@var{expr}, @var{bound})
@deffnx {Função} realroots (@var{eqn}, @var{bound})
@deffnx {Função} realroots (@var{expr})
@deffnx {Função} realroots (@var{eqn})
Calcula aproximações racionais das raízes reais da expressão polinomial @var{expr}
ou da equação polinomial @var{eqn} de uma variável,
dentro de uma tolerância de @var{bound}.
coeficientes de @var{expr} ou de @var{eqn} devem ser números literais;
constantes símbolo tais como @code{%pi} são rejeitadas.

@code{realroots} atribui as multiplicidades das raízes que encontrar
para a variável global @code{multiplicities}.

@code{realroots} constrói uma sequência de Sturm para delimitar cada raíz,
e então palica a bisecção para redefinir as aproximações.
Todos os coeficientes são convertidos para os equivalentes racionais antes da busca por raízes,
e cálculos são realizados por meio de aritmética racional exacta.
Mesmo se alguns coeficientes forem números em ponto flutuante,
os resultados são racionais (a menos que forçados a números em ponto flutuante por @code{float} ou por @code{numer} flags).

Quando @var{bound} for menor que 1, todas as raízes inteiras são encontradas exactamente.
Quando @var{bound} não for especificado, será assumido como sendo igual à variável globa @code{rootsepsilon}.

Quando a varável global @code{programmode} for @code{true},
@code{realroots} retorna uma lista da forma @code{[x = @var{x_1}, x = @var{x_2}, ...]}.
Quando @code{programmode} for @code{false},
@code{realroots} cria rótulos de expressões intermédias @code{%t1}, @code{%t2}, ...,
atribui os resultados a eles, e retorna a lista de rótulos.

Exemplos:
@c ===beg===
@c realroots (-1 - x + x^5, 5e-6);
@c ev (%[1], float);
@c ev (-1 - x + x^5, %);
@c ===end===

@example
(%i1) realroots (-1 - x + x^5, 5e-6);
                               612003
(%o1)                     [x = ------]
                               524288
(%i2) ev (%[1], float);
(%o2)                 x = 1.167303085327148
(%i3) ev (-1 - x + x^5, %);
(%o3)                - 7.396496210176905E-6
@end example

@c ===beg===
@c realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
@c multiplicities;
@c ===end===

@example
(%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
(%o1)                 [x = 1, x = 2, x = 3]
(%i2) multiplicities;
(%o2)                       [5, 3, 1]
@end example

@end deffn

@deffn {Função} rhs (@var{expr})
Retorna o lado direito (isto é, o segundo argumento)
da expressão @var{expr},
quando o operador de @var{expr}
for um dos operadores relacionais @code{< <= = # equal notequal >= >},
@c MENTION -> (MARROW) IN THIS LIST IF/WHEN THE PARSER RECOGNIZES IT
um dos operadores de atribuição @code{:= ::= : ::},
ou um operador binário infixo definido pelo utilizador, como declarado por meio de @code{infix}.

Quando @var{expr} for um étomo ou
seu operadro for alguma coisa que não esses listados acima,
@code{rhs} retorna 0.

Veja também @code{lhs}.

Exemplos:

@c ===beg===
@c e: aa + bb = cc;
@c lhs (e);
@c rhs (e);
@c [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
@c [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
@c e1: '(foo(x) := 2*x);
@c e2: '(bar(y) ::= 3*y);
@c e3: '(x : y);
@c e4: '(x :: y);
@c [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
@c infix ("][");
@c rhs (aa ][ bb);
@c ===end===
@example
(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
(%o4)                   [bb, bb, bb, bb]
(%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
(%o5)                   [bb, bb, bb, bb]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
(%o10)                  [2 x, 3 y, y, y]
(%i11) infix ("][");
(%o11)                         ][
(%i12) rhs (aa ][ bb);
(%o12)                         bb
@end example

@end deffn

@defvr {Variável de opção} rootsconmode
Valor por omissão: @code{true}

@code{rootsconmode} governa o comportamento do comando
@code{rootscontract}.  Veja @code{rootscontract} para detalhes.

@end defvr

@c NEEDS WORK
@deffn {Função} rootscontract (@var{expr})
Converte produtos de raízes em raízes de produtos.
Por exemplo,
@code{rootscontract (sqrt(x)*y^(3/2))} retorna @code{sqrt(x*y^3)}.

Quando @code{radexpand} é @code{true} e @code{domain} é @code{real},
@code{rootscontract} converte @code{abs} em @code{sqrt}, e.g.,
@code{rootscontract (abs(x)*sqrt(y))} retorna @code{sqrt(x^2*y)}.

Existe uma opção @code{rootsconmode}
afectando @code{rootscontract} como segue:

@example
Problem            Value of        Result of applying
                  rootsconmode        rootscontract
      
x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)
@end example

Quando @code{rootsconmode} é @code{false}, @code{rootscontract} contrai somente como relação a expoentes
de número racional cujos denominadores são os mesmos.  A chave para os exemplos
@code{rootsconmode: true} é simplesmente que 2 divides 4 mas não 
divide 3.  @code{rootsconmode: all} envolve pegar o menor múltiplo comum
dos denominadores dos expoentes.

@code{rootscontract} usa @code{ratsimp} em uma maneira similar a @code{logcontract}.

Exemplos:
@c FOLLOWING ADAPTED FROM example (rootscontract)
@c rootsconmode: false$
@c rootscontract (x^(1/2)*y^(3/2));
@c rootscontract (x^(1/2)*y^(1/4));
@c rootsconmode: true$
@c rootscontract (x^(1/2)*y^(1/4));
@c rootscontract (x^(1/2)*y^(1/3));
@c rootsconmode: all$
@c rootscontract (x^(1/2)*y^(1/4));
@c rootscontract (x^(1/2)*y^(1/3));
@c rootsconmode: false$
@c rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
@c                     *sqrt(sqrt(1 + x) - sqrt(x)));
@c rootsconmode: true$
@c rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));

@example
(%i1) rootsconmode: false$
(%i2) rootscontract (x^(1/2)*y^(3/2));
                                   3
(%o2)                      sqrt(x y )
(%i3) rootscontract (x^(1/2)*y^(1/4));
                                   1/4
(%o3)                     sqrt(x) y
(%i4) rootsconmode: true$
(%i5) rootscontract (x^(1/2)*y^(1/4));
(%o5)                    sqrt(x sqrt(y))
(%i6) rootscontract (x^(1/2)*y^(1/3));
                                   1/3
(%o6)                     sqrt(x) y
(%i7) rootsconmode: all$
(%i8) rootscontract (x^(1/2)*y^(1/4));
                              2   1/4
(%o8)                       (x  y)
(%i9) rootscontract (x^(1/2)*y^(1/3));
                             3  2 1/6
(%o9)                      (x  y )
(%i10) rootsconmode: false$
(%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                    *sqrt(sqrt(1 + x) - sqrt(x)));
(%o11)                          1
(%i12) rootsconmode: true$
(%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
(%o13)                          0
@end example

@end deffn

@defvr {Variável de opção} rootsepsilon
Valor por omissão: 1.0e-7

@code{rootsepsilon} é a tolerância que estabelece o
intervalo de conficência para as raízes achadas pela função @code{realroots}.
@c IS IT GUARANTEED THAT |ACTUAL - ESTIMATE| < rootepsilon OR IS IT SOME OTHER NOTION ??
@c NEED EXAMPLE HERE

@end defvr

@c NEEDS WORK
@deffn {Função} solve (@var{expr}, @var{x})
@deffnx {Função} solve (@var{expr})
@deffnx {Função} solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])
Resolve a equação algébrica @var{expr} para a variável
@var{x} e retorna uma lista de equações solução em @var{x}.  Se @var{expr} não é uma
equação, a equação @code{@var{expr} = 0} é assumida em seu lugar.
@var{x} pode ser uma função (e.g. @code{f(x)}), ou outra expressão não at@^omica
excepto uma adição ou um produto.  @var{x} pode ser omitido se @var{expr} contém somente uma
variável.  @var{expr} pode ser uma expressão racional, e pode conter
funções trigonométricas, exponenciais, etc.

O seguinte método é usado:

Tome @var{E} sendo a expressão e @var{X} sendo a variável.  Se @var{E} é linear em @var{X}
então isso é trivialmente resolvido para @var{X}.  De outra forma se @var{E} é da forma
@code{A*X^N + B} então o resultado é @code{(-B/A)^1/N)} vezes as @code{N}'ésimas raízes da
unidade.

Se @var{E} não é linear em @var{X} então o máximo divisor comum (mdc) dos expoentes de @var{X} em @var{E} (digamos
@var{N}) é dividido dentro dos expoentes e a multiplicidade das raízes é
multiplicada por @var{N}.  Então @code{solve} é chamada novamente sobre o resultado.
Se @var{E} for dada em factores então @code{solve} é chamada sobre cada um dos factores.  Finalmente
@code{solve} usará as fórmulas quadráticas, cúbicas, ou quárticas onde
necessário.

No caso onde @var{E} for um polinómio em alguma função de variável a ser
resolvida, digamos @code{F(X)}, então isso é primeiro resolvida para @code{F(X)} (chama o
resultado @var{C}), então a equação @code{F(X)=C} pode ser resolvida para @var{X} fornecendo o
inverso da função @var{F} que é conhecida.

@code{breakup} se @code{false} fará com que @code{solve} expresse as soluções de
equações cúbicas ou quárticas como expressões simples ao invés de como feito
em cima de várias subexpressões comuns que é o padrão.

@code{multiplicities} - será escolhido para uma lista de multiplicidades de
soluções individuais retornadas por @code{solve}, @code{realroots}, ou @code{allroots}.
Tente @code{apropos (solve)} para os comutadores que afectam @code{solve}.  @code{describe} pode
então ser usada sobre o nome do comutador individual se seu proprósito não é
claro.

@code{solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])}
resolve um sistema de equações polinomiais
(lineares ou não-lineares) simultâneas por chamada a @code{linsolve} ou
@code{algsys} e retorna uma lista de listas solução nas variáveis.  No
caso de @code{linsolve} essa lista conterá uma lista simples de
soluções.  Isso pega duas listas como argumentos.  A primeira lista
representa as equações a serem resolvidas; a segunda lista é a
lista de desconhecidos a ser determinada.  Se o número total de
variáveis nas equações é igual ao número de equações, a
segunda lista-argumento pode ser omitida.  Para sistemas lineares se as dadas
equações não são compatíveis, a mensagem @code{inconsistent} será
mostrada (veja o comutador @code{solve_inconsistent_error} ); se não existe
solução única, então @code{singular} será mostrado.

Exemplos:
@c FOLLOWING ADAPTED FROM example (solve)
@c solve (asin (cos (3*x))*(f(x) - 1), x);
@c ev (solve (5^f(x) = 125, f(x)), solveradcan);
@c [4*x^2 - y^2 = 12, x*y - x = 2];
@c solve (%, [x, y]);
@c solve (1 + a*x + x^3, x);
@c solve (x^3 - 1);
@c solve (x^6 - 1);
@c ev (x^6 - 1, %[1]);
@c expand (%);
@c x^2 - 1;
@c solve (%, x);
@c ev (%th(2), %[1]);

@example
(%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

SOLVE is using arc-trig functions to get a solution.
Some soluções will be lost.
                            %pi
(%o1)                  [x = ---, f(x) = 1]
                             6
(%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                log(125)
(%o2)                   [f(x) = --------]
                                 log(5)
(%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                      2    2
(%o3)             [4 x  - y  = 12, x y - x = 2]
(%i4) solve (%, [x, y]);
(%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

 - .1331240357358706, y = .0767837852378778

 - 3.608003221870287 %i], [x = - .5202594388652008 %i

 - .1331240357358706, y = 3.608003221870287 %i

 + .0767837852378778], [x = - 1.733751846381093, 

y = - .1535675710019696]]
(%i5) solve (1 + a*x + x^3, x);
                                       3
              sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(%o5) [x = (- ---------- - -) (--------------- - -)
                  2        2      6 sqrt(3)      2

        sqrt(3) %i   1
       (---------- - -) a
            2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

                          3
 sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(---------- - -) (--------------- - -)
     2        2      6 sqrt(3)      2

         sqrt(3) %i   1
      (- ---------- - -) a
             2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

         3
 sqrt(4 a  + 27)   1 1/3               a
(--------------- - -)    - --------------------------]
    6 sqrt(3)      2                  3
                              sqrt(4 a  + 27)   1 1/3
                           3 (--------------- - -)
                                 6 sqrt(3)      2
(%i6) solve (x^3 - 1);
             sqrt(3) %i - 1        sqrt(3) %i + 1
(%o6)   [x = --------------, x = - --------------, x = 1]
                   2                     2
(%i7) solve (x^6 - 1);
           sqrt(3) %i + 1      sqrt(3) %i - 1
(%o7) [x = --------------, x = --------------, x = - 1, 
                 2                   2

                     sqrt(3) %i + 1        sqrt(3) %i - 1
               x = - --------------, x = - --------------, x = 1]
                           2                     2
(%i8) ev (x^6 - 1, %[1]);
                                      6
                      (sqrt(3) %i + 1)
(%o8)                 ----------------- - 1
                             64
(%i9) expand (%);
(%o9)                           0
(%i10) x^2 - 1;
                              2
(%o10)                       x  - 1
(%i11) solve (%, x);
(%o11)                  [x = - 1, x = 1]
(%i12) ev (%th(2), %[1]);
(%o12)                          0
@end example

@end deffn

@defvr {Variável de opção} solvedecomposes
Valor por omissão: @code{true}

Quando @code{solvedecomposes} é @code{true}, @code{solve} chama
@code{polydecomp} se perguntado para resolver polinómios.
@c OTHERWISE WHAT HAPPENS -- CAN'T SOLVE POLYNOMIALS, OR SOME OTHER METHOD IS USED ??

@end defvr

@defvr {Variável de opção} solveexplicit
Valor por omissão: @code{false}

Quando @code{solveexplicit} é @code{true}, inibe @code{solve} de
retornar soluções implícitas, isto é, soluções da forma @code{F(x) = 0}
onde @code{F} é alguma função.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Variável de opção} solvefactors
Valor por omissão: @code{true}

@c WHAT IS THIS ABOUT EXACTLY ??
Quando @code{solvefactors} é @code{false}, @code{solve} não tenta
factorizar a expressão. A escolha do @code{false} poderá ser útil
em alguns casos onde a factorização não é
necessária.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Variável de opção} solvenullwarn
Valor por omissão: @code{true}

Quando @code{solvenullwarn} é @code{true}, 
@code{solve} imprime uma mensagem de alerta se chamada com ou uma lista equação ou uma variável lista nula.
Por exemplo, @code{solve ([], [])} imprimirá duas mensagens de alerta e retorna @code{[]}.

@end defvr

@defvr {Variável de opção} solveradcan
Valor por omissão: @code{false}

Quando @code{solveradcan} é @code{true}, @code{solve} chama @code{radcan}
que faz @code{solve} lento mas permitirá certamente que problemas
contendo exponeniais e logaritmos sejam resolvidos.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Variável de opção} solvetrigwarn
Valor por omissão: @code{true}

@c MAYBE THIS CAN BE CLARIFIED
Quando @code{solvetrigwarn} é @code{true},
@code{solve} pode imprimir uma mensagem dizendo que está usando funções
trigonométricas inversas para resolver a equação, e desse modo perdendo
soluções.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Variável de opção} solve_inconsistent_error
Valor por omissão: @code{true}

Quando @code{solve_inconsistent_error} é 
@code{true}, @code{solve} e
@code{linsolve} resultam em erro se as equações a serem resolvidas são inconsistentes.

Se @code{false}, @code{solve} e @code{linsolve} retornam uma lista vazia @code{[]} 
se as equações forem inconsistentes.

Exemplo:

@example
(%i1) solve_inconsistent_error: true$
(%i2) solve ([a + b = 1, a + b = 2], [a, b]);
Inconsistent equações:  (2)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i3) solve_inconsistent_error: false$
(%i4) solve ([a + b = 1, a + b = 2], [a, b]);
(%o4)                          []
@end example

@end defvr

