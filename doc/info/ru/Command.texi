@c Language=Russian
@c Encoding=UTF-8
@c File=Command.texi
@c OriginalRevision=1.46
@c TranslatedBy: (c) 2005-12 Vadim V. Zhytnikov <vvzhyt@gmail.ru>

@menu
* Введение в командную строку::
* Функции и переменные для работы в командной строке::
@end menu

@node Введение в командную строку, Функции и переменные для работы в командной строке, Командная строка, Командная строка
@section Введение в командную строку

@c NEEDS EXAMPLES
@c THIS ITEM IS VERY IMPORTANT !!
@deffn {Оператор} '
@ifinfo
@fnindex Оператор "одиночная кавычка"
@end ifinfo
Оператор "одиночная кавычка" @code{'} предотвращает вычисление,
иными словами "экранирует" свой аргумент.

Примененный к символу, оператор "одиночная кавычка" предотвращает
вычисление этого символа.

Примененный к вызову функции, оператор "одиночная кавычка"
предотвращает вычисление этой функции, но не вычисление
ее аргументов (если оно не предотвращено по другим причинам).
Результатом является невычисляемая (noun) форма вызова функции.

Примененный к выражению в скобках, предотвращает вычисление
всех функций и символов внутри скобок.
@c DUNNO IF THESE EXAMPLES ARE STILL NEEDED -- COVERED BY ITEMS UNDER "Examples"
Например, @code{'(f(x))} означает -- не вычислять выражение
@code{f(x)}, тогда как @code{'f(x)} (кавычка примененная к @code{f}
а не к @code{f(x)}) означает -- невычисляемая форма @code{f},
примененная к @code{[x]}.

Одиночная кавычка не предотвращает упрощение.

Когда глобальный флаг @code{noundisp} имеет значение @code{true},
невычисляемые формы функций выводятся с одиночной кавычкой.
Этот переключатель всегда установлен равным @code{true} при
печати определений функций.

См. также оператор "кавычка-кавычка" @code{''} и @code{nouns}.

Примеры:

Примененный к символу, оператор "одиночная кавычка" предотвращает
вычисление этого символа.

@c ===beg===
@c aa: 1024;
@c aa^2;
@c 'aa^2;
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) aa^2;
(%o2)                        1048576
(%i3) 'aa^2;
                                 2
(%o3)                          aa
(%i4) ''%;
(%o4)                        1048576
@end example


Примененный к вызову функции, оператор "одиночная кавычка"
предотвращает вычисление этой функции.
Результатом является невычисляемая форма вызова функции.

@c ===beg===
@c x0: 5;
@c x1: 7;
@c integrate (x^2, x, x0, x1);
@c 'integrate (x^2, x, x0, x1);
@c %, nouns;
@c ===end===
@example
(%i1) x0: 5;
(%o1)                           5
(%i2) x1: 7;
(%o2)                           7
(%i3) integrate (x^2, x, x0, x1);
                               218
(%o3)                          ---
                                3
(%i4) 'integrate (x^2, x, x0, x1);
                             7
                            /
                            [   2
(%o4)                       I  x  dx
                            ]
                            /
                             5
(%i5) %, nouns;
                               218
(%o5)                          ---
                                3
@end example

Примененный к выражению в скобках, предотвращает вычисление
всех функций и символов внутри скобок.

@c ===beg===
@c aa: 1024;
@c bb: 19;
@c sqrt(aa) + bb;
@c '(sqrt(aa) + bb);
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) bb: 19;
(%o2)                          19
(%i3) sqrt(aa) + bb;
(%o3)                          51
(%i4) '(sqrt(aa) + bb);
(%o4)                     bb + sqrt(aa)
(%i5) ''%;
(%o5)                          51
@end example

Одиночная кавычка не предотвращает упрощение.

@c ===beg===
@c sin (17 * %pi) + cos (17 * %pi);
@c '(sin (17 * %pi) + cos (17 * %pi));
@c ===end===
@example
(%i1) sin (17 * %pi) + cos (17 * %pi);
(%o1)                          - 1
(%i2) '(sin (17 * %pi) + cos (17 * %pi));
(%o2)                          - 1
@end example

@opencatbox{Категории:}
@category{Вычисление}
@category{Операторы}
@closecatbox
@end deffn

@deffn {Оператор} ''
@ifinfo
@fnindex Оператор "кавычка-кавычка"
@end ifinfo
Оператор "кавычка-кавычка"  @code{'@w{}'} (две одиночные кавычки) изменяет
вычисление вводимого выражения.

Примененный к выражению общего вида @var{expr}, кавычка-кавычка вызывает подстановку значения @var{expr}
вместо @var{expr} в вводимом выражении.

Примененный к оператору в выражении,
кавычка-кавычка изменяет невычисляемую форму оператора на вычисляемую (если она не является таковой).

Оператор кавычка-кавычка применяется при синтаксическом анализе вводимого выражения
и не сохраняется как часть этого выражения.
Оператор кавычка-кавычка применяется сразу после распознавания и не
может быть экранирован.

Оператор кавычка-кавычка распознается функциями @code{batch} и @code{load}.

См. также оператор "кавычка" @code{'} и @code{nouns}.

Примеры:

Примененный к выражению общего вида @var{expr}, кавычка-кавычка вызывает подстановку значения @var{expr}
вместо @var{expr} в вводимом выражении.

@c ===beg===
@c expand ((a + b)^3);
@c [_, ''_];
@c [%i1, ''%i1];
@c [aa : cc, bb : dd, cc : 17, dd : 29];
@c foo_1 (x) := aa - bb * x;
@c foo_1 (10);
@c ''%;
@c ''(foo_1 (10));
@c foo_2 (x) := ''aa - ''bb * x;
@c foo_2 (10);
@c [x0 : x1, x1 : x2, x2 : x3];
@c x0;
@c ''x0;
@c '' ''x0;
@c ===end===
@example
(%i1) expand ((a + b)^3);
                     3        2      2      3
(%o1)               b  + 3 a b  + 3 a  b + a
(%i2) [_, ''_];
                         3    3        2      2      3
(%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i3) [%i1, ''%i1];
                         3    3        2      2      3
(%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
(%o4)                   [cc, dd, 17, 29]
(%i5) foo_1 (x) := aa - bb * x;
(%o5)                 foo_1(x) := aa - bb x
(%i6) foo_1 (10);
(%o6)                      cc - 10 dd
(%i7) ''%;
(%o7)                         - 273
(%i8) ''(foo_1 (10));
(%o8)                         - 273
(%i9) foo_2 (x) := ''aa - ''bb * x;
(%o9)                 foo_2(x) := cc - dd x
(%i10) foo_2 (10);
(%o10)                        - 273
(%i11) [x0 : x1, x1 : x2, x2 : x3];
(%o11)                    [x1, x2, x3]
(%i12) x0;
(%o12)                         x1
(%i13) ''x0;
(%o13)                         x2
(%i14) '' ''x0;
(%o14)                         x3
@end example

Примененный к оператору в выражении,
кавычка-кавычка изменяет невычисляемую форму оператора на вычисляемую (если она не является таковой).

@c ===beg===
@c sin (1);
@c ''sin (1);
@c declare (foo, noun);
@c foo (x) := x - 1729;
@c foo (100);
@c ''foo (100);
@c ===end===
@example
(%i1) sin (1);
(%o1)                        sin(1)
(%i2) ''sin (1);
(%o2)                    0.8414709848079
(%i3) declare (foo, noun);
(%o3)                         done
(%i4) foo (x) := x - 1729;
(%o4)                 ''foo(x) := x - 1729
(%i5) foo (100);
(%o5)                       foo(100)
(%i6) ''foo (100);
(%o6)                        - 1629
@end example

Оператор кавычка-кавычка применяется при синтаксическом анализе вводимого выражения
и не сохраняется как часть этого выражения.

@c ===beg===
@c [aa : bb, cc : dd, bb : 1234, dd : 5678];
@c aa + cc;
@c display (_, op (_), args (_));
@c ''(aa + cc);
@c display (_, op (_), args (_));
@c ===end===
@example
(%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
(%o1)                 [bb, dd, 1234, 5678]
(%i2) aa + cc;
(%o2)                        dd + bb
(%i3) display (_, op (_), args (_));
                           _ = cc + aa

                         op(cc + aa) = +

                    args(cc + aa) = [cc, aa]

(%o3)                         done
(%i4) ''(aa + cc);
(%o4)                         6912
(%i5) display (_, op (_), args (_));
                           _ = dd + bb

                         op(dd + bb) = +

                    args(dd + bb) = [dd, bb]

(%o5)                         done
@end example

Оператор кавычка-кавычка вызывает вычисление в случаях когда оно
заблокировано, таких как определения функций, лямбда-выражения и выражения,
экранированные оператором кавычка @code{'}.

@c ===beg===
@c foo_1a (x) := ''(integrate (log (x), x));
@c foo_1b (x) := integrate (log (x), x);
@c dispfun (foo_1a, foo_1b);
@c integrate (log (x), x);
@c foo_2a (x) := ''%;
@c foo_2b (x) := %;
@c dispfun (foo_2a, foo_2b);
@c F : lambda ([u], diff (sin (u), u));
@c G : lambda ([u], ''(diff (sin (u), u)));
@c '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
@c '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
@c ===end===
@example
(%i1) foo_1a (x) := ''(integrate (log (x), x));
(%o1)               foo_1a(x) := x log(x) - x
(%i2) foo_1b (x) := integrate (log (x), x);
(%o2)           foo_1b(x) := integrate(log(x), x)
(%i3) dispfun (foo_1a, foo_1b);
(%t3)               foo_1a(x) := x log(x) - x

(%t4)           foo_1b(x) := integrate(log(x), x)

(%o4)                      [%t3, %t4]
(%i4) integrate (log (x), x);
(%o4)                     x log(x) - x
(%i5) foo_2a (x) := ''%;
(%o5)               foo_2a(x) := x log(x) - x
(%i6) foo_2b (x) := %;
(%o6)                    foo_2b(x) := %
(%i7) dispfun (foo_2a, foo_2b);
(%t7)               foo_2a(x) := x log(x) - x

(%t8)                    foo_2b(x) := %

(%o8)                      [%t7, %t8]
(%i8) F : lambda ([u], diff (sin (u), u));
(%o8)             lambda([u], diff(sin(u), u))
(%i9) G : lambda ([u], ''(diff (sin (u), u)));
(%o9)                  lambda([u], cos(u))
(%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
(%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                    k                  k
(%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
(%o11)             b  + a  + b  + a  + b  + a
                    3    3    2    2    1    1
@end example

@opencatbox{Категории:}
@category{Вычисление}
@category{Операторы}
@closecatbox
@end deffn

@c end concepts Command Line
@node Функции и переменные для работы в командной строке,  , Введение в командную строку, Командная строка
@section Функции и переменные для работы в командной строке

@c NEEDS WORK, ESPECIALLY EXAMPLES
@deffn {Функция} alias (@var{new_name_1}, @var{old_name_1}, ..., @var{new_name_n}, @var{old_name_n})
создает альтернативное имя для пользовательской или системной
функции, переменной, массива и т.п.
Данная функция может иметь любое число парных аргументов.

@opencatbox{Категории:}
@category{Факты и выводы}
@closecatbox
@end deffn

@defvr {Управляющая переменная} debugmode
Значение по умолчанию: @code{false}

Если во время работы Maxima возникла ошибка, Maxima запускает отладчик
если значение переключателя @code{debugmode} равно @code{true}.
В отладчике пользователь может исследовать значения стека, установить
точки останова, просматривать код и т.д.  См.  @code{debugging}
для списка команд отладчика.

Отладчик Maxima, включаемый с помощью @code{debugmode}, не
обрабатывает ошибки на уровне Lisp.
@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@opencatbox{Категории:}
@category{Отладка}
@category{Глобальные флаги}
@closecatbox
@end defvr

@c NEEDS CLARIFICATION
@c VERY IMPORTANT !!
@deffn {Функция} ev (@var{expr}, @var{arg_1}, ..., @var{arg_n})
Вычисляет выражение @var{expr} в окружении определяемом аргументами
@var{arg_1}, ..., @var{arg_n}.  Данные аргументы могут быть
переключателями (логические флаги), присваиваниями, уравнениями и функциями.
@code{ev} возвращает результат вычисления (выражение).

Вычисление осуществляется в несколько шагов.

@enumerate
@item
Сначала окружение устанавливается в соответствии с аргументами,
которые могут быть одним из следующего:

@itemize @bullet
@item
@code{simp} вызывает упрощение выражения @var{expr} вне зависимости
от текущего значения переключателя @code{simp} (отключает упрощение
если равен @code{false}).
@item
@code{noeval} отключает вычисление для данной стадии @code{ev}
(см. шаг (4) ниже).  Это может быть полезно в комбинации с другими
переключателями и вызывает повторное упрощение @var{expr} без
перевычисления.
@item
@code{nouns} вызывает вычисление невычисляемых (noun) форм
(обычно это невычисляемые функции, такие как @code{'integrate}
или @code{'diff}) в @var{expr}.
@item
@code{expand} вызывает раскрытие скобок.
@item
@code{expand (@var{m},@var{n})} вызывает раскрытие скобок при  @code{maxposex} и
@code{maxnegex} равным  @var{m} и @var{n} соответственно.
@item
@code{detout} при вычислении обратных матриц в @var{expr}, сохраняет
определитель матрицы как общий множитель вместо того чтобы делить
на него каждый элемент матрицы в отдельности.
@item
@code{diff} вызывает вычисление всех производных в @var{expr}.
@item
@code{derivlist (@var{x}, @var{y}, @var{z}, ...)} вызовет вычисление
производных только относительно указанных переменных.
@item
@code{float} вызывает преобразование нецелых рациональных чисел
в числа с плавающей точкой.
@item
@code{numer} вызывает численное вычисление математических
функций (включая экспоненты), имеющих числовые аргументы.  Вызывает
замену переменных, имеющих числовые значения (см. @code{numerval}), этими
значениями.  Устанавливает значение переключателя @code{float}
равным @code{true}.
@item
@code{pred} вызывает вычисление предикатов (выражений, значение
которых @code{true} или @code{false}).
@item
@code{eval} вызывает дополнительное пост-вычисление @var{expr}
(см. шаг (5) ниже).
@code{eval} может встречаться несколько раз.
Для каждого @code{eval} выражение вычисляется еще раз.
@item
@code{A}, где @code{A} есть атом, являющийся флагом вычисления (см. @code{evflag}),
устанавливает значение @code{A} равным @code{true} в процессе
вычисления @var{expr}.
@item
@code{V: expression} (или альтернативно @code{V=expression})
присваивает @code{V} значение  @code{expression} в процессе вычисления
@var{expr}.  Если @code{V} является управляющей переменной (опцией)
Maxima, тогда значение @code{expression} используется в качестве
значения опции в процессе вычисления @var{expr}.  Если имеется более
одного аргумента @code{ev} данного типа, то присваивание осуществляется
параллельно.  Если @code{V} является не атомарным выражением, то
вместо присваивания осуществляется подстановка.
@item
@code{F}, где @code{F} есть имя функции, являющейся функцией
вычисления (см. @code{evfun}) вызывает применение @code{F} к @var{expr}.
@item
Любые другие имена функций (скажем @code{sum}) вызывают вычисление
этих функций в @var{expr}, так как если бы они имели
вычисляемую форму.
@item
Кроме того, встречающаяся в @var{expr} функция (скажем @code{F(x)})
может быть локально определена для вычисления @var{expr}, путем
задания аргумента в форме @code{F(x) := expression}.
@item
Если в качестве аргумента указан любой, не указанный выше атом, или
переменная с индексом, или выражение с индексом, то данный аргумент
вычисляется.  Если результатом вычисления является уравнение или
присваивание, то выполняется соответствующее присваивание или
подстановка.  Если результатом вычисления является список, то
элементы этого списка трактуются как дополнительные аргументы
@code{ev}.  Это, в частности, позволяет использовать список
уравнений (например @code{[X=1, Y=A**2]}), или список имен
уравнений (например @code{[%t1, %t2]}, где @code{%t1} и
@code{%t2} являются результатом работы функции @code{solve}.
@end itemize

Аргументы @code{ev} могут быть указаны в произвольном порядке за
исключением уравнений, которые выполняются последовательно слева
направо, и составных вычисляющих функций (например
@code{ev (@var{expr}, ratsimp, realpart)} выполняется как
@code{realpart (ratsimp (@var{expr}))}).

Переключатели @code{simp}, @code{numer}, @code{float} и @code{pred}
могут быть установлены локально в блоке, или глобально.
В последнем случае они будут действовать до переопределения.

Если выражение @var{expr} является каноническим рациональным
выражением (КРВ, canonical rational expression (CRE)), тогда
результатом @code{ev} тоже является КРВ, если только переключатели
@code{numer} и @code{float} оба не равны @code{true}.

@item
На шаге (1), составляется список не-индексированных
переменных входящих в левые части аргументов, являющихся уравнениями,
или в значения аргументов, если эти значения являются уравнениями.
Переменные (индексированные, которые не имеют соответствующих
функций массивов, и не-индексированные) в выражении @var{expr}
заменяются на свои глобальные значения, за исключением тех,
которые входят в вышеуказанный список.   Обычно, @var{expr} это просто
метка @code{%} (как @code{%i2} в примере ниже), так что на данном шаге
просто получается выражение, обозначаемое данной меткой.

@item
Если среди аргументов имеются подстановки, то они выполняются.

@item
Полученное выражение снова вычисляется (если одним из аргументов не
является @code{noeval}) и упрощается в соответствии с заданными
аргументами.  Все вызовы функций в @var{expr} выполняются после
вычисления переменных.  Таким образом @code{ev(F(x))} трактуется
как @code{F(ev(x))}.

@item
Для каждого @code{eval}, шаги (3) и (4) повторяются.
@end enumerate

Примеры:

@example
(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, sin, expand, diff, x=2, y=1);
                          2
(%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682
@end example

Имеется альтернативный синтаксис функции @code{ev}, который может
использоваться только на верхнем уровне: аргументы @code{ev()}
перечисляются через запятую после выражения.  Т.е. можно просто
написать

@example
@var{expr}, @var{arg_1}, ..., @var{arg_n}
@end example

Такая конструкция недопустима как часть другого выражения,
функции, блока и т.п.

Обратите внимание на параллельное присваивание в следующих
примерах.

@example
(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Solution

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x > gamma (1/2);
                                   1
(%o9)                          x + - > sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 > 1.772453850905516
(%i11) %, pred;
(%o11)                               true
@end example

@opencatbox{Категории:}
@category{Вычисление}
@closecatbox
@end deffn

@defvr {Свойство} evflag
Если символ @var{x} имеет свойство @code{evflag},
то выражения @code{ev(@var{expr}, @var{x})} и @code{@var{expr}, @var{x}}
(в интерактивной командной строке) эквивалентны @code{ev(@var{expr}, @var{x} = true)}.
Т.е. @var{x} имеет значение @code{true} в процессе вычисления @var{expr}.

Выражение @code{declare(@var{x}, evflag)}
устанавливает свойство @code{evflag} для переменной @var{x}.

Следующие переключатели имеют по умолчанию свойство @code{evflag}:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evflag properties) ...)
@c NEAR LINE 2649 OF mlisp.lisp AT PRESENT (2004/11).
@code{algebraic},
@code{cauchysum},
@code{demoivre},
@code{dotscrules},
@code{%emode},
@code{%enumer},
@code{exponentialize},
@code{exptisolate},
@code{factorflag},
@code{float},
@code{halfangles},
@code{infeval},
@code{isolate_wrt_times},
@code{keepfloat},
@code{letrat},
@code{listarith},
@code{logabs},
@code{logarc},
@code{logexpand},
@code{lognegint},
@code{lognumer},
@code{m1pbranch},
@code{numer_pbranch},
@code{programmode},
@code{radexpand},
@code{ratalgdenom},
@code{ratfac},
@code{ratmx},
@code{ratsimpexpons},
@code{simp},
@code{simpsum},
@code{sumexpand} и
@code{trigexpand}.

Примеры:

@c ===beg===
@c sin (1/2);
@c sin (1/2), float;
@c sin (1/2), float=true;
@c simp : false;
@c 1 + 1;
@c 1 + 1, simp;
@c simp : true;
@c sum (1/k^2, k, 1, inf);
@c sum (1/k^2, k, 1, inf), simpsum;
@c declare (aa, evflag);
@c if aa = true then YES else NO;
@c if aa = true then YES else NO, aa;
@c ===end===
@example
(%i1) sin (1/2);
                                 1
(%o1)                        sin(-)
                                 2
(%i2) sin (1/2), float;
(%o2)                   0.479425538604203
(%i3) sin (1/2), float=true;
(%o3)                   0.479425538604203
(%i4) simp : false;
(%o4)                         false
(%i5) 1 + 1;
(%o5)                         1 + 1
(%i6) 1 + 1, simp;
(%o6)                           2
(%i7) simp : true;
(%o7)                         true
(%i8) sum (1/k^2, k, 1, inf);
                            inf
                            ====
                            \     1
(%o8)                        >    --
                            /      2
                            ====  k
                            k = 1
(%i9) sum (1/k^2, k, 1, inf), simpsum;
                                 2
                              %pi
(%o9)                         ----
                               6
(%i10) declare (aa, evflag);
(%o10)                        done
(%i11) if aa = true then YES else NO;
(%o11)                         NO
(%i12) if aa = true then YES else NO, aa;
(%o12)                         YES
@end example

@opencatbox{Категории:}
@category{Флаги вычисления}
@category{Флаги и переменные упрощения}
@closecatbox
@end defvr

@defvr {Свойство} evfun
Если функция @var{F} имеет свойство @code{evfun},
то выражения @code{ev(@var{expr}, @var{F})} и @code{@var{expr}, @var{F}}
(в интерактивной командной строке)
эквивалентны @code{@var{F}(ev(@var{expr}))}.

Если заданы две или более @code{evfun} функций @var{F}, @var{G}, то
функции применяются в порядке задания.

Выражение @code{declare(@var{F}, evfun)}
устанавливает свойство @code{evfun} для функции @var{F}.

Следующие функции имеют по умолчанию свойство @code{evfun}:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evfun properties) ...)
@c NEAR LINE 2643 IN mlisp.lisp AT PRESENT (2004/11).
@code{bfloat},
@code{factor},
@code{fullratsimp},
@code{logcontract},
@code{polarform},
@code{radcan},
@code{ratexpand},
@code{ratsimp},
@code{rectform},
@code{rootscontract},
@code{trigexpand} и
@code{trigreduce}.

Примеры:

@c ===beg===
@c x^3 - 1;
@c x^3 - 1, factor;
@c factor (x^3 - 1);
@c cos(4 * x) / sin(x)^4;
@c cos(4 * x) / sin(x)^4, trigexpand;
@c cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
@c ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
@c declare ([F, G], evfun);
@c (aa : bb, bb : cc, cc : dd);
@c aa;
@c aa, F;
@c F (aa);
@c F (ev (aa));
@c aa, F, G;
@c G (F (ev (aa)));
@c ===end===
@example
(%i1) x^3 - 1;
                              3
(%o1)                        x  - 1
(%i2) x^3 - 1, factor;
                                2
(%o2)                 (x - 1) (x  + x + 1)
(%i3) factor (x^3 - 1);
                                2
(%o3)                 (x - 1) (x  + x + 1)
(%i4) cos(4 * x) / sin(x)^4;
                            cos(4 x)
(%o4)                       --------
                               4
                            sin (x)
(%i5) cos(4 * x) / sin(x)^4, trigexpand;
                 4           2       2         4
              sin (x) - 6 cos (x) sin (x) + cos (x)
(%o5)         -------------------------------------
                                4
                             sin (x)
(%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                           2         4
                      6 cos (x)   cos (x)
(%o6)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                           2         4
                      6 cos (x)   cos (x)
(%o7)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i8) declare ([F, G], evfun);
(%o8)                         done
(%i9) (aa : bb, bb : cc, cc : dd);
(%o9)                          dd
(%i10) aa;
(%o10)                         bb
(%i11) aa, F;
(%o11)                        F(cc)
(%i12) F (aa);
(%o12)                        F(bb)
(%i13) F (ev (aa));
(%o13)                        F(cc)
(%i14) aa, F, G;
(%o14)                      G(F(cc))
(%i15) G (F (ev (aa)));
(%o15)                      G(F(cc))
@end example

@opencatbox{Категории:}
@category{Флаги вычисления}
@closecatbox
@end defvr
@c NEEDS WORK
@defvr {Управляющая переменная} infeval
Включает режим "бесконечного вычисления".  @code{ev} вычисляет
выражение повторно до тех пор пока оно не перестает изменяться.
Чтобы предотвратить вычисление отдельной переменной, скажем @code{X},
в данном режиме следует указать @code{X='X} в качестве
аргумента @code{ev}.  Разумеется, выражения вроде
@code{ev (X, X=X+1, infeval)} приводят к бесконечному циклу.

@opencatbox{Категории:}
@category{Флаги вычисления}
@closecatbox
@end defvr

@c REVIEW FOR ACCURACY AND COMPLETENESS
@c THIS ITEM IS VERY IMPORTANT !!
@c NEEDS EXAMPLES
@deffn {Функция} kill (@var{a_1}, ..., @var{a_n})
@deffnx {Функция} kill (labels)
@deffnx {Функция} kill (inlabels, outlabels, linelabels)
@deffnx {Функция} kill (@var{n})
@deffnx {Функция} kill ([@var{m}, @var{n}])
@deffnx {Функция} kill (values, functions, arrays, ...)
@deffnx {Функция} kill (all)
@deffnx {Функция} kill (allbut (@var{a_1}, ..., @var{a_n}))

Удаляет все связи (значение, функцию, массив или правило) аргументов @var{a_1}, ..., @var{a_n}.
Аргумент @var{a_k} может быть символом или отдельным элементом массива.
Если @var{a_k} является отдельным элементом массива, то @code{kill} удаляет
значение одного этого элемента и не затрагивает другие элементы массива.

Распознается несколько специальных форм аргументов.  При
этом аргументы различных типов могут быть скомбинированы,
например  @code{kill (inlabels, functions, allbut (foo, bar))}.

@code{kill (labels)} очищает значение меток ввода,
результата и меток промежуточных выражений, определенных на момент вызова.
@code{kill (inlabels)} очищает значение меток ввода, имена которых
начинаются с текущего значения @code{inchar}.
Аналогично,
@code{kill (outlabels)} очищает значение меток результата, имена которых
начинаются с текущего значения @code{outchar},
и @code{kill (linelabels)} очищает значение меток промежуточных
выражений, имена которых начинаются с текущего значения @code{linechar}.

@code{kill (@var{n})}, где @var{n} является целым числом,
очищает значение @var{n} первых меток ввода и результата.

@code{kill ([@var{m}, @var{n}])} очищает метки ввода и результата
с номерами от @var{m} до @var{n} включительно.

@code{kill (@var{infolist})}, где @var{infolist} есть один из
информационных списков @code{infolists} (например @code{values}, @code{functions}
или @code{arrays}), очищает значение всех элементов в
@var{infolist}.  См. также @code{infolists}.

@code{kill (all)} очищает значения всех элементов во всех
информационных списках (infolists).
@code{kill (all)} не восстанавливает стандартные значения глобальных
переменных.  См. @code{reset} по поводу восстановления стандартных
значений глобальных переменных.

@code{kill (allbut (@var{a_1}, ..., @var{a_n}))}
очищает все элементы во всех информационных списках кроме  @var{a_1}, ..., @var{a_n}.
@code{kill (allbut (@var{infolist}))} очищает все элементы кроме тех,
которые принадлежат информационному списку @var{infolist},
где @var{infolist} есть @code{values}, @code{functions}, @code{arrays}
и т.д.

Отметим, что для освобождения памяти, занимаемой значением символа,
необходимо очистить все объекты ссылающиеся на это значение.
Необходимо не только очистить сам символ, но и результирующую метку
указывающую на его значение.

Функция @code{kill} не вычисляет свои аргументы.
Для их вычисления можно использовать оператор кавычка-кавычка @code{'@w{}'}.

@code{kill (@var{symbol})} очищает все свойства символа @var{symbol} в
отличии от @code{remvalue}, @code{remfunction}, @code{remarray} и
@code{remrule}, которые очищают только определенное свойство.

@code{kill} всегда возвращает @code{done} даже если аргументы не имели
значения.

@opencatbox{Категории:}
@category{Вычисление}
@category{Управление сессией}
@category{Работа в консоли}
@closecatbox
@end deffn

@deffn {Функция} labels (@var{symbol})
@deffnx {Системная переменная} labels
Возвращает список меток ввода, результата или меток промежуточных
выражений, имена которых начинаются с символа @var{symbol}.
Обычно @var{symbol} это значение @code{inchar}, @code{outchar} или @code{linechar}.
Значение @var{symbol} может быть указано с или без знака процента,
например @code{i} и @code{%i} дадут одинаковый результат.

Если ни одна из меток не начинается с @var{symbol}, то возвращается
пустой список.

Функция @code{labels} не вычисляет свои аргументы.
Для их вычисления можно использовать оператор кавычка-кавычка @code{'@w{}'}.
Например, @code{labels (''inchar)} возвращает список меток ввода,
имена которых начинаются с текущего значения символа ввода.

Переменная @code{labels} есть список всех меток ввода, результата и
меток промежуточных выражений, включая все предыдущие метки если
значение @code{inchar}, @code{outchar}  или @code{linechar}
изменялось.

По умолчанию Maxima выводит результат каждого входного выражения
присваивая ему результирующую метку.  Печать результата можно подавить
используя для окончания выражения символ @code{$} вместо обычного
@code{;}.  В этом случае метка результата создается но сам
результат вычисления не печатается.  Тем не менее значение
метки результата запоминается и в дальнейшем может быть
использовано как обычно.  См. также @code{%}, @code{%%} и @code{%th}.

Метки промежуточных выражений создаются некоторыми функциями.
Переключатель @code{programmode} определяет будет ли команда
@code{solve}, и некоторые другие функции, создавать промежуточные
метки или возвращать список выражений.  Некоторые другие функции,
такие как @code{ldisplay}, всегда создают метки промежуточных
выражений.

См. также @code{inchar}, @code{outchar}, @code{linechar} и @code{infolists}.

@opencatbox{Категории:}
@category{Функции вывода}
@category{Флаги и переменные вывода}
@category{Работа в консоли}
@closecatbox
@end deffn

@c EXPAND; SHOW WHAT HAPPENS WHEN linenum IS ASSIGNED A VALUE
@defvr {Системная переменная} linenum
Порядковый номер текущей пары входного и результирующего выражений.


@opencatbox{Категории:}
@category{Флаги и переменные вывода}
@category{Работа в консоли}
@closecatbox
@end defvr

@c NEEDS WORK
@defvr {Системная переменная} myoptions
Значение по умолчанию: @code{[]}

@code{myoptions} есть список всех переключателей (флагов) переопределенных
пользователем вне зависимости от того имеет ли в данный момент
переключатель значение по умолчанию или нет.

@opencatbox{Категории:}
@category{Глобальные переменные}
@category{Управление сессией}
@category{Работа в консоли}
@closecatbox
@end defvr

@defvr {Управляющая переменная} nolabels
Значение по умолчанию: @code{false}

Если @code{nolabels} равна @code{true},
то метки ввода и результата
(@code{%i} и @code{%o}, соответственно)
печатаются но результирующее значение
этим меткам не присваивается а сами  метки не
добавляются к списку @code{labels}.
Поскольку результаты вычислений не
присваиваются меткам, то сборщик мусора
может освободить занимаемую ими память
для дальнейшего использования.

В противном случае меткам ввода и меткам результата присваиваются
соответствующие значения а сами метки добавляются к списку @code{labels}.

Флаг @code{nolabels} не влияет на метки промежуточных выражений (@code{%t}).
Независимо от значения @code{nolabels} равного @code{true} или @code{false},
меткам промежуточных выражений присваиваются значение и они 
добавляются к списку @code{labels}.

См. также @code{batch}, @code{load} и @code{labels}.

@opencatbox{Категории:}
@category{Глобальные флаги}
@category{Управление сессией}
@closecatbox
@end defvr

@c NEEDS WORK
@defvr {Управляющая переменная} optionset
Значение по умолчанию: @code{false}

Если @code{optionset} равно @code{true}, Maxima печатает сообщение
при изменении значения любого переключателя (опция, флаг) Maxima.
Это может быть полезно, когда пользователь не уверен в написании
названия опции и хочет быть уверен, что он переопределил
значение правильной переменной.

@opencatbox{Категории:}
@category{Глобальные флаги}
@category{Управление сессией}
@category{Работа в консоли}
@closecatbox
@end defvr

@deffn {Функция} playback ()
@deffnx {Функция} playback (@var{n})
@deffnx {Функция} playback ([@var{m}, @var{n}])
@deffnx {Функция} playback ([@var{m}])
@deffnx {Функция} playback (input)
@deffnx {Функция} playback (slow)
@deffnx {Функция} playback (time)
@deffnx {Функция} playback (grind)
Выводит значения входных, результирующих и промежуточных
выражений без их перевычисления.
@code{playback} выводит только выражения связанные с метками --
любой другой вывод (текст выведенный @code{print} или @code{describe},
сообщения об ошибках) не отображается.
См. также @code{labels}.

Функция @code{playback} не вычисляет свои аргументы.
Для их вычисления можно использовать оператор кавычка-кавычка @code{'@w{}'}.
@code{playback} возвращает значение @code{done}.

@code{playback ()} (без аргументов) печатает все входные, результирующие и
промежуточные выражения.  Результирующие выражения печатаются даже в случае,
когда во время первоначальных вычислений использовался @code{$} для
подавления печати результата.

@code{playback (@var{n})} печатает @var{n} последних выражений.
Каждое входное, результирующее и промежуточное выражение
считается за одно.

@code{playback ([@var{m}, @var{n}])} печатает входные, результирующие
и промежуточные выражения с номерами от @var{m} до @var{n} включительно.

@code{playback ([@var{m}])} эквивалентно
@code{playback ([@var{m}, @var{m}])} и обычно печатает
одну пару из входного и результирующего выражений.

@code{playback (input)} печатает все входные выражения.

@code{playback (slow)} останавливается между выражениями и
ожидает пока пользователь нажмет "ввод" (@code{enter}).
Данное поведение аналогично команде @code{demo}.
@c WHAT DOES THE FOLLOWING MEAN ???
@code{playback (slow)} полезно в сочетании с @code{save} или
@code{stringout} для выбора выражений, которые надо
сохранить в файле.

@code{playback (time)} показывает время вычисления для каждого выражения.
@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} and @code{totaltime} have the same effect as @code{time}.

@code{playback (grind)} печатает входные выражения в
формате функции @code{grind}.  На результирующие выражения
данная опция не влияет.  См. @code{grind}.

Аргументы функции @code{playback} могут быть скомбинированы,
например @code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS). CORRECT ???

@opencatbox{Категории:}
@category{Функции вывода}
@category{Работа в консоли}
@closecatbox
@end deffn

@c NEEDS WORK ESPECIALLY EXAMPLES
@c WHOLE BUSINESS WITH PROPERTIES IS PRETTY CONFUSING, TRY TO CLEAR IT UP
@deffn {Функция} printprops (@var{a}, @var{i})
@deffnx {Функция} printprops ([@var{a_1}, ..., @var{a_n}], @var{i})
@deffnx {Функция} printprops (all, @var{i})
Печатает свойство с именем @var{i}, ассоциированное с атомом
@var{a}.  @var{a} может быть списком атомов или @code{all}.
В последнем случае будут использованы все атомы имеющие данное свойство.
Например, @code{printprops ([f, g], atvalue)}.  Функция
@code{printprops} предназначена для свойств, которые не могут быть
отображены другим способом, например для
@code{atvalue}, @code{atomgrad}, @code{gradef} и @code{matchdeclare}.

@opencatbox{Категории:}
@category{Факты и выводы}
@category{Функции вывода}
@closecatbox
@end deffn

@defvr {Управляющая переменная} prompt
Значение по умолчанию: @code{_}

@code{prompt} символ приглашения для функции @code{demo},
@code{playback (slow)} и диалога прерывания Maxima (break loop)
(см. @code{break}).

@opencatbox{Категории:}
@category{Глобальные переменные}
@category{Работа в консоли}
@closecatbox
@end defvr

@deffn {Функция} quit ()
Завершает сессию Maxima.
Команда должна быть введена именно как @code{quit();} или @code{quit()$},
а не просто @code{quit}.

Для прерывания длительных вычислений можно нажать @code{control-C}.
При этом по умолчанию Maxima возвращается на верхний уровень к
приглашению ввода следующей команды.
Если значение Lisp-переменной @code{*debugger-hook*} равно @code{nil},
тогда нажатие @code{control-C} запускает Lisp отладчик.
См. также @code{debugging}.

@opencatbox{Категории:}
@category{Работа в консоли}
@closecatbox
@end deffn

@deffn {Функция} remfunction (@var{f_1}, ..., @var{f_n})
@deffnx {Функция} remfunction (all)
@c REPHRASE THIS TO SAY "UNBIND" OR SOMETHING OTHER THAN "REMOVE" (LATTER IS AMBIGUOUS) !!!
Удаляет определенные пользователем функции @var{f_1}, ..., @var{f_n}.
Аргументы могут быть именами обычных функций, созданных при помощи
@code{:=} или @code{define}, или макро функций, созданных при помощи
@code{::=}.

@code{remfunction (all)} -- удаляет все определенные пользователем
функции.

@code{remfunction} не вычисляет свои аргументы.

@code{remfunction} возвращает список символов, для которых
было удалено определение функции.  Для символов, у которых
не было соответствующих определений функций, возвращается
@code{false}.

Функция @code{remfunction} не применима к функциям массивам и переменным с индексом,
к этим типам функций применима @code{remarray}.

@opencatbox{Категории:}
@category{Определение функций}
@closecatbox
@end deffn

@deffn {Функция} reset ()
Восстанавливает значения по умолчанию для глобальных переменных,
опций и некоторых других переменных.

@code{reset} восстанавливает значения переменных хранящихся в Lisp
списке @code{*variable-initial-values*}.
Lisp макрос @code{defmvar} добавляет переменные в этот список
(вместе с выполнением других действий).  Многие, но не все,
глобальные переменные и опции определены с помощью @code{defmvar};
некоторые, определенные с помощью @code{defmvar} переменные, не
являются глобальными переменными или опциями.

@opencatbox{Категории:}
@category{Управление сессией}
@closecatbox
@end deffn

@defvr {Управляющая переменная} showtime
Значение по умолчанию: @code{false}

Если @code{showtime} равно @code{true} Maxima печатает время
вычисления для каждого результирующего выражения.

Время вычисления всегда запоминается, так что
@code{time} и @code{playback} могут показать
это время даже если @code{showtime} равно @code{false}.

См. также @code{timer}.

@opencatbox{Категории:}
@category{Флаги и переменные вывода}
@category{Отладка}
@closecatbox
@end defvr

@c IS THIS ANY DIFFERENT FROM ASSIGNING A PROPERTY ??
@c THIS REALLY SEEMS LIKE A HACK
@deffn {Функция} sstatus (@var{feature}, @var{package})
Устанавливает статус @var{feature} в @var{package}.
После выполнения @code{sstatus (@var{feature}, @var{package})},
@code{status (@var{feature}, @var{package})} возвращает @code{true}.
Этот механизм может быть полезен при работе с пакетами для того, чтобы
иметь возможность проверять какие опции пакета загружены.

@opencatbox{Категории:}
@category{Факты и выводы}
@closecatbox
@end deffn

@c NEEDS EXPANSION, EXAMPLES
@deffn {Функция} to_lisp ()
Запускает интерпретатор используемой Lisp системы.
Lisp функция @code{(to-maxima)} возвращает на уровень командной
строки Maxima.

@opencatbox{Категории:}
@category{Работа в консоли}
@closecatbox
@end deffn

@anchor{eval_string_lisp}
@deffn {Function} eval_string_lisp (@var{str})

Sequentially read lisp forms from the string @var{str} and evaluate them.
Any values produced from the last form are returned as a Maxima list.

Examples:

@c ===beg===
@c eval_string_lisp ("");
@c eval_string_lisp ("(values)");
@c eval_string_lisp ("69");
@c eval_string_lisp ("1 2 3");
@c eval_string_lisp ("(values 1 2 3)");
@c eval_string_lisp ("(defun $foo (x) (* 2 x))");
@c foo (5);
@c ===end===
@example
@group
(%i1) eval_string_lisp ("");
(%o1) []
@end group
@group
(%i2) eval_string_lisp ("(values)");
(%o2) []
@end group
@group
(%i3) eval_string_lisp ("69");
(%o3) [69]
@end group
@group
(%i4) eval_string_lisp ("1 2 3");
(%o4) [3]
@end group
@group
(%i5) eval_string_lisp ("(values 1 2 3)");
(%o5) [1,2,3]
@end group
@group
(%i6) eval_string_lisp ("(defun $foo (x) (* 2 x))");
(%o6) [foo]
@end group
@group
(%i7) foo (5);
(%o7) 10
@end group
@end example

See also @ref{eval_string}.

@opencatbox{Категории:}
@category{Debugging}
@category{Evaluation}
@closecatbox

@end deffn

@defvr {Системная переменная} values
Начальное значение: @code{[]}

@code{values} содержит список всех пользовательских переменных, которым
присвоено значение (не Maxima опций и переключателей).
Этот список состоит из символов, которым было присвоено значение при
помощи операторов @code{:}, @code{::} или @code{:=}.

@opencatbox{Категории:}
@category{Вычисление}
@category{Глобальные переменные} 
@closecatbox
@end defvr

