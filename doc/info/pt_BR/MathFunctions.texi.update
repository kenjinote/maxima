@c
@c versao pt_BR baseada no md5sum abaixo:
@c 942fe3a0d1afebd3279a82c404442e4c  MathFunctions.texi
@c
@menu
* Functions for Numbers::
* Functions for Complex Numbers::
* Combinatorial Functions::
* Root Exponential and Logarithmic Functions::
* Trigonometric Functions::
* Random Numbers::
@end menu

@c -----------------------------------------------------------------------------
@node Functions for Numbers, Functions for Complex Numbers, Mathematical Functions, Mathematical Functions
@section Functions for Numbers
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{abs}
@deffn {Fun@,{c}@~{a}o} abs (@var{z})

A fun@,{c}@~{a}o @code{abs} representa a fun@,{c}@~{a}o de valor absoluto da matem@'{a}tica e
trabalha para ambos os valores num@'{e}ricos e simb@'{o}licos. Se o argumento, @var{z}, for um
n@'{u}mero real ou um n@'{u}mero complexo, a fun@,{c}@~{a}o @code{abs} retorna o valor absoluto de @var{z}. Se
for poss@'{i}vel, express@~{o}es simb@'{o}licas usando a fun@,{c}@~{a}o do valor absoluto s@~{a}o
tambáº½m simplificadas.

Maxima pode derivar, integrar e calcular limites de express@~{o}es
contendo a fun@,{c}@~{a}o @code{abs}. O pacote @code{abs_integrate} adicionalmente extende
a habilidade do Maxima em calcular entegrais envolvendo a fun@,{c}@~{a}o @code{abs}. Veja
(%i12) nos exemplos adiante.

Quando aplicada a uma lista ou a uma matriz, @code{abs} automaticamente distribui sobre
os termos da lista ou da matriz. Similarmente, @code{abs} distribui sobre ambos os lados de uma
equa@,{c}@~{a}o. Para mudar esse comportamento, veja a vari@'{a}vel @mrefdot{distribute_over}

Exemplos:

C@'{a}lculos de @code{abs} para n@'{u}meros reais e para n@'{u}meros complexos, incluindo constantes
num@'{e}ricas e v@'{a}rias infinidades. O primeiro exemplo mostra como @code{abs}
se distribui sobre os componentes de uma lista.

@example
(%i1) abs([-4, 0, 1, 1+%i]);
(%o1)                  [4, 0, 1, sqrt(2)]

(%i2) abs((1+%i)*(1-%i));
(%o2)                           2
(%i3) abs(%e+%i);
                                2
(%o3)                    sqrt(%e  + 1)
(%i4) abs([inf, infinity, minf]);
(%o4)                   [inf, inf, inf]
@end example

Simplifica@,{c}@~{a}o de express@~{o}es contendo @code{abs}:

@example
(%i5) abs(x^2);
                                2
(%o5)                          x
(%i6) abs(x^3);
                             2
(%o6)                       x  abs(x)

(%i7) abs(abs(x));
(%o7)                       abs(x)
(%i8) abs(conjugate(x));
(%o8)                       abs(x)
@end example

Integrando e derivando com a fun@,{c}@~{a}o @code{abs}. Note que mais
integrais envolvendo a fun@,{c}@~{a}o @code{abs} podem ser executadas, se o
pacote @code{abs_integrate} for carregado. O @'{u}ltimo exemplo mostra a transformada de
Laplace de @code{abs}: veja @mrefdot{laplace}

@example
(%i9) diff(x*abs(x),x),expand;
(%o9)                       2 abs(x)

(%i10) integrate(abs(x),x);
                             x abs(x)
(%o10)                       --------
                                2

(%i11) integrate(x*abs(x),x);
                           /
                           [
(%o11)                     I x abs(x) dx
                           ]
                           /

(%i12) load(abs_integrate)$
(%i13) integrate(x*abs(x),x);
                      2           3
                     x  abs(x)   x  signum(x)
(%o13)               --------- - ------------
                         2            6

(%i14) integrate(abs(x),x,-2,%pi);
                               2
                            %pi
(%o14)                      ---- + 2
                             2

(%i15) laplace(abs(x),x,s);
                               1
(%o15)                         --
                                2
                               s
@end example

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{ceiling}
@deffn {Fun@,{c}@~{a}o} ceiling (@var{x})

Quando @var{x} for um n@'{u}mero real, retorna o menor inteiro que
@'{e} maior que ou igual a @var{x}.

Se @var{x} for uma express@~{a}o contante (@code{10 * %pi}, por exemplo), 
@code{ceiling} avalia @var{x} usando grandes n@'{u}meros em ponto flutuante, e 
aplica @code{ceiling} ao grande n@'{u}mero em ponto flutuante resultante.  Devido a @code{ceiling} usar
avalia@,{c}@~{a}o em ponto flutuante, @'{e} poss@'{i}vel, embora com pouca probabilidade, que @code{ceiling}
possa retornar uma valor err@^{o}neo para entradas que envolvam constantes.  Para proteger contra erros,
a avalia@,{c}@~{a}o de n@'{u}meros em ponto flutuante @'{e} realizada usando tr@^{e}s valores para @mrefdot{fpprec}

Para entradas n@~{a}o constantes, @code{ceiling} tenta retornar um valor simplificado.
Aqui est@~{a}o exemplos de simplifica@,{c}@~{o}es que @code{ceiling} sabe fazer:

@c ===beg===
@c ceiling (ceiling (x));
@c ceiling (floor (x));
@c declare (n, integer)$
@c [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
@c assume (x > 0, x < 1)$
@c ceiling (x);
@c tex (ceiling (a));
@c ===end===
@example
(%i1) ceiling (ceiling (x));
(%o1)                      ceiling(x)
(%i2) ceiling (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
(%o4)                [n, abs(n), max(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) ceiling (x);
(%o6)                           1
(%i7) tex (ceiling (a));
$$\left \lceil a \right \rceil$$
(%o7)                         false
@end example

A fun@,{c}@~{a}o @code{ceiling} distribui sobre listas, matrizes e equa@,{c}@~{o}es.
Veja @mrefdot{distribute_over}

Finalmente, para todas as entradas que forem claramente complexas, @code{ceiling} retorna 
uma forma substantiva.

Se o intervalo de uma fun@,{c}@~{a}o for um subconjunto dos inteiros, essa fun@,{c}@~{a}o pode ser declarada
como portadora da propriedade @code{integervalued}.  Ambas as fun@,{c}@~{o}es @code{ceiling} e @mref{floor}
podem usar essa informa@,{c}@~{a}o, por exemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

Exemplo de uso:

@c ===beg===
@c unitfrac(r) := block([uf : [], q],
@c     if not(ratnump(r)) then 
@c        error("unitfrac: argument must be a rational number"),
@c     while r # 0 do (
@c         uf : cons(q : 1/ceiling(1/r), uf),
@c         r : r - q),
@c     reverse(uf));
@c unitfrac (9/10);
@c apply ("+", %);
@c unitfrac (-9/10);
@c apply ("+", %);
@c unitfrac (36/37);
@c apply ("+", %);
@c ===end===
@example
@group
(%i1) unitfrac(r) := block([uf : [], q],
    if not(ratnump(r)) then
       error("unitfrac: argument must be a rational number"),
    while r # 0 do (
        uf : cons(q : 1/ceiling(1/r), uf),
        r : r - q),
    reverse(uf))$
@end group
(%i2) unitfrac (9/10);
                            1  1  1
(%o2)                      [-, -, --]
                            2  3  15
(%i3) apply ("+", %);
                               9
(%o3)                          --
                               10
(%i4) unitfrac (-9/10);
                                  1
(%o4)                       [- 1, --]
                                  10
(%i5) apply ("+", %);
                                9
(%o5)                         - --
                                10
(%i6) unitfrac (36/37);
                        1  1  1  1    1
(%o6)                  [-, -, -, --, ----]
                        2  3  8  69  6808
(%i7) apply ("+", %);
                               36
(%o7)                          --
                               37
@end example

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{entier}
@deffn {Fun@,{c}@~{a}o} entier (@var{x})

Retorna o maior inteiro menor que ou igual a @var{x} onde @var{x} @'{e}
num@'{e}rico.  A fun@,{c}@~{a}o @mref{fix} (como em @code{fixnum}) @'{e} um sin@^{o}nimo de @code{entier}, de forma que
@code{fix(@var{x})} significa precisamente a mesma coisa.

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{floor}
@deffn {Fun@,{c}@~{a}o} floor (@var{x})

Quando @var{x} for um n@'{u}mero real, retorna o maior inteiro que @'{e} menor que ou
igual a @var{x}.

Se @var{x} for uma express@~{a}o constante (@code{10 * %pi}, por exemplo), @code{floor}
avalia @var{x} usando grandes n@'{u}meros em ponto flutuante, e aplica @code{floor} ao
grande n@'{u}mero em ponto flutuante resultante. Devido a @code{floor} usar avalia@,{c}@~{a}o em ponto flutuante,
@'{e} poss@'{i}vel, embora com pouca probabilidade, que @code{floor} possa retornar uma valor err@^{o}neo
para entradas que envolvam constantes.  Para proteger contra erros, a avalia@,{c}@~{a}o de
n@'{u}meros em ponto flutuante @'{e} realizada usando tr@^{e}s valores para @mrefdot{fpprec}

Para entradas n@~{a}o constantes, @code{floor} tenta retornar um valor simplificado.  Aqui
est@'{a} exemplos de simplifica@,{c}@~{o}es que @code{floor} sabe fazer:

@c ===beg===
@c floor (ceiling (x));
@c floor (floor (x));
@c declare (n, integer)$
@c [floor (n), floor (abs (n)), floor (min (n, 6))];
@c assume (x > 0, x < 1)$
@c floor (x);
@c tex (floor (a));
@c ===end===
@example
(%i1) floor (ceiling (x));
(%o1)                      ceiling(x)
(%i2) floor (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
(%o4)                [n, abs(n), min(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) floor (x);
(%o6)                           0
(%i7) tex (floor (a));
$$\left \lfloor a \right \rfloor$$
(%o7)                         false
@end example

A fun@,{c}@~{a}o @code{floor} distribui sobre listas, matrizes e equa@,{c}@~{o}es.
Veja @mrefdot{distribute_over}

Finalmente, para todas as entradas que forem claramente complexas, @code{floor} retorna 
uma forma substantiva.

Se o intervalo de uma fun@,{c}@~{a}o for um subconjunto dos inteiros, essa fun@,{c}@~{a}o pode ser declarada
como portadora da propriedade @code{integervalued}.  Ambas as fun@,{c}@~{o}es @mref{ceiling} e @code{floor}
podem usar essa informa@,{c}@~{a}o, por exemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{fix}
@deffn {Fun@,{c}@~{a}o} fix (@var{x})

Um sin@^{o}nimo para @code{entier (@var{x})}.

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{lmax}
@deffn {Fun@,{c}@~{a}o} lmax (@var{L})

Quando @var{L} for uma lista ou um conjunto, retorna @code{apply ('max, args (@var{L}))}.
Quando @var{L} n@~{a}o for uma lista ou um conjunto, sinaliza um erro.
Veja tamb@'{e}m @mref{lmin} e @mrefdot{max}

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas} @category{Listas} @category{Sets}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{lmin}
@deffn {Fun@,{c}@~{a}o} lmin (@var{L})

Quando @var{L} for uma lista ou um conjunto, retorna @code{apply ('min, args (@var{L}))}.
Quando @var{L} n@~{a}o for uma lista ou um conjunto, sinaliza um erro.
Veja tamb@'{e}m @mref{lmax} e @mrefdot{min}

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas} @category{Listas} @category{Sets}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{max}
@deffn {Fun@,{c}@~{a}o} max (@var{x_1}, @dots{}, @var{x_n})

Retorna a valor simplificado para o maior valor entre os membros de @var{x_1} a
@var{x_n}.  Quando @code{get (trylevel, maxmin)}, for 2 ou maior, a fun@,{c}@~{a}o @code{max}
usa a simplifica@,{c}@~{a}o @code{max (e, -e) --> |e|}.  Quando
@code{get (trylevel, maxmin)} for 3 ou maior, @var{max} tenta eliminar
express@~{o}es que estejam entre dois outros argumentos; por exemplo,
@code{max (x, 2*x, 3*x) --> max (x, 3*x)}.  Para ajustar o valor de @code{trylevel}
para 2, use @code{put (trylevel, 2, maxmin)}.

Veja tamb@'{e}m @mref{min} e @mrefdot{lmax}

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{min}
@deffn {Fun@,{c}@~{a}o} min (@var{x_1}, @dots{}, @var{x_n})

Retorna um valor simplificado para o menor valor entre os membros de @code{x_1} a
@code{x_n}.  Quando @code{get (trylevel, maxmin)}, for 2 ou maior, a fun@,{c}@~{a}o @code{min}
usa a simplifica@,{c}@~{a}o @code{min (e, -e) --> -|e|}.  Quando
@code{get (trylevel, maxmin)} for 3 ou maior, @code{min} tenta eliminar
express@~{o}es que est@~{a}o entre dois outros argumentos; por exemplo,
@code{min (x, 2*x, 3*x) --> min (x, 3*x)}.  Para ajustar o valor de @code{trylevel}
para 2, use @code{put (trylevel, 2, maxmin)}.

Veja tamb@'{e}m @mref{max} e @mrefdot{lmin}

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{round}
@deffn {Fun@,{c}@~{a}o} round (@var{x})

Quando @var{x} for um n@'{u}mero real, retorna o inteiro mais pr@'{o}ximo a @var{x}.
Multiplos de 1/2 s@~{a}o arredonda the nearest even integer.  Evaluation of
@var{x} is similar to @mref{floor} and @mrefdot{ceiling}

A fun@,{c}@~{a}o @code{round} distribui sobre listas, matrizes e equa@,{c}@~{o}es.
Veja @mrefdot{distribute_over}

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{signum}
@deffn {Fun@,{c}@~{a}o} signum (@var{x})

Para n@'{u}meros reais e complexos @var{x}, a fun@,{c}@~{a}o @code{signum} retorna
0 se @var{x} for zero; para uma entrada @var{x} n@~{a}o nula, a fun@,{c}@~{a}o @code{signum}
retorna @code{x/abs(x)}.

Para entradas n@~{a}o num@'{e}ricas, Maxima tenta determinar o sinal da entrada.
Quando o sinal for negativo, quando o n@'{u}mero for zero, quando o sinal for positive, @code{signum} retorna -1,0, 1,
respectivamente.  Para todos os outros valores para o sinal, @code{signum} retorna uma forma
simplificada mas equivalente.  As simplifica@,{c}@~{o}es incluem reflection (@code{signum(-x)}
gives @code{-signum(x)}) and multiplicative identity (@code{signum(x*y)} gives
@code{signum(x) * signum(y)}).

A fun@,{c}@~{a}o @code{signum} distribui sobre uma lista, uma matriz, ou sobre uma
equa@,{c}@~{a}o.  Veja @mrefdot{distribute_over}

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{truncate}
@deffn {Fun@,{c}@~{a}o} truncate (@var{x})

Quando @var{x} for um n@'{u}mero real, retorna o inteiro mais pr@'{o}ximo a @var{x} n@~{a}o
maior que (em valor absoluto) @var{x}.  Avalia@,{c}@~{a}o de @var{x} @'{e} similar
a @mref{floor} e a @mrefdot{ceiling}

A fun@,{c}@~{a}o @code{truncate} distribui sobre listas, matrizes e equa@,{c}@~{o}es.
Veja @mrefdot{distribute_over}

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Functions for Complex Numbers, Combinatorial Functions, Functions for Numbers, Mathematical Functions
@section Functions for Complex Numbers
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{cabs}
@deffn {Fun@,{c}@~{a}o} cabs (@var{expr})

Calcula o valor absoluto de uma express@~{a}o representando um n@'{u}mero
complexo.  Diferentemente da fun@,{c}@~{a}o @mrefcomma{abs} a fun@,{c}@~{a}o @code{cabs} sempre
decomp@~{o}es seus argumentos em uma parte real e uma parte imagin@'{a}ria.  Se @code{x} e
@code{y} representarem vari@'{a}veis reais ou express@~{o}es reais, a fun@,{c}@~{a}o @code{cabs}
calculates o valor absoluto de @code{x + %i*y} como sendo
@example
                           2    2
                     sqrt(y  + x )
@end example

A fun@,{c}@~{a}o @code{cabs} pode usar conhecidas propriedades como as propriedades de simetria das
fun@,{c}@~{o}es complexas para ajudar no c@'{a}lculo do valor absoluto de uma express@~{a}o.  Se
tais identidades ocorrerem nas express@~{o}es, elas podem alertar @code{cabs} sobre o uso das propriedade de
simetria.  As propriedades de simetria que @code{cabs} entende s@~{a}o: reflex@~{a}o em rela@,{c}@~{a}o @`{a} or@'{i}gem,
conjugado e caracter@'{i}stica complexa.

A fun@,{c}@~{a}o @code{cabs} @'{e} uma fun@,{c}@~{a}o verbo e n@~{a}o @'{e} adequada a c@'{a}lculos
simb@'{o}licos.  Para tais c@'{a}lculos simb@'{o}licos (incluindo integra@,{c}@~{a}o,
diferencia@,{c}@~{a}o e limites de express@~{o}es contendo valores
absolutos), use @mrefdot{abs}

O resultado de @code{cabs} pode incluir a fun@,{c}@~{a}o de valor absoluto,
@mrefcomma{abs} e a fun@,{c}@~{a}o arco tangente, @mrefdot{atan2}

Quando aplicada a uma lista ou a uma matriz, @code{cabs} automaticamente se distribui nos
termos da lista ou da matriz.  Similarmente, a @code{cabs} se distribui sobre ambos os lados de uma equa@,{c}@~{a}o.

Para caminhos adicionais para c@'{a}lculos com n@'{u}meros complexos, veja as fun@,{c}@~{o}es
@mrefcomma{rectform} @mrefcomma{realpart} @mrefcomma{imagpart}@w{}
@mrefcomma{carg} @mref{conjugate} e @mrefdot{polarform}

Exemplos:

Exemplos com @mref{sqrt} e @mrefdot{sin}

@example
(%i1) cabs(sqrt(1+%i*x));
                             2     1/4
(%o1)                      (x  + 1)
(%i2) cabs(sin(x+%i*y));
                    2        2         2        2
(%o2)       sqrt(cos (x) sinh (y) + sin (x) cosh (y))
@end example

A fun@,{c}@~{a}o de erro, @mrefcomma{erf} tem reflex@~{a}o, que @'{e} usada aqui no
c@'{a}lculo do valor absoluto com um argumento complexo:

@example
(%i3) cabs(erf(x+%i*y));
                                          2
           (erf(%i y + x) - erf(%i y - x))
(%o3) sqrt(--------------------------------
                          4
                                                               2
                                (erf(%i y + x) + erf(%i y - x))
                              - --------------------------------)
                                               4
@end example

Maxima conhece identidades complexas para as fun@,{c}@~{o}es de Bessel, que permitem
ao Maxima calcular o valor absoluto para argumentos complexos.  Aqui est@'{a} um
exemplo para @mrefdot{bessel_j}

@example
(%i4) cabs(bessel_j(1,%i));
(%o4)                 abs(bessel_j(1, %i))
@end example

@opencatbox
@category{Vari@'{a}veis complexas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{carg}
@deffn {Fun@,{c}@~{a}o} carg (@var{z})

Retorna o argumento de @var{z}.  O argumento @'{e} um @^{a}ngulo
@code{theta} no intervalo @code{(-%pi, %pi]} tal que @code{r exp (theta %i) = @var{z}}
onde @code{r} @'{e} a magnitude @footnote{Nota do tradutor:m@'{o}dulo.} de @var{z}.

A fun@,{c}@~{a}o @code{carg} @'{e} uma fun@,{c}@~{a}o computacional, n@~{a}o uma fun@,{c}@~{a}o de simplifica@,{c}@~{a}o.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT

Veja tamb@'{e}m @mref{abs} (magnitude de um n@'{u}mero complexo), @mrefcomma{polarform}@w{}
@mrefcomma{rectform} @mrefcomma{realpart} e @mrefdot{imagpart}

Exemplos:

@c ===beg===
@c carg (1);
@c carg (1 + %i);
@c carg (exp (%i));
@c carg (exp (%pi * %i));
@c carg (exp (3/2 * %pi * %i));
@c carg (17 * exp (2 * %i));
@c ===end===
@example
(%i1) carg (1);
(%o1)                           0
(%i2) carg (1 + %i);
                               %pi
(%o2)                          ---
                                4
(%i3) carg (exp (%i));
(%o3)                           1
(%i4) carg (exp (%pi * %i));
(%o4)                          %pi
(%i5) carg (exp (3/2 * %pi * %i));
                                %pi
(%o5)                         - ---
                                 2
(%i6) carg (17 * exp (2 * %i));
(%o6)                           2
@end example

@opencatbox
@category{Vari@'{a}veis complexas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{conjugate}
@deffn {Fun@,{c}@~{a}o} conjugate (@var{x})

Retorna o conjugado de @var{x}.

@c ===beg===
@c declare ([aa, bb], real, cc, complex, ii, imaginary);
@c conjugate (aa + bb*%i);
@c conjugate (cc);
@c conjugate (ii);
@c conjugate (xx + yy);
@c ===end===
@example
(%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

(%o1)                         done
(%i2) conjugate (aa + bb*%i);

(%o2)                      aa - %i bb
(%i3) conjugate (cc);

(%o3)                     conjugate(cc)
(%i4) conjugate (ii);

(%o4)                         - ii
(%i5) conjugate (xx + yy);

(%o5)             conjugate(yy) + conjugate(xx)
@end example

@opencatbox
@category{Vari@'{a}veis complexas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{imagpart}
@deffn {Fun@,{c}@~{a}o} imagpart (@var{expr})

Retorna a parte imagin@'{a}ria da express@~{a}o @var{expr}.

A fun@,{c}@~{a}o @code{imagpart} @'{e} uma fun@,{c}@~{a}o computacional, n@~{a}o uma fun@,{c}@~{a}o de simplifica@,{c}@~{a}o.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

Veja tamb@'{e}m @mrefcomma{abs} @mrefcomma{carg} @mrefcomma{polarform}@w{}
@mrefcomma{rectform} e @mrefdot{realpart}

Exemplo:

@c ===beg===
@c imagpart (a+b*%i);
@c imagpart (1+sqrt(2)*%i);
@c imagpart (1);
@c imagpart (sqrt(2)*%i);
@c ===end===
@example
(%i1) imagpart (a+b*%i);
(%o1)                                  b
(%i2) imagpart (1+sqrt(2)*%i);
(%o2)                               sqrt(2)
(%i3) imagpart (1);
(%o3)                                  0
(%i4) imagpart (sqrt(2)*%i);
(%o4)                               sqrt(2)
@end example

@opencatbox
@category{Vari@'{a}veis complexas}
@closecatbox
@end deffn
@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{polarform}
@deffn {Fun@,{c}@~{a}o} polarform (@var{expr})

Retorna uma express@~{a}o @code{r %e^(%i theta)} equivalente a @var{expr},
tal que @code{r} e @code{theta} sejam reais.

Exemplo:

@c ===beg===
@c polarform(a+b*%i);
@c polarform(1+%i);
@c polarform(1+2*%i);
@c ===end===
@example
(%i1) polarform(a+b*%i);
                              2    2    %i atan2(b, a)
(%o1)                   sqrt(b  + a ) %e
(%i2) polarform(1+%i);
                                         %i %pi
                                         ------
                                           4
(%o2)                          sqrt(2) %e
(%i3) polarform(1+2*%i);
                                       %i atan(2)
(%o3)                        sqrt(5) %e
@end example

@opencatbox
@category{Vari@'{a}veis complexas} @category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{realpart}
@deffn {Fun@,{c}@~{a}o} realpart (@var{expr})

Retorna a parte real de @var{expr}.  As fun@,{c}@~{o}es @code{realpart} e @mref{imagpart} ir@~{a}o
trabalhar sobre express@~{o}es envolvendo fun@,{c}@~{o}es trigonom@'{e}tricas e hiperb@'{o}licas,
bem como ra@'{i}zes quadradas, logaritmos, e exponenciais.

Exemplo:

@c ===beg===
@c realpart (a+b*%i);
@c realpart (1+sqrt(2)*%i);
@c realpart (sqrt(2)*%i);
@c realpart (1);
@c ===end===
@example
(%i1) realpart (a+b*%i);
(%o1)                                  a
(%i2) realpart (1+sqrt(2)*%i);
(%o2)                                  1
(%i3) realpart (sqrt(2)*%i);
(%o3)                                  0
(%i4) realpart (1);
(%o4)                                  1
@end example

@opencatbox
@category{Vari@'{a}veis complexas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{rectform}
@deffn {Fun@,{c}@~{a}o} rectform (@var{expr})

Retorna uma express@~{a}o @code{a + b %i} equivalente a @var{expr},
tal que @var{a} e @var{b} sejam reais.

Exemplo:

@c ===beg===
@c rectform(sqrt(2)*%e^(%i*%pi/4));
@c rectform(sqrt(b^2+a^2)*%e^(%i*atan2(b, a)));
@c rectform(sqrt(5)*%e^(%i*atan(2)));
@c ===end===
@example
(%i1) rectform(sqrt(2)*%e^(%i*%pi/4));
(%o1)                               %i + 1
(%i2) rectform(sqrt(b^2+a^2)*%e^(%i*atan2(b, a)));
(%o2)                              %i b + a
(%i3) rectform(sqrt(5)*%e^(%i*atan(2)));
(%o3)                              2 %i + 1
@end example

@opencatbox
@category{Vari@'{a}veis complexas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Combinatorial Functions, Root Exponential and Logarithmic Functions, Functions for Complex Numbers, Mathematical Functions
@section Combinatorial Functions
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{!!}
@deffn {Operador} !!
@ifinfo
@fnindex Duplo fatorial
@end ifinfo

O operador de duplo fatorial.

Para um n@'{u}mero inteiro, n@'{u}mero em ponto flutuante, ou n@'{u}mero racional @code{n}, @code{n!!} avalia para o
produto @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))} onde @code{k} @'{e} igual a
@code{entier (n/2)}, isto @'{e}, o maior inteiro menor que ou igual a
@code{n/2}.  Note que essa defini@,{c}@~{a}o n@~{a}o coincide com outras defini@,{c}@~{o}es
publicadas para argumentos que n@~{a}o s@~{a}o inteiros.
@c REPORTED TO BUG TRACKER AS BUG # 1093138 !!!

Para um inteiro par (ou @'{i}mpar) @code{n}, @code{n!!} avalia para o produto de
todos os inteiros consecutivos pares (ou @'{i}mpares) a partir de 2 (ou de 1) at@'{e} @code{n}
inclusive.

Para um argumento @code{n} que n@~{a}o @'{e} um n@'{u}mero inteiro, n@'{u}mero em ponto flutuante, ou n@'{u}mero racional, @code{n!!}
retorna uma forma substantiva @code{genfact (n, n/2, 2)}.
@c n!! IS NEITHER SIMPLIFIED NOR EVALUATED IN THIS CASE 
@c -- MENTION THAT? OR TOO MUCH DETAIL ???

@opencatbox
@category{Gamma and factorial functions} @category{Operadores}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{binomial}
@deffn {Fun@,{c}@~{a}o} binomial (@var{x}, @var{y})

O coeficiente binaomial @code{@var{x}!/(@var{y}! (@var{x} - @var{y})!)}.
Se @var{x} e @var{y} forem inteiros, ent@~{a}o o valor num@'{e}rico do coeficiente
binomial @'{e} calculado.  Se @var{y}, ou @var{x - y}, for um intero, o
coeficiente binomial @'{e} expresso como um polin@^{o}mio.

Exemplos:

@c ===beg===
@c binomial (11, 7);
@c 11! / 7! / (11 - 7)!;
@c binomial (x, 7);
@c binomial (x + 7, x);
@c binomial (11, y);
@c ===end===
@example
(%i1) binomial (11, 7);
(%o1)                          330
(%i2) 11! / 7! / (11 - 7)!;
(%o2)                          330
(%i3) binomial (x, 7);
        (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
(%o3)   -------------------------------------------------
                              5040
(%i4) binomial (x + 7, x);
      (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
(%o4) -------------------------------------------------------
                               5040
(%i5) binomial (11, y);
(%o5)                    binomial(11, y)
@end example

@opencatbox
@category{Number theory}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{factcomb}
@deffn {Fun@,{c}@~{a}o} factcomb (@var{expr})

Tenta combinar os coeficientes de fatoriais em @var{expr}
com os fatoriais em si mesmos por convers@~{a}o, por exemplo, @code{(n + 1)*n!}
converte em @code{(n + 1)!}.

A vari@'{a}vel de op@,{c}@~{a}o @mref{sumsplitfact} se ajustada para @code{false} far@'{a} com que @mref{minfactorial} seja
aplicada ap@'{o}s um @code{factcomb}.

Exemplo:

@c ===beg===
@c sumsplitfact;
@c (n + 1)*(n + 1)*n!;
@c factcomb (%);
@c sumsplitfact: not sumsplitfact;
@c (n + 1)*(n + 1)*n!;
@c factcomb (%);
@c ===end===
@example
(%i1) sumsplitfact;
(%o1)                                true
(%i2) (n + 1)*(n + 1)*n!;
                                         2
(%o2)                             (n + 1)  n!
(%i3) factcomb (%);
(%o3)                         (n + 2)! - (n + 1)!
(%i4) sumsplitfact: not sumsplitfact;
(%o4)                                false
(%i5) (n + 1)*(n + 1)*n!;
                                          2
(%o5)                             (n + 1)  n!
(%i6) factcomb (%);
(%o6)                        n (n + 1)! + (n + 1)!
@end example

@opencatbox
@category{Gamma and factorial functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{!}
@anchor{factorial}
@deffn  {Fun@,{c}@~{a}o} factorial
@deffnx {Operador} !

Representa a fun@,{c}@~{a}o fatorial.  Maxima trata @code{factorial (@var{x})}
da mesma forma que @code{@var{x}!}.

Para quaisquer n@'{u}meros complexos @code{x}, exceto para inteiros negativos, @code{x!} @'{e} 
definido como @code{gamma(x+1)}.

Para um inteiro @code{x}, @code{x!} simplifica para o produto de inteiros 
de 1 a @code{x} inclusive.  O comando @code{0!} simplifica para 1.  Para um n@'{u}mero real ou para um
n@'{u}mero complexo de precis@~{a}o equivalente @`{a} de um float ou @`{a} de um bigfloat @code{x}, @code{x!} simplifica para o
valor de @code{gamma (x+1)}.  Para @code{x} igual a @code{n/2} onde @code{n} @'{e} 
um inteiro @'{i}mpar, @code{x!} simplifica para um fator racional vezes 
@code{sqrt (%pi)} (uma vez que @code{gamma (1/2)} @'{e} igual a @code{sqrt (%pi)}).

As vari@'{a}veis de op@,{c}@~{a}o @mref{factlim} e @mref{gammalim} controlam a avalia@,{c}@~{a}o
num@'{e}rica de fatoriais para argumentos inteiros e racionais.  As fun@,{c}@~{o}es 
@mref{minfactorial} e @mref{factcomb} simplificam express@~{o}es contendo
fatoriais.

As fun@,{c}@~{o}es @mrefcomma{gamma} @mrefcomma{bffac} e @mref{cbffac} s@~{a}o
variedades da fun@,{c}@~{a}o gama.  As fun@,{c}@~{o}es @code{bffac} e @code{cbffac} s@~{a}o chamadas
internamente por @code{gamma} para avaliar a fun@,{c}@~{a}o gama para n@'{u}meros reais e
complexos em precis@~{a}o equivalente @`{a} de um bigfloat.

A fun@,{c}@~{a}o @mref{makegamma} substitui a fun@,{c}@~{a}o @code{gamma} para fatoriais e fun@,{c}@~{o}es relacionadas.

Maxima conhece a derivada da fun@,{c}@~{a}o fatorial e os limites para 
valores espec@'{i}ficos como inteiros negativos.

A vari@'{a}vel de op@,{c}@~{a}o @mref{factorial_expand} controla a simplifica@,{c}@~{a}o de
express@~{o}es como @code{(n+x)!}, onde @code{n} @'{e} um inteiro.

Veja tamb@'{e}m @mrefdot{binomial}

O fatorial de um inteiro @'{e} simplificado para um n@'{u}mero exato a menos que o operando 
seja maior que @code{factlim}.  O fatorial para n@'{u}meros reais e para n@'{u}meros complexos @'{e} 
avaliado em precis@~{a}o equivalente @`{a} de um float ou em precis@~{a}o equivalente @`{a} de um bigfloat.

@c ===beg===
@c factlim : 10;
@c [0!, (7/2)!, 8!, 20!];
@c [4,77!, (1.0+%i)!];
@c [2.86b0!, 1.0b0+%i)!];
@c ===end===
@example
(%i1) factlim:10;
(%o1)                                 10
(%i2) [0!, (7/2)!, 8!, 20!];
@group
                            105 sqrt(%pi)
(%o2)                   [1, -------------, 40320, 20!]
                                 16
@end group
(%i3) [4.77!, (1.0+%i)!];
(%o3)    [81.44668037931197, 
          .3430658398165454 %i + .6529654964201665]
(%i4) [2.86b0!, (1.0b0+%i)!];
(%o4) [5.046635586910012b0, 
       3.430658398165454b-1 %i + 6.529654964201667b-1]
@end example

O fatorial de uma constante assumida, ou de uma express@~{a}o geral n@~{a}o @'{e} simplificado.
Mesmo assim pode ser poss@'{i}vel simplificar o fatorial ap@'{o}s ser feita a avalia@,{c}@~{a}o do
operando.

@c ===beg===
@c [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
@c ev (%, numer, %enumer);
@c ===end===
@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [.3430658398165454 %i + .6529654964201665, 
       7.188082728976031, 
       4.260820476357003, 1.227580202486819]
@end example

@c REMOVING THIS EXAMPLE. IT IS NOT SPECIFIC FOR THE FACTORIAL FUNCTION:
@c The factorial of an unbound symbol is not simplified.

@c @c ===beg===
@c @c kill (foo);
@c @c foo!;
@c @c ===end===
@c @example
@c (%i1) kill (foo);
@c (%o1)                         done
@c (%i2) foo!;
@c (%o2)                         foo!
@c @end example

Fatoriais s@~{a}o simplificados, n@~{a}o avaliados.
Dessa forma @code{x!} pode ser substitu@'{i}do mesmo em uma express@~{a}o com um ap@'{o}strofo inicial.

@c ===beg===
@c '([0!, (7/2)!, 4.77!, 8!, 20!]);
@c ===end===
@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931199, 40320, 
               16
                                             2432902008176640000]
@end example

Maxima conhece a derivada da fun@,{c}@~{a}o fatorial.

@c ===beg===
@c diff(x!,x);
@c ===end===
@example
(%i1) diff(x!,x);
(%o1)                           x! psi (x + 1)
                                      0
@end example

A vari@'{a}vel de op@,{c}@~{a}o @code{factorial_expand} controla a expans@~{a}o e 
simplifica@,{c}@~{a}o de express@~{o}es com a fun@,{c}@~{a}o fatorial.

@c ===beg===
@c (n+1)!/n!,factorial_expand:true;
@c ===end===
@example
(%i1) (n+1)!/n!,factorial_expand:true;
(%o1)                                n + 1
@end example

@opencatbox
@category{Gamma and factorial functions} @category{Operadores}
@closecatbox
@end deffn

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{factlim}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} factlim
Valor padr@~{a}o: -1

A vari@'{a}vel de op@,{c}@~{a}o @code{factlim} especifica o maior fatorial que @'{e}
automaticamente expandido.  Se for -1 ent@~{a}o qualquer inteiro @'{e} expandido.

@opencatbox
@category{Gamma and factorial functions}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{factorial_expand}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} factorial_expand
Valor padr@~{a}o: false

A vari@'{a}vel de op@,{c}@~{a}o @code{factorial_expand} controla a simplifica@,{c}@~{a}o de 
express@~{o}es como @code{(n+1)!}, onde @code{n} @'{e} um inteiro.
Veja @mref{factorial} para um exemplo.

@opencatbox
@category{Gamma and factorial functions}
@closecatbox
@end defvr

@c IS THIS DEFINITION CORRECT ??

@c -----------------------------------------------------------------------------
@anchor{genfact}
@deffn {Fun@,{c}@~{a}o} genfact (@var{x}, @var{y}, @var{z})

Retorna o fatorial generalizado @footnote{Nota do tradutor: a fun@,{c}@~{a}o gama.}, definido como
@code{x (x-z) (x - 2 z) ... (x - (y - 1) z)}.  Dessa forma, quando @var{x} for inteiro,
@code{genfact (x, x, 1) = x!} e @code{genfact (x, x/2, 2) = x!!}.

@opencatbox
@category{Gamma and factorial functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{minfactorial}
@deffn {Fun@,{c}@~{a}o} minfactorial (@var{expr})

Examina @var{expr} @`{a} procura de ocorr@^{e}ncias de dois fatoriais
que diferem entre s@'{i} de uma quantidade inteira.
@code{minfactorial} ent@~{a}o transforma um em um polin@^{o}mio vezes o outro.

@c I CAN'T TELL WHAT THIS IS SUPPOSED TO MEAN. !!!
@c minfactorial DOESN'T SEEM TO DO ANYTHING binomial DOESN'T DO BY ITSELF !!!
@c LOOKING AT THE minfactorial CODE DOESN'T HELP !!!
@c If exp involves binomial coefficients then they will be
@c converted into ratios of factorials.

@example
(%i1) n!/(n+2)!;
                               n!
(%o1)                       --------
                            (n + 2)!
(%i2) minfactorial (%);
                                1
(%o2)                    ---------------
                         (n + 1) (n + 2)
@end example

@opencatbox
@category{Number theory}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sumsplitfact}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} sumsplitfact
Valor padr@~{a}o: @code{true}

Quando @code{sumsplitfact} for @code{false},
@c "IS APPLIED" -- UNDER WHAT CIRCUMSTANCES EXACTLY ??
@mref{minfactorial} @'{e} aplicada ap@'{o}s um @mrefdot{factcomb}

@c ===beg===
@c sumsplitfact;
@c n!/(n+2)!;
@c factcomb(%);
@c sumsplitfact: not sumsplitfact ;
@c n!/(n+2)!;
@c factcomb(%);
@c ===end===
@example
(%i1) sumsplitfact
(%o1)                                true
(%i2) n!/(2+n)!
                                      n!
(%o2)                              --------
                                   (n + 2)!
(%i3) factcomb(%)
                                      n!
(%o3)                              --------
                                   (n + 2)!
(%i4) sumsplitfact:not sumsplitfact
(%o4)                                false
(%i5) n!/(2+n)!
                                      n!
(%o5)                              --------
                                   (n + 2)!
(%i6) factcomb(%)
                                       1
(%o6)                           ---------------
                                (n + 1) (n + 2)
@end example

@opencatbox
@category{Gamma and factorial functions} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@node Root Exponential and Logarithmic Functions, Trigonometric Functions, Combinatorial Functions, Mathematical Functions
@section Root, Exponential and Logarithmic Functions
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{%e_to_numlog}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} %e_to_numlog
Valor padr@~{a}o: @code{false}

Quando @code{true}, @code{r} algum n@'{u}mero racional, e @code{x} slguma express@~{a}o,
@code{%e^(r*log(x))} ir@'{a} ser simplificado em @code{x^r} .  Deve ser notado
que o comando @code{radcan} tamb@'{e}m faz essa transforma@,{c}@~{a}o, e mais
complicadas transforma@,{c}@~{o}es desse mesmo tipo tamb@'{e}m.  O comando
@code{logcontract} "contrai" express@~{o}es contendo @code{log}.

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{%emode}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} %emode
Valor padr@~{a}o: @code{true}

Quando @code{%emode} for @code{true}, @code{%e^(%pi %i x)} @'{e} simplificado como
segue.

O comando @code{%e^(%pi %i x)} simplifica para @code{cos (%pi x) + %i sin (%pi x)} se
@code{x} for um n@'{u}mero em ponto flutuante, um inteiro, ou um m@'{u}ltiplo de 1/2, 1/3, 1/4,
ou 1/6, e ent@~{a}o @'{e} simplificado novamente.

Para outro n@'{u}mero @code{x}, @code{%e^(%pi %i x)} simplifica para
@code{%e^(%pi %i y)} onde @code{y} @'{e} @code{x - 2 k} para algum inteiro @code{k}
tal que @code{abs(y) < 1}.

Quando @code{%emode} for @code{false}, nenhuma simplifica@,{c}@~{a}o especial de
@code{%e^(%pi %i x)} @'{e} realizada.

@c ===beg===
@c %emode;
@c %e^(%pi*%i*1);
@c %e^(%pi*%i*216/144);
@c %e^(%pi*%i*192/144);
@c %e^(%pi*%i*180/144);
@c %e^(%pi*%i*120/144);
@c %e^(%pi*%i*121/144);
@c ===end===
@example
(%i1) %emode
(%o1)                                true
(%i2) %e^(%pi*%i*1)
(%o2)                                 - 1
(%i3) %e^(%pi*%i*216/144)
(%o3)                                - %i
(%i4) %e^(%pi*%i*192/144)
                                 sqrt(3) %i   1
(%o4)                          - ---------- - -
                                     2        2
(%i5) %e^(%pi*%i*180/144)
                                  %i         1
(%o5)                         - ------- - -------
                                sqrt(2)   sqrt(2)
(%i6) %e^(%pi*%i*120/144)
                                 %i   sqrt(3)
(%o6)                            -- - -------
                                 2       2
(%i7) %e^(%pi*%i*121/144)
                                   121 %i %pi
                                   ----------
                                      144
(%o7)                            %e
@end example

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{%enumer}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} %enumer
Valor padr@~{a}o: @code{false}

Quando @code{%enumer} for @code{true}, @code{%e} @'{e} substitu@'{i}do por seu valor num@'{e}rico
2.718@dots{}  sempre que @code{numer} for @code{true}.

Quando @code{%enumer} for @code{false}, essa subtitui@,{c}@~{a}o @'{e} realizada
somente se o expoente em @code{%e^x} avaliar para um n@'{u}mero.

Veja tamb@'{e}m @mref{ev} e @mrefdot{numer}

@c ===beg===
@c %enumer;
@c numer;
@c 2*%e;
@c %enumer: not %enumer;
@c 2*%e;
@c numer: not numer;
@c 2*%e;
@c 2*%e^1;
@c 2*%e^x;
@c ===end===
@example
(%i1) %enumer
(%o1)                                false
(%i2) numer
(%o2)                                false
(%i3) 2*%e
(%o3)                                2 %e
(%i4) %enumer:not %enumer
(%o4)                                true
(%i5) 2*%e
(%o5)                                2 %e
(%i6) numer:not numer
(%o6)                                true
(%i7) 2*%e
(%o7)                          5.43656365691809
(%i8) 2*%e^1
(%o8)                          5.43656365691809
(%i9) 2*%e^x
                                               x
(%o9)                       2 2.718281828459045
@end example

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica} @category{Sinalizadores de avalia@,{c}@~{a}o}
@closecatbox
@end defvr

@c PROBABLY MORE TO BE SAID HERE

@c -----------------------------------------------------------------------------
@anchor{exp}
@deffn {Fun@,{c}@~{a}o} exp (@var{x})

Representa a fun@,{c}@~{a}o exponencial.  Inst@^{a}ncias de @code{exp (@var{x})} na entrada
s@~{a}o simplificadas para @code{%e^@var{x}}; @code{exp} n@~{a}o aparece em express@~{o}es
simplificadas.

A vari@'{a}vel de op@,{c}@~{a}o @code{demoivre} se @code{true} faz com que @code{%e^(a + b %i)} simplifique para
@code{%e^(a (cos(b) + %i sin(b)))} se @code{b} for independente de @code{%i}.
Veja @mrefdot{demoivre}

A vari@'{a}vel de op@,{c}@~{a}o @code{%emode}, quando @code{true}, faz com que @code{%e^(%pi %i x)} seja simplificado.
Veja @mrefdot{%emode}

A vari@'{a}vel de op@,{c}@~{a}o @code{%enumer}, quando @code{true} faz com que @code{%e} seja substitu@'{i}do por
2.718@dots{} sempre que @code{numer} for @code{true}.  Veja @mrefdot{%enumer}

@c ===beg===
@c demoivre;
@c %e^(a + b*%i);
@c demoivre: not demoivre;
@c %e^(a + b*%i);
@c ===end===
@example
(%i1) demoivre;
(%o1)                                false
(%i2) %e^(a + b*%i);
                                    %i b + a
(%o2)                             %e
(%i3) demoivre: not demoivre;
(%o3)                                true
(%i4) %e^(a + b*%i);
                             a
(%o4)                      %e  (%i sin(b) + cos(b))
@end example

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica}
@closecatbox
@end deffn


@c -----------------------------------------------------------------------------
@anchor{li}
@deffn {Fun@,{c}@~{a}o} li [@var{s}] (@var{z})

Representa o polilogaritmo de ordem @var{s} e argumento @var{z},
definido por meio de s@'{e}ries infinitas

@tex
$${\rm Li}_s \left(z\right) = \sum_{k=1}^\infty {z^k \over k^s}$$
@end tex
@ifnottex
@example
                                 inf
                                 ====   k
                                 \     z
                        Li (z) =  >    --
                          s      /      s
                                 ====  k
                                 k = 1
@end example
@end ifnottex

O comando @code{li [1]} corresponde a @code{- log (1 - z)}.  Os comandos @code{li [2]} e @code{li [3]} s@~{a}o as
fun@,{c}@~{o}es dilogaritmo e trilogaritmo, respectivamente.

Quando a ordem for 1, o polilogaritmo simplifica para @code{- log (1 - z)}, que
por sua vez simplifica para um valor num@'{e}rico se @var{z} for um n@'{u}mero real ou um n@'{u}mero complexo em
ponto flutuante ou o sinalizador de avalia@,{c}@~{a}o @code{numer} estiver presente.

Quando a ordem for 2 ou 3,
o polilogaritmo simplifica para um valor num@'{e}rico
se @var{z} for uma n@'{u}mero real em ponto flutuante
ou o sinalizador de avalia@,{c}@~{a}o @code{numer} estiver presente.

Exemplos:

@c ===beg===
@c assume (x > 0);
@c integrate ((log (1 - t)) / t, t, 0, x);
@c li [2] (7);
@c li [2] (7), numer;
@c li [3] (7);
@c li [2] (7), numer;
@c L : makelist (i / 4.0, i, 0, 8);
@c map (lambda ([x], li [2] (x)), L);
@c map (lambda ([x], li [3] (x)), L);
@c ===end===
@example
(%i1) assume (x > 0);
(%o1)                        [x > 0]
(%i2) integrate ((log (1 - t)) / t, t, 0, x);
(%o2)                       - li (x)
                                2
(%i3) li [2] (7);
(%o3)                        li (7)
                               2
(%i4) li [2] (7), numer;
(%o4)        1.24827317833392 - 6.113257021832577 %i
(%i5) li [3] (7);
(%o5)                        li (7)
                               3
(%i6) li [2] (7), numer;
(%o6)        1.24827317833392 - 6.113257021832577 %i
(%i7) L : makelist (i / 4.0, i, 0, 8);
(%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
(%i8) map (lambda ([x], li [2] (x)), L);
@group
(%o8) [0, .2676526384986274, .5822405249432515, 
.9784693966661848, 1.64493407, 2.190177004178597
 - .7010261407036192 %i, 2.374395264042415
 - 1.273806203464065 %i, 2.448686757245154
 - 1.758084846201883 %i, 2.467401098097648
 - 2.177586087815347 %i]
@end group
(%i9) map (lambda ([x], li [3] (x)), L);
(%o9) [0, .2584613953442624, 0.537213192678042, 
.8444258046482203, 1.2020569, 1.642866878950322
 - .07821473130035025 %i, 2.060877505514697
 - .2582419849982037 %i, 2.433418896388322
 - .4919260182322965 %i, 2.762071904015935
 - .7546938285978846 %i]
@end example

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{log}
@deffn {Fun@,{c}@~{a}o} log (@var{x})

Representa o logaritmo natural (base @math{e}) de @var{x}.

Maxima n@~{a}o tem uma fun@,{c}@~{a}o interna para logaritmo de base 10 ou outras 
bases. A defini@,{c}@~{a}o @code{log10(x) := log(x) / log(10)} @'{e} @'{u}til.

Simplifica@,{c}@~{a}o e avalia@,{c}@~{a}o de logaritmos @'{e} governada por muitos sinalizadores globais:

@table @code
@item @code{logexpand}
faz com que @code{log(a^b)} torne-se @code{b*log(a)}. Se @code{logexpand} for 
ajustada para @code{all}, @code{log(a*b)} tamb@'{e}m simplificar@'{a} para @code{log(a)+log(b)}.
Se @code{logexpand} for ajustada para @code{super}, ent@~{a}o @code{log(a/b)} tamb@'{e}m ir@'{a} simplificar para 
@code{log(a)-log(b)} para n@'{u}meros racionais @code{a/b}, @code{a#1}. 
(@code{log(1/b)}, para @code{b} inteiro, sempre simplifica.) Se Se @code{logexpand} for 
ajustada para @code{false}, todas essas simplifica@,{c}@~{o}es ser@~{a}o ignoradas.

@item @code{logsimp}
se @code{false} ent@~{a}o nenhuma simplifica@,{c}@~{a}o de @code{%e} para uma pot@^{e}ncia contendo 
@code{log}'s @'{e} feita.

@item @code{lognegint}
se @code{true} implementa a regra @code{log(-n)} -> @code{log(n)+%i*%pi} para 
@code{n} um inteiro positivo.

@item @code{%e_to_numlog}
quando @code{true}, sendo @code{r} algum n@'{u}mero racional, e @code{x} alguma express@~{a}o,
a express@~{a}o @code{%e^(r*log(x))} simplificar@'{a} em @code{x^r}.  Deve-se
ressaltar que o comando @code{radcan} tamb@'{e}m faz essa transforma@,{c}@~{a}o,
e transforma@,{c}@~{o}es mais complicadas desse tipo tambáº½m. O comando
@code{logcontract} "contrai" express@~{o}es contendo @code{log}.
@end table

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{logabs}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} logabs
Valor padr@~{a}o: @code{false}

Ao fazer integra@,{c}@~{a}o indefinida onde s@~{a}o gerados logaritmos, e.g.
@code{integrate(1/x,x)}, a resposta @'{e} dada em termos de @code{log(abs(...))}
se @code{logabs} for @code{true}, mas tamb@'{e}m @'{e} dada em termos de @code{log(...)} se
@code{logabs} for @code{false}.  Para integral definida, o ajuste
@code{logabs:true} @'{e} usado, porque aqui "avalia@,{c}@~{a}o" de integral indefinida nas
extremidades @'{e} muitas vezes necess@'{a}ria.

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica} @category{Integral calculus} @category{Global flags}
@closecatbox
@end defvr

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{logarc}
@defvr  {Vari@'{a}vel de op@,{c}@~{a}o} logarc
@defvrx {Fun@,{c}@~{a}o} logarc (@var{expr})

Quando a vari@'{a}vel global @code{logarc} for @code{true},
fun@,{c}@~{o}es circulares inversas e hiperb@'{o}licas inversas s@~{a}o substitu@'{i}das por
fun@,{c}@~{o}es logaritmicas equivalentes.
O valor padr@~{a}o de @code{logarc} @'{e} @code{false}.

A fun@,{c}@~{a}o @code{logarc(@var{expr})} realiza aquela substitui@,{c}@~{a}o por
uma express@~{a}o @var{expr}
sem ajustar a vari@'{a}vel global @code{logarc}.

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica} @category{Simplification flags and variables} @category{Simplification functions}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{logconcoeffp}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} logconcoeffp
Valor padr@~{a}o: @code{false}

Controla quais coeficientes s@~{a}o
contra@'{i}dos ao se usar @code{logcontract}.  A @code{logconcoeffp} pode ser ajustada para o nome de uma
fun@,{c}@~{a}o predicada de um argumento.  E.g. se voc@^{e} deseja gerar
SQRTs, voc@^{e} pode fazer @code{logconcoeffp:'logconfun$
logconfun(m):=featurep(m,integer) ou ratnump(m)$} .  Ent@~{a}o
@code{logcontract(1/2*log(x));} will give @code{log(sqrt(x))}.

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{logcontract}
@deffn {Fun@,{c}@~{a}o} logcontract (@var{expr})

Recursivamente examina a express@~{a}o @var{expr}, transformando
subexpress@~{o}es da forma @code{a1*log(b1) + a2*log(b2) + c} em
@code{log(ratsimp(b1^a1 * b2^a2)) + c}

@c ===beg===
@c 2*(a*log(x) + 2*a*log(y))$
@c logcontract(%);
@c ===end===
@example
(%i1) 2*(a*log(x) + 2*a*log(y))$
(%i2) logcontract(%);
                                 2  4
(%o2)                     a log(x  y )
@end example

A declara@,{c}@~{a}o @code{declare(n,integer)} faz 
@code{logcontract(2*a*n*log(x))} simplificar para @code{a*log(x^(2*n))}.  Os
coeficientes que "contraem" dessa forma s@~{a}o aqueles cujo 2 e o
@code{n} aqui satisfazem @code{featurep(coeff,integer)}.  O usu@'{a}rio pode
controlar quais coeficientes s@~{a}o contra@'{i}dos ajustando a op@,{c}@~{a}o
@code{logconcoeffp} para o nome de uma fun@,{c}@~{a}o predicado de um argumento.
E.g. se voc@^{e} gosta de gerar SQRTs, voc@^{e} pode fazer @code{logconcoeffp:'logconfun$
logconfun(m):=featurep(m,integer) ou ratnump(m)$} .  Ent@~{a}o
@code{logcontract(1/2*log(x));} fornecer@'{a} @code{log(sqrt(x))}.

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{logexpand}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} logexpand
Valor padr@~{a}o: @code{true}

Se @code{true}, que @'{e} o valor padr@~{a}o, faz com que @code{log(a^b)} torne-se
@code{b*log(a)}.  Se @code{logexpand} for ajustada para @code{all}, @code{log(a*b)} tamb@'{e}m simplificar@'{a}
para @code{log(a)+log(b)}.  Se @code{logexpand} for ajustada para @code{super}, ent@~{a}o @code{log(a/b)}
tambáº½m simplificar@'{a} para @code{log(a)-log(b)} para n@'{u}meros racionais @code{a/b},
@code{a#1} (A express@~{a}o @code{log(1/b)}, para @code{b} inteiro, sempre simplifica).  Se @code{logexpand}
for ajustada para @code{false}, todas essas simplifica@,{c}@~{o}es ser@~{a}o desabilitadas.

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{lognegint}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} lognegint
Valor padr@~{a}o: @code{false}

Se @code{true} implementa a regra
@code{log(-n)} -> @code{log(n)+%i*%pi} para @code{n} um inteiro positivo.

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{logsimp}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} logsimp
Valor padr@~{a}o: @code{true}

Se @code{false} nenhuma simplifica@,{c}@~{a}o de @code{%e} para uma
potencia contendo @code{log}'s @'{e} realizada.

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{plog}
@deffn {Fun@,{c}@~{a}o} plog (@var{x})

Representa o ramo principal do logaritmo natural
complexo com @code{-%pi} < @code{carg(@var{x})} <= @code{+%pi} .

@opencatbox
@category{Fun@,{c}@~{o}es exponecial e logar@'{i}tmica} @category{Vari@'{a}veis complexas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sqrt}
@deffn {Fun@,{c}@~{a}o} sqrt (@var{x})

A ra@'{i}z quadrada de @var{x}.  @'{E} representada internamente por
@code{@var{x}^(1/2)}.  Veja tamb@'{e}m @code{rootscontract}.

A vari@'{a}vel de op@,{c}@~{a}o @code{radexpand} se @code{true} far@'{a} com que en@'{e}simas ra@'{i}zes de fatores de um produto
que s@~{a}o pot@^{e}ncias de n sejam empurados para fora do radical, e.g.
@code{sqrt(16*x^2)} tornar-se-@'{a} @code{4*x} somente se @code{radexpand} for
@code{true}.

@opencatbox
@category{Fun@,{c}@~{o}es matem@'{a}ticas}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@page
@node Trigonometric Functions, Random Numbers, Root Exponential and Logarithmic Functions, Mathematical Functions
@section Trigonometric Functions
@c -----------------------------------------------------------------------------

@menu
* Introduction to Trigonometric::
* Functions and Variables for Trigonometric::
@end menu

@c -----------------------------------------------------------------------------
@node Introduction to Trigonometric, Functions and Variables for Trigonometric, Trigonometric Functions, Trigonometric Functions
@subsection Introduction to Trigonometric
@c -----------------------------------------------------------------------------

Maxima tem muitas fun@,{c}@~{o}es trigonom@'{e}tricas definidas.  Faltam algumas identidades
trigronom@'{e}tricas serem programadas, mas @'{e} poss@'{i}vel a um usu@'{a}rio acrescentar muitas
delas usando as capacidades de modelagem do sistema.  As
fun@,{c}@~{o}es trigonom@'{e}tricas definidas no Maxima s@~{a}o: @code{acos},
@code{acosh}, @code{acot}, @code{acoth}, @code{acsc},
@code{acsch}, @code{asec}, @code{asech}, @code{asin},
@code{asinh}, @code{atan}, @code{atanh}, @code{cos},
@code{cosh}, @code{cot}, @code{coth}, @code{csc}, @code{csch},
@code{sec}, @code{sech}, @code{sin}, @code{sinh}, @code{tan},
e @code{tanh}.  Existem muitos comandos especiais para
tratar fun@,{c}@~{o}es trigonom@'{e}tricas, veja @code{trigexpand},
@code{trigreduce}, e o comutador @code{trigsign}.  Dois pacotes
compartilham o aumento das regras de simplifica@,{c}@~{a}o embutidas no Maxima,
@code{ntrig} e @code{atrig1}.  Fa@,{c}a @code{describe(@var{command})}
para detalhes.

@opencatbox
@category{Trigonometric functions}
@closecatbox

@c -----------------------------------------------------------------------------
@node Functions and Variables for Trigonometric,  , Introduction to Trigonometric, Trigonometric Functions
@subsection Functions and Variables for Trigonometric
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{%piargs}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} %piargs
Valor padr@~{a}o: @code{true}

Quando @code{%piargs} for @code{true},
fun@,{c}@~{o}es trigonom@'{e}tricas s@~{a}o simplificadas para constantes alg@'{e}bricas
quando o argumento for um inteiro m@'{u}ltiplo de
@iftex
@math{\pi}, @math{\pi/2}, @math{\pi/3}, @math{\pi/4}, ou @math{\pi/6}.
@end iftex
@ifnottex
@math{%pi}, @math{%pi/2}, @math{%pi/3}, @math{%pi/4}, ou @math{%pi/6}.
@end ifnottex

@iftex
Maxima conhece algumas identidades que podem ser aplicadas quando @math{\pi}, etc.,
@end iftex
@ifnottex
Maxima conhece algumas identidades que podem ser aplicadas quando @math{%pi}, etc.,
@end ifnottex
forem multiplicadas por uma vari@'{a}vel inteira (isto @'{e}, um s@'{i}mbolo declara explicitamente como
inteiro).

Exemplos:

@c ===beg===
@c %piargs : false$
@c [sin (%pi), sin (%pi/2), sin (%pi/3)];
@c [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
@c %piargs : true$
@c [sin (%pi), sin (%pi/2), sin (%pi/3)];
@c [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
@c [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
@c        cos (sqrt(2)*%pi/3)];
@c ===end===
@example
(%i1) %piargs : false$
@group
(%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                %pi       %pi
(%o2)            [sin(%pi), sin(---), sin(---)]
                                 2         3
@end group
@group
(%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                      %pi       %pi       %pi
(%o3)            [sin(---), sin(---), sin(---)]
                       4         5         6
@end group
(%i4) %piargs : true$
@group
(%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                sqrt(3)
(%o5)                    [0, 1, -------]
                                   2
@end group
@group
(%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                         1         %pi   1
(%o6)                [-------, sin(---), -]
                      sqrt(2)       5    2
@end group
@group
(%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
       cos (sqrt(2)*%pi/3)];
                1    1               sqrt(2) %pi
(%o7)          [-, - -, sqrt(3), cos(-----------)]
                2    2                    3
@end group
@end example

@iftex
Algumas identidades s@~{a}o aplicadas quando @math{\pi} e @math{\pi/2} forem multiplicadas por
uma vari@'{a}vel inteira.
@end iftex
@ifnottex
Algumas identidades s@~{a}o aplicadas quando @math{%pi} e @math{%pi/2} forem multiplicadas por
uma vari@'{a}vel inteira.
@end ifnottex

@c ===beg===
@c declare (n, integer, m, even)$
@c [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
@c        cos (%pi/2 * m)];
@c ===end===
@example
(%i1) declare (n, integer, m, even)$
(%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
       cos (%pi/2 * m)];
@group
                                      m/2
(%o2)                  [0, 1, 0, (- 1)   ]
@end group
@end example

@opencatbox
@category{Trigonometric functions} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{%iargs}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} %iargs
Valor padr@~{a}o: @code{true}

Quando @code{%iargs} for @code{true},
fun@,{c}@~{o}es trigonom@'{e}tricas s@~{a}o simplificadas para fun@,{c}@~{o}es hiperb@'{o}licas
@iftex
quando o argumento for aparentemente um m@'{u}ltiplo da unidade imagin@'{a}ria @math{i}.
@end iftex
@ifnottex
quando o argumento for aparentemente um m@'{u}ltiplo da unidade imagin@'{a}ria @math{%i}.
@end ifnottex

Mesmo quando o argumento for demonstradamente real, a simplifica@,{c}@~{a}o @'{e} aplicada;
@iftex
Maxima considera somente se o argumento @'{e} um literal m@'{u}ltiplo de @math{i}.
@end iftex
@ifnottex
Maxima considera somente se o argumento @'{e} um literal m@'{u}ltiplo de @math{%i}.
@end ifnottex

Exemplos:

@c ===beg===
@c %iargs : false$
@c [sin (%i * x), cos (%i * x), tan (%i * x)];
@c %iargs : true$
@c [sin (%i * x), cos (%i * x), tan (%i * x)];
@c ===end===
@example
(%i1) %iargs : false$
(%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o2)           [sin(%i x), cos(%i x), tan(%i x)]
(%i3) %iargs : true$
(%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o4)           [%i sinh(x), cosh(x), %i tanh(x)]
@end example

Mesmo quando o argumento for demonstradamente real, a simplifica@,{c}@~{a}o @'{e} aplicada.

@c ===beg===
@c declare (x, imaginary)$
@c [featurep (x, imaginary), featurep (x, real)];
@c sin (%i * x);
@c ===end===
@example
(%i1) declare (x, imaginary)$
@group
(%i2) [featurep (x, imaginary), featurep (x, real)];
(%o2)                     [true, false]
@end group
@group
(%i3) sin (%i * x);
(%o3)                      %i sinh(x)
@end group
@end example

@opencatbox
@category{Trigonometric functions} @category{Hyperbolic functions} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} acos (@var{x})

-- Arc Cosine.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} acosh (@var{x})

-- Arco Cosseno Hiperb@'{o}lico.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} acot (@var{x})

-- Arc Cotangent.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} acoth (@var{x})

-- Arco Cotangente Hiperb@'{o}lico.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} acsc (@var{x})

-- Arc Cosecant.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} acsch (@var{x})

-- Arco Cossecante Hiperb@'{o}lico.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} asec (@var{x})

-- Arco Secante.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} asech (@var{x})

-- Arco Secante Hiperb@'{o}lico.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} asin (@var{x})

-- Arco Seno.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} asinh (@var{x})

-- Arco Seno Hiperb@'{o}lico.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} atan (@var{x})

-- Arco Tangente.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{atan2}
@deffn {Fun@,{c}@~{a}o} atan2 (@var{y}, @var{x})

-- retorna o valor de @code{atan(@var{y}/@var{x})} no intervalo de @code{-%pi}
a @code{%pi}.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} atanh (@var{x})

-- Arco Tangente Hiperb@'{o}lico.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c IS THIS DESCRIPTION ACCURATE ??
@c LET'S BE EXPLICIT ABOUT EXACTLY WHAT ARE THE RULES IMPLEMENTED BY THIS PACKAGE

@c -----------------------------------------------------------------------------
@defvr {Pacote} atrig1

O pacote @code{atrig1} cont@'{e}m muitas regras adicionais de simplifica@,{c}@~{a}o
para fun@,{c}@~{o}es trigonom@'{e}tricas inversas.  Juntamente com regras
j@'{a} conhecidas pelo Maxima, os seguinte @^{a}ngulos est@~{a}o completamente implementados:
@code{0}, @code{%pi/6}, @code{%pi/4}, @code{%pi/3}, e @code{%pi/2}.
@^{a}ngulos correspontentes nos outros t@^{e}s quadrantes est@~{a}o tamb@'{e}m dispon@'{i}veis.
Fa@,{c}a @code{load(atrig1);} para usar o pacote @code{atrig1}.

@opencatbox
@category{Trigonometric functions} @category{Package atrig1}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} cos (@var{x})

-- Cosine.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} cosh (@var{x})

-- Cosseno Hiperb@'{o}lico.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} cot (@var{x})

-- Cotangente.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} coth (@var{x})

-- Cotangente Hiperb@'{o}lica.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} csc (@var{x})

-- Cossecante.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} csch (@var{x})

-- Cossecante Hiperb@'{o}lica.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{halfangles}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} halfangles
Valor padr@~{a}o: @code{false}

Quando @code{halfangles} for @code{true}, fun@,{c}@~{o}es trigonom@'{e}tricas de argumentos 
@code{@var{expr}/2} s@~{a}o simplificadas para fun@,{c}@~{o}es de @var{expr}.

Para um argumento real @var{x} no intervalo @code{0 < x < 2*%pi} o seno do 
arco metade simplifica para f@'{o}rmula simples:

@example
                         sqrt(1 - cos(x))
                         ----------------
                             sqrt(2)
@end example

Um fator complicado @'{e} necess@'{a}rio para fazer essa f@'{o}rmula correta para todos os argumentos
complexos @var{z}:

@verbatim
           realpart(z)
     floor(-----------)
              2 %pi
(- 1)                   (1 - unit_step(- imagpart(z))

                            realpart(z)            realpart(z)
                      floor(-----------) - ceiling(-----------)
                               2 %pi                  2 %pi
                ((- 1)                                          + 1))
@end verbatim

Maxima conhece esse fator e fatores similares para as fun@,{c}@~{o}es @code{sin}, 
@code{cos}, @code{sinh}, e @code{cosh}.  Para valores especiais do argumento 
@math{z} esses fatores simplificam conforme.

Exemplos:

@c ===beg===
@c halfangles : false$
@c sin (x / 2);
@c halfangles : true$
@c sin (x / 2);
@c assume(x>0, x<2*%pi)$
@c sin(x / 2);
@c ===end===
@example
(%i1) halfangles:false;
(%o1)                                false
(%i2) sin(x/2);
                                        x
(%o2)                               sin(-)
                                        2
(%i3) halfangles:true;
(%o3)                                true
(%i4) sin(x/2);
                                                    x
                                            floor(-----)
                                                  2 %pi
                      sqrt(1 - cos(x)) (- 1)
(%o4)                 ----------------------------------
                                   sqrt(2)
(%i5) assume(x>0, x<2*%pi)$
(%i6) sin(x/2);
                               sqrt(1 - cos(x))
(%o6)                          ----------------
                                   sqrt(2)
@end example

@opencatbox
@category{Trigonometric functions} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c IS THIS DESCRIPTION ACCURATE ??
@c LET'S BE EXPLICIT ABOUT EXACTLY WHAT ARE THE RULES IMPLEMENTED BY THIS PACKAGE

@c -----------------------------------------------------------------------------
@defvr {Pacote} ntrig

O pacote @code{ntrig} cont@'{e}m um conjunto de regras de simplifica@,{c}@~{a}o que s@~{a}o
usadas para simplificar fun@,{c}@~{o}es trigonom@'{e}tricas cujos argumentos forem da forma
@code{@var{f}(@var{n} %pi/10)} onde @var{f} @'{e} qualquer das fun@,{c}@~{o}es
@code{sin}, @code{cos}, @code{tan}, @code{csc}, @code{sec} e @code{cot}.
@c NEED TO LOAD THIS PACKAGE ??

@opencatbox
@category{Trigonometric functions} @category{Package ntrig}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} sec (@var{x})

-- Secante.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} sech (@var{x})

-- Secante Hiperb@'{o}lica.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sin}
@deffn {Fun@,{c}@~{a}o} sin (@var{x})

-- Seno.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} sinh (@var{x})

-- Seno Hiperb@'{o}lico.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} tan (@var{x})

-- Tangente.

@opencatbox
@category{Trigonometric functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Fun@,{c}@~{a}o} tanh (@var{x})

-- Hyperbolic Tangent.

@opencatbox
@category{Hyperbolic functions}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{trigexpand}
@deffn {Fun@,{c}@~{a}o} trigexpand (@var{expr})

Expande fun@,{c}@~{o}es trigonom@'{e}tricas e hiperb@'{o}licas de
somas de @^{a}ngulos de angulos m@'{u}ltiplos que ocorram em @var{expr}.  Para melhores
resultados, @var{expr} deve ser expandida.  Para melhorar o controle do usu@'{a}rios sobre
simplifica@,{c}@~{a}o, essa fun@,{c}@~{a}o expande somente um n@'{i}vel pr vez,
expandindo somas de @^{a}ngulos ou @^{a}ngulos m@'{u}ltiplos.  Par obter expans@~{a}o completa
em senos e cossenos imediatamente, ajuste o sinalizador global @code{trigexpand: true}.

A fun@,{c}@~{a}o @code{trigexpand} @'{e} governada pelos seguintes sinalizadores globais:

@table @code
@item trigexpand
Se @code{true} expande todas as
express@~{o}es contendo senos e cossenos que ocorram ap@'{o}s o ajuste.
@item halfangles
Se @code{true} faz com que arcos metade sejam simplificados
completamente.
@item trigexpandplus
Controla a regra da "soma" para @code{trigexpand},
expans@~{a}o de somas (e.g. @code{sin(x + y)}) ser@~{a}o feitas somente se
@code{trigexpandplus} for @code{true}.
@item trigexpandtimes
Controla a egra do "produto" para @code{trigexpand},
expans@~{a}o de produtos (e.g. @code{sin(2 x)}) ser@~{a}o feitas somente se
@code{trigexpandtimes} for @code{true}.
@end table

Exemplos:

@c ===beg===
@c x+sin(3*x)/sin(x),trigexpand=true,expand;
@c trigexpand(sin(10*x+y));
@c ===end===
@example
(%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
@group
                         2           2
(%o1)               - sin (x) + 3 cos (x) + x
@end group
(%i2) trigexpand(sin(10*x+y));
(%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)
@end example

@opencatbox
@category{Trigonometric functions} @category{Simplification functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{trigexpandplus}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} trigexpandplus
Valor padr@~{a}o: @code{true}

A vari@'{a}vel de op@,{c}@~{a}o @code{trigexpandplus} controla a regra da "soma" para
@code{trigexpand}.  Dessa forma, quando o comando @code{trigexpand} for usado ou o
comutador @code{trigexpand} for ajustado para @code{true}, expans@~{a}o de somas
(e.g. @code{sin(x+y))} ser@~{a}o feitas somente se @code{trigexpandplus} for
@code{true}.

@opencatbox
@category{Trigonometric functions} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{trigexpandtimes}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} trigexpandtimes
Valor padr@~{a}o: @code{true}

A vari@'{a}vel de op@,{c}@~{a}o @code{trigexpandtimes} controla a regra do "produto" para @code{trigexpand}.
Dessa forma, quando o comando @code{trigexpand} for usado ou o comutador @code{trigexpand}
for ajustado para @code{true}, expans@~{a}o de produtos (e.g. @code{sin(2*x)})
ocorrer@~{a}o somente se @code{trigexpandtimes} for @code{true}.

@opencatbox
@category{Trigonometric functions} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{triginverses}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} triginverses
Valor padr@~{a}o: @code{true}

@code{triginverses} controla a simplifica@,{c}@~{a}o da
composi@,{c}ao de fun@,{c}@~{o}es trigonom@'{e}tricas e hiperb@'{o}licas com suas fun@,{c}@~{o}es
inversas.

Se @code{all}, ambas e.g. @code{atan(tan(@var{x}))}
e @code{tan(atan(@var{x}))} simplificam para @var{x}.

Se @code{true}, a simplifica@,{c}@~{a}o de
@code{@var{arcfun}(@var{fun}(@var{x}))} @'{e} desabilitada.

Se @code{false}, ambas as simplifica@,{c}@~{o}es
@code{@var{arcfun}(@var{fun}(@var{x}))} e
@code{@var{fun}(@var{arcfun}(@var{x}))}
s@~{a}o desabilitadas.

@opencatbox
@category{Trigonometric functions} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{trigreduce}
@deffn  {Fun@,{c}@~{a}o} trigreduce @
@fname{trigreduce} (@var{expr}, @var{x}) @
@fname{trigreduce} (@var{expr})

Combina produtos e pot@^{e}ncias de senos e cossenos
trigonom@'{e}tricos hiperb@'{o}licos de @var{x} naqueles de m@'{u}ltiplos de @var{x}.
Tamb@'{e}m tenta eliminar essas fun@,{c}@~{o}es quando elas ocorrerem em
denominadores.  Se @var{x} for omitido ent@~{a}o todas as vari@'{a}veis em @var{expr} s@~{a}o usadas.

Veja tamb@'{e}m @code{poissimp}.

@c ===beg===
@c trigreduce(-sin(x)^2+3*cos(x)^2+x);
@c ===end===
@example
(%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
@group
               cos(2 x)      cos(2 x)   1        1
(%o1)          -------- + 3 (-------- + -) + x - -
                  2             2       2        2
@end group
@end example

@c 
@c     OBSOLETE
@c     The behavior was changed in order to avoid calling expand in the core
@c     simplifier (trigi.lisp rev 1.31)
@c     See http://www.math.utexas.edu/pipermail/maxima/2008/010919.html.
@c 
@c The trigonometric simplification routines will use declared
@c information in some simple cases.  Declarations about variables are
@c used as follows, e.g.
@c 
@c ---beg---
@c declare(j, integer, e, even, o, odd)$
@c sin(x + (e + 1/2)*%pi);
@c sin(x + (o + 1/2)*%pi);
@c ---end---
@c @example
@c (%i1) declare(j, integer, e, even, o, odd)$
@c (%i2) sin(x + (e + 1/2)*%pi);
@c (%o2)                        cos(x)
@c (%i3) sin(x + (o + 1/2)*%pi);
@c (%o3)                       - cos(x)
@c @end example

@opencatbox
@category{Trigonometric functions} @category{Simplification functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{trigsign}
@defvr {Vari@'{a}vel de op@,{c}@~{a}o} trigsign
Valor padr@~{a}o: @code{true}

Quando @code{trigsign} for @code{true}, permite simplifica@,{c}@~{a}o de argumentos
negativos em fun@,{c}@~{o}es trigonom@'{e}tricas.  E.g., @code{sin(-x)} tornar-se-@'{a}
@code{-sin(x)} somente se @code{trigsign} for @code{true}.

@opencatbox
@category{Trigonometric functions} @category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{trigsimp}
@deffn {Fun@,{c}@~{a}o} trigsimp (@var{expr})

@iftex
Emprega as identidades
@tex
$\sin\left(x\right)^2 + \cos\left(x\right)^2 = 1$
@end tex
and
@tex
$\cosh\left(x\right)^2 - \sinh\left(x\right)^2 = 1$
@end tex
para simplificar express@~{o}es contendo @code{tan}, @code{sec},
etc., em @code{sin}, @code{cos}, @code{sinh}, @code{cosh}.
@end iftex
@ifnottex
Emprega as identidades @math{sin(x)^2 + cos(x)^2 = 1} e
@math{cosh(x)^2 - sinh(x)^2 = 1} para simplificar express@~{o}es contendo @code{tan},
@code{sec}, etc., em @code{sin}, @code{cos}, @code{sinh}, @code{cosh}.
@end ifnottex

As fun@,{c}@~{o}es @code{trigreduce}, @code{ratsimp}, e @code{radcan} podem ser
capazes de simplificar um pouco mais o resultado.

O comando @code{demo ("trgsmp.dem")} mostra alguns exemplos de @code{trigsimp}:

@c demo ("trgsmp.dem") output:
@c ===beg===
@c tan(x)*sec(x)^2+(1-sin(x)^2)*cos(x)/cos(x)^2;
@c trigsimp(%);
@c sec(x)^2/(1-tan(x)*sec(x))+tan(x)^2;
@c trigsimp(%);
@c (3+cos(x)^4+8*sin(x)+4*(cos(x)^2-sin(x)^2)-6*cos(x)^2*sin(x)^2+sin(x)^4)/(8*cos(x)^3);
@c trigsimp(%);
@c sech(x)^2*tanh(x)/coth(x)^2+cosh(x)^2*sech(x)^2*tanh(x)/coth(x)^2+sech(x)^2*sinh(x)*tanh(x)/coth(x)^2;
@c trigsimp(%);
@c (-sech(x)^5*(6+34*sinh(x)+5*cosh(x)^4*sinh(x)-8*(cosh(x)^2+sinh(x)^2)+10*cosh(x)^2*sinh(x)^3-13*(3*cosh(x)^2*sinh(x)+sinh(x)^3)+2*(cosh(x)^4+6*cosh(x)^2*sinh(x)^2+sinh(x)^4)+sinh(x)^5));
@c trigsimp(%);
@c -cos(x)-sec(x)^2*sin(x)+cos(x)*(1+sec(x)^2*tan(x));
@c trigsimp(%);
@c 'diff(v,x,2)*cos(x)+'diff(v,x)*cos(x)*sec(x)+(-2*'diff(v,x)-v*sec(x)^2)*sin(x)+v*cos(x)*sec(x)^2*tan(x);
@c trigsimp(%);
@c ===beg===

@example
(%i1) tan(x)*sec(x)^2+(1-sin(x)^2)*cos(x)/cos(x)^2;
@group
                                                 2
                            2             1 - sin (x)
(%o1)                    sec (x) tan(x) + -----------
                                            cos(x)
@end group
(%i2) trigsimp(%);
@group
                                           4
                               sin(x) + cos (x)
(%o2)                          ----------------
                                      3
                                   cos (x)
@end group
(%i3) (3+cos(x)^4+8*sin(x)+4*(cos(x)^2-sin(x)^2)-6*cos(x)^2*
sin(x)^2+sin(x)^4)/(8*cos(x)^3);
@group
(%o3) 
      4           2       2            2         2                     4
   sin (x) - 6 cos (x) sin (x) + 4 (cos (x) - sin (x)) + 8 sin(x) + cos (x) + 3
   ----------------------------------------------------------------------------
                                         3
                                    8 cos (x)
@end group
(%i4) trigsimp(%);
@group
                                           4
                               sin(x) + cos (x)
(%o4)                          ----------------
                                      3
                                   cos (x)
@end group
(%i5) sech(x)^2*tanh(x)/coth(x)^2+cosh(x)^2*sech(x)^2*tanh(x)/
coth(x)^2+sech(x)^2*sinh(x)*tanh(x)/coth(x)^2;
@group
          2                          2        2                  2
      sech (x) sinh(x) tanh(x)   cosh (x) sech (x) tanh(x)   sech (x) tanh(x)
(%o5) ------------------------ + ------------------------- + ----------------
                  2                          2                       2
              coth (x)                   coth (x)                coth (x)
@end group
(%i6) trigsimp(%);
@group
                           5          4            3
                       sinh (x) + sinh (x) + 2 sinh (x)
(%o6)                  --------------------------------
                                       5
                                   cosh (x)
@end group
(%i7) (-sech(x)^5*(6+34*sinh(x)+5*cosh(x)^4*sinh(x)-8*(cosh(x)^2+
sinh(x)^2)+10*cosh(x)^2*sinh(x)^3-13*(3*cosh(x)^2*sinh(x)+sinh(x)^3)+
2*(cosh(x)^4+6*cosh(x)^2*sinh(x)^2+sinh(x)^4)+sinh(x)^5));
@group
            5         5             4            2        2          4
(%o7) - sech (x) (sinh (x) + 2 (sinh (x) + 6 cosh (x) sinh (x) + cosh (x))
           3            2                      2        3
 - 13 (sinh (x) + 3 cosh (x) sinh(x)) + 10 cosh (x) sinh (x)
          2          2             4
 - 8 (sinh (x) + cosh (x)) + 5 cosh (x) sinh(x) + 34 sinh(x) + 6)
@end group
(%i8) trigsimp(%);
@group
                            5             4             3
                     16 sinh (x) + 16 sinh (x) - 32 sinh (x)
(%o8)              - ---------------------------------------
                                        5
                                    cosh (x)
@end group
(%i9) -cos(x)-sec(x)^2*sin(x)+cos(x)*(1+sec(x)^2*tan(x));
@group
                        2                     2
(%o9)        cos(x) (sec (x) tan(x) + 1) - sec (x) sin(x) - cos(x)
@end group
(%i10) trigsimp(%);
(%o10)                                 0
(%i11) 'diff(v,x,2)*cos(x)+'diff(v,x)*cos(x)*sec(x)+
(-2*'diff(v,x)-v*sec(x)^2)*sin(x)+v*cos(x)*sec(x)^2*tan(x);
@group
                   2                     2        dv           dv
(%o11) v cos(x) sec (x) tan(x) + (- v sec (x) - 2 --) sin(x) + -- cos(x) sec(x)
                                                  dx           dx
                             2
         dv                 d v
sin(x) + -- cos(x) sec(x) + --- cos(x)
         dx                   2
                            dx
@end group
(%i12) trigsimp(%);
@group
                                         2
                            dv          d v          dv
(%o12)                  - 2 -- sin(x) + --- cos(x) + --
                            dx            2          dx
                                        dx
@end group
@end example

@opencatbox
@category{Trigonometric functions} @category{Simplification functions}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION

@c -----------------------------------------------------------------------------
@anchor{trigrat}
@deffn {Fun@,{c}@~{a}o} trigrat (@var{expr})

Fornece uma forma can@^{o}nica simplificada quase linear de uma expres@~{a}o trigonom@'{e}trica;
a @var{expr} @'{e} uma fra@,{c}@~{a}o racional dcontendo muitos @code{sin}, @code{cos} ou
@code{tan}, os argumentos desses senos e cossenos e tangentes s@~{a}o formas lineares em algumas vari@'{a}veis (ou
n@'{u}cleos) e @code{%pi/@var{n}} (sendo @var{n} inteiro) com coeficientes inteiros.
O resultado @'{e} uma fra@,{c}@~{a}o simplificada com numerador e delnominador linear em
@code{sin} e @code{cos}.  Dessa forma @code{trigrat} lineariza sempre quando que for
poss@'{i}vel.

@c ===beg===
@c trigrat(sin(3*a)/sin(a+%pi/3));
@c ===end===
@example
@group
(%i1) trigrat(sin(3*a)/sin(a+%pi/3));
(%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1
@end group
@end example

O seguinte exemplo foi retirado de
Davenport, Siret, and Tournier, @i{Calcul Formel}, Masson (or in English,
Addison-Wesley), section 1.5.5, Morley theorem.

@c ===beg===
@c c : %pi/3 - a - b$
@c bc : sin(a)*sin(3*c)/sin(a+b);
@c ba : bc, c=a, a=c;
@c ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
@c trigrat (ac2);
@c ===end===
@example
(%i1) c : %pi/3 - a - b$
(%i2) bc : sin(a)*sin(3*c)/sin(a+b);
@group
                                          %pi
                  sin(a) sin(3 (- b - a + ---))
                                           3
(%o2)             -----------------------------
                           sin(b + a)
@end group
(%i3) ba : bc, c=a, a=c;
@group
                                         %pi
                    sin(3 a) sin(b + a - ---)
                                          3
(%o3)               -------------------------
                                  %pi
                          sin(a - ---)
                                   3
@end group
(%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
@group
         2         2         %pi
      sin (3 a) sin (b + a - ---)
                              3
(%o4) ---------------------------
                2     %pi
             sin (a - ---)
                       3
                                       %pi
 - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                        3
             %pi            %pi
 sin(b + a - ---))/(sin(a - ---) sin(b + a))
              3              3
      2       2              %pi
   sin (a) sin (3 (- b - a + ---))
                              3
 + -------------------------------
                2
             sin (b + a)
@end group
(%i5) trigrat (ac2);
@group
(%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
 - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
 - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
 + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
 + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
 + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
 - 9)/4
@end group
@end example

@opencatbox
@category{Trigonometric functions} @category{Simplification functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@page
@node Random Numbers,  , Trigonometric Functions, Mathematical Functions
@section Random Numbers
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{make_random_state}
@deffn  {Fun@,{c}@~{a}o} make_random_state @
@fname{make_random_state} (@var{n}) @
@fname{make_random_state} (@var{s}) @
@fname{make_random_state} (true) @
@fname{make_random_state} (false)

@c OMIT THIS FOR NOW. SEE COMMENT BELOW.
@c @defunx make_random_state (@var{a})

Um objeto de estado aleat@'{o}rio representa o estado do gerador de n@'{u}meros aleat@'{o}rios.
O estado compreende 627 palavras de 32-bit.

O comando @code{make_random_state (@var{n})} retorna um novo objeto de estado aleat@'{o}rio
criado a partir de um valor inteiro semente igual a @var{n} modulo 2^32.
@var{n} pode ser negativo.

@c OMIT THIS FOR NOW. NOT SURE HOW THIS IS SUPPOSED TO WORK.
@c @code{make_random_state (@var{a})} returns a new random state object
@c created from an array @var{a}, which must be a Lisp array of 32 unsigned bytes.

O comando @code{make_random_state (@var{s})} retorna uma c@'{o}pia do estado aleat@'{o}rio @var{s}.

O comando @code{make_random_state (true)} retorna um novo objeto de estado aleat@'{o}rio,
usando a data e hora atual do rel@'{o}gio do computador como semente.

O comando @code{make_random_state (false)} retorna uma c@'{o}pia do estado atual
do gerador de n@'{u}meros aleat@'{o}rios.

@opencatbox
@category{Random numbers}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{set_random_state}
@deffn {Fun@,{c}@~{a}o} set_random_state (@var{s})

Copia @var{s} para o estado atual do gerador de n@'{u}meros aleat@'{o}rios.

@code{set_random_state} always returns @code{done}.

@opencatbox
@category{Random numbers}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{random}
@deffn {Fun@,{c}@~{a}o} random (@var{x})

Retorna um n@'{u}mero pseudoaleat@'{o}rio.  Se @var{x} for um inteiro,
@code{random (@var{x})} retorna um inteiro de 0 a @code{@var{x} - 1}
inclusive.  Se @var{x} for um n@'{u}mero em ponto flutuante, @code{random (@var{x})}
retorna um n@'{u}mero em ponto flutuante n@~{a}o negativo menor que @var{x}.  A fun@,{c}@~{a}o @code{random}
reclama com um erro se @var{x} n@~{a}o for nem inteiro nem um n@'{u}mero em ponto flutuante, ou se
@var{x} n@~{a}o for positivo.

As fun@,{c}@~{o}es @code{make_random_state} e @code{set_random_state}
preservam o estado do gerador de n@'{u}meros aleat@'{o}rios.

O gerador de n@'{u}meros aleat@'{o}rios do Maxima @'{e} uma implementa@,{c}@~{a}o de Mersenne twister
MT 19937.

Exemplos:

@c ===beg===
@c s1: make_random_state (654321)$
@c set_random_state (s1);
@c random (1000);
@c random (9573684);
@c random (2^75);
@c s2: make_random_state (false)$
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c set_random_state (s2);
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c ===end===
@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example

@opencatbox
@category{Random numbers} @category{Numerical methods}
@closecatbox
@end deffn
