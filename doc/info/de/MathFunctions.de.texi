@c -----------------------------------------------------------------------------
@c File        : MathFunctions.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : New file
@c Translation : Dr. Dieter Kaiser
@c Date        : 19.10.2010
@c Revision    : 01.11.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Funktionen f@"ur Zahlen::
* Funktionen f@"ur komplexe Zahlen::
* Funktionen der Kombinatorik::
* Wurzel- Exponential- und Logarithmusfunktion::
* Winkelfunktionen::
* Hyperbelfunktionen::
* Zufallszahlen::
@end menu

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur Zahlen, Funktionen f@"ur komplexe Zahlen, Mathematische Funktionen, Mathematische Funktionen
@section Funktionen f@"ur Zahlen
@c -----------------------------------------------------------------------------

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{abs}
@deffn {Funktion} abs (@var{z})

Die Funktion @code{abs} ist die Betragsfunktion und f@"ur das numerische und
symbolische Rechnen geeignet.  Ist das Argument @var{z} eine reelle oder
komplexe Zahl wird der Betrag berechnet.  Wenn m@"oglich werden allgemeine
Ausdr@"ucke mit der Betragsfunktion vereinfacht.  Maxima kann Ausdr@"ucke mit
der Betragsfunktion integrieren und ableiten sowie Grenzwerte von Ausdr@"ucken
mit der Betragsfunktion ermitteln.  Das Paket @mref{abs_integrate} erweitert
Maximas M@"oglichkeiten, Integrale mit der Betragsfunktion zu l@"osen.

Die Betragsfunktion wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe die Funktion @mrefcomma{cabs} um den Betrag eines komplexen Ausdrucks
oder einer Funktion zu berechnen.

Beispiele:

Berechnung des Betrages f@"ur reelle und komplexen Zahlen sowie numerische
Konstanten und unendliche Gr@"o@ss{}en.  Das erste Beispiel zeigt, wie die
Betragsfunktion von Maxima auf die Elemente einer Liste angewendet wird.

@example
(%i1) abs([-4, 0, 1, 1+%i]);
(%o1)                  [4, 0, 1, sqrt(2)]

(%i2) abs((1+%i)*(1-%i));
(%o2)                           2
(%i3) abs(%e+%i);
                                2
(%o3)                    sqrt(%e  + 1)
(%i4) abs([inf, infinity, minf]);
(%o4)                   [inf, inf, inf]
@end example

Vereinfachung von Ausdr@"ucken mit der Betragsfunktion.

@example
(%i5) abs(x^2);
                                2
(%o5)                          x
(%i6) abs(x^3);
                             2
(%o6)                       x  abs(x)

(%i7) abs(abs(x));
(%o7)                       abs(x)
(%i8) abs(conjugate(x));
(%o8)                       abs(x)
@end example

Ableitung und Integrale mit der Betragsfunktion.  Wird das Paket
@nref{abs_integrate} geladen, k@"onnen weitere Integrale mit der Betragsfunktion
gel@"ost werden.  Das letzte Beispiel zeigt die Laplacetransformation der
Betragsfunktion.  Siehe @mrefdot{laplace}

@example
(%i9) diff(x*abs(x),x),expand;
(%o9)                       2 abs(x)

(%i10) integrate(abs(x),x);
                             x abs(x)
(%o10)                       --------
                                2

(%i11) integrate(x*abs(x),x);
                           /
                           [
(%o11)                     I x abs(x) dx
                           ]
                           /

(%i12) load(abs_integrate)$
(%i13) integrate(x*abs(x),x);
                      2           3
                     x  abs(x)   x  signum(x)
(%o13)               --------- - ------------
                         2            6

(%i14) integrate(abs(x),x,-2,%pi);
                               2
                            %pi
(%o14)                      ---- + 2
                             2

(%i15) laplace(abs(x),x,s);
                               1
(%o15)                         --
                                2
                               s
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{ceiling}
@deffn {Funktion} ceiling (@var{x})

Die Funktion @code{ceiling} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Ist das Argument @var{x} eine reelle Zahl, gibt @code{ceiling} die kleinste
ganze Zahl zur@"uck, die gr@"o@ss{}er oder gleich @var{x} ist.

Die Funktion @code{ceiling} gibt auch dann einen numerischen Wert zur@"uck, wenn
das Argument ein konstanter Ausdruck ist, wie zum Beispiel @code{1+%e}, der zu
einer reellen Zahl ausgewertet werden kann.  In diesem Fall wird der konstante
Ausdruck in eine gro@ss{}e Gleitkommazahl umgewandelt, auf die die Funktion
@code{ceiling} angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von @code{ceiling}
kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
@mref{fpprec} f@"ur die Berechnung von @code{ceiling} um drei Stellen erh@"oht.

Ist das Argument @var{expr} der Funktion ein komplexer Ausdruck, wird eine
Substantivform zur@"uckgegeben.

Wenn m@"oglich werden Ausdr@"ucke mit der Funktion @code{ceiling} von Maxima
vereinfacht.  Maxima kennt insbesondere Vereinfachungen f@"ur den Fall, dass
das Argument der Funktion @code{ceiling} ein Ausdruck mit den Funktionen
@mref{floor} oder @mref{round} ist.  Weiterhin werden f@"ur die Vereinfachung
die Aussagen und Fakten der aktiven Kontexte herangezogen.  Siehe 
@ref{Funktionen und Variablen f@"ur Fakten}.

@code{ceiling} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe auch die Funktionen @mref{floor} und @mrefdot{round}

Beispiele:

@example
(%i1) ceiling(ceiling(x));
(%o1)                      ceiling(x)
(%i2) ceiling(floor(x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) ceiling([n, abs(n), max (n, 6)]);
(%o4)               [n, abs(n), max(6, n)]
(%i5) assume (x > 0, x < 1)$
(%i6) ceiling (x);
(%o6)                           1
@end example

Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen, kann diese als
@mref{integervalued} deklariert werden.  Die Funktionen @code{ceiling} und
@mref{floor} k@"onnen diese Information nutzen, um Ausdr@"ucke zu vereinfachen.

@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

Maxima kennt das Integral der Funktion @code{ceiling}.

@example
(%i1) integrate(ceiling(x),x);
               (- ceiling(x) + 2 x + 1) ceiling(x)
(%o1)          -----------------------------------
                                2
@end example
@end deffn

@c --- 19.10.2010 DK -----------------------------------------------------------
@anchor{entier}
@deffn {Funktion} entier (@var{x})

@code{entier} ist eine andere Bezeichnung f@"ur die Funktion @code{floor}.
Siehe @mrefdot{floor}
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{floor}
@deffn {Funktion} floor (@var{x})

Die Funktion @code{floor} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Ist das Argument @var{x} eine reelle Zahl, gibt @code{floor} die gr@"o@ss{}te
ganze Zahl zur@"uck, die kleiner oder gleich @var{x} ist.

Die Funktion @code{floor} gibt auch dann einen numerischen Wert zur@"uck, wenn
das Argument ein konstanter Ausdruck ist, wie zum Beispiel @code{1+%e}, der zu
einer reellen Zahl ausgewertet werden kann.  In diesem Fall wird der konstante
Ausdruck in eine gro@ss{}e Gleitkommazahl umgewandelt, auf die die Funktion
@code{floor} angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von @code{floor}
kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
@mref{fpprec} f@"ur die Berechnung von @code{floor} um drei Stellen erh@"oht.

Ist das Argument @var{x} der Funktion ein komplexer Ausdruck, wird eine
Substantivform zur@"uckgegeben.

Wenn m@"oglich werden Ausdr@"ucke mit der Funktion @code{floor} von Maxima
vereinfacht.  Maxima kennt insbesondere Vereinfachungen f@"ur den Fall, dass
das Argument der Funktion @code{floor} ein Ausdruck mit den Funktionen
@mref{ceiling} oder @mref{round} ist.  Weiterhin werden f@"ur die Vereinfachung
die Aussagen und Fakten der aktiven Kontexte herangezogen.  Siehe
@ref{Funktionen und Variablen f@"ur Fakten}.

@code{floor} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe auch die Funktionen @mref{ceiling} und @mrefdot{round}

Beispiele:

@example
(%i1) floor(ceiling(x));
(%o1)                      ceiling(x)
(%i2) floor(floor(x));
(%o2)                       floor(x)
(%i3) declare(n, integer);
(%o3)                         done
(%i4) floor([n, abs(n), min (n, 6)]);
(%o4)                [n, abs(n), min(6, n)]
(%i5) assume(x>0, x<1)$
(%i6) floor(x);
(%o6)                           0
@end example

Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen, kann diese als
@mref{integervalued} deklariert werden.  Die Funktionen @mref{ceiling} und
@code{floor} k@"onnen diese Information nutzen, um Ausdr@"ucke zu vereinfachen.

@example
(%i1) declare (f, integervalued)$
(%i2) floor(f(x));
(%o2)                         f(x)
(%i3) ceiling(f(x) - 1);
(%o3)                       f(x) - 1
@end example

Maxima kennt das Integral der Funktion @code{floor}.

@example
(%i6) integrate(floor(x),x);
                 (- floor(x) + 2 x - 1) floor(x)
(%o6)            -------------------------------
                                2
@end example
@end deffn

@c --- 19.10.2010 DK -----------------------------------------------------------
@anchor{fix}
@deffn {Funktion} fix (@var{x})

@code{fix} ist eine andere Bezeichnung f@"ur die Funktion @code{floor}.  Siehe
@mrefdot{floor}
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{lmax}
@deffn {Funktion} lmax (@var{L})

Ist das Argument @var{L} eine Liste oder Menge, wird die Funktion @mref{max} auf
die Elemente der Liste oder Menge angewendet und das Ergebnis zur@"uckgegeben.
Ist @var{L} keine Liste oder Menge, signalisiert Maxima einen Fehler.

@need 600
Beispiel:

@example
(%i1) L:[1+%e, %pi, 3];
(%o1)                   [%e + 1, %pi, 3]
(%i1) lmax(L);
(%o1)                        %e + 1
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{lmin}
@deffn {Funktion} lmin (@var{L})

Ist das Argument @var{L} eine Liste oder Menge, wird die Funktion @mref{min} auf
die Elemente der Liste oder Menge angewendet und das Ergebnis zur@"uckgegeben.
Ist @var{L} keine Liste oder Menge, signalisiert Maxima einen Fehler.

Beispiel:

@example
(%i1) L:[1+%e, %pi, 3];
(%o1)                   [%e + 1, %pi, 3]
(%i2) lmin(L);
(%o2)                           3
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{max}
@deffn {Funktion} max (@var{x_1}, @dots{}, @var{x_n})

Sind alle Argumente @var{x_1}, @dots{}, @var{x_n} Zahlen oder konstante
Ausdr@"ucke wie zum Beispiel @code{1+%e} oder @code{sin(1)}, dann wird der
gr@"o@ss{}te Zahlenwert zur@"uckgegeben.  Sind symbolische Variablen oder
allgemeine Ausdr@"ucke unter den Argumenten, gibt Maxima einen vereinfachten
Ausdruck zur@"uck.  Die unendliche Gr@"o@ss{}en @mref{inf} und @mref{minf}@w{}
k@"onnen als Argument auftreten.

Die Vereinfachung der Funktion @code{max} kann kontrolliert werden, in dem mit
der Funktion @mref{put} dem Symbol @code{trylevel} zu der Eigenschaft
@code{maxmin} ein Wert zwischen 1 bis 3 gegeben wird.  Folgende Werte k@"onnen 
mit der Funktion @code{put} gesetzt werden:

@table @code
@item put(trylevel, 1, maxmin)
@code{trylevel} hat den Wert 1.  Das ist der Standardwert.  Maxima f@"uhrt
keine besonderen Vereinfachungen aus.
@item put(trylevel, 2, maxmin)
Maxima wendet die Vereinfachung @code{max(e,-e) --> |e|} an.
@item put(trylevel, 3, maxima)
Maxima wendet die Vereinfachung @code{max(e,-e) --> |e|} an und versucht
Ausdr@"ucke zu eliminieren, die zwischen zwei anderen Argumenten liegen.  So
wird zum Beispiel @code{max(x, 2*x, 3*x)} zu @code{max(x, 3*x)} vereinfacht.
@end table

Mit dem Kommando @code{get(trylevel, maxmin)} wird der aktuelle Wert f@"ur
das Symbol @code{trylevel} angezeigt.  Siehe die Funktion @mrefdot{get}

@code{max} ber@"ucksichtigt bei der Vereinfachung von Ausdr@"ucken die
Aussagen und Fakten der aktiven Kontexte.  Siehe das Kapitel
@ref{Funktionen und Variablen f@"ur Fakten}.

Beispiele:

@example
(%i1) max(1.6, 3/2, 1);
(%o1)                          1.6
(%i2) max(1.5b0,1.5,3/2);
@group
                                3
(%o2)                           -
                                2
@end group
(%i3) max(%e,%pi,1,2,3);
(%o3)                          %pi
(%i4) max(1+%e,%pi,1,2,3);
(%o4)                        %e + 1
(%i5) max(minf,inf);
(%o5)                          inf
(%i6) assume(a>b);
(%o6)                        [a > b]
(%i7) max(a,b);
(%o7)                           a
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{min}
@deffn {Funktion} min (@var{x_1}, @dots{}, @var{x_n})

Sind alle Argumente @var{x_1}, @dots{}, @var{x_n} Zahlen oder konstante
Ausdr@"ucke wie zum Beispiel @code{1+%e} oder @code{sin(1)}, dann wird der
kleinste Zahlenwert zur@"uckgegeben.  Sind symbolische Variablen oder
allgemeine Ausdr@"ucke unter den Argumenten, gibt Maxima einen vereinfachten
Ausdruck zur@"uck.  Die unendliche Gr@"o@ss{}en @mref{inf} und @mref{minf}@w{}
k@"onnen als Argument auftreten.

Die Vereinfachung der Funktion @code{min} kann kontrolliert werden, in dem mit
der Funktion @mref{put} dem Symbol @code{trylevel} zu der Eigenschaft
@code{maxmin} ein Wert zwischen 1 bis 3 gegeben wird.  Folgende Werte k@"onnen
mit der Funktion @code{put} gesetzt werden:

@table @code
@item put(trylevel, 1, maxmin)
@code{trylevel} hat den Wert 1.  Das ist der Standardwert.  Maxima f@"uhrt
keine besonderen Vereinfachungen aus.
@item put(trylevel, 2, maxmin)
Maxima wendet die Vereinfachung @code{min(e,-e) --> |e|} an.
@item put(trylevel, 3, maxima)
Maxima wendet die Vereinfachung @code{min(e,-e) --> |e|} an und versucht
Ausdr@"ucke zu eliminieren, die zwischen zwei anderen Argumenten liegen.  So
wird zum Beispiel @code{min(x, 2*x, 3*x)} zu @code{min(x, 3*x)} vereinfacht.
@end table

Mit dem Kommando @code{get(trylevel, maxmin)} wird der aktuelle Wert f@"ur
das Symbol @code{trylevel} angezeigt.  Siehe die Funktion @mrefdot{get}

@code{min} ber@"ucksichtigt bei der Vereinfachung von Ausdr@"ucken die
Aussagen und Fakten der aktiven Kontexte.  Siehe das Kapitel
@nrefdot{Funktionen und Variablen f@"ur Fakten}

Beispiele:

@example
(%i1) min(1.6, 3/2, 1);
(%o1)                           1
(%i2) min(1.5b0,1.5,3/2);
                                3
(%o2)                           -
                                2
(%i3) min(%e,%pi,3);
(%o3)                          %e
(%i4) min(1+%e,%pi,3);
(%o4)                           3
(%i5) min(minf,inf);
(%o5)                         minf
(%i6) assume(a>b);
(%o6)                        [a > b]
(%i7) min(a,b);
(%o7)                           b
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{round}
@deffn {Funktion} round (@var{x})

Die Funktion @code{round} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Ist das Argument @var{x} eine reelle Zahl, gibt @code{round} die am
n@"achsten liegende ganze Zahl zur@"uck.  Vielfache von 1/2 werden auf die 
n@"achste gerade ganze Zahl gerundet.

Die Funktion @code{round} gibt auch dann einen numerischen Wert zur@"uck, wenn
das Argument ein konstanter Ausdruck ist, wie zum Beispiel @code{1+%e}, der zu
einer reellen Zahl ausgewertet werden kann.  In diesem Fall wird der konstante
Ausdruck in eine gro@ss{}e Gleitkommazahl umgewandelt, auf die die Funktion
@code{round} angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von @code{round}
kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
@mref{fpprec} f@"ur die Berechnung von @code{round} um drei Stellen erh@"oht.

Ist das Argument @var{x} der Funktion ein komplexer Ausdruck, wird eine
Substantivform zur@"uckgegeben.

Wenn m@"oglich werden Ausdr@"ucke mit der Funktion @code{round} von Maxima
vereinfacht.  Maxima kennt insbesondere Vereinfachungen f@"ur den Fall, dass
das Argument der Funktion @code{round} ein Ausdruck mit den Funktionen
@mref{ceiling} oder @mref{floor} ist.  Weiterhin werden f@"ur die Vereinfachung
die Aussagen und Fakten der aktiven Kontexte herangezogen.  Siehe 
@ref{Funktionen und Variablen f@"ur Fakten}.

@code{round} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe auch die Funktionen @mref{ceiling} und @mrefdot{floor}

Beispiele:

@example
(%i1) round(floor(x));
(%o1)                       floor(x)
(%i2) round(round(x));
(%o2)                       round(x)
(%i3) declare(n, integer);
(%o3)                         done
(%i4) round([n, abs(n), min(n,6)]);
(%o4)                [n, abs(n), min(6, n)]
@end example

Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen, kann diese als
@mref{integervalued} deklariert werden.  Die Funktion @code{round} kann diese
Information nutzen, um Ausdr@"ucke zu vereinfachen.

@example
(%i1) declare(f, integervalued);
(%o1)                         done
(%i2) round(f(x));
(%o2)                         f(x)
(%i3) round(f(x) - 1);
(%o3)                       f(x) - 1
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{signum}
@deffn {Funktion} signum (@var{z})

Die Signumfunktion @code{signum} ist f@"ur das numerische und symbolische
Rechnen geeignet.  Ist das Argument @var{z} eine Zahl, ist das Ergebnis 0, 1
oder -1, wenn die Zahl Null, positiv oder negativ ist.  Das Argument kann auch
ein konstanter Ausdruck wie @code{%pi} oder @code{1+%e} sein.  Ist das Argument
@var{z} eine komplexe Zahl, vereinfacht die der Ausdruck @code{signum(z)} zu
@code{z/abs(z)}.

Ist das Argument @var{z} keine Zahl oder kein konstanter Ausdruck, versucht
Maxima den Ausdruck zu vereinfachen.  Maxima kann die Funktion @code{signum}
differenzieren.  Wird das Paket @nref{abs_integrate} geladen, kann Maxima
Integrale mit der Funktion @code{signum} l@"osen.

@code{signum} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Beispiele:

Ergebnisse f@"ur verschiedene Zahlen und konstante Ausdr@"ucke.  Die Beispiele
zeigen, dass das Ergebnis der Signumfunktion den Typ der Zahl erh@"alt.  Die
unendlichen Gr@"o@ss{}en @mref{minf} und @mref{inf} k@"onnen als Argument
auftreten.

@example
(%i1) signum([-1.5, 0, 0.0, 1.5, 1.5b0, %e, sin(1), cos(4)]);
(%o1)        [- 1.0, 0, 0.0, 1.0, 1.0b0, 1, 1, - 1]
(%i2) signum(1+%i);
                          %i         1
(%o2)                   ------- + -------
                        sqrt(2)   sqrt(2)
(%i3) signum([minf,inf]);
(%o3)                      [- 1, 1]
@end example

Vereinfachungen der Signumfunktion.

@example
(%i3) signum(x*y);
(%o3)                  signum(x) signum(y)
(%i4) signum(-x);
(%o4)                      - signum(x)
@end example

Wird das Paket @nref{abs_integrate} geladen, kann Maxima Integrale mit der
Signumfunktion l@"osen.  Ausdr@"ucke mit der Signumfunktion k@"onnen
differenziert werden.

@example
(%i5) load(abs_integrate)$

(%i6) integrate(signum(x),x);
(%o6)                        abs(x)

(%i7) integrate(sin(x)*signum(x),x);
(%o7)               (1 - cos(x)) signum(x)

(%i7) diff(%,x);
(%o7)                  signum(x) sin(x)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur komplexe Zahlen, Funktionen der Kombinatorik, Funktionen f@"ur Zahlen, Mathematische Funktionen
@section Funktionen f@"ur komplexe Zahlen
@c -----------------------------------------------------------------------------

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{cabs}
@deffn {Funktion} cabs (@var{expr})

Berechnet den Betrag eines komplexen Ausdrucks @var{expr}.  Im Unterschied
zu der Funktion @mrefcomma{abs} zerlegt die Funktion @code{cabs} einen komplexen
Ausdruck immer in einen Realteil und Imagin@"arteil, um den komplexen Betrag zu
berechnen.  Sind @var{x} und @var{y} zwei reelle Variablen oder Ausdr@"ucke,
berechnet die Funktion @code{cabs} den Betrag des komplexen Ausdrucks
@code{x + %i*y} als:
@example
                           2    2
                     sqrt(y  + x )
@end example

Die Funktion @code{cabs} nutzt Symmetrieeigenschaften und implementierte
Eigenschaften komplexer Funktionen, um den Betrag eines Ausdrucks zu berechnen.
Sind solche Eigenschaften f@"ur eine Funktion vorhanden, k@"onnen diese mit der
Funktion @mref{properties} angezeigt werden.  Eigenschaften, die das Ergebnis
der Funktion @code{cabs} bestimmen, sind: @code{mirror symmetry},
@code{conjugate function} und @code{complex characteristic}.

@code{cabs} ist eine Verbfunktion, die nicht f@"ur das symbolische Rechnen
geeignet ist.  F@"ur das symbolische Rechnen wie der Integration oder der
Ableitung von Ausdr@"ucken mit der Betragsfunktion muss die Funktion @code{abs}
verwendet werden.

Das Ergebnis der Funktion @code{cabs} kann die Betragsfunktion @mref{abs} und
den Arkustangens @mref{atan2} enthalten.

@code{cabs} wird automatisch auf die Elemente von Listen und Matrizen sowie auf
die beiden Seiten von Gleichungen angewendet.

Siehe auch die Funktionen @mrefcomma{rectform} @mrefcomma{realpart}@w{}
@mrefcomma{imagpart} @mrefcomma{carg} @mrefcomma{conjugate} und 
@mref{polarform} f@"ur das Rechnen mit komplexen Zahlen.

Beispiele:

Zwei Beispiele mit der Wurzelfunktion @mref{sqrt} und der Sinusfunktion
@mrefdot{sin}

@example
(%i1) cabs(sqrt(1+%i*x));
                             2     1/4
(%o1)                      (x  + 1)
(%i2) cabs(sin(x+%i*y));
                    2        2         2        2
(%o2)       sqrt(cos (x) sinh (y) + sin (x) cosh (y))
@end example

Die Funktion @mref{erf} hat Spiegelsymmetrie, die hier f@"ur die Berechnung des
komplexen Betrages angewendet wird.

@example
(%i3) cabs(erf(x+%i*y));
@group
                                          2
           (erf(%i y + x) - erf(%i y - x))
(%o3) sqrt(--------------------------------
                          4
                                                               2
                                (erf(%i y + x) + erf(%i y - x))
                              - --------------------------------)
                                               4
@end group
@end example

Maxima kennt komplexe Eigenschaften der Besselfunktionen, um den komplexen
Betrag zu vereinfachen.  Dies ist ein Beispiel f@"ur die Besselfunktion
@mrefdot{bessel_j}

@example
(%i4) cabs(bessel_j(1,%i));
(%o4)                 abs(bessel_j(1, %i))
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{carg}
@deffn {Funktion} carg (@var{expr})

Gibt das komplexe Argument des Ausdrucks @var{expr} zur@"uck.  Das komplexe
Argument ist ein Winkel @code{theta} im Intervall @code{(-%pi, %pi)} derart,
dass @var{expr} = @code{r exp (theta %i)} gilt, wobei @code{r} den Betrag des
komplexen Ausdrucks @var{expr} bezeichnet.  Das ist die Polarform des Ausdrucks,
wie sie auch von der Funktion @mref{polarform} zur@"uckgegeben wird.  Der Betrag
des komplexen Ausdrucks kann mit der Funktion @mref{cabs} berechnet werden.

Das Ergebnis der Funktion @code{carg} kann die Funktion @mref{atan2} enthalten.

@code{carg} wird automatisch auf die Elemente von Listen und Matrizen sowie auf
die beiden Seiten von Gleichungen angewendet.  Siehe @mrefdot{distribute_over}

Die Funktion @code{carg} ist eine Verbfunktion, mit der nicht symbolisch
gerechnet werden kann.

Siehe auch die Funktionen @mrefcomma{rectform} @mref{realpart} und
@mref{imagpart} sowie die Funktionen @mref{cabs} und @mrefdot{conjugate}

Beispiele:

@example
(%i1) carg (1);
(%o1)                           0
(%i2) carg (1 + %i);
@group
                               %pi
(%o2)                          ---
                                4
@end group
(%i3) carg (exp (%i));
(%o3)                           1

(%i4) carg (exp (3/2 * %pi * %i));
                                %pi
(%o4)                         - ---
                                 2
(%i5) carg(exp(x+%i*y));
(%o5)                atan2(sin(y), cos(y))

(%i6) carg(sqrt(x+%i*y));
                          atan2(y, x)
(%o6)                     -----------
                               2
(%i7) carg(sqrt(1+%i*y));
                            atan(y)
(%o7)                       -------
                               2
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{conjugate}
@deffn {Funktion} conjugate (@var{expr})

Gibt den konjugiert komplexen Wert des Ausdrucks @var{expr} zur@"uck.  Sind
@var{x} und @var{y} reelle Variablen oder Ausdr@"ucke, dann hat der Ausdruck
@code{x + %i*y} das Ergebnis @code{x - %i*y}.  Die Funktion @code{conjugate} ist
f@"ur numerische und symbolische Rechnungen geeignet.

Maxima kennt Regeln, um den konjugierten Wert f@"ur Summen, Produkte und
Quotienten von komplexen Ausdr@"ucken zu vereinfachen.  Weiterhin kennt Maxima
Symmetrieeigenschaften und komplexe Eigenschaften von Funktionen, um den 
konjugierten Wert mit diesen Funktionen zu vereinfachen.  Sind solche
Eigenschaften f@"ur eine Funktion vorhanden, k@"onnen diese mit der
Funktion @mref{properties} angezeigt werden.  Eigenschaften, die das Ergebnis
der Funktion @code{conjugate} bestimmen, sind: @code{mirror symmetry},
@code{conjugate function} und @code{complex characteristic}.

@code{conjugate} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

F@"ur das Rechnen mit komplexen Ausdr@"ucken siehe auch die Funktionen
@mref{cabs} und @mref{carg} sowie @mref{rectform} und @mrefdot{polarform}

Beispiele:

Beispiele mit reellen, imagin@"aren und komplexen Variablen.

@example
(%i1) declare ([x, y], real, [z1, z2], complex, j, imaginary);
(%o1)                         done
(%i2) conjugate(x + %i*y);
(%o2)                       x - %i y
(%i3) conjugate(z1*z2);
(%o3)              conjugate(z1) conjugate(z2)
(%i4) conjugate(j/z2);
                                 j
(%o4)                    - -------------
                           conjugate(z2)
@end example

Im Folgenden nutzt Maxima Symmetrieeigenschaften, um den konjugiert komplexen
Wert der Funktionen @mref{gamma} und @mref{sin} zu berechnen.  Die
Logarithmusfunktion @mref{log} hat Spiegelsymmetrie, wenn das Argument einen
positiven Realteil hat.

@example
(%i5) conjugate(gamma(x+%i*y));
(%o5)                    gamma(x - %i y)
(%i6) conjugate(sin(x+%i*y));
(%o6)                    - sin(%i y - x)
(%i7) conjugate(log(x+%i*y));
(%o7)               conjugate(log(%i y + x))
(%i8) conjugate(log(1+%i*y));
(%o8)                     log(1 - %i y)
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{imagpart}
@deffn {Funktion} imagpart (@var{expr})

Gibt den Imagin@"arteil des Ausrucks @var{expr} zur@"uck.  Intern berechnet
Maxima den Imagin@"arteil mit der Funktion @mrefcomma{rectform} die einen
Ausdruck in den Realteil und in den Imagin@"arteil zerlegt.  Daher treffen die
Ausf@"uhrungen zu @code{rectform} auch auf die Funktion @code{imagpart} zu.

Wie die Funktion @code{rectform} ist auch die Funktion @code{imagpart} eine
Verbfunktion, mit der nicht symbolisch gerechnet werden kann.

@code{imagpart} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Mit der Funktion @mref{realpart} wird der Realteil eines Ausdrucks berechnet.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.  Mit der Funktion
@mref{polarform} kann ein komplexer Ausdruck in die Polarform gebracht werden.

Beispiele:

F@"ur weitere Erl@"auterungen dieser Beispiele siehe auch die Funktion
@mrefdot{rectform}

@example
(%i1) imagpart((2-%i)/(1-%i));
                                1
(%o1)                           -
                                2
(%i2) imagpart(sin(x+%i*y));
(%o2)                    cos(x) sinh(y)
(%i3) imagpart(gamma(x+%i*y));
             %i (gamma(x - %i y) - gamma(%i y + x))
(%o3)        --------------------------------------
                               2
(%i4) imagpart(bessel_j(1,%i));
(%o4)                    bessel_j(1, %i)
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{polarform}
@deffn {Funktion} polarform (@var{expr})

Gibt den Ausdruck @var{expr} in der Polarform @code{r %e^(%i theta)} zur@"uck.
@code{r} ist der Betrag des komplexen Ausdrucks, wie er auch mit der Funktion
@mref{cabs} berechnet werden kann.  @code{theta} ist das Argument des komplexen
Ausdrucks, das mit der Funktion @mref{carg} berechnet werden kann.

Maxima kennt komplexe Eigenschaften von Funktionen, die bei der Berechnung der
Polarform angewendet werden.  Siehe die Funktion @mref{cabs} f@"ur weitere
Erl@"auterungen.

Wenn mit komplexen Ausdr@"ucken in der Polarform gerechnet werden soll, ist es
hilfreich die Optionsvariable @mref{%emode} auf den Wert @code{false} zu setzen.
Damit wird verhindert, dass Maxima komplexe Ausdr@"ucke mit der
Exponentialfunktion @mref{exp} automatisch in die Standardform vereinfacht.

@code{polarform} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Die Funktion @code{polarform} ist eine Verbfunktion, mit der nicht symbolisch
gerechnet werden kann.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.  Mit der Funktion
@mref{rectform} kann ein komplexer Ausdruck in die Standardform gebracht werden.

Beispiele:

Die allgemeine Polarform eines komplexen Ausdrucks.  Die Variablen @var{x} und
@var{y} werden von Maxima als reell angenommen.

@example
(%i1) polarform(x+%i*y);
@group
                       2    2    %i atan2(y, x)
(%o1)            sqrt(y  + x ) %e
@end group
@end example

Die Polarform einer komplexen Zahl und eines Ausdrucks mit einer reellen 
Variablen @var{x}.

@example
(%i2) polarform(4/5+3*%i/5);
                           %i atan(3/4)
(%o2)                    %e
(%i3) polarform(sqrt(1+%i*x));
                                  %i atan(x)
                                  ----------
                      2     1/4       2
(%o3)               (x  + 1)    %e
@end example

Wenn in der Polarform gerechnet werden soll, ist es hilfreich die
Optionsvariable @mref{%emode} auf den Wert @code{false} zu setzen.  Damit wird
verhindert, dass Maxima komplexe Ausdr@"ucke mit der Exponentialfunktion 
@mref{exp} automatisch in eine Standardform vereinfacht.

@example
(%i4) z:polarform(1+%i);
                                  %i %pi
                                  ------
                                    4
(%o4)                   sqrt(2) %e
(%i5) z^3;
                     3/2    %i         1
(%o5)               2    (------- - -------)
                          sqrt(2)   sqrt(2)
(%i6) %emode:false;
(%o6)                         false
(%i7) z^3;
                                3 %i %pi
                                --------
                          3/2      4
(%o7)                    2    %e
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{realpart}
@deffn {Funktion} realpart (@var{expr})

Gibt den Realteil des Ausdrucks @var{expr} zur@"uck.  Intern berechnet Maxima
den Realteil mit der Funktion @mrefcomma{rectform} die einen Ausdruck in den
Realteil und in den Imagin@"arteil zerlegt.  Daher treffen die Ausf@"uhrungen
zu @code{rectform} auch auf die Funktion @code{realpart} zu.

Wie die Funktion @code{rectform} ist auch die Funktion @code{realpart} eine
Verbfunktion, mit der nicht symbolisch gerechnet werden kann.

@code{realpart} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Mit der Funktion @mref{imagpart} wird der Imagin@"arteil eines Ausdrucks
berechnet.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.  Mit der Funktion
@mref{polarform} kann ein komplexer Ausdruck in die Polarform gebracht werden.

Beispiele:

F@"ur weitere Erl@"auterungen dieser Beispiele siehe auch die Funktion
@mrefdot{rectform}

@example
(%i1) realpart((2-%i)/(1-%i));
                                3
(%o1)                           -
                                2
(%i2) realpart(sin(x+%i*y));
(%o2)                    sin(x) cosh(y)
(%i3) realpart(gamma(x+%i*y));
                gamma(%i y + x) + gamma(x - %i y)
(%o3)           ---------------------------------
                                2
(%i4) realpart(bessel_j(1,%i));
(%o4)                           0
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{rectform}
@deffn {Funktion} rectform (@var{expr})

Zerlegt den Ausdruck @var{expr} in den Realteil @code{a} und den Imagin@"arteil
@code{b} und gibt den komplexen Ausdruck in der Standardform @code{a + b %i}
zur@"uck.

Die Funktion @code{rectform} nutzt Symmetrieeigenschaften und implementierte
Eigenschaften komplexer Funktionen, um den Realteil und Imagin@"arteil eines
komplexen Ausdrucks zu berechnen.  Sind solche Eigenschaften f@"ur eine Funktion
vorhanden, k@"onnen diese mit der Funktion @mref{properties} angezeigt werden.
Eigenschaften, die das Ergebnis der Funktion @code{rectform} bestimmen, sind:
@code{mirror symmetry}, @code{conjugate function} und
@code{complex characteristic}.

@code{rectform} ist eine Verbfunktion, die nicht f@"ur das symbolische Rechnen
geeignet ist.

@code{rectform} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Die Funktionen @mref{realpart} und @mref{imagpart} geben jeweils allein den
Realteil und den Imagin@"arteil eines Ausdrucks zur@"uck.  Um einen Ausdruck in
die Polarform zu bringen, kann die Funktion @mref{polarform} verwendet werden.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.

Beispiele:

Zerlegung eines komplexen Ausdrucks und der Sinusfunktion @mref{sin} in den
Realteil und Imagin@"arteil.  Maxima kennt komplexe Eigenschaften der
trigonometrischen Funktionen, um den Realteil und den Imagin@"arteil zu
bestimmen.

@example
(%i1) rectform((2-%i)/(1-%i));
@group
                             %i   3
(%o1)                        -- + -
                             2    2
@end group
(%i2) rectform(sin(x+%i*y));
(%o2)          %i cos(x) sinh(y) + sin(x) cosh(y)
@end example

Bei der Zerlegung in einen Realteil und einen Imagin@"arteil nutzt Maxima die
Spiegelsymmetrie der Gammfunktion @mrefdot{gamma}  Die Eigenschaft der 
Spiegelsymmetrie wird mit der Funktion @mref{properties} angezeigt, der Eintrag
lautet @code{mirror symmetry}.

@example
(%i3) properties(gamma);
(%o3)    [mirror symmetry, noun, rule, gradef, transfun]

(%i4) rectform(gamma(x+%i*y));
      gamma(%i y + x) + gamma(x - %i y)
(%o4) ---------------------------------
                      2
                                gamma(x - %i y) - gamma(%i y + x)
                              - ---------------------------------
                                                2
@end example

Maxima kennt komplexe Eigenschaften der Besselfunktionen.  Die Besselfunktion
@mref{bessel_j} ist f@"ur eine ganzzahlige Ordnung und einem imagin@"aren
Argument rein imagin@"ar.

@example
(%i5) rectform(bessel_j(1,%i));
(%o5)                  %i bessel_j(1, %i)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen der Kombinatorik, Wurzel- Exponential- und Logarithmusfunktion, Funktionen f@"ur komplexe Zahlen, Mathematische Funktionen
@section Funktionen der Kombinatorik
@c -----------------------------------------------------------------------------

@c --- 25.02.2011 DK -----------------------------------------------------------
@anchor{!!}
@deffn {Operator} !!
@ifinfo
@fnindex Doppelte Fakult@"at
@end ifinfo

Ist der Operator der doppelten Fakult@"at.

F@"ur eine positive ganze Zahl @code{n}, wird @code{n!!} zu dem Produkt
@code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))} vereinfacht, wobei @code{k} gleich
@code{floor(n/2)} ist und @mref{floor} die gr@"o@ss{}te ganze Zahl als Ergebnis
hat, die kleiner oder gleich @code{n/2} ist.

F@"ur ein Argument @code{n}, das keine ganze positive Zahl ist, gibt @code{n!!}
die Substantivform @code{genfact(n, n/2,2)} zur@"uck.  Siehe die Funktion
@mrefdot{genfact}

Die Verallgemeinerung der doppelten Fakult@"at f@"ur reelle und komplexe Zahlen
ist als die Funktion @mref{double_factorial} implementiert.

Beispiele:

@example
(%i1) [0!!, 1!!, 2!!, 3!!, 4!!, 5!!, 6!!, 7!!, 8!!];
(%o1)           [1, 1, 2, 3, 8, 15, 48, 105, 384]
(%i2) 1.5!!;
(%o2)                  genfact(1.5, 0, 2)
(%i3) x!!;
                                   x
(%o3)                   genfact(x, -, 2)
                                   2
@end example
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{binomial}
@deffn {Funktion} binomial (@var{x}, @var{y})

Ist der Binominialkoeffizient, der definiert ist als
@ifnottex
@example
                                  x!
             binomial(x, y) = -----------
                              (x - y)! y!
@end example
@end ifnottex
@tex
$${{x}\choose{y}}={{x!}\over{\left(x-y\right)!\,y!}}$$
@end tex

Die Funktion @code{binomial} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Sind die Argumente @var{x} oder @var{y} ganze Zahlen, wird der
Binominialkoeffizient zu einer ganzen Zahl vereinfacht.  Sind die Argumente
@var{x} und @var{y} reelle oder komplexe Gleitkommazahlen, wird der
Binominialkoeffizient mit der entsprechenden verallgemeinerten Fakult@"at
berechnet.  Siehe auch @mref{factorial} und @mrefdot{gamma}

Ist das Argument @var{y} oder die Differenz @var{x-y} eine ganz Zahl, wird
der Binominialkoeffizient zu einem Polynom vereinfacht.

Mit den Funktionen @mref{makefact} oder @mref{makegamma} werden
Binominialkoeffizienten in einem Ausdruck durch @"aquivalente Ausdr@"ucke mit
der Fakult@"at oder der Gammafunktion ersetzt.

Maxima kennt die Ableitung des Binominialkoeffizienten nach den Argumenten
@var{x} und @var{y}.

Beispiele:

@example
(%i1) binomial(11, 7);
(%o1)                          330
(%i2) binomial(%i, 1.5);
(%o2)       .3693753994635863 %i - .7573400496142132
(%i3) binomial(x, 3);
                        (x - 2) (x - 1) x
(%o3)                   -----------------
                                6
(%i4) binomial(x+3, 3);
                     (x + 1) (x + 2) (x + 3)
(%o4)                -----------------------
                                6
(%i5) makefact(binomial(x,y));
                               x!
(%o5)                      -----------
                           (x - y)! y!

(%i6) diff(binomial(x,y), y);
(%o6)  - binomial(x, y) (psi (y + 1) - psi (- y + x + 1))
                            0             0
@end example
@end deffn

@c --- 25.02.2011 DK -----------------------------------------------------------
@anchor{double_factorial}
@deffn {Funktion} double_factorial (z)

Ist die doppelte Fakult@"at, die allgemein definiert ist als
@ifnottex
@example
               2  1/4 (1 - cos(z %pi))  z/2       z
             (---)                     2    gamma(- + 1)
              %pi                                 2
@end example
@end ifnottex
@tex
$$\left({{2}\over{\pi}}\right)^{{{1}\over{4}}\,\left(1-\cos \left(z\,
 \pi\right)\right)}\,2^{{{z}\over{2}}}\,\Gamma\left({{z}\over{2}}+1
 \right)$$
@end tex

Die Funktion @code{double_factorial} ist f@"ur das numerische und symbolische
Rechnen geeignet.  Ist das Argument @var{z} eine ganze Zahl, eine
Gleitkommazahl, eine gro@ss{}e Gleitkommazahl oder eine komplexe Gleitkommazahl,
dann wird ein numerisches Ergebnis berechnet.  F@"ur eine positive ganze Zahl
ist das Ergebnis gleich dem Ergebnis des Operators der doppelten Fakult@"at
@mref{!!}.  F@"ur rationale Zahlen ist das Ergebnis eine Substantivform.

F@"ur negative gerade ganze Zahlen ist die Funktion @code{double_factorial}
nicht definiert.

Hat die Optionsvariable @mref{factorial_expand} den Wert @code{true}, 
vereinfacht Maxima @code{double_factorial} f@"ur das Argument @code{n-1} und
f@"ur Argumente @code{n+2*k}, wobei @code{k} eine ganze Zahl ist.

Maxima kennt die Ableitung der Funktion @code{double_factorial}.

@code{double_factorial} wird automatisch auf die Elemente von Listen und
Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Beispiele:

Numerische Ergebnisse f@"ur ganze Zahlen, Gleitkommazahlen und komplexen
Gleitkommazahlen.

@example
(%i1) double_factorial([-3, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
(%o1) [- 1, 1, 1, 1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]

(%i2) double_factorial([1.5, 1.5b0, 0.5+%i, 0.5b0+%i]);
(%o2) [1.380662681753386, 1.380662681753387b0,
.4186422526242637 - .7218816624466643 %i, 
4.186422526242633b-1 - 7.218816624466641b-1 %i]
@end example

Vereinfachungen, wenn die Optionsvariable @mref{factorial_expand} den Wert
@code{true} hat.

@example
(%i3) factorial_expand:true;
(%o3)                         true
(%i4) double_factorial(n-1);
                               n!
(%o4)                  -------------------
                       double_factorial(n)
(%i5) double_factorial(n+4);
(%o5)          (n + 2) (n + 4) double_factorial(n)
(%i6) double_factorial(n-4);
@group
                       double_factorial(n)
(%o6)                  -------------------
                            (n - 2) n
@end group
@end example

Die Ableitung der Funktion @code{double_factorial}.

@example
(%i7) diff(double_factorial(x), x);
                                     2
                            %pi log(---) sin(%pi x)
                                    %pi                    x
(%o7) (double_factorial(x) (----------------------- + psi (- + 1)
                                       2                 0 2
                                                     + log(2)))/2
@end example
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{factcomb}
@deffn {Funktion} factcomb (@var{expr})

Fasst Faktoren mit Fakult@"aten im Ausdruck @var{expr} zusammen.  Zum Beispiel
wird @code{(n+1)*n!} zu @code{(n+1)!} zusammengefasst.

Hat die Optionsvariable @mref{sumsplitfact} den Wert @code{false}, wird nach
der Vereinfachung mit @code{factcomb} die Funktion @mref{minfactorial} auf den 
Ausdruck @var{expr} angewendet.

Beispiele:

@example
(%i1) expr: ((n+1)*n!)/(n+2)!;
                           (n + 1) n!
(%o1)                      ----------
                            (n + 2)!
(%i2) factcomb(expr);
@group
                            (n + 1)!
(%o2)                       --------
                            (n + 2)!
@end group
(%i3) factcomb(expr), sumsplitfact:false;
                                1
(%o3)                         -----
                              n + 2
@end example
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{factorial}
@anchor{!}
@deffn  {Funktion} factorial (@var{z})
@deffnx {Operator} !
@ifinfo
@fnindex Fakult@"at
@end ifinfo

Die Funktion @code{factorial} ist f@"ur das numerische und symbolische Rechnen
der Fakult@"at geeignet.  Der Operator der Fakult@"at @code{!}, ist identisch
mit der Funktion @code{factorial}.

F@"ur eine ganze Zahl @code{n}, vereinfacht @code{n!} zum Produkt der ganzen
Zahlen von 1 bis einschlie@ss{}lich @code{n}.  @code{0!} vereinfacht zu 1.
F@"ur reelle und komplexe Gleitkommazahlen wird @code{z!} mit der
Verallgemeinerung @code{gamma(z+1)} berechnet.  Siehe die Funktion
@mrefdot{gamma}  F@"ur eine halbzahlige rationale Zahl @code{n/2}, vereinfacht
@code{(n/2)!} zu einem rationalen Faktor multipliziert mit @code{sqrt(%pi)}.

Die Optionsvariable @mref{factlim} enth@"alt die gr@"o@ss{}te Zahl, f@"ur die
die Fakult@"at einer ganzen Zahl numerisch berechnet wird.  Ist das Argument
der Fakult@"at eine rationale Zahl, wird von Maxima die Funktion
@mref{gamma} f@"ur die numerische Berechnung aufgerufen.  In diesem Fall ist
@code{gammalim - 1} der gr@"o@ss{}te Nenner, f@"ur den die Fakult@"at vereinfacht
wird.  Siehe @mrefdot{gammalim}

Hat die Optionsvariable @mref{factorial_expand} den Wert @code{true}, wird die
Fakult@"at von Argumenten der Form @code{(n+k)!} oder @code{(n-k)!} vereinfacht,
wobei @code{k} eine ganze Zahl ist.

Mit den Funktionen @mref{minfactorial} und @mref{factcomb} k@"onnen Fakult@"aten
in Ausdr@"ucken vereinfacht werden.

Die Funktion @mref{makegamma} ersetzt Fakult@"aten in einem Ausdruck durch die
Gammafunktion @mrefdot{gamma}  Umgekehrt ersetzt die Funktion
@mref{makefact} Binomialkoeffizienten und die Gammafunktion in einem Ausdruck
durch Fakult@"aten.

Maxima kennt die Ableitung der Fakult@"at und die Grenzwerte der Fakult@"at
f@"ur spezielle Werte wie negative ganze Zahlen.

Siehe auch die Gammfunktion @mref{gamma} und den Binomialkoeffizienten
@mrefdot{binomial}

Beispiele:

Die Fakult@"at einer ganzen Zahl wird zu einer exakten Zahl vereinfacht, wenn
das Argument nicht gr@"o@ss{}er als @code{factlim} ist.  Die Fakult@"at f@"ur 
reelle und komplexe Zahlen wird als Gleitkommazahl berechnet.

@example
(%i1) factlim:10;
(%o1)                          10
(%i2) [0!, (7/2)!, 8!, 20!];
                     105 sqrt(%pi)
(%o2)            [1, -------------, 40320, 20!]
                          16
(%i3) [4.77!, (1.0+%i)!];
(%o3) [81.44668037931197, .3430658398165451 %i
                                             + .6529654964201663]
(%i4) [2.86b0!, (1.0b0+%i)!];
(%o4) [5.046635586910012b0, 3.430658398165454b-1 %i
                                          + 6.529654964201667b-1]
@end example

Die Fakult@"at von numerischen Konstanten oder eines konstanten Ausdrucks wird
numerisch berechnet, wenn die Konstante oder der Ausdruck zu einer Zahl
ausgewertet werden kann.

@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [.3430658398165451 %i + .6529654964201663, 
         7.188082728976031, 4.260820476357003, 1.227580202486819]
@end example

Fakult@"aten werden vereinfacht und nicht ausgewertet.  Daher wird die
Fakult@"at auch dann berechnet, wenn die Auswertung mit dem
@nxref{', Quote-Operator} @code{'} unterdr@"uckt ist.

@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
            105 sqrt(%pi)
(%o1)   [1, -------------, 81.44668037931197, 40320, 20!]
                 16
@end example

Maxima kennt die Ableitung der Fakult@"at.

@example
(%i1) diff(x!, x);
(%o1)                    x! psi (x + 1)
                               0
@end example

Die Optionsvariable @code{factorial_expand} kontrolliert die Expansion und
Vereinfachung von Ausdr@"ucken, die die Fakult@"at enthalten.

@example
(%i1) (n+1)!/n!,factorial_expand:true;
(%o1)                         n + 1
@end example
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{factlim}
@defvr {Optionsvariable} factlim
Standardwert: 100000

Die Optionsvariable @code{factlim} spezifiziert die gr@"o@ss{}te ganze Zahl, 
f@"ur die die Fakult@"at einer ganzen Zahl numerisch berechnet wird.  Hat
@code{factlim} den Wert -1, wird die Fakult@"at f@"ur jede ganze Zahl
berechnet.  Siehe die Funktion @mrefdot{factorial}
@end defvr

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{factorial_expand}
@defvr {Optionsvariable} factorial_expand
Standardwert: @code{false}

Die Optionsvariable @code{factorial_expand} kontrolliert die Vereinfachung von
Aus@-dr@"u@-cken wie @code{(n+k)!} oder @code{(n-k)!}, wobei @code{k} eine
ganze Zahl ist.  Siehe @mref{factorial} f@"ur ein Beispiel.

Siehe auch die Funktionen @mref{minfactorial} und @mref{factcomb} f@"ur die
Vereinfachung von Ausdr@"ucken mit der Fakult@"at.
@end defvr

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{genfact}
@deffn {Funktion} genfact (@var{x}, @var{y}, @var{z})

Gibt die verallgemeinerte Fakult@"at zur@"uck, die als @code{x (x-z) (x - 2 z) 
... (x - (y - 1) z)} definiert ist.  Ist @var{x} eine ganze Zahl, dann
entspricht @code{genfact(x, x, 1)} der Fakult@"at @code{x!} und 
@code{genfact(x, x/2, 2)} der doppelten Fakult@"at @code{x!!}.  Siehe auch die 
Funktionen @mref{factorial} und @mref{double_factorial} sowie die Operatoren
@mref{!} und @mrefdot{!!}
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{minfactorial}
@deffn {Funktion} minfactorial (@var{expr})

Die Funktion @code{minfactorial} vereinfacht Fakult@"aten @mref{factorial} in
dem Ausdruck @var{epxr}, die sich um eine ganze Zahl voneinander unterscheiden.
Siehe auch die Funktion @mrefcomma{factcomb} um Fakult@"aten zusammenzufassen,
sowie die Optionsvariable @mrefdot{factorial_expand}

@example
(%i1) n!/(n+2)!;
                               n!
(%o1)                       --------
                            (n + 2)!
(%i2) minfactorial (%);
                                1
(%o2)                    ---------------
                         (n + 1) (n + 2)
@end example
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{sumsplitfact}
@defvr {Optionsvariable} sumsplitfact
Standardwert: @code{true}

Hat die Optionsvariable @code{sumsplitfact} den Wert @code{false}, wird von
der Funktion @code{factcomb} nach der Zusammenfassung von Fakult@"aten die
Funktion @mref{minfactorial} angewendet.  Siehe die Funktion
@mref{factcomb} f@"ur ein Beispiel.
@end defvr

@c -----------------------------------------------------------------------------
@node Wurzel- Exponential- und Logarithmusfunktion, Winkelfunktionen, Funktionen der Kombinatorik, Mathematische Funktionen
@section Wurzel-, Exponential- und Logarithmusfunktion
@c -----------------------------------------------------------------------------

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{%e_to_numlog}
@defvr {Optionsvariable} %e_to_numlog
Standardwert: @code{false}

Hat die Optionsvariable @code{%e_to_numlog} den Wert @code{true}, wird ein 
Ausdruck mit der Exponentialfunktion @mref{exp} der Form @code{%e^(r*log(x))}
zu @code{x^r} vereinfacht, wenn @code{r} eine rationale Zahl ist.  Ist @code{r}
eine ganze Zahl, wird die Vereinfachung von der Optionsvariablen
@mref{logsimp} kontrolliert.

Beispiel:

@example
(%i1) exp(1/2*log(x));
                              log(x)
                              ------
                                2
(%o1)                       %e
(%i2) exp(1/2*log(x)), %e_to_numlog:true;
(%o2)                        sqrt(x)
@end example
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{%emode}
@defvr {Optionsvariable} %emode
Standardwert: @code{true}

Die Optionsvariable @code{%emode} kontrolliert die Vereinfachung von
Ausdr@"ucken mit der Exponentialfunktion @mref{exp} der Form
@code{%e^(%pi %i x)}.

Ist das Argument @var{x} eine ganze Zahl oder eine rationale Zahl, die ein
Vielfaches von 1/2, 1/3, 1/4 oder 1/6 ist, dann wird der Ausdruck
@code{%e^(%pi %i x)} zu einer reellen oder komplexen Zahl vereinfacht.  F@"ur
Gleitkommazahlen wird diese Vereinfachung dann ausgef@"uhrt, wenn diese eine
ganze Zahl oder halbzahlige rationale Zahl repr@"asentieren.

Eine Summe im Exponenten wie zum Beispiel @code{%e^(%pi *%i (x+n))}, wobei 
@var{n} eine der oben genannten Zahlen und @var{x} ein allgemeiner Ausdruck ist,
wird vereinfacht, indem der Faktor @code{%^(%pi %i n)} entsprechend vereinfacht
wird.

Hat @code{%emode} den Wert @code{false}, werden keine speziellen Vereinfachungen
f@"ur den Ausdruck @code{%e^(%pi %i x)} vorgenommen.

Beispiele:

@example
(%i1) exp([2*%pi*%i, 1/2*%pi*%i, 0.5*%pi*%i, 0.5b0*%pi*%i]);
(%o1)               [1, %i, 1.0 %i, 1.0b0 %i]

(%i2) exp([1/3*%pi*%i, 1/4*%pi*%i, 1/6*%pi*%i]);
         sqrt(3) %i   1    %i         1     %i   sqrt(3)
(%o2)   [---------- + -, ------- + -------, -- + -------]
             2        2  sqrt(2)   sqrt(2)  2       2

(%i3) exp((1/3+x)*%pi*%i);
                    sqrt(3) %i   1    %i %pi x
(%o3)              (---------- + -) %e
                        2        2
@end example
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{%enumer}
@defvr {Optionsvariable} %enumer
Standardwert: @code{false}

Hat @code{%enumer} den Wert @code{true}, wird die Konstante @code{%e} immer dann
durch ihren nummerischen Wert ersetzt, wenn die Optionsvariable @mref{numer} den
Wert @code{true} hat.

Hat @code{%enumer} den Wert @code{false}, wird die Konstante @code{%e} nur dann
durch ihren nummerischen Wert ersetzt, wenn der Exponent von @code{%e^x} zu 
einer Gleitkommazahl ausgewertet wird.

Siehe auch @mref{ev} und @mrefdot{numer}

Beispiel:

@example
(%i1) %enumer:true;
(%o1)                         true
(%i2) exp(x);
                                 x
(%o2)                          %e
(%i3) exp(x),numer;
                                        x
(%o3)                  2.718281828459045
@end example
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{exp}
@deffn {Funktion} exp (@var{z})

Ist die Exponentialfunktion.  Die Exponentialfunktion @code{exp} wird von Maxima
sofort zu @code{%e^@var{z}} vereinfacht und tritt in vereinfachten
Ausdr@"ucken nicht auf.  Maxima vereinfacht die Exponentialfunktion daher wie
die allgemeine Exponentiation @mrefdot{^}  Dar@"uberhinaus kennt Maxima
spezielle Regeln f@"ur die Vereinfachung der Exponentialfunktion.

Ist das Argument @var{z} der Exponentialfunktion eine ganze oder rationale
Zahl wird ein vereinfachter Ausdruck zur@"uckgegeben.  Ist das Argument
@var{z} eine reelle oder komplexe Gleitkommazahl wird ein numerisches
Ergebnis berechnet.

Folgende Optionsvariablen kontrollieren die Vereinfachung der
Exponentialfunktion:

@table @code
@item %enumer
Hat die Optionsvariable @mref{%enumer} den Wert @code{true}, vereinfacht Maxima
die Eulersche Zahl @mref{%e} immer dann zu ihrem numerischen Wert, wenn die
Optionsvariable @mref{numer} auch den Wert @code{true} hat.

@item %emode
Hat die Optionsvariable @mref{%emode} den Wert @code{true}, wendet Maxima
Regeln an, um Ausdr@"ucke der Form @code{%e^(x*%i*%pi)} zu vereinfachen.
Der Standardwert von @code{%emode} ist @code{true}.  Wenn mit komplexen Zahlen
in der Polarform gerechnet wird, kann es hilfreich sein, die Optionsvariable
@code{%emode} auf den Wert @code{false} zu setzen.

@item %e_to_numlog
Hat die Optionsvariable @mref{%e_to_numlog} den Wert @code{true}, vereinfacht
Maxima einen Ausdruck @code{%e^(r*log(x)} zu @code{x^r}, wobei @var{r}
eine rationale Zahl ist.  Ist @var{r} eine ganze Zahl wird diese Vereinfachung
von der Optionsvariablen @mref{logsimp} kontrolliert.  F@"ur reelle oder
komplexe Gleitkommazahlen wird diese Vereinfachung nicht ausgef@"uhrt.

@item radexpand
Die Optionsvariable @mref{radexpand} kontrolliert die Vereinfachung von
Ausdr@"ucken der Form @code{(%e^a)^b}.  Ist @var{a} ein reelles Argument
vereinfacht Maxima immer zu einem Ausdruck @code{%e^(a*b)}.  Ist @var{a} ein
komplexes Argument, wird die Vereinfachung @code{%e^(a*b)} dann ausgef@"uhrt,
wenn die Optionsvariable @code{radexpand} den Wert @code{all} hat.

@item logsimp
Die Optionsvariable @mref{logsimp} kontrolliert die Vereinfachung der 
Exponentialfunktion f@"ur den Fall, dass im Argument @var{expr} die
Logarithmusfunktion @mref{log} auftritt.  Hat die @code{logsimp} den Wert
@code{true}, wird ein Ausdruck @code{%e^(n*log(x)} zu @code{x^n} vereinfacht,
wenn @var{n} eine ganze Zahl ist.  Mit der Optionsvariablen
@mref{%e_to_numlog} wird diese Vereinfachung f@"ur eine rationale Zahl @var{n}
kontrolliert.

@item demoivre
Ist eine Optionsvariable und eine Funktion, die auch als Auswertungsschalter
@mref{evflag} definiert ist.  Hat die Optionsvariable @mref{demoivre} den Wert
@code{true}, wird ein Ausdruck @code{%e^(x + %i y)} zu
@code{%e^x (cos(y) + %i sin(y))} vereinfacht.  Siehe auch die Optionsvariable
@mrefdot{exponentialize}
@end table

Maxima kennt viele spezielle unbestimmte und bestimmte Integrale mit der 
Exponentialfunktion.
@end deffn

@c --- 01.11.2011 DK -----------------------------------------------------------
@anchor{log}
@deffn {Funktion} log (@var{z})

Ist der nat@"urliche Logarithmus zur Basis @math{e}.  Die Logarithmusfunktion
ist f@"ur das numerische und symbolische Rechnen geeignet.

Maxima hat keine vordefinierte Logarithmusfunktion zur Basis 10 oder anderen 
Basen.  Eine einfache Definition ist zum Beispiel 
@code{log10(x) := log(x)/log(10)}.  Mit dem Kommando @code{load(log10)} kann ein
Paket geladen werden, dass eine dekadische Logarithmusfunktion @code{log10}
definiert.

Ist das Argument @var{z} der Logarithmusfunktion eine ganze oder rationale
Zahl wird ein vereinfachter Ausdruck zur@"uckgegeben.  Ist das Argument
@var{z} eine reelle oder komplexe Gleitkommazahl wird ein numerisches
Ergebnis berechnet.

Die folgenden Optionsvariablen kontrollieren die Vereinfachung und Auswertung
der Logarithmusfunktion:

@table @code
@item logexpand
Hat die Optionsvariable @code{logexpand} den Wert @code{true}, dann wird
@code{log(a^b)} zu @code{b*log(a)} vereinfacht.  Hat @code{logexpand} den
Wert @code{all}, wird zus@"atzlich @code{log(a*b)} zu @code{log(a)+log(b)}
vereinfacht.  Mit den Wert @code{super} vereinfacht Maxima weiterhin
@code{log(a/b)} zu @code{log(a)-log(b)}, wobei @code{a/b} eine rationale Zahl
ist.  @code{log(1/b} wird f@"ur eine ganze Zahl @code{b} immer vereinfacht.
Hat die Optionsvariable @code{logexpand} den Wert @code{false} werden alle
obigen Vereinfachungen ausgeschaltet.

@item logsimp
Hat die Optionsvariable @code{logsimp} den Wert @code{false}, werden 
Exponentialfunktionen @mrefcomma{exp} die Logarithmusfunktionen im Exponenten
enthalten, nicht vereinfacht.

@item lognegint
Hat die Optionsvariable @code{lognegint} den Wert @code{true}, wird
@code{log(-n)} zu @code{log(n)+%i*%pi} f@"ur positive @code{n} vereinfacht.

@item %e_to_numlog
Hat die Optionsvariable @code{%e_to_numlog} den Wert @code{true}, wird ein 
Ausdruck @code{%e^(r*log(x))} zu @code{x^r} vereinfacht.  Dabei sind @code{r}  
eine rationale Zahl und @code{x} ein beliebiger Ausdruck.  Die Funktion 
@code{radcan} f@"uhrt diese Vereinfachung ebenfalls aus.
@end table

Die Logarithmusfunktion wird automatisch auf die Elemente von Listen und
Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Beispiele:

Verschiedene Beispiele mit der Logarithmusfunktion.

@example
(%i1) log(%e);
(%o1)                           1
(%i2) log(100.0);
(%o2)                   4.605170185988092
(%i3) log(2.5+%i);
(%o3)       .3805063771123649 %i + .9905007344332917
(%i4) taylor(log(1+x),x,0,5);
                       2    3    4    5
                      x    x    x    x
(%o4)/T/          x - -- + -- - -- + -- + . . .
                      2    3    4    5
(%i5) rectform(log(x+%i*y));
                       2    2
                  log(y  + x )
(%o5)             ------------ + %i atan2(y, x)
                       2
(%i6) limit(log(x),x,0,plus);
(%o6)                         minf
(%i7) integrate(log(z)^n,z);
@group
                                                    - n - 1
(%o7) - gamma_incomplete(n + 1, - log(z)) (- log(z))
                                                            n + 1
                                                      log(z)
@end group
(%i8) laplace(log(t),t,s);
@group
                        - log(s) - %gamma
(%o8)                   -----------------
                                s
@end group
(%i9) depends(y,x);
(%o9)                        [y(x)]
(%i10) ode2(diff(y,x)+log(y)+1,y,x);
            - 1
(%o10)    %e    expintegral_e(1, - log(y) - 1) = x + %c
@end example
@end deffn

@c --- 12.03.2011 DK -----------------------------------------------------------
@anchor{logabs}
@defvr {Optionsvariable} logabs
Standardwert: @code{false}

Treten bei der unbestimmten Integration Logarithmusfunktionen im Ergebnis auf,
so wird der Betrag der Argumente der Logarithmusfunktionen gebildet, wenn die
Optionsvariable @code{logabs} den Wert @code{true} hat.

Beispiele:

@example
(%i1) logabs:true;
(%o1)                         true
(%i2) integrate(1/x,x);
(%o2)                      log(abs(x))
(%i3) integrate(1/(1+x^3),x);
                                                   2 x - 1
            ! 2        !                      atan(-------)
        log(!x  - x + 1!)   log(abs(x + 1))        sqrt(3)
(%o3) - ----------------- + --------------- + -------------
                6                  3             sqrt(3)
@end example
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logarc}
@deffn  {Funktion} logarc (@var{expr})
@deffnx {Optionsvariable} logarc

Hat die Optionsvariable @code{logarc} den Wert @code{true}, werden inverse
Winkel- und Hyperbelfunktionen durch Logarithmusfunktionen ersetzt.  Der 
Standardwert von @code{logarc} ist @code{false}.

Die Funktion @code{logarc(@var{expr})} f@"uhrt diese Ersetzung aus, ohne dass 
die Optionsvariable @code{logarc} gesetzt wird.

Beispiele:

@example
(%i1) logarc(asin(x));
                                     2
(%o1)             - %i log(sqrt(1 - x ) + %i x)
(%i2) logarc:true;
(%o2)                         true
(%i3) asin(x);
                                     2
(%o3)             - %i log(sqrt(1 - x ) + %i x)
@end example
@end deffn

@c --- 12.03.2011 DK -----------------------------------------------------------
@need 800
@anchor{logconcoeffp}
@defvr {Optionsvariable} logconcoeffp
Standardwert: @code{false}

Der Optionsvariablen @code{logconcoeffp} kann eine Aussagefunktion mit einem
Argument zugewiesen werden, die kontrolliert, welche Koeffizienten von
der Funktion @mref{logcontract} zusammengezogen werden.  Sollen zum Beispiel
Wurzeln generiert werden, kann folgende Aussagefunktion definiert werden:

@example
logconcoeffp:'logconfun$ 
logconfun(m) := featurep(m,integer) or ratnump(m)$
@end example

Das Kommando @code{logcontract(1/2*log(x))} liefert nun das Ergebnis
@code{log(sqrt(x))}.
@end defvr

@c --- 20.03.2011 DK -----------------------------------------------------------
@anchor{logcontract}
@deffn {Funktion} logcontract (@var{expr})

Der Ausdruck @var{expr} wird rekursiv nach Ausdr@"ucken der Form 
@code{a1*log(b1) + a2*log(b2) + c} durchsucht.  Diese werden zu
@code{log(ratsimp(b1^a1 * b2^a2)) + c} transformiert.

@example
(%i1) 2*(a*log(x) + 2*a*log(y))$
(%i2) logcontract(%);
                                 2  4
(%o2)                     a log(x  y )
@end example

Wird die Variable @var{n} mit dem Kommando @code{declare(n, integer)} als eine
ganze Zahl deklariert, dann wird  @code{logcontract(2*a*n*log(x))} zu
@code{a*log(x^(2*n))} vereinfacht.  Die Koeffizienten, die zusammengezogen 
werden, sind in diesem Fall die Zahl 2 und die Variable @var{n}, welche
die folgende Aussage erf@"ullen @code{featurep(coeff, integer)}.
Der Nutzer kann kontrollieren, welche Koeffizienten zusammengezogen werden.
Dazu wird der Optionsvariablen @mref{logconcoeffp} eine Aussagefunktion mit 
einem Argument zugewiesen.  Sollen zum Beispiel Wurzeln generiert werden, kann 
folgende Definition verwendet: @code{logconcoeffp: 'logconfun$ logconfun(m) :=
featurep(m,integer) or ratnump(m)$}.  Dann hat das Kommando
@code{logcontract(1/2*log(x))} das Ergebnis @code{log(sqrt(x))}.
@end deffn

@c --- 01.11.2011 DK -----------------------------------------------------------
@anchor{logexpand}
@defvr {Optionsvariable} logexpand
Standardwert: @code{true}

Die Optionsvariable @code{logexpand} kontrolliert die Vereinfachung der
Logarithmusfunktion @mrefdot{log}

Hat @code{logexpand} den Wert @code{true}, wird @code{log(a^b)} zu
@code{b*log(a)} vereinfacht.  Hat @code{logexpand} den Wert @code{all}, wird
zus@"atzlich @code{log(a*b)} zu @code{log(a)+log(b)} vereinfacht.  Mit dem Wert
@code{super} vereinfacht Maxima weiterhin @code{log(a/b)} zu
@code{log(a)-log(b)}, wobei @code{a/b} eine rationale Zahl ist.  @code{log(1/b}
wird f@"ur eine ganze Zahl @code{b} immer vereinfacht.  Hat die Optionsvariable
@code{logexpand} den Wert @code{false} werden alle obigen Vereinfachungen
ausgeschaltet.
@end defvr

@c --- 12.03.2011 DK -----------------------------------------------------------
@anchor{lognegint}
@defvr {Optionsvariable} lognegint
Standardwert: @code{false}

Hat die Optionsvariable @code{lognegint} den Wert @code{true}, wird
@code{log(-n)} zu @code{log(n)+%i*%pi} f@"ur positive @code{n} vereinfacht.
@end defvr

@c --- 12.03.2011 DK -----------------------------------------------------------
@need 800
@anchor{logsimp}
@defvr {Optionsvariable} logsimp
Standardwert: @code{true}

Hat die Optionsvariable @code{logsimp} den Wert @code{false}, werden 
Exponentialfunktionen @mrefcomma{exp} die Logarithmusfunktionen im Exponenten
enthalten, nicht vereinfacht.
@end defvr

@c --- 12.03.2011 DK -----------------------------------------------------------
@anchor{plog}
@deffn {Funktion} plog (@var{x})

Gibt den Hauptwert des komplexen nat@"urlichen Logarithmus im Intervall
@code{-%pi} < @code{carg(@var{x})} <= @code{+%pi} zur@"uck.
@end deffn

@c --- 12.03.2011 DK -----------------------------------------------------------
@anchor{rootsconmode}
@defvr {Optionsvariable} rootsconmode
Standardwert: @code{true}

@code{rootsconmode} kontrolliert das Verhalten der Funktion 
@code{rootscontract}.  Siehe die Funktion @mref{rootscontract} f@"ur Details.
@end defvr

@c --- 12.03.2011 DK -----------------------------------------------------------
@anchor{rootscontract}
@deffn {Funktion} rootscontract (@var{expr})

Konvertiert Produkte von Wurzeln in Wurzeln von Produkten.  Zum Beispiel hat 
@code{rootscontract(sqrt(x)*y^(3/2))} das Ergebnis @code{sqrt(x*y^3)}.

Hat die Optionsvariable @mref{radexpand} den Wert @code{true} und die
Optionsvariable @mref{domain} den Wert @code{real}, das sind die Standardwerte,
wird @code{abs(x)} zu @code{sqrt(x^2)} vereinfacht.  Zum Beispiel hat
@code{rootscontract(abs(x) * sqrt(y))} das Ergebnis @code{sqrt(x^2*y)}.

Die Optionsvariable @mref{rootsconmode} kontrolliert das Ergebnis
folgenderma@ss{}en:

@example
Problem             Wert             Ergebnis 
                    rootsconmode     rootscontract
      
x^(1/2)*y^(3/2)     false            sqrt(x*y^3)
x^(1/2)*y^(1/4)     false            sqrt(x)*y^(1/4)
x^(1/2)*y^(1/4)     true             sqrt(x*sqrt(y))
x^(1/2)*y^(1/3)     true             sqrt(x)*y^(1/3)
x^(1/2)*y^(1/4)     all              (x^2*y)^(1/4)
x^(1/2)*y^(1/3)     all              (x^3*y^2)^(1/6)
@end example

Hat @code{rootsconmode} den Wert @code{false}, kontrahiert @code{rootscontract}
nur Faktoren mit rationalen Exponenten, die den gleichen Nenner haben.  Hat
@code{rootsconmode} den Wert @code{all}, wird das kleinste gemeinsame Vielfache
des Nenners der Faktoren verwendet, um die Faktoren zusammenzufassen.

@"Ahnlich wie bei der Funktion @mref{logcontract} werden von
@code{rootscontract} die Argumente unter der Wurzel mit der Funktion 
@mref{ratsimp} vereinfacht.

Beispiele:

@example
(%i1) rootsconmode: false$
(%i2) rootscontract (x^(1/2)*y^(3/2));
                                   3
(%o2)                      sqrt(x y )
(%i3) rootscontract (x^(1/2)*y^(1/4));
                                   1/4
(%o3)                     sqrt(x) y
(%i4) rootsconmode: true$
(%i5) rootscontract (x^(1/2)*y^(1/4));
(%o5)                    sqrt(x sqrt(y))
@group
(%i6) rootscontract (x^(1/2)*y^(1/3));
                                   1/3
(%o6)                     sqrt(x) y
@end group
(%i7) rootsconmode: all$
(%i8) rootscontract (x^(1/2)*y^(1/4));
                              2   1/4
(%o8)                       (x  y)
(%i9) rootscontract (x^(1/2)*y^(1/3));
                             3  2 1/6
(%o9)                      (x  y )
(%i10) rootsconmode: false$
(%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                    *sqrt(sqrt(1 + x) - sqrt(x)));
(%o11)                          1
(%i12) rootsconmode: true$
(%i13) rootscontract (sqrt(5+sqrt(5)) - 5^(1/4)*sqrt(1+sqrt(5)));
(%o13)                          0
@end example
@end deffn

@c --- 12.03.2011 DK -----------------------------------------------------------
@anchor{sqrt}
@deffn {Funktion} sqrt (@var{z})

Ist die Wurzelfunktion.  Die Wurzelfunktion wird von Maxima sofort zu
@code{@var{x}^(1/2)} vereinfacht und tritt in Ausdr@"ucken nicht auf.

Die Wurzelfunktion ist f@"ur das numerische und symbolische Rechnen geeignet.
Ist das Argument @var{z} der Wurzelfunktion eine Gleitkommazahl, wird ein
numerisches Ergebnis zur@"uckgegeben.  F@"ur ganze und rationale Zahlen wird
die Wurzelfunktion vereinfacht.  Die numerische Berechnung kann mit den 
Optionsvariablen und Auswertungsschaltern @mref{numer} und
@mref{float} kontrolliert werden.

Hat die Optionsvariable @mref{radexpand} den Wert @code{true}, werden die
n-ten Wurzeln von Faktoren unter einer Wurzel aus der Wurzel herausgezogen.
So wird zum Beispiel @code{sqrt(16*x^2)} nur dann zu @code{4*x} vereinfacht,
wenn @code{radexpand} den Wert @code{true} hat.

Siehe auch die Funktionen @mref{rootscontract} und @mref{sqrtdenest} f@"ur die
Vereinfachung von Ausdr@"ucken, die die Wurzelfunktion enthalten.

Beispiele:

Verschiedene Beispiele mit der Wurzelfunktion.

@example
(%i1) sqrt(4);
(%o1)                           2
(%i2) sqrt(24);
(%o2)                       2 sqrt(6)
(%i3) sqrt(2.0);
(%o3)                   1.414213562373095
(%i4) taylor(sqrt(1+x),x,0,5);
                       2    3      4      5
                  x   x    x    5 x    7 x
(%o4)/T/      1 + - - -- + -- - ---- + ---- + . . .
                  2   8    16   128    256
(%i5) rectform(sqrt(x+%i*y));
           2    2 1/4     atan2(y, x)
(%o5) %i (y  + x )    sin(-----------)
                               2
                                      2    2 1/4     atan2(y, x)
                                  + (y  + x )    cos(-----------)
                                                          2
(%i6) integrate(sqrt(t)*(t+1)^-2,t,0,1);
                             %pi - 2
(%o6)                        -------
                                4
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Winkelfunktionen, Hyperbelfunktionen, Wurzel- Exponential- und Logarithmusfunktion, Mathematische Funktionen
@section Winkelfunktionen
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Winkelfunktionen::
* Funktionen und Variablen f@"ur Winkelfunktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Winkelfunktionen, Funktionen und Variablen f@"ur Winkelfunktionen, Winkelfunktionen, Winkelfunktionen
@subsection Einf@"uhrung in Winkelfunktionen
@c -----------------------------------------------------------------------------

Maxima kennt viele Winkel- und Hyperbelfunktionen.  Nicht alle Identit@"aten 
f@"ur Winkel- und Hyperbelfunktionen sind programmiert, aber es ist m@"oglich 
weitere Identit@"aten mit der F@"ahigkeit der Erkennung von Mustern 
hinzuzuf@"ugen.

Maxima kennt die folgenden Winkel- und Hyperbelfunktionen sowie deren Inverse:

@verbatim
     sin       cos       tan
     sec       csc       cot
     asin      acos      atan
     asec      acsc      acot
     sinh      cosh      tanh
     sech      csch      coth
     asinh     acosh     atanh
     asech     acsch     acoth
@end verbatim

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Winkelfunktionen, , Einf@"uhrung in Winkelfunktionen, Winkelfunktionen
@subsection Funktionen und Variablen f@"ur Winkelfunktionen
@c -----------------------------------------------------------------------------

@c --- 12.03.2011 DK -----------------------------------------------------------
@anchor{asin}
@anchor{acos}
@anchor{atan}
@anchor{acot}
@anchor{acsc}
@anchor{asec}
@deffn  {Funktion} asin (@var{z})
@deffnx {Funktion} acos (@var{z})
@deffnx {Funktion} atan (@var{z})
@deffnx {Funktion} acot (@var{z})
@deffnx {Funktion} acsc (@var{z})
@deffnx {Funktion} asec (@var{z})

Die inversen Winkelfunktionen: Arkussinus, Arkuskosinus, Arkustangens,
Arkuskotangens, Arkuskosekans und Arkussekans.

Die inversen Winkelfunktionen sind f@"ur das numerische und symbolische Rechnen
geeignet.  Die inversen Winkelfunktionen k@"onnen f@"ur reelle und komplexe
Gleitkommazahlen in doppelter und in beliebiger Genauigkeit berechnet werden.
Ist das Argument eine ganze oder rationale Zahl, werden die inversen
Winkelfunktionen nicht numerisch berechnet, sondern vereinfacht.  Die numerische
Berechnung kann mit den Optionsvariablen und Auswertungsschaltern
@mref{numer} und @mref{float} erzwungen werden.

Die inversen Winkelfunktionen sind bis auf die Funktionen @code{acos} und
@code{asec} als ungerade definiert.  Die Funktionen @code{acos} und @code{asec}
vereinfachen f@"ur ein negatives Argument @code{-x} zu @code{%pi-acos(x)} und
@code{%pi-asec(x)}.  F@"ur die inversen Winkelfunktion @code{asin}, @code{acos}
und @code{atan} ist die Spiegelsymmetrie f@"ur den Fall implementiert, dass das
komplexe Argument @code{x+%i*y} einen Realteil @code{abs(x)<1} hat.

Ist das Argument @var{z} eine Matrix, eine Liste oder eine Gleichung werden die
inversen Winkelfunktionen auf die Elemente der Matrix, der Liste oder auf die
beiden Seiten der Gleichung angewendet.  Dieses Verhalten wird von der
Optionsvariablen @mref{distribute_over} kontrolliert.

Inverse Winkelfunktionen k@"onnen f@"ur das symbolische Rechnen verwendet
werden.  Maxima kann Ausdr@"ucke mit inversen Winkelfunktionen differenzieren
und integrieren, Grenzwerte bestimmen sowie Gleichungen mit inversen
Winkelfunktionen l@"osen.
 
Das Argument der inversen Winkelfunktionen kann eine Taylorreihe sein.  In
diesem Fall wird die Taylorreihenentwicklung f@"ur die inverse Winkelfunktion
vollst@"andig ausgef@"uhrt.

Die folgenden Optionsvariablen kontrollieren die Vereinfachung der
inversen Winkelfunktionen:

@table @code
@item distribute_over
Hat die Optionsvariable @mref{distribute_over} den Wert @code{true} und ist das
Argument der inversen Winkelfunktion eine Matrix, Liste oder Gleichung wird die
Funktion auf die Elemente oder beiden Seiten der Gleichung angewendet.  Der
Standardwert ist @code{true}.

@item %piargs
Hat die Optionsvariable @mref{%piargs} den Wert @code{true}, werden die
inversen Winkelfunktionen f@"ur spezielle Werte als Argument vereinfacht.
Der Standardwert ist @code{true}.

@item %iargs
Hat die Optionsvariable @mref{%iargs} den Wert @code{true} und ist das Argument
der inversen Winkelfunktion ein Vielfaches der imagin@"aren Einheit @code{%i}
werden die inversen Winkelfunktionen zu inversen Hyperbelfunktionen vereinfacht.
Der Standardwert ist @code{true}.

@item triginverses
Hat die Optionsvariable @mref{triginverses} den Wert @code{all} und ist das
Argument die entsprechende Winkelfunktion vereinfachen die inversen
Winkelfunktionen, zum Beispiel vereinfacht @code{asin(sin(x))} zu @code{x}.
Der Standardwert ist @code{true} und die Vereinfachung wird nicht vorgenommen.

@item logarc
Hat die Optionsvariable @mref{logarc} den Wert @code{true}, werden inverse
Winkelfunktionen durch Logarithmusfunktionen ersetzt.  Der Standardwert von
@code{logarc} ist @code{false}.
@end table
@end deffn

@c --- 01.06.2011 DK -----------------------------------------------------------
@anchor{atan2}
@deffn {Funktion} atan2 (@var{y}, @var{x})

Ist der Arkustangens mit zwei Argumenten, der in Maxima wie folgt definiert ist:

@verbatim
     atan(y/x)           x>0
     atan(y/x) + %pi     x<0 und y>=0
     atan(y/x) - %pi     x<0 und y<0
       %pi / 2           x=0 und y>0
     - %pi / 2           x=0 und y<0
     nicht definiert     x=0 und y=0
@end verbatim

Mit der obigen Definition ist der Wertebereich des Arkustangens
@code{-%pi < atan2(y,x) <= %pi}.  Alternativ kann der Arkustangens mit zwei
Argumenten definiert werden als

@verbatim
                              %i y + x
     atan2(y, x) = - %i log(-------------)
                                  2    2
                            sqrt(y  + x )
@end verbatim

Der Arkustangens ist f@"ur das symbolische und numerische Rechnen geeignet.
F@"ur reelle Argumente @var{x} und @var{y} deren Vorzeichen bestimmt werden
kann, vereinfacht Maxima den Arkustangens wie oben in der Definition angegeben.
Sind beide Argumente Gleitkommazahlen wird ein numerisches Ergebnis berechnet.
Die numerische Berechnung f@"ur komplexe Gleitkommazahlen ist nicht
implementiert.  Weiterhin kennt Maxima die speziellen Werte, wenn eines der
Argumente @var{x} oder @var{y} unendlich ist.  @code{atan2(x, x)} und
@code{atan2(x, -x)} werden von Maxima vereinfacht, wenn Maxima das Vorzeichen
von @var{x} ermitteln kann.

Die Vereinfachung des Arkustangens wird weiterhin von den folgenden
Optionsvariablen kontrolliert:

@table @code
@item distribute_over
Hat die Optionsvariable @mref{distribute_over} den Wert @code{true} und ist das
Argument des Arkustangens eine Matrix, Liste oder Gleichung wird die Funktion
auf die Elemente oder beiden Seiten der Gleichung angewendet.  Der Standardwert
ist @code{true}.

@item trigsign
Hat die Optionsvariable @mref{trigsign} den Wert @code{true}, vereinfacht
Maxima @code{atan2(-y, x)} zu @code{- atan2(y, x)}.  Der Standardwert ist
@code{true}.

@item logarc
Hat die Optionsvariable @mref{logarc} den Wert @code{true}, wird der
Arkustangens durch einen Ausdruck mit der Logarithmusfunktionen ersetzt.
Der Standardwert von @code{logarc} ist @code{false}.
@end table

Maxima kann Ausdr@"ucke mit dem Arkustangens ableiten und integrieren sowie die
Grenzwerte von Ausdr@"ucken mit dem Arkustangens ermitteln.

Beispiele:

@example
(%i1) atan2([-1, 1],[-1, 0, 1]);
              3 %pi    %pi    %pi    3 %pi  %pi  %pi
(%o1)     [[- -----, - ---, - ---], [-----, ---, ---]]
                4       2      4       4     2    4
(%i2) atan2(1,[-0.5, 0.5]);
(%o2)         [2.034443935795703, 1.10714871779409]
(%i3) assume(a>0)$

(%i4) atan2(2*a, -2*a);
                              3 %pi
(%o4)                         -----
                                4
(%i5) diff(atan2(y,x), x);
@group
                                 y
(%o5)                       - -------
                               2    2
                              y  + x
@end group
(%i6) integrate(atan2(y,x), x);
                          2    2
                   y log(y  + x )          y
(%o6)              -------------- + x atan(-)
                         2                 x
@end example
@end deffn

@c --- 12.03.2011 DK -----------------------------------------------------------
@anchor{sin}
@anchor{cos}
@anchor{tan}
@anchor{cot}
@anchor{csc}
@anchor{sec}
@deffn  {Funktion} sin (@var{z})
@deffnx {Funktion} cos (@var{z})
@deffnx {Funktion} tan (@var{z})
@deffnx {Funktion} cot (@var{z})
@deffnx {Funktion} csc (@var{z})
@deffnx {Funktion} sec (@var{z})

Die Winkelfunktionen: Sinus, Kosinus, Tangens, Kotangens, Kosekans und Sekans.

Die Winkelfunktionen sind f@"ur das numerische und symbolische Rechnen geeignet.
Die Winkelfunktionen k@"onnen f@"ur reelle und komplexe Gleitkommazahlen in
doppelter und in beliebiger Genauigkeit berechnet werden.  Ist das Argument 
eine ganze oder rationale Zahl, werden die Winkelfunktionen nicht numerisch
berechnet, sondern vereinfacht.  Die numerische Berechnung kann mit den
Optionsvariablen und Auswertungsschaltern @mref{numer} und @mref{float}@w{}
erzwungen werden.

Die Winkelfunktionen sind gerade oder ungerade und haben Spiegelsymmetrie.
Maxima wendet diese Symmetrieeigenschaften automatisch bei der Vereinfachung
von Ausdr@"ucken mit Winkelfunktionen an.

Ist das Argument @var{z} eine Matrix, eine Liste oder eine Gleichung werden die
Winkelfunktionen auf die Elemente der Matrix, der Liste oder auf die beiden
Seiten der Gleichung angewendet.  Dieses Verhalten wird von der Optionsvariablen
@mref{distribute_over} kontrolliert.

Winkelfunktionen k@"onnen f@"ur das symbolische Rechnen verwendet werden.
Maxima kann Ausdr@"ucke mit Winkelfunktionen differenzieren und integrieren,
Grenzwerte bestimmen sowie Gleichungen und  Differentialgleichungen mit
Winkelfunktionen l@"osen.

Das Argument der Winkelfunktionen kann eine Taylorreihe sein.  In diesem Fall
wird die Taylorreihenentwicklung f@"ur die Winkelfunktion vollst@"andig
ausgef@"uhrt.

Die folgenden Optionsvariablen kontrollieren die Vereinfachung der
Winkelfunktionen:

@table @code
@item distribute_over
Hat die Optionsvariable @mref{distribute_over} den Wert @code{true} und ist das
Argument der Winkelfunktion eine Matrix, Liste oder Gleichung wird die Funktion
auf die Elemente oder beiden Seiten der Gleichung angewendet.  Der Standardwert
ist @code{true}.

@item %piargs
Hat die Optionsvariable @mref{%piargs} den Wert @code{true}, werden die
Winkelfunktionen f@"ur ganzzahlige und halbzahlige Vielfache der Konstanten
@code{%pi} zu speziellen Werten vereinfacht.  Der Standardwert ist @code{true}.

@item %iargs
Hat die Optionsvariable @mref{%iargs} den Wert @code{true} und ist das Argument
der Winkelfunktion ein Vielfaches der imagin@"aren Einheit @code{%i} werden die
Winkelfunktionen zu Hyperbelfunktionen vereinfacht.  Der Standardwert ist
@code{true}.

@item trigsign
Hat die Optionsvariable @mref{trigsign} den Wert @code{true}, werden die gerade
oder ungerade Symmetrie der Winkelfunktionen bei der Vereinfachung angewendet.
Der Standardwert ist @code{true}.

@item triginverses
Hat die Optionsvariable @mref{triginverses} den Wert @code{true} und ist das
Argument eine inverse Winkelfunktion vereinfachen die Winkelfunktionen zu einem
einfachen algebraischen Ausdruck, zum Beispiel vereinfacht @code{sin(acos(x))}
zu @code{sqrt(1-x^2)}.  Der Standardwert ist @code{true}.

@item trigexpand
Hat die Optionsvariable @mref{trigexpand} den Wert @code{true}, dann werden die
Winkelfunktionen f@"ur ein Argument expandiert, das eine Summe oder ein Produkt
mit einer ganzen Zahl ist.  Der Standardwert ist @code{false}.

@item exponentialize
Hat die Optionsvariable @mref{exponentialize} den Wert @code{true}, dann werden
die Winkelfunktionen in eine Exponentialform transformiert.  Der Standardwert
ist @code{false}.

@item halfangles
Hat die Optionsvariable @mref{halfangles} den Wert @code{true}, dann werden die
Winkelfunktionen f@"ur halbzahlige Argumente zu einem @"aquivalenten Ausdruck
transformiert.  Der Standardwert ist @code{false}.
@end table

Beispiele:

Im Folgenden werden Beispiele f@"ur die Sinusfunktion gezeigt.  Numerische
Berechnungen f@"ur Gleitkommazahlen:

@example
(%i1) sin(1+%i);
(%o1)                      sin(%i + 1)
(%i2) sin(1.0+%i);
(%o2)       .6349639147847361 %i + 1.298457581415977
(%i3) sin(1.0b0+%i);
(%o3)     6.349639147847361b-1 %i + 1.298457581415977b0
(%i4) sin(1.0b0),fpprec:45;
(%o4)   8.41470984807896506652502321630298999622563061b-1
@end example

Einige Vereinfachungen der Sinusfunktionen:

@example
(%i5) sin(%i*(x+y));
(%o5)                    %i sinh(y + x)
(%i6) sin(%pi/3);
                             sqrt(3)
(%o6)                        -------
                                2
(%i2) sin(x+y),trigexpand:true;
(%o2)             cos(x) sin(y) + sin(x) cos(y)
(%i3) sin(2*x+y),trigexpand:true;
           2         2
(%o3)  (cos (x) - sin (x)) sin(y) + 2 cos(x) sin(x) cos(y)
@end example

Grenzwerte, Ableitungen und Integrale mit der Sinusfunktion:

@example
(%i4) limit(sin(x)/x,x,0);
(%o4)                          1
(%i5) diff(sin(sqrt(x))/x,x);
                  cos(sqrt(x))   sin(sqrt(x))
(%o5)             ------------ - ------------
                        3/2            2
                     2 x              x
(%i6) integrate(sin(x^3),x);
@group
(%o6) 
                         1      3                     1        3
        gamma_incomplete(-, %i x ) + gamma_incomplete(-, - %i x )
                         3                            3
      - ---------------------------------------------------------
                                   12
@end group
@end example

Reihenentwicklung der Sinusfunktion:

@example
(%i7) taylor(sin(x),x,0,3);
@group
                              3
                             x
(%o7)/T/                 x - -- + . . .
                             6
@end group
@end example
@end deffn

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{%piargs}
@defvr {Optionsvariable} %piargs
Standardwert: @code{true}

Hat @code{%piargs} den Wert @code{true}, werden Winkel- und Hyperbelfunktionen 
sowie deren Inverse zu algebraischen Konstanten vereinfacht, wenn das Argument
ein ganzzahliges Vielfaches der folgenden Konstanten ist:
@iftex
@math{\pi}, @math{\pi/2}, @math{\pi/3}, @math{\pi/4} oder @math{\pi/6}.
@end iftex
@ifnottex
@code{%pi}, @code{%pi/2}, @code{%pi/3}, @code{%pi/4} oder @code{%pi/6}.
@end ifnottex

Maxima kennt weiterhin einige Identit@"aten, wenn die Konstante
@iftex 
@math{\pi}
@end iftex
@ifnottex 
@code{%pi}
@end ifnottex
mit einer Variablen multipliziert wird, die als ganzzahlig deklariert wurde.

Beispiele:

@example
(%i1) %piargs : false$
@group
(%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                %pi       %pi
(%o2)            [sin(%pi), sin(---), sin(---)]
                                 2         3
@end group
@group
(%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                      %pi       %pi       %pi
(%o3)            [sin(---), sin(---), sin(---)]
                       4         5         6
@end group
(%i4) %piargs : true$
@group
(%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                sqrt(3)
(%o5)                    [0, 1, -------]
                                   2
@end group
@group
(%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                         1         %pi   1
(%o6)                [-------, sin(---), -]
                      sqrt(2)       5    2
@end group
@group
(%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
       cos (sqrt(2)*%pi/3)];
                1    1               sqrt(2) %pi
(%o7)          [-, - -, sqrt(3), cos(-----------)]
                2    2                    3
@end group
@end example

Weitere Identit@"aten werden angewendet, wenn
@iftex 
@math{\pi} und @math{\pi/2}
@end iftex 
@ifnottex 
@code{%pi} und @code{%pi/2}
@end ifnottex
mit einer ganzzahligen Variable multipliziert werden.

@example
(%i1) declare (n, integer, m, even)$
@group
(%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
       cos (%pi/2 * m)];
                                      m/2
(%o2)                  [0, 1, 0, (- 1)   ]
@end group
@end example
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{%iargs}
@defvr {Optionsvariable} %iargs
Standardwert: @code{true}

Hat @code{%iargs} den Wert @code{true}, werden Winkelfunktionen zu 
Hyperbelfunktionen vereinfacht, wenn das Argument ein Vielfaches der 
imagin@"aren Einheit
@iftex
@math{i}
@end iftex
@ifnottex
@code{%i}
@end ifnottex
ist.

Die Vereinfachung zu Hyperbelfunktionen wird auch dann ausgef@"uhrt, wenn das
Argument offensichtlich reell ist.

Beispiele:

@example
(%i1) %iargs : false$
@group
(%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o2)           [sin(%i x), cos(%i x), tan(%i x)]
@end group
(%i3) %iargs : true$
@group
(%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o4)           [%i sinh(x), cosh(x), %i tanh(x)]
@end group
@end example

Auch wenn das Argument offensichtlich reell ist, wird zu einer Hyperbelfunktion
vereinfacht.

@example
(%i1) declare (x, imaginary)$
@group
(%i2) [featurep (x, imaginary), featurep (x, real)];
(%o2)                     [true, false]
@end group
@group
(%i3) sin (%i * x);
(%o3)                      %i sinh(x)
@end group
@end example
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{halfangles}
@defvr {Optionsvariable} halfangles
Standardwert: @code{false}

Hat @code{halfangles} den Wert @code{true}, werden Winkel- und 
Hyperbelfunktionen mit halbzahligen Argumenten @code{@var{expr}/2} vereinfacht.

F@"ur ein reelles Argument @var{x} im Intervall @code{0 < x < 2*%pi} vereinfacht
der Sinus f@"ur ein halbzahliges Argument zu einer einfachen Formel: 

@example
                         sqrt(1 - cos(x))
                         ----------------
                             sqrt(2)
@end example

Ein komplizierter Faktor wird gebraucht, damit die Formel korrekt ist f@"ur ein
komplexes Argument @var{z}:

@need 1600
@verbatim
           realpart(z)
     floor(-----------)
              2 %pi
(- 1)                   (1 - unit_step(- imagpart(z))

                            realpart(z)            realpart(z)
                      floor(-----------) - ceiling(-----------)
                               2 %pi                  2 %pi
                ((- 1)                                          + 1))
@end verbatim

Maxima kennt diesen Faktor und @"ahnliche Faktoren f@"ur die Sinus, Kosinus,
Sinus Hyperbolicus und Kosinus Hyperbolicus Funktionen.  F@"ur spezielle 
Argumente @math{z} dieser Funktionen vereinfachen diese Funktionen entsprechend.

Beispiele:

@example
(%i1) halfangles:false;
(%o1)                                false
(%i2) sin(x/2);
                                        x
(%o2)                               sin(-)
                                        2
(%i3) halfangles:true;
(%o3)                                true
(%i4) sin(x/2);
                                                    x
                                            floor(-----)
                                                  2 %pi
                      sqrt(1 - cos(x)) (- 1)
(%o4)                 ----------------------------------
                                   sqrt(2)
(%i5) assume(x>0, x<2*%pi)$
(%i6) sin(x/2);
                               sqrt(1 - cos(x))
(%o6)                          ----------------
                                   sqrt(2)
@end example
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{ntrig}
@defvr {Paket} ntrig

Das Paket @code{ntrig} enth@"alt Regeln, um Winkelfunktionen zu vereinfachen, 
die Argumente der Form @code{@var{f}(@var{n} %pi/10)} haben.  @var{f} ist eine 
der Funktionen @code{sin}, @code{cos}, @code{tan}, @code{csc}, @code{sec} oder 
@code{cot}.

Das Kommando @code{load(ntrig)} l@"adt das Paket.  Die Vereinfachungen werden
dann von Maxima automatisch ausgef@"uhrt.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigexpand}
@deffn {Funktion} trigexpand (@var{expr})

Die Funktion @code{trigexpand} expandiert Winkel- und Hyperbelfunktionen im 
Ausdruck @var{expr}, die Summen und Vielfache von Winkeln als Argument haben.
Die besten Ergebnisse werden erzielt, wenn der Ausdruck @var{expr} zun@"achst
expandiert wird.

Folgende Schalter kontrollieren @code{trigexpand}:

@table @code
@item trigexpand
Wenn @code{true}, werden Sinus- und Kosinusfunktionen expandiert.

@item halfangles
Wenn @code{true}, werden Vereinfachungen f@"ur halbzahlige Argumente angewendet.

@item trigexpandplus
Wenn @code{true}, werden Winkelfunktionen, die eine Summe als Argument haben,
wie zum Beispiel @code{sin(x+y)}, vereinfacht.

@item trigexpandtimes
Wenn @code{true},  werden Winkelfunktionen, die ein Produkt als Argument haben,
wie zum Beispiel @code{sin(2 x)}, vereinfacht.
@end table

Beispiele:

@example
@group
(%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                         2           2
(%o1)               - sin (x) + 3 cos (x) + x
@end group
@group
(%i2) trigexpand(sin(10*x+y));
(%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)
@end group
@end example
@end deffn

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigexpandplus}
@defvr {Optionsvariable} trigexpandplus
Standardwert: @code{true}

@code{trigexpandplus} kontrolliert die Vereinfachung von Winkelfunktionen mit
der Funktion @mref{trigexpand} f@"ur den Fall, dass Winkelfunktionen mit Summen
als Argumente auftreten.  Hat @code{trigexpandplus} den Wert @code{true},
werden zum Beispiel Winkelfunktionen wie @code{sin(x+y)} vereinfacht.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigexpandtimes}
@defvr {Optionsvariable} trigexpandtimes
Standardwert: @code{true}

@code{trigexpandtimes} kontrolliert die Vereinfachung von Winkelfunktionen mit
der Funktion @mref{trigexpand} f@"ur den Fall, dass Winkelfunktionen mit
Produkten als Argumente auftreten.  Hat @code{trigexpandtimes} den Wert 
@code{true}, werden zum Beispiel Winkelfunktionen wie @code{sin(2 x)} 
vereinfacht.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{triginverses}
@defvr {Optionsvariable} triginverses
Standardwert: @code{true}

Kontrolliert die Vereinfachung, wenn das Argument einer Winkelfunktion oder
Hyperbelfunktion eine der inversen Funktion ist.

Hat @code{triginverses} den Wert @code{all}, vereinfachen beide Ausdr@"ucke
@code{atan(tan(@var{x}))} und @code{tan(atan(@var{x}))} zum Wert @var{x}.

Hat @code{triginverses} den Wert @code{all}, wird
@code{@var{arcfun}(@var{fun}(@var{x}))} nicht vereinfacht.

Hat @code{triginverses} den Wert @code{false}, werden
@code{@var{arcfun}(@var{fun}(@var{x}))} und 
@code{@var{fun}(@var{arcfun}(@var{x}))} nicht vereinfacht.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigreduce}
@deffn  {Funktion} trigreduce (@var{expr}, @var{x})
@deffnx {Funktion} trigreduce (@var{expr})

Produkte und Potenzen von Winkelfunktionen und den Hyperbelfunktionen mit dem
Argument @var{x} werden zu Funktionen vereinfacht, die Vielfache von @var{x}
enthalten.  @code{trigreduce} versucht auch, Sinus- und Kosinusfunktionen in
einem Nenner zu eliminieren.  Wird keine Variable @var{x} angegeben, werden alle
Variablen im Ausdruck @code{expr} betrachtet.

Siehe auch @mrefdot{poissimp}

@example
@group
(%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
               cos(2 x)      cos(2 x)   1        1
(%o1)          -------- + 3 (-------- + -) + x - -
                  2             2       2        2
@end group
@end example
@end deffn

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigsign}
@defvr {Optionsvariable} trigsign
Standardwert: @code{true}

Hat @code{trigsign} den Wert @code{true}, werden Winkelfunktionen mit einem
negativem Argument vereinfacht.  Zum Beispiel vereinfacht in diesem Fall
@code{sin(-x)} zu @code{-sin(x)}.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigsimp}
@deffn {Funktion} trigsimp (@var{expr})

Wendet die Identit@"aten
@iftex
@tex
$\sin\left(x\right)^2 + \cos\left(x\right)^2 = 1$
@end tex
@end iftex
@ifnottex
@code{sin(x)^2 + cos(x)^2 = 1}
@end ifnottex
und
@iftex
@tex
$\cosh\left(x\right)^2 - \sinh\left(x\right)^2 = 1$
@end tex
@end iftex
@ifnottex
@code{cosh(x)^2 - sinh(x)^2 = 1}
@end ifnottex
an, um Ausdr@"ucke, die Funktionen wie @code{tan}, @code{sec}, usw. enthalten, 
zu Ausdr@"ucken mit den Funktionen @code{sin}, @code{cos}, @code{sinh}, 
@code{cosh} zu vereinfachen.

Die Anwendung von Funktionen wie @mrefcomma{trigreduce} @mref{ratsimp} und
@mref{radcan} kann den Ausdruck weiter vereinfachen.

Das Kommando @code{demo(trgsmp)} zeigt einige Beispiele.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{trigrat}
@deffn {Funktion} trigrat (@var{expr})

Gives a canonical simplifyed quasilinear form of a trigonometrical expression; 
@var{expr} is a rational fraction of several @code{sin}, @code{cos} or 
@code{tan}, the arguments of them are linear forms in some variables (or 
kernels) and @code{%pi/@var{n}} (@var{n} integer) with integer coefficients.
The result is a simplified fraction with numerator and denominator linear in 
@code{sin} and @code{cos}.  Thus @code{trigrat} linearize always when it is 
possible.

@example
@group
(%i1) trigrat(sin(3*a)/sin(a+%pi/3));
(%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1
@end group
@end example

The following example is taken from
Davenport, Siret, and Tournier, @i{Calcul Formel}, Masson (or in English,
Addison-Wesley), section 1.5.5, Morley theorem.

@example
(%i1) c : %pi/3 - a - b$
(%i2) bc : sin(a)*sin(3*c)/sin(a+b);
@group
                                          %pi
                  sin(a) sin(3 (- b - a + ---))
                                           3
(%o2)             -----------------------------
                           sin(b + a)
@end group
(%i3) ba : bc, c=a, a=c;
@group
                                         %pi
                    sin(3 a) sin(b + a - ---)
                                          3
(%o3)               -------------------------
                                  %pi
                          sin(a - ---)
                                   3
@end group
(%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
@group
         2         2         %pi
      sin (3 a) sin (b + a - ---)
                              3
(%o4) ---------------------------
                2     %pi
             sin (a - ---)
                       3
                                       %pi
 - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                        3
             %pi            %pi
 sin(b + a - ---))/(sin(a - ---) sin(b + a))
              3              3
      2       2              %pi
   sin (a) sin (3 (- b - a + ---))
                              3
 + -------------------------------
                2
             sin (b + a)
@end group
(%i5) trigrat (ac2);
@group
(%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
 - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
 - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
 + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
 + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
 + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
 - 9)/4
@end group
@end example
@end deffn

@c -----------------------------------------------------------------------------
@need 900
@node Hyperbelfunktionen, Zufallszahlen, Winkelfunktionen, Mathematische Funktionen
@section Hyperbelfunktionen
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Hyperbelfunktionen::
* Funktionen und Variablen f@"ur Hyperbelfunktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Hyperbelfunktionen, Funktionen und Variablen f@"ur Hyperbelfunktionen, Hyperbelfunktionen, Hyperbelfunktionen
@subsection Einf@"uhrung in Hyperbelfunktionen
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Hyperbelfunktionen, , Einf@"uhrung in Hyperbelfunktionen, Hyperbelfunktionen
@subsection Funktionen und Variablen f@"ur Hyperbelfunktionen

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{asinh}
@anchor{acosh}
@anchor{atanh}
@anchor{acoth}
@anchor{acsch}
@anchor{asech}
@deffn  {Funktion} asinh (@var{x})
@deffnx {Funktion} acosh (@var{x})
@deffnx {Funktion} atanh (@var{x})
@deffnx {Funktion} acoth (@var{x})
@deffnx {Funktion} acsch (@var{x})
@deffnx {Funktion} asech (@var{x})

Die inversen Hyperbelfunktionen: Areasinus Hyperbolicus, Areakosinus
Hyperbolicus, Areatangens Hyperbolicus, Areakotangens Hyperbolicus, Areakosekans
Hyperbolicus, Areasekans Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{sinh}
@anchor{cosh}
@anchor{tanh}
@anchor{coth}
@anchor{csch}
@anchor{sech}
@deffn  {Funktion} sinh (@var{x})
@deffnx {Funktion} cosh (@var{x})
@deffnx {Funktion} tanh (@var{x})
@deffnx {Funktion} coth (@var{x})
@deffnx {Funktion} csch (@var{x})
@deffnx {Funktion} sech (@var{x})

Die Hyperbelfunktionen: Sinus Hyperbolicus, Kosinus Hyperbolicus, Tangens
Hyperbolicus, Kotangens Hyperbolicus, Kosekans Hyperbolicus, Sekans
Hyperbolicus.
@end deffn

@c -----------------------------------------------------------------------------
@node Zufallszahlen, , Hyperbelfunktionen, Mathematische Funktionen
@section Zufallszahlen
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{make_random_state}
@deffn  {Funktion} make_random_state (@var{n})
@deffnx {Funktion} make_random_state (@var{s})
@deffnx {Funktion} make_random_state (true)
@deffnx {Funktion} make_random_state (false)

Ein Zufallszustand repr@"asentiert den Zustand des Zufallszahlengenerators.  Der
Zustand enth@"alt 627 32-Bit Worte.

@code{make_random_state(@var{n})} gibt einen neuen Zufallszustand zur@"uck, der 
aus einer ganzen Zahl @var{n} modulo 2^32 erzeugt wird.  @var{n} kann eine 
negative Zahl sein.

@code{make_random_state(@var{s})} gibt eine Kopie des Zufallszutandes @var{s}
zur@"uck.

@code{make_random_state(true)} gibt einen neuen Zufallszustand zur@"uck, der aus
der aktuellen Systemzeit des Computers erzeugt wird.

@code{make_random_state(false)} gibt eine Kopie des aktuellen Zustands des
Zufallszahlengenerators zur@"uck.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{set_random_state}
@deffn {Funktion} set_random_state (@var{s})

Kopiert @var{s} in den Zufallszustand des Zufallszahlengenerators.

@code{set_random_state} gibt immer @code{done} zur@"uck.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{random}
@deffn {Funktion} random (@var{x})

Erzeugt eine Pseudo-Zufallszahl.  Ist @var{x} eine ganze Zahl, gibt 
@code{random(@var{x})} eine ganze Zahl im Intervall 0 bis einschlie@ss{}lich
@code{@var{x}-1} zur@"uck.  Ist @var{x} eine Gleitkommazahl, gibt
@code{random(@var{x})} eine positive Gleitkommazahl zur@"uck, die kleiner als
@var{x} ist.  @code{random} gibt eine Fehlermeldung, wenn @var{x} weder eine
ganze Zahl noch eine Gleitkommazahl ist oder wenn @var{x} eine negative Zahl 
ist.

Die Funktionen @code{make_random_state} und @code{set_random_state} verwalten
den Zustand des Zufallszahlengenerators.

Der Maxima-Zufallszahlengenerator ist eine Implementation des Mersenne twister
MT 19937.

Beispiele:

@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example
@end deffn

@c --- End of file MathFunctions.de.texi ---------------------------------------

