@c -----------------------------------------------------------------------------
@c File        : Matrices.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Matrices.texi revision 03.07.2011
@c Translation : Dr. Dieter Kaiser
@c Date        : 10.12.2010
@c Revision    : 10.07.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in die lineare Algebra::
* Funktionen und Variablen der linearen Algebra::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in die lineare Algebra, Funktionen und Variablen der linearen Algebra, Lineare Algebra, Lineare Algebra
@section Einf@"uhrung in die lineare Algebra
@c -----------------------------------------------------------------------------

@menu
* Nicht-kommutative Multiplikation::
* Vektoren::
* Eigenwerte::
@end menu

@c -----------------------------------------------------------------------------
@anchor{dot}
@node Nicht-kommutative Multiplikation, Vektoren, Einf@"uhrung in die lineare Algebra, Einf@"uhrung in die lineare Algebra
@subsection Nicht-kommutative Multiplikation
@c -----------------------------------------------------------------------------

@c The operator @code{.} represents noncommutative multiplication and scalar 
@c product. When the operands are 1-column or 1-row matrices @code{a} and 
@c @code{b}, the expression @code{a.b} is equivalent to 
@c @code{sum (a[i]*b[i], i, 1, length(a))}. If @code{a} and @code{b} are not
@c complex, this is the scalar product, also called the inner product or dot
@c product, of @code{a} and @code{b}. The scalar product is defined as 
@c @code{conjugate(a).b} when @code{a} and @code{b} are complex; 
@c @code{innerproduct} in the @code{eigen} package provides the complex scalar
@c product.

Der Operator @code{.} repr@"asentiert die nichtkommutative Multiplikation oder
das Skalarprodukt. Sind die Argumente 1-spaltige oder 1-reihige Matrizen
@code{a} und @code{b}, dann ist der Ausdruck @code{a . b} @"aquivalent zu
@code{sum(a[i]*b[i], i, 1, length(a))}. Sind @code{a} und @code{b} nicht
komplex, dann ist der vorhergende Ausdruck das Skalarprodukt von @code{a} und
@code{b}. Das Skalarprodukt ist als @code{conjugate(a) . b} definiert, wenn
@code{a} und @code{b} komplex sind. Die Funktion @mref{innerproduct} im Paket
@code{eigen} stellt das komplexe Skalarprodukt zur Verf@"ugung.

@c When the operands are more general matrices, the product is the matrix 
@c product @code{a} and @code{b}. The number of rows of @code{b} must equal the
@c number of columns of @code{a}, and the result has number of rows equal to the
@c number of rows of @code{a} and number of columns equal to the number of 
@c columns of @code{b}.

Sind die Argumente @code{a} und @code{b} allgemeine Matrizen, dann ist das
Ergebnis der nichtkommutativen Multiplikation das Matrizprodukt der Argumente. 
Die Anzahl der Zeilen der Matrix @code{b} muss gleich der Anzahl der Spalten der
Matrix @code{a} sein. Das Ergebnis ist eine Matrix, deren Anzahl der Zeilen der 
der Matrix @code{a} entspricht und deren Anzahl der Spalten der der Matrix 
@code{b} entspricht.

@c To distinguish @code{.} as an arithmetic operator from  the decimal point in 
@c a floating point number, it may be necessary to leave spaces on either side.
@c For example, @code{5.e3} is @code{5000.0} but @code{5 . e3} is @code{5} times
@c @code{e3}.

Um den nichtkommutativen Operator @code{.} vom Dezimalpunkt einer Gleitkommazahl
zu unterscheiden, kann es notwendig sein, dem Operator ein Leerzeichen 
voranzustellen und folgen zu lassen. Zum Beispiel ist @code{5.e3} die 
Gleitkommazahl @code{5000.0} und @code{5 .  e3} ist @code{5} multipliziert mit
der Variablen @code{e3}.

@c There are several flags which govern the simplification of expressions 
@c involving @code{.}, namely @code{dot}, @code{dot0nscsimp}, @code{dot0simp}, 
@c @code{dot1simp}, @code{dotassoc}, @code{dotconstrules}, @code{dotdistrib}, 
@c @code{dotexptsimp}, @code{dotident}, and @code{dotscrules}.

Verschiedene Schalter kontrollieren die Vereinfachung der nichtkommutativen
Multiplikation. Zu diesen geh@"oren:

@verbatim
   dot            dot0nscsimp     dot0simp
   dot1simp       dotassoc        dotconstrules
   dotdistrib     dotexptsimp     dotident
   dotscrules
@end verbatim

@c -----------------------------------------------------------------------------
@node Vektoren, Eigenwerte, Nicht-kommutative Multiplikation, Einf@"uhrung in die lineare Algebra
@subsection Vektoren
@c -----------------------------------------------------------------------------

@c @code{vect} is a package of functions for vector analysis.
@c @code{load ("vect")} loads this package, and @code{demo ("vect")} displays a 
@c demonstration.
@c find maxima -name \*orth\* YIELDS NOTHING; 
@c ARE THESE FUNCTIONS IN ANOTHER FILE NOW ??
@c and SHARE;VECT ORTH contains definitions of various orthogonal curvilinear 
@c coordinate systems.

@code{vect} ist ein Paket mit Funktionen der Vektoranalysis.  Mit dem Kommando
@code{load(vect)} wird das Paket geladen.  Das Kommando @code{demo(vect)} zeigt
Beispiele.

@c The vector analysis package can combine and simplify symbolic expressions 
@c including dot products and cross products, together with the gradient, 
@c divergence, curl, and Laplacian operators.  The distribution of these 
@c operators over sums or products is governed by several flags, as are various 
@c other expansions, including expansion into components in any specific 
@c orthogonal coordinate systems. There are also functions for deriving the 
@c scalar or vector potential of a field.

Das Paket enth@"alt Funktionen, um Ausdr@"ucke mit nicht-kommutativen 
Multiplikationen und Kreuzprodukten sowie Gradienten, Divergenzen, Rotationen
und Laplace-Operatoren zu vereinfachen.  Die Vereinfachung dieser Operatoren
wird von verschiedenen Schaltern kontrolliert.  Weiterhin k@"onnen die
Ergebnisse in verschiedenen Koordinatensystemen berechnet werden.  Mit weiteren 
Funktionen kann das Skalarpotential oder das Vektorpotential eines Feldes
bestimmt werden.

@c The @code{vect} package contains these functions: @code{vectorsimp}, 
@c @code{scalefactors}, @code{express}, @code{potential}, and 
@c @code{vectorpotential}.
@c REVIEW vect.usg TO ENSURE THAT TEXINFO HAS WHATEVER IS THERE
@c PRINTFILE(VECT,USAGE,SHARE); for details.

Das Paket @code{vect} enth@"alt die folgenden Funktionen:
@code{vectorsimp},
@code{scalefactors},
@code{express},
@code{potential} und
@code{vectorpotential}.

@c Warning: the @code{vect} package declares the dot operator @code{.}
@c to be a commutative operator.

@c -----------------------------------------------------------------------------
@node Eigenwerte, , Vektoren, Einf@"uhrung in die lineare Algebra
@subsection Eigenwerte
@c -----------------------------------------------------------------------------

@c The package @code{eigen} contains several functions devoted to the symbolic 
@c computation of eigenvalues and eigenvectors. Maxima loads the package 
@c automatically if one of the functions @code{eigenvalues} or 
@c @code{eigenvectors} is invoked. The package may be loaded explicitly as 
@c @code{load ("eigen")}.

Das Paket @code{eigen} enth@"alt verschiedene Funktionen, um symbolisch 
Eigenwerte und Eigenvektoren zu bestimmen.  Maxima l@"adt dieses Paket 
automatisch, wenn eine der Funktionen dieses Pakets genutzt wird.  Das Paket 
kann auch mit dem Kommando @code{load(eigen)} geladen werden.

@c @code{demo ("eigen")} displays a demonstration of the capabilities of this 
@c package. @code{batch ("eigen")} executes the same demonstration, but without 
@c the user prompt between successive computations.

Das Kommando @code{demo(eigen)} zeigt Beispiele f@"ur das Paket.  Die Beispiele
k@"onnen auch mit dem Kommando @code{batch(eigen} angezeigt werden.  In diesem
Fall wartet Maxima zwischen den einzelnen Beispielen auf die Eingabe des
Nutzers.

@c The functions in the @code{eigen} package are @code{innerproduct}, 
@c @code{unitvector}, @code{columnvector}, @code{gramschmidt}, 
@c @code{eigenvalues}, @code{eigenvectors}, @code{uniteigenvectors},
@c and @code{similaritytransform}.

Das Paket @code{eigen} enth@"alt die folgenden Funktionen:

@verbatim
   innerproduct       unitvector            columnvector
   gramschmidt        eigenvalues           eigenvectors
   uniteigenvectors   similaritytransform
@end verbatim

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen der linearen Algebra,  , Einf@"uhrung in die lineare Algebra, Lineare Algebra
@section Funktionen und Variablen der linearen Algebra
@c -----------------------------------------------------------------------------

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{addcol}
@deffn {Funktion} addcol (@var{M}, @var{list_1}, @dots{}, @var{list_n})

@c Appends the column(s) given by the one or more lists (or matrices) onto the
@c matrix @var{M}.

H@"angt eine oder mehrere Spalten, die als Listen @var{list_1}, @dots{}, 
@var{list_n} @"ubergeben werden, an die Matrix @var{M} an.

Beispiel:

@example
(%i1) M:matrix([a,b],[c,d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) addcol(M,[1,2],[x,y]);
                         [ a  b  1  x ]
(%o2)                    [            ]
                         [ c  d  2  y ]
@end example
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{addrow}
@deffn {Funktion} addrow (@var{M}, @var{list_1}, @dots{}, @var{list_n})

@c Appends the row(s) given by the one or more lists (or matrices) onto the 
@c matrix @var{M}.

H@"angt eine oder mehrere Zeilen, die als Listen @var{list_1}, @dots{},
@var{list_n} @"ubergeben werden, an die Matrix @var{M} an.

Beispiel:

@example
(%i1) M:matrix([a,b],[c,d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) addrow(M,[1,2],[x,y]);
                            [ a  b ]
                            [      ]
                            [ c  d ]
(%o2)                       [      ]
                            [ 1  2 ]
                            [      ]
                            [ x  y ]
@end example
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{adjoint}
@deffn {Funktion} adjoint (@var{M})

@c Returns the adjoint of the matrix @var{M}. The adjoint matrix is the 
@c transpose of the matrix of cofactors of @var{M}.

Gibt die adjungierte der Matrix @var{M} zur@"uck.
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{augcoefmatrix}
@deffn {Funktion} augcoefmatrix ([@var{eqn_1}, @dots{}, @var{eqn_m}], [@var{x_1}, @dots{}, @var{x_n}])

@c Returns the augmented coefficient matrix for the variables @var{x_1}, ..., 
@c @var{x_n} of the system of linear equations @var{eqn_1}, ..., @var{eqn_m}.
@c This is the coefficient matrix with a column adjoined for the constant terms 
@c in each equation (i.e., those terms not dependent upon @var{x_1}, ..., 
@c @var{x_n}).

Gibt die erweiterte Koeffizientenmatrix f@"ur die Variablen @var{x_1}, @dots{}, 
@var{x_n} und dem linearen Gleichungssystem @var{eqn_1}, @dots{}, @var{eqn_m}.
Die erweiterte Koeffizientenmatrix entsteht, wenn an die Koeffizientenmatrix 
des Gleichungssystems die Spalte mit der rechten Seite des Gleichungssystems
angef@"ugt wird.

Beispiel:

@example
(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
@end example
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{charpoly}
@deffn {Funktion} charpoly (@var{M}, @var{x})

@c Returns the characteristic polynomial for the matrix @var{M} with respect to
@c variable @var{x}. That is, 
@c @code{determinant (@var{M} - diagmatrix (length (@var{M}), @var{x}))}.

Gibt das charakteristische Polynom der Matrix @var{M} f@"ur die Variable @var{x}
zur@"uck.  Das charakterische Polynom wird als
@code{determinant(@var{M} - diagmatrix(length (@var{M}), @var{x}))} berechnet.

Beispiel:

@example
(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
@end example
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{coefmatrix}
@deffn {Funktion} coefmatrix ([@var{eqn_1}, @dots{}, @var{eqn_m}], [@var{x_1}, @dots{}, @var{x_n}])

@c Returns the coefficient matrix for the variables @var{x_1}, ..., @var{x_n} 
@c of the system of linear equations @var{eqn_1}, ..., @var{eqn_m}.

Gibt die Koeffizientenmatrix f@"ur die Variablen @var{x_1}, @dots{}, @var{x_n}
des linearen Gleichungssystem @var{eqn_1}, @dots{}, @var{eqn_m} zur@"uck.

Beispiel:

@example
(%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
@group
                                 [ 2  1 - a ]
(%o1)                            [          ]
                                 [ a    b   ]
@end group
@end example
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{col}
@deffn {Funktion} col (@var{M}, @var{i})

@c Returns the @var{i}'th column of the matrix @var{M}. The return value is a
@c matrix.
@c EXAMPLE HERE

Gibt die @var{i}-te Spalte der Matrix @var{M} zur@"uck.  Das Ergebnis ist eine
Matrix.

Beispiel:

@example
(%i1) M:matrix([1,2,3],[a,b,c]);
                           [ 1  2  3 ]
(%o1)                      [         ]
                           [ a  b  c ]
(%i2) col(M,2);
                              [ 2 ]
(%o2)                         [   ]
                              [ b ]
@end example
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{columnvector}
@deffn  {Funktion} columnvector (@var{L})
@deffnx {Funktion} covect (@var{L})

@c Returns a matrix of one column and @code{length(@var{L})} rows, containing 
@c the elements of the list @var{L}.

Gibt eine Matrix mit einer Spalte zur@"uck, die die Elemente der Liste @var{L}
enth@"alt.

@c @code{covect} is a synonym for @code{columnvector}.
@c @code{load ("eigen")} loads this function.

@code{covect} ist ein Alias-Name f@"ur die Funktion @code{columnvector}.  Das 
Kommando @code{load(eigen)} l@"adt die Funktion.

@c FOLLOWING COMMENT PRESERVED. WHAT DOES THIS MEAN ??
@c This is useful if you want to use parts of the outputs of
@c the functions in this package in matrix calculations.

Beispiel:

@c HMM, SPURIOUS "redefining the Macsyma function".
@c LEAVE IT HERE SINCE THAT'S WHAT A USER ACTUALLY SEES.

@example
(%i1) load(eigen)$

(%i2) columnvector ([aa, bb, cc]);
                             [ aa ]
                             [    ]
(%o2)                        [ bb ]
                             [    ]
                             [ cc ]
@end example
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{copymatrix}
@deffn {Funktion} copymatrix (@var{M})

@c Returns a copy of the matrix @var{M}.  This is the only way to make a copy 
@c aside from copying @var{M} element by element.

Gibt eine Kopie der Matrix @var{M} zur@"uck.

@c Note that an assignment of one matrix to another, as in @code{m2: m1}, does 
@c not copy @code{m1}. An assignment @code{m2 [i,j]: x} or 
@c @code{setelmx (x, i, j, m2} also modifies @code{m1 [i,j]}. Creating a copy 
@c with @code{copymatrix} and then using assignment creates a separate, 
@c modified copy.

Die Zuweisung wie zum Beispiel @code{m2: m1} kopiert die Matrix @code{m1} nicht.
Wird nach dieser Zuweisung die Matrix @code{m2} ge@"andert, wird auch die Matrix
@code{m1} ge@"andert.  Um eine Kopie zu erhalten, muss @code{m2: copymatrix(m1)}
ausgef@"uhrt werden.
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{determinat}
@deffn {Funktion} determinant (@var{M})

@c Computes the determinant of @var{M} by a method similar to Gaussian 
@c elimination.

Berechnet die Determinate der Matrix @var{M}.  Die angewendete Methode ist
vergleichbar mit dem Gau@ss{}-Verfahren.

@c JUST HOW DOES ratmx AFFECT THE RESULT ?? IS A SPARSE DETERMINANT SOMETHING 
@c OTHER THAN THE DETERMINANT OF A SPARSE MATRIX ??

@c The form of the result depends upon the setting of the switch @code{ratmx}.
@c There is a special routine for computing sparse determinants which is called
@c  when the switches @code{ratmx} and @code{sparse} are both @code{true}.

@code{determinat} wird von den Schaltern @code{ratmx} und @code{sparse}
kontrolliert.  Haben beide Schalter den Wert @code{true}, wird ein spezieller
Algorithmus f@"ur schwachbesetzte Matrizen aufgerufen.
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{detout}
@defvr {Optionsvariable} detout
Standardwert: @code{false}

@c When @code{detout} is @code{true}, the determinant of a matrix whose inverse 
@c is computed is factored out of the inverse.

Hat @code{detout} den Wert @code{true}, wird die Determinate einer Matrix, f@"ur
die die inverse Matrix berechnet wird, aus der Matrix herausmultipliziert.

@c For this switch to have an effect @code{doallmxops} and @code{doscmxops} 
@c should be @code{false} (see their descriptions).  Alternatively this switch 
@c can be given to @code{ev} which causes the other two to be set correctly.

Damit dieser Schalter einen Effekt hat, m@"ussen die Optionsvariablen 
@code{doallmxops} und @code{doscmxops} den Wert @code{false} haben.

Beispiele:

@example
(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
@end example

@c THERE'S MORE TO THIS STORY detout: false$ invert (m); RETURNS THE SAME THING.
@c IT APPEARS THAT doallmxops IS CRUCIAL HERE.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{diagmatrix}
@deffn {Funktion} diagmatrix (@var{n}, @var{x})

@c Returns a diagonal matrix of size @var{n} by @var{n} with the diagonal 
@c elements all equal to @var{x}. @code{diagmatrix (@var{n}, 1)} returns an 
@c identity matrix (same as @code{ident (@var{n})}).

Gibt eine @var{n}-dimensionale Diagonalmatrix zur@"uck, deren Diagonalelemente
alle den Wert @var{x} haben.

@c @var{n} must evaluate to an integer, otherwise @code{diagmatrix} complains 
@c with an error message.

@var{n} muss zu einer ganzen Zahl auswerten.  Ansonsten meldet Maxima einen
Fehler.

@c @var{x} can be any kind of expression, including another matrix. If @var{x} 
@c is a matrix, it is not copied; all diagonal elements refer to the same 
@c instance, @var{x}.

@var{x} kann ein beliebiger Ausdruck einschlie@ss{}lich einer Matrix sein.  Ist
@var{x} eine Matrix, dann wird diese nicht kopiert.
@end deffn

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{doallmxops}
@defvr {Optionsvariable} doallmxops
Standardwert: @code{true}

@c When @code{doallmxops} is @code{true},
@c UMM, WHAT DOES THIS MEAN EXACTLY ??
@c all operations relating to matrices are carried out. When it is @code{false}
@c then the setting of the individual @code{dot} switches govern which 
@c operations are performed.

Hat @code{doallmxops} den Wert @code{true}, werden Matrixoperationen 
ausgef@"uhrt.  Ist der Wert @code{false}, werden nur die Matrixoperationen 
ausgef@"uhrt, die mit den einzelnen @code{dot}-Schaltern eingeschaltet sind.
@end defvr

@c --- 08.12.2010 DK -----------------------------------------------------------
@anchor{domexpt}
@defvr {Optionsvariable} domxexpt
Standardwert: @code{true}

@c When @code{domxexpt} is @code{true}, a matrix exponential, 
@c @code{exp (@var{M})} where @var{M} is a matrix, is interpreted as a matrix 
@c with element @code{[i,j} equal to @code{exp (m[i,j])}. Otherwise 
@c @code{exp (@var{M})} evaluates to @code{exp (@var{ev(M)}}.

Hat @code{domxexpt} den Wert @code{true}, wird die Exponentiation
@code{exp(@var{M})}, wobei @var{M} eine Matrix ist, elementweise f@"ur jedes
einzelne Matrixelement ausgef@"uhrt, so dass f@"ur jedes Element der Matrix 
gilt @code{exp (m[i,j])}.  Ansonsten wird die Exponentiation als
@code{exp (@var{ev(M)}} ausgewertet.

@c @code{domxexpt} affects all expressions of the form 
@c @code{@var{base}^@var{power}} where @var{base} is an expression assumed 
@c scalar or constant, and @var{power} is a list or matrix.

@code{domxexpt} beeinflu@ss{}t alle Ausdr@"ucke der Form @code{@var{a}^@var{b}},
wobei @var{a} eine Konstante oder ein skalarer Ausdruck und @var{b} eine
Liste oder Matrix ist.

Beispiele:

@example
(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
@end example
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{domxmxops}
@defvr {Optionsvariable} domxmxops
Standardwert: @code{true}

@c When @code{domxmxops} is @code{true}, all matrix-matrix or matrix-list
@c operations are carried out (but not scalar-matrix operations); if this 
@c switch is @code{false} such operations are not carried out.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

Hat @code{domxmxops} den Wert @code{true}, werden allen Matrix-Matrix und 
Matrix-Listen-Operationen ausgef@"uhrt.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{domxnctimes}
@defvr {Optionsvariable} domxnctimes
Standardwert: @code{false}

@c When @code{domxnctimes} is @code{true}, non-commutative products of matrices 
@c are carried out.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

Hat @code{domxnctimes} den Wert @code{true}, werden nichtkommutative Produkte
von Matrizen ausgef@"uhrt.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{doscmxops}
@defvr {Optionsvariable} doscmxops
Standardwert: @code{false}

@c When @code{doscmxops} is @code{true}, scalar-matrix operations are carried 
@c out.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

Hat @code{doscmxops} den Wert @code{true}, werden Skalar-Matrix-Operationen
ausgef@"uhrt.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{doscmxplus}
@defvr {Optionsvariable} doscmxplus
Standardwert: @code{false}

@c When @code{doscmxplus} is @code{true}, scalar-matrix operations yield a 
@c matrix result.  This switch is not subsumed under @code{doallmxops}.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

Hat @code{doscmxplus} den Wert @code{true}, haben Skalar-Matrix-Operationen
eine Matrix als Ergebnis.  Dieser Schalter ist nicht unter @code{doallmxops}
subsumiert.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dot0nscsimp}
@defvr {Optionsvariable} dot0nscsimp
Standardwert: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
@c When @code{dot0nscsimp} is @code{true}, a non-commutative product of zero
@c and a nonscalar term is simplified to a commutative product.

Hat @code{dot0nscsimp} den Wert @code{true}, werden nichtkommutative Produkte
mit einer Null und einem nichtskalaren Term zu einem kommutativen Produkt
vereinfacht.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dot0simp}
@defvr {Optionsvariable} dot0simp
Standardwert: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
@c When @code{dot0simp} is @code{true}, a non-commutative product of zero and
@c a scalar term is simplified to a commutative product.

Hat @code{dot0simp} den Wert @code{true}, werden nichtkommutative Produkte mit
einer Null und einem skalaren Term zu einem kommutatitiven Produkt vereinfacht.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dot1simp}
@defvr {Optionsvariable} dot1simp
Standardwert: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
@c When @code{dot1simp} is @code{true}, a non-commutative product of one and
@c another term is simplified to a commutative product.

Hat @code{dot1simp} den Wert @code{true}, werden nichtkommutative Produkte mit
einer Eins und einem anderen Term zu einem kommutativen Produkt vereinfacht.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dotassoc}
@defvr {Optionsvariable} dotassoc
Standardwert: @code{true}

@c When @code{dotassoc} is @code{true}, an expression @code{(A.B).C} simplifies 
@c to @code{A.(B.C)}.
@c "." MEANS NONCOMMUTATIVE MULTIPLICATION RIGHT ??

Hat @code{dotassoc} den Wert @code{true}, vereinfacht Maxima ein Ausdruck
@code{(A.B).C} zu @code{A.(B.C)}.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dotconstrules}
@defvr {Optionsvariable} dotconstrules
Standardwert: @code{true}

@c When @code{dotconstrules} is @code{true}, a non-commutative product of a
@c constant and another term is simplified to a commutative product.
@c TERMINOLOGY: (1) SWITCH/FLAG/SOME OTHER TERM ?? (2) ASSIGN/SET/TURN ON/SOME
@c OTHER TERM ??
@c Turning on this flag effectively turns on @code{dot0simp}, 
@c @code{dot0nscsimp}, and @code{dot1simp} as well.

Hat @code{dotconstrules} den Wert @code{true}, werden nichtkommutative Produkte
einer Konstanten und eines Termes zu einem kommutativen Produkt vereinfacht.
Die folgenden Optionsvariablen @code{dot0simp}, @code{dot0nscsimp} und 
@code{dot1simp} erhalten den Wert @code{true}, wenn @code{construles} 
eingeschaltet wird.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dotdistrib}
@defvr {Optionsvariable} dotdistrib
Standardwert: @code{false}

@c When @code{dotdistrib} is @code{true}, an expression @code{A.(B + C)} 
@c simplifies to @code{A.B + A.C}.

Hat @code{dotdistrib} den Wert @code{true}, vereinfacht Maxima einen Ausdruck
@code{A.(B + C)} zu @code{A.B + A.C}.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dotexptsimp}
@defvr {Optionsvariable} dotexptsimp
Standardwert: @code{true}

@c When @code{dotexptsimp} is @code{true}, an expression @code{A.A} simplifies 
@c to @code{A^^2}.

Hat @code{dotexptsimp} den Wert @code{true}, vereinfacht Maxima einen Ausdruck 
@code{A.A} zu @code{A^^2}.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dotident}
@defvr {Optionsvariable} dotident
Standardwert: 1

@c @code{dotident} is the value returned by @code{X^^0}.
@c "RETURNED" ?? IS THIS A SIMPLIFICATION OR AN EVALUATION ??

@code{dotident} ist der Wert der f@"ur den Ausdruck @code{X^^0} zur@"uckgegeben 
wird.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dotscrules}
@defvr {Optionsvariable} dotscrules
Standardwert: @code{false}

@c When @code{dotscrules} is @code{true}, an expression @code{A.SC} or 
@c @code{SC.A} simplifies to @code{SC*A} and @code{A.(SC*B)} simplifies to 
@c @code{SC*(A.B)}.
@c HMM, DOES "SC" MEAN "SCALAR" HERE ?? CLARIFY

Hat @code{dotscrules} den Wert @code{true}, vereinfacht Maxima Ausdr@"ucke 
@code{A.SC} oder @code{SC.A} zu @code{SC*A} und @code{A.(SC*B)} zu 
@code{SC*(A.B)}.

@c NEED EXAMPLE HERE
@end defvr

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{echelon}
@deffn {Funktion} echelon (@var{M})

@c Returns the echelon form of the matrix @var{M}, as produced by Gaussian 
@c elimination. The echelon form is computed from @var{M} by elementary row 
@c operations such that the first non-zero element in each row in the resulting 
@c matrix is one and the column elements under the first one in each row are 
@c all zero.

Gibt die Matrix @var{m} in ihrer Stufenform zur@"uck, wie sie im Gau@ss{}schen
Eliminationsverfahren auftritt.

@c @code{triangularize} also carries out Gaussian elimination,
@c but it does not normalize the leading non-zero element in each row.

Im Unterschied zur Funktion @code{triangularize} wird die Matrix so normiert,
dass die Hauptdiagonalelemente den Wert 1 haben.

@c @code{lu_factor} and @code{cholesky} are other functions which yield
@c triangularized matrices.

@code{lu_factor} und @code{cholesky} sind weitere Funktionen, um 
Dreiecksmatrizen zu erhalten.

Beispiel:

@example
(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) echelon (M);
@group
                  [ 1  - 8  - 5      - 2     ]
                  [                          ]
                  [         28       11      ]
                  [ 0   1   --       --      ]
(%o2)             [         37       37      ]
                  [                          ]
                  [              37 bb - 119 ]
                  [ 0   0    1   ----------- ]
                  [              37 aa - 313 ]
@end group
@end example
@end deffn

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{eigenvalues}
@deffn  {Funktion} eigenvalues (@var{M})
@deffnx {Funktion} eivals (@var{M})

@c eigen.mac IS AUTOLOADED IF eigenvalues OR eigenvectors IS REFERENCED; 
@c EXTEND THAT TO ALL FUNCTIONS ??
@c EACH FUNCTION INTENDED FOR EXTERNAL USE SHOULD HAVE ITS OWN DOCUMENTATION 
@c ITEM

@c Returns a list of two lists containing the eigenvalues of the matrix @var{M}.
@c The first sublist of the return value is the list of eigenvalues of the
@c matrix, and the second sublist is the list of the
@c multiplicities of the eigenvalues in the corresponding order.

Gibt eine Liste mit den Eigenwerten der Matrix @var{M} und deren
Multiplizit@"aten zur@"uck.  Die erste Teilliste enth@"alt die Eigenwerte, die
zweite deren Multiplizit@"aten.

@c @code{eivals} is a synonym for @code{eigenvalues}.

@code{eivals} ist ein Alias-Name der Funktion @code{eigenvalues}.

@c @code{eigenvalues} calls the function @code{solve} to find the roots of the
@c characteristic polynomial of the matrix. Sometimes @code{solve} may not be 
@c able to find the roots of the polynomial; in that case some other functions 
@c in this package (except @code{innerproduct}, @code{unitvector}, 
@c @code{columnvector} and @code{gramschmidt}) will not work.
@c WHICH ONES ARE THE FUNCTIONS WHICH DON'T WORK ??
@c ACTUALLY IT'S MORE IMPORTANT TO LIST THE ONES WHICH DON'T WORK HERE
@c WHAT DOES "will not work" MEAN, ANYWAY ??

@code{eigenvalues} ruft die Funktion @code{solve} auf, um die Nullstellen des
charakeristischen Polynoms der Matrix zu finden.  Wenn @code{solve} keine
Nullstellen finden kann, funktionieren einige Funktionen des Pakets nicht.
Dies trifft nicht auf die Funktionen @code{innerproduct}, @code{unitvector}, 
@code{columnvector} und @code{gramschmidt} zu.

@c In some cases the eigenvalues found by @code{solve} may be complicated
@c expressions. (This may happen when @code{solve} returns a not-so-obviously 
@c real expression for an eigenvalue which is known to be real.) It may be 
@c possible to simplify the eigenvalues using some other functions.
@c WHAT ARE THOSE OTHER FUNCTIONS ??

Die Eigenwerte, die @code{solve} findet, k@"onnen sehr komplizierte Ausdr@"ucke 
sein.  Es kann m@"oglich sein, solche Ausdr@"ucke weiter zu vereinfachen.

@c The package @code{eigen.mac} is loaded automatically when @code{eigenvalues} 
@c or @code{eigenvectors} is referenced. If @code{eigen.mac} is not already 
@c loaded, @code{load ("eigen")} loads it. After loading, all functions and
@c variables in the package are available.
@c REFER TO OVERVIEW OF PACKAGE (INCLUDING LIST OF FUNCTIONS) HERE

Das Paket @code{eigen} wird automatisch geladen, wenn eine der Funktionen
@code{eigenvalues} oder @code{eigenvectors} aufgerufen wird.

@c NEED EXAMPLES HERE
@end deffn

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{eigenvectors}
@deffn  {Funktion} eigenvectors (@var{M})
@deffnx {Funktion} eivects (@var{M})

@c Computes eigenvectors of the matrix @var{M}. The return value is a list of 
@c two elements. The first is a list of the eigenvalues of @var{M} and a list 
@c of the multiplicities of the eigenvalues. The second is a list of lists of 
@c eigenvectors. There is one list of eigenvectors for each eigenvalue. There 
@c may be one or more eigenvectors in each list.

Berechnet die Eigenvektoren der Matrix @var{M}.  Die R@"uckgabe ist eine Liste, 
die zwei weitere Listen enth@"alt.  Die erste Liste enth@"alt die Eigenwerte der
Matrix @var{m} und deren Multiplizit@"aten.  Die zweite Liste enth@"alt die
Eigenvektoren.

@c @code{eivects} is a synonym for @code{eigenvectors}.

@code{eivects} ist ein Alias-Name der Funktion @code{eigenvectors}.

@c The package @code{eigen.mac} is loaded automatically when @code{eigenvalues} 
@c or @code{eigenvectors} is referenced. If @code{eigen.mac} is not already 
@c loaded, @code{load ("eigen")} loads it. After loading, all functions and
@c variables in the package are available.

Das Paket @code{eigen} wird automatisch geladen, wenn die Funktionen
@code{eigenvalues} oder @code{eigenvectors} aufgerufen werden.

@c The flags that affect this function are:

Folgende Schalter kontrollieren @code{eigenvectors}:

@table @code

@c @code{nondiagonalizable} is set to @code{true} or @code{false} depending 
@c on whether the matrix is nondiagonalizable or diagonalizable after
@c @code{eigenvectors} returns.

@item nondiagonalizable
@code{nondiagonalizabel} hat den Wert @code{true} oder @code{false} nach
R@"uckkehr der Funktion @code{eigenvectros} abh@"angig davon, ob die Matrix 
diagonalisierbar ist oder nicht.

@c @code{hermitianmatrix} when @code{true}, causes the degenerate
@c eigenvectors of the Hermitian matrix to be orthogonalized using the
@c Gram-Schmidt algorithm.

@item hermitianmatrix
Hat @code{hermitianmatrix} den Wert @code{true}, werden die entarteten
Eigenvektoren einer Hermitischen Matrix mit dem Gram-Schmidt-Verfahren 
orthogonalisiert.

@c @code{knowneigvals} when @code{true} causes the @code{eigen} package to 
@c assume the eigenvalues of the matrix are known to the user and stored under 
@c the global name @code{listeigvals}.  @code{listeigvals} should be set to a 
@c list similar to the output @code{eigenvalues}.

@item knowneigvals
Hat @code{knowneigvals} den Wert @code{true}, werden die Eigenwerte der Matrix 
von den Funktionen des Paketes @code{eigen} als bekannt angenommen.  Die
Eigenwerte sind in diesem Fall in der Liste @code{listeigvals} abgespeichert.
Die Liste @code{listeigvals} muss dieselbe Form haben, wie die R@"uckgabe der
Funktion @code{eigenvalues}.

@end table

@c The function @code{algsys} is used here to solve for the eigenvectors. 
@c Sometimes if the eigenvalues are messy, @code{algsys} may not be able to find
@c a solution. In some cases, it may be possible to simplify the eigenvalues by
@c first finding them using @code{eigenvalues} command and then using other
@c functions to reduce them to something simpler. Following simplification, 
@c @code{eigenvectors} can be called again with the @code{knowneigvals} flag set
@c to @code{true}.

Die Eigenvektoren werden von der Funktion @code{algsys} berechnet.  Es ist 
m@"oglich, dass @code{algsys} die Eigenvektoren nicht findet.  In diesem Fall 
k@"onnen m@"oglicherweise zun@"achst die Eigenwerte bestimmt und weiter 
vereinfacht werden.  Dannach kann die Funktion @code{eigenvectors} mit dem 
Schalter @code{knowneigvals} aufgerufen werden.

@c See also @code{eigenvalues}.

Siehe auch @mrefdot{eigenvalues}

Beispiele:

@c A matrix which has just one eigenvector per eigenvalue.

Eine Matrix, die einen Eigenvektor zu jedem Eigenwert hat.

@example
(%i1) M1 : matrix ([11, -1], [1, 7]);
                           [ 11  - 1 ]
(%o1)                      [         ]
                           [ 1    7  ]
(%i2) [vals, vecs] : eigenvectors (M1);
(%o2) [[[9 - sqrt(3), sqrt(3) + 9], [1, 1]], 
                        [[[1, sqrt(3) + 2]], [[1, 2 - sqrt(3)]]]]
(%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
  mult[i] = vals[2][i], vec[i] = vecs[i]);
                       val  = 9 - sqrt(3)
                          1

                            mult  = 1
                                1

                    vec  = [[1, sqrt(3) + 2]]
                       1

                       val  = sqrt(3) + 9
                          2

                            mult  = 1
                                2

                    vec  = [[1, 2 - sqrt(3)]]
                       2

(%o3)                         done
@end example

@c A matrix which has two eigenvectors for one eigenvalue (namely 2).

Eine Matrix, die zwei Eigenvektoren zu jedem Eigenwert hat.

@example
(%i1) M1 : matrix([0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0], 
                  [0, 0, 0, 2]);
@group
                         [ 0  1  0  0 ]
                         [            ]
                         [ 0  0  0  0 ]
(%o1)                    [            ]
                         [ 0  0  2  0 ]
                         [            ]
                         [ 0  0  0  2 ]
@end group
(%i2) [vals, vecs] : eigenvectors (M1);
(%o2) [[[0, 2], [2, 2]], [[[1, 0, 0, 0]],
                                   [[0, 0, 1, 0], [0, 0, 0, 1]]]]
(%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
  mult[i] = vals[2][i], vec[i] = vecs[i]);
                            val  = 0
                               1

                            mult  = 2
                                1

                      vec  = [[1, 0, 0, 0]]
                         1

                            val  = 2
                               2

                            mult  = 2
                                2

               vec  = [[0, 0, 1, 0], [0, 0, 0, 1]]
                  2

(%o3)                         done
@end example
@end deffn

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{ematrix}
@deffn {Funktion} ematrix (@var{m}, @var{n}, @var{x}, @var{i}, @var{j})

@c Returns an @var{m} by @var{n} matrix, all elements of which are zero except 
@c for the @code{[@var{i}, @var{j}]} element which is @var{x}.
@c WOW, THAT SEEMS PRETTY SPECIALIZED ...

Gibt eine @var{m} @code{x} @var{n}-Matrix zur@"uck, deren Elemente den Wert 0 
haben, bis auf das Element @code{[@var{i}, @var{j}]}, das den Wert @var{x} hat.
@end deffn

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{entermatrix}
@deffn {Funktion} entermatrix (@var{m}, @var{n})

@c Returns an @var{m} by @var{n} matrix, reading the elements interactively.

Gibt eine @var{m} @code{x} @var{n}-Matrix zur@"uck, die von der Konsole 
eingelesen wird.

@c If @var{n} is equal to @var{m}, Maxima prompts for the type of the matrix 
@c (diagonal, symmetric, antisymmetric, or general) and for each element.
@c Each response is terminated by a semicolon @code{;} or dollar sign @code{$}.

Ist @var{n} gleich @var{m}, fragt Maxima nach dem Typ der Matrix.  Folgende
Typen k@"onnen angegeben werden: diagonal, symmetric, antisymmetric oder 
allgemein.  Dannach werden die einzelnen Elemente der Matrix abgefragt.

@c If @var{n} is not equal to @var{m}, Maxima prompts for each element.

Sind @var{n} und @var{m} voneinander verschieden, fragt Maxima nach jedem 
Element der Matrix.

@c The elements may be any expressions, which are evaluated. @code{entermatrix}
@c evaluates its arguments.

Die Elemente k@"onnen beliebige Ausdr@"ucke sein, die ausgewertet werden.
@code{entermatrix} wertet die Argumente aus.

Beispiel:

@example
(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric 
4. General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matrix entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
@end example
@end deffn

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{express}
@deffn {Funktion} express (@var{expr})

@c HERE IS THE PREVIOUS TEXT. WHAT IS THE POINT ABOUT depends ?? 
@c I'M NOT GETTING IT
@c The result uses the noun form of any
@c derivatives arising from expansion of the vector differential
@c operators.  To force evaluation of these derivatives, the built-in @code{ev}
@c function can be used together with the @code{diff} evflag, after using the
@c built-in @code{depends} function to establish any new implicit dependencies.

@c Expands differential operator nouns into expressions in terms of partial 
@c derivatives. @code{express} recognizes the operators @code{grad}, @code{div}, 
@c @code{curl}, @code{laplacian}. @code{express} also expands the cross product 
@c @code{~}.

Expandiert Differentialoperatoren in einem Ausdruck in partielle Ableitungen.
@code{express} erkennt die Operatoren @code{grad}, @code{div}, @code{curl}, 
@code{laplacian} und das Kreuzprodukt @code{~}.

@c Symbolic derivatives (that is, @code{diff} nouns) in the return value of 
@c express may be evaluated by including @code{diff} in the @code{ev} function 
@c call or command line. In this context, @code{diff} acts as an @code{evfun}.

Enth@"alt die R@"uckgabe Substantivformen von Ableitungen, k@"onnen diese mit 
der Funktion @code{ev} und den Auswertungsschaltern @code{nouns} oder 
@code{diff} ausgewertet werden.

@c @code{load ("vect")} loads this function.
@c IN POINT OF FACT, express IS A SIMPLIFICATION RULE, AND express1 IS THE FCN 
@c WHICH DOES ALL THE WORK

Mit dem Kommando @code{load(vect)} wird die Funktion geladen.

Beispiele:

@example
(%i1) load ("vect")$
(%i2) grad (x^2 + y^2 + z^2);
                              2    2    2
(%o2)                  grad (z  + y  + x )
(%i3) express (%);
       d    2    2    2   d    2    2    2   d    2    2    2
(%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
       dx                 dy                 dz
(%i4) ev (%, diff);
(%o4)                    [2 x, 2 y, 2 z]
(%i5) div ([x^2, y^2, z^2]);
                              2   2   2
(%o5)                   div [x , y , z ]
(%i6) express (%);
                   d    2    d    2    d    2
(%o6)              -- (z ) + -- (y ) + -- (x )
                   dz        dy        dx
(%i7) ev (%, diff);
(%o7)                    2 z + 2 y + 2 x
(%i8) curl ([x^2, y^2, z^2]);
                               2   2   2
(%o8)                   curl [x , y , z ]
(%i9) express (%);
       d    2    d    2   d    2    d    2   d    2    d    2
(%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
       dy        dz       dz        dx       dx        dy
(%i10) ev (%, diff);
(%o10)                      [0, 0, 0]
(%i11) laplacian (x^2 * y^2 * z^2);
                                  2  2  2
(%o11)                laplacian (x  y  z )
(%i12) express (%);
         2                2                2
        d     2  2  2    d     2  2  2    d     2  2  2
(%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
          2                2                2
        dz               dy               dx
(%i13) ev (%, diff);
                      2  2      2  2      2  2
(%o13)             2 y  z  + 2 x  z  + 2 x  y
(%i14) [a, b, c] ~ [x, y, z];
(%o14)                [a, b, c] ~ [x, y, z]
(%i15) express (%);
(%o15)          [b z - c y, c x - a z, a y - b x]
@end example
@end deffn

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{genmatrix}
@deffn  {Funktion} genmatrix (@var{a}, @var{i_2}, @var{j_2}, @var{i_1}, @var{j_1})
@deffnx {Funktion} genmatrix (@var{a}, @var{i_2}, @var{j_2}, @var{i_1})
@deffnx {Funktion} genmatrix (@var{a}, @var{i_2}, @var{j_2})

@c Returns a matrix generated from @var{a}, taking element 
@c @code{@var{a}[@var{i_1},@var{j_1}]} as the upper-left element and 
@c @code{@var{a}[@var{i_2},@var{j_2}]} as the lower-right element of the matrix.
@c Here @var{a} is a declared array (created by @code{array} but not by 
@c @code{make_array}) or an undeclared array, or an array function, or a lambda 
@c expression of two arguments. (An array function is created like other 
@c functions with @code{:=} or @code{define}, but arguments are enclosed in 
@c square brackets instead of parentheses.)

Generiert eine Matrix aus einem Array @var{a}.  Das erste Element der Matrix
ist der Wert @code{@var{a}[@var{i_1},@var{j_1}]} und das letzte Element der
Matrix ist @code{@var{a}[@var{i_2},@var{j_2}]}.  @var{a} muss ein deklariertes
Array sein, dass mit der Funktion @code{array} definiert wurde.  Weiterhin kann
@var{a} ein undeklariertes Array, eine Array-Funktion oder ein lambda-Ausdruck
mit zwei Argumenten sein.

@c If @var{j_1} is omitted, it is assumed equal to @var{i_1}. If both @var{j_1} 
@c and @var{i_1} are omitted, both are assumed equal to 1.

Wird @var{j_1} nicht angegeben, nimmt Maxima an, das der Wert gleich @var{i_1} 
ist.  Werden beide Argumente @var{j_1} und @var{i_1} nicht angegeben, werden
die Werte zu 1 angenommen.

@c If a selected element @code{i,j} of the array is undefined, the matrix will
@c contain a symbolic element @code{@var{a}[i,j]}.

Ist eines der Elemente @code{[i,j]} des Arrays nicht definiert, enth@"alt die
Matrix den symbolischen Wert @code{@var{a}[i,j]}.

Beispiele:

@example
(%i1) h [i, j] := 1 / (i + j - 1);
@group
                                    1
(%o1)                  h     := ---------
                        i, j    i + j - 1
@end group
(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2);
(%o3)                           a
(%i4) a [1, 1] : %e;
(%o4)                          %e
(%i5) a [2, 2] : %pi;
(%o5)                          %pi
(%i6) genmatrix (a, 2, 2);
                           [ %e   0  ]
(%o6)                      [         ]
                           [ 0   %pi ]
(%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                         [  0    1   2 ]
                         [             ]
(%o7)                    [ - 1   0   1 ]
                         [             ]
                         [ - 2  - 1  0 ]
(%i8) genmatrix (B, 2, 2);
                        [ B      B     ]
                        [  1, 1   1, 2 ]
(%o8)                   [              ]
                        [ B      B     ]
                        [  2, 1   2, 2 ]
@end example
@end deffn

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{gramschmidt}
@deffn  {Funktion} gramschmidt (@var{x})
@deffnx {Funktion} gramschmidt (@var{x}, @var{F})

@c Carries out the Gram-Schmidt orthogonalization algorithm on @var{x}, which 
@c is either a matrix or a list of lists. @var{x} is not modified by
@c @code{gramschmidt}. The inner product employed by @code{gramschmidt} is 
@c @var{F}, if present, otherwise the inner product is the function 
@c @code{innerproduct}.

Wendet das Gram-Schmidtsche Orthogonalisierungsverfahren auf das Argument
@var{x} an.  @var{x} ist eine Matrix oder eine Liste mit Listen f@"ur die 
Spalten.  Das Argument @var{x} wird von @code{gramschmidt} nicht ver@"andert.
@var{F} bezeichnet eine Funktion, die als Skalarprodukt f@"ur das Verfahren 
verwendet wird.  Wird @var{F} nicht angegeben, wird die Funktion 
@code{innerproduct} f@"ur das Skalarprodukt angewendet.

@c If @var{x} is a matrix, the algorithm is applied to the rows of @var{x}.
@c If @var{x} is a list of lists, the algorithm is applied to the sublists,
@c which must have equal numbers of elements. In either case, the return value 
@c is a list of lists, the sublists of which are orthogonal and span the same 
@c space as @var{x}. If the dimension of the span of @var{x} is less than the
@c number of rows or sublists, some sublists of the return value are zero.

Ist @var{x} eine Matrix, wird der Algorithmus auf die Zeilen der Matrix
angewendet.  Ist @var{x} eine Liste mit Listen, wird der Algorithmus auf die
Teillisten angewendet, die jeweils die gleiche Anzahl an Elementen haben
m@"ussen.

@c @code{factor} is called at each stage of the algorithm to simplify 
@c intermediate results. As a consequence, the return value may contain factored
@c integers.

Jede Stufe des Verfahrens ruft die Funktion @code{factor} auf, um die 
Zwischenergebnisse zu vereinfachen.  Dadurch kann das Ergebnis faktorisierte
ganze Zahlen enthalten.

@c @code{load(eigen)} loads this function.

Das Kommando @code{load(eigen)} l@"adt die Funktion.

Beispiele:

@c Gram-Schmidt algorithm using default inner product function.

Das Gram-Schmidtsche Orthogonalisierungsverfahren mit @code{innerproduct} 
als Skalarprodukt.

@example
(%i1) load (eigen)$
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) map (innerproduct, [y[1], y[2], y[3]], [y[2], y[3], y[1]]);
(%o4)                       [0, 0, 0]
@end example

@c Gram-Schmidt algorithm using a specified inner product function.

Das Gram-Schmidtsche Orthogonalisierungsverfahren mit einer selbstdefinierten
Funktion f@"ur das Skalarprodukt.

@example
(%i1) load (eigen)$
(%i2) ip (f, g) := integrate (f * g, u, a, b);
(%o2)          ip(f, g) := integrate(f g, u, a, b)
(%i3) y : gramschmidt([1, sin(u), cos(u)], ip), a=-%pi/2, b=%pi/2;
                               %pi cos(u) - 2
(%o3)              [1, sin(u), --------------]
                                    %pi
(%i4) map(ip,[y[1],y[2],y[3]],[y[2],y[3],y[1]]), a=-%pi/2, b=%pi/2;
(%o4)                       [0, 0, 0]
@end example
@end deffn

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{ident}
@deffn {Funktion} ident (@var{n})

@c Returns an @var{n} by @var{n} identity matrix.

Gibt eine @var{n} @code{x} @var{n}-Einheitsmatrix zur@"uck.
@end deffn

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{innerproduct}
@deffn  {Funktion} innerproduct (@var{x}, @var{y})
@deffnx {Funktion} inprod (@var{x}, @var{y})

@c Returns the inner product (also called the scalar product or dot product) of 
@c @var{x} and @var{y}, which are lists of equal length, or both 1-column or 
@c 1-row matrices of equal length. The return value is @code{conjugate (x) . y},
@c where @code{.} is the noncommutative multiplication operator.

Gibt das Skalarprodukt der Argumente @var{x} und @var{y} zur@"uck.  Die Argument
k@"onnen Listen oder 1-spaltige oder 1-reihige Matrizen sein.  Das Skalarprodukt
wird als @code{conjugate(x) . y} berechnet, wobei @code{.} der Operator der
nicht-kommutativen Multiplikation ist.

@c @code{load ("eigen")} loads this function.

Das Kommando @code{load(eigen)} l@"adt die Funktion.

@c @code{inprod} is a synonym for @code{innerproduct}.

@code{inprod} ist ein Alias-Name der Funktion @code{innerproduct}.

@c NEED EXAMPLE HERE
@end deffn

@c THIS DESCRIPTION NEEDS WORK

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{invert}
@deffn {Funktion} invert (@var{M})

@c Returns the inverse of the matrix @var{M}. The inverse is computed by the
@c adjoint method.

Gibt die inverse Matrix der Matrix @var{M} zur@"uck.  Die inverse Matrix wird
mittels der Adjunkten Matrix berechnet.

@c This allows a user to compute the inverse of a matrix with bfloat entries or
@c polynomials with floating pt. coefficients without converting to cre-form.

Mit dieser Methode kann die inverse Matrix auch f@"ur gro@ss{}e Gleitkommazahlen
sowie Polynomme als Matrixelemente berechnet werden.

@c Cofactors are computed by the @code{determinant} function, so if @code{ratmx}
@c is @code{false} the inverse is computed without changing the representation 
@c of the elements.

Die Kofaktoren werden mit der Funktion @code{determinant} berechnet.  Hat die
Optionsvariable @code{ratmx} den Wert @code{true}, wird die inverse Matrix
daher ohne einen Wechsel der Darstellung berechnet.

@c The current implementation is inefficient for matrices of high order.

Die implementierte Methode ist jedoch ineffizient f@"ur gro@ss{}e Matrizen.

@c When @code{detout} is @code{true}, the determinant is factored out of the
@c inverse.

Hat die Optionsvariable @code{detout} den Wert @code{true}, wird die 
Determinante als Faktor aus der Matrix herausgezogen.

@c The elements of the inverse are not automatically expanded. If @var{M} has 
@c polynomial elements, better appearing output can be generated by 
@c @code{expand (invert (m)), detout}. If it is desirable to then divide through
@c by the determinant this can be accomplished by @code{xthru (%)} or 
@c alternatively from scratch by

Die Elemente der inversen Matrix werden nicht automatisch expandiert.  Hat
@var{M} Polynome als Elemente, hat das Ergebnis m@"oglicherweise mit dem
Kommando @code{expand(invert(m)), detout} eine einfachere Form.  Mit der Funktion
@code{multthru} die Determinate in die Matrix hereinmultipliziert werden.  Die
inverse Matrix kann auch folgenderma@ss{}en berechnet werden:

@example
expand (adjoint (m)) / expand (determinant (m))
invert (m) := adjoint (m) / determinant (m)
@end example

@c See @code{^^} (noncommutative exponent) for another method of inverting a 
@c matrix.

Siehe auch den Operator @code{^^} der nicht-kommutativen Exponentiation f@"ur 
eine andere Methode zur Berechnung der inversen Matrix.

@c NEED EXAMPLE HERE
@end deffn

@c --- 28.08.2010 DK -----------------------------------------------------------
@defvr {Optionsvariable} lmxchar
Standardwert: @code{[}

@c @code{lmxchar} is the character displayed as the left delimiter of a matrix.
@c See also @code{rmxchar}.

@code{lmxchar} ist das Zeichen, das f@"ur die linke Seite einer Matrix 
ausgegeben wird.  Siehe auch @code{rmxchar}.

Beispiel:

@example
(%i1) lmxchar: "|"$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
@end example
@end defvr

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{matrix}
@deffn {Funktion} matrix (@var{row_1}, @dots{}, @var{row_n})

@c Returns a rectangular matrix which has the rows @var{row_1}, ..., 
@c @var{row_n}. Each row is a list of expressions. All rows must be the same 
@c length.

Gibt eine Matrix mit den Spalten @var{row_1}, @dots{}, @var{row_n} zur@"uck.
Jede Spalte ist eine Liste mit Asudr@"ucken.  Alle Spalten m@"ussen die gleiche
L@"ange haben.

@c The operations @code{+} (addition), @code{-} (subtraction), @code{*} 
@c (multiplication), and @code{/} (division), are carried out element by element
@c when the operands are two matrices, a scalar and a matrix, or a matrix and a
@c scalar. The operation @code{^} (exponentiation, equivalently @code{**})
@c is carried out element by element if the operands are a scalar and a matrix 
@c or a matrix and a scalar, but not if the operands are two matrices.
@c WHAT DOES THIS NEXT PHRASE MEAN EXACTLY ??
@c All operations are normally carried out in full, including @code{.} 
@c (noncommutative multiplication).

Die Addition @code{+}, Subtraktion @code{-}, Multiplikation @code{*} und 
Division @code{/} werden elementweise ausgef@"uhrt, wenn die Argumente zwei 
Matrizen, ein Skalar und eine Matrix oder eine Matrix und ein Skalar sind.
Die Exponentiation @code{^} wird elementweise ausgef@"uhrt, wenn die Argumente
ein Skalar und eine Matrix oder umgekehrt sind.

@c Matrix multiplication is represented by the noncommutative multiplication
@c operator @code{.}. The corresponding noncommutative exponentiation operator 
@c is @code{^^}. For a matrix @code{@var{A}}, @code{@var{A}.@var{A} =@var{A}^^2}
@c and @code{@var{A}^^-1} is the inverse of @var{A}, if it exists.

Die nichtkommutatie Multiplikation von Matrizen wird mit dem Operator @code{.}
ausgef@"uhrt.  Der entsprechende Operator f@"ur die nichtkommutative 
Exponentiation ist @code{^^}. F@"ur eine Matrix @code{@var{A}} ist 
@code{@var{A} . @var{A} = @var{A}^^2}. @code{@var{A}^^-1} ist die inverse 
Matrix, falls diese existiert.

@c There are switches for controlling simplification of expressions involving 
@c dot and matrix-list operations. These are
@c @code{doallmxops}, @code{domxexpt}, @code{domxmxops}, @code{doscmxops}, and 
@c @code{doscmxplus}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Folgende Schalter kontrollieren die Vereinfachung von Ausdr@"ucken, welche die
nichtkommutative Multiplikation und Matrizen enthalten:

@code{doallmxops},
@code{domxexpt},
@code{domxmxops}, 
@code{doscmxops} und 
@code{doscmxplus}.

@c There are additional options which are related to matrices. These are:
@c @code{lmxchar}, @code{rmxchar}, @code{ratmx}, @code{listarith}, 
@c @code{detout}, @code{scalarmatrix}, and @code{sparse}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Weitere Optionsvariablen f@"ur Matrizen sind:

@code{lmxchar}, 
@code{rmxchar}, 
@code{ratmx}, 
@code{listarith}, 
@code{detout},
@code{scalarmatrix} und
@code{sparse}.

@c There are a number of functions which take matrices as arguments or yield
@c matrices as return values. @c See @code{eigenvalues}, @code{eigenvectors},
@c @code{determinant},@code{charpoly}, @code{genmatrix}, @code{addcol}, 
@c @code{addrow}, @code{copymatrix}, @code{transpose}, @code{echelon},
@c and @code{rank}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Folgende Funktionen akzeptieren Matrizen als ein Argument oder haben eine 
Matrix als R@"uckgabewert: 

@code{eigenvalues}, 
@code{eigenvectors},
@code{determinant},
@code{charpoly}, 
@code{genmatrix}, 
@code{addcol}, 
@code{addrow}, 
@code{copymatrix}, 
@code{transpose}, 
@code{echelon} and
@code{rank}.

Beispiele:

@c Construction of matrices from lists.

Konstruiere eine Matrix mit Listen.

@example
(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
@end example

@c Addition, element by element.

Elementweise Addition zweier Matrizen.

@example
(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
@end example

@c Subtraction, element by element.

Elementweise Subtraktion zweier Matrizen.

@example
(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
@end example

@c Multiplication, element by element.

Elementweise Multiplikation zweier Matrizen.

@example
(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
@end example

@c Division, element by element.

Elementweise Division zweier Matrizen.

@example
(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
@end example

@c Matrix to a scalar exponent, element by element.

Elementweise Exponentiation einer Matrix mit einem Skalar.

@example
(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
@end example

@c Scalar base to a matrix exponent, element by element.

Elementweise Exponentiation eines Skalars mit einer Matrix.

@example
(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
@end example

@c Matrix base to a matrix exponent. This is not carried out element by element.
@c WHAT IS THIS ??

Die Exponentiation zweier Matrizen wird nicht elementweise ausgef@"uhrt.

@example
(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
@end example

@c Noncommutative matrix multiplication.

Nichtkommutative Multiplikation zweier Matrizen.

@example
(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
@end example

@c Noncommutative matrix exponentiation. A scalar base @var{b} to a matrix power
@c @var{M} is carried out element by element and so @code{b^^m} is the same as 
@c @code{b^m}.

Nichtkommutative Exponentiation einer Matrix.  Ist die Basis ein Skalar wird die
Exponentiation elementweise ausgef@"uhrt.  Daher haben die Operationen @code{^^}
und @code{^} f@"ur diesen Fall dasselbe Ergebnis.

@example
(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
@end example

@c A matrix raised to a -1 exponent with noncommutative exponentiation is the
@c matrix inverse, if it exists.

Berechnung der inversen Matrix mit @code{x^^-1}.

@example
(%i14) x ^^ -1;
@group
                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
@end group
(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
@end example
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{matrixmap}
@deffn {Funktion} matrixmap (@var{f}, @var{M})

@c Returns a matrix with element @code{i,j} equal to 
@c @code{@var{f}(@var{M}[i,j])}.

Gibt eine Matrix mit den Elementen @code{[i,j]} zur@"uck, die mit
@code{@var{f}(@var{M}[i,j])} berechnet werden.

@c See also @code{map}, @code{fullmap}, @code{fullmapl}, and @code{apply}.

Siehe auch @code{map}, @code{fullmap}, @code{fullmapl}, and @code{apply}.

@c NEED EXAMPLE HERE
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{matrixp}
@deffn {Funktion} matrixp (@var{expr})

@c Returns @code{true} if @var{expr} is a matrix, otherwise @code{false}.

Gibt @code{true} zur@"uck, wenn @var{expr} eine Matrix ist.  Ansonsten wird
@code{false} zur@"uckgegeben.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{matrix_element_add}
@defvr {Optionsvariable} matrix_element_add
Standardwert: @code{+}

@c @code{matrix_element_add} is the operation invoked in place of addition in a
@c matrix multiplication. @code{matrix_element_add} can be assigned any n-ary 
@c operator (that is, a function which handles any number of arguments).
@c The assigned value may be the name of an operator enclosed in quote marks,
@c the name of a function, or a lambda expression.

@code{matrix_element_add} enth@"alt die Operation f@"ur die Ausf@"uhrung der
Addition von Matrizen.  Der Optionsvariablen @code{matrix_element_add} kann
ein N-Ary-Operator zugewiesen werden.  Der zugewiesene Wert kann der Name
eines Operators, einer Funktion oder ein Lambda-Ausdruck sein.

@c See also @code{matrix_element_mult} and @code{matrix_element_transpose}.

Siehe auch @code{matrix_element_mult} und @code{matrix_element_transpose}.

Beispiele:

@example
(%i1) matrix_element_add: "*"$
(%i2) matrix_element_mult: "^"$
(%i3) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o3)                      [         ]
                           [ d  e  f ]
(%i4) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o4)                      [         ]
                           [ x  y  z ]
(%i5) aa . transpose (bb);
                     [  u  v  w   x  y  z ]
                     [ a  b  c   a  b  c  ]
(%o5)                [                    ]
                     [  u  v  w   x  y  z ]
                     [ d  e  f   d  e  f  ]
@end example
@end defvr

@c --- 10.12.2010 DK -----------------------------------------------------------
@need 800
@anchor{matrix_element_mult}
@defvr {Optionsvariable} matrix_element_mult
Standardwert: @code{*}

@c @code{matrix_element_mult} is the operation invoked in place of 
@c multiplication in a matrix multiplication. @code{matrix_element_mult} can be
@c assigned any binary operator. The assigned value may be the name of an 
@c operator enclosed in quote marks, the name of a function, or a lambda 
@c expression.

@code{matrix_element_mult} enth@"alt die Operation f@"ur die Ausf@"uhrung der
Multiplikation von Matrizen.  Der Optionsvariablen @code{matrix_element_mult} 
kann ein bin@"arer Operator zugewiesen werden.  Der zugewiesene Wert kann der 
Name eines Operators, einer Funktion oder ein Lambda-Ausdruck sein.

@c The dot operator @code{.} is a useful choice in some contexts.

Der nichtkommutative Operator @code{.} kann eine sinnvolle Alternative sein.

@c See also @code{matrix_element_add} and @code{matrix_element_transpose}.

Siehe auch @code{matrix_element_add} und @code{matrix_element_transpose}.

Beispiele:

@example
(%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
(%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
(%i3) [a, b, c] . [x, y, z];
                          2          2          2
(%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
(%i4) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o4)                      [         ]
                           [ d  e  f ]
(%i5) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o5)                      [         ]
                           [ x  y  z ]
(%i6) aa . transpose (bb);
               [             2          2          2  ]
               [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
(%o6)  Col 1 = [                                      ]
               [             2          2          2  ]
               [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                         [             2          2          2  ]
                         [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                 Col 2 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - z)  + (e - y)  + (d - x) ) ]
@end example
@end defvr

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{matrix_element_transpose}
@defvr {Optionsvariable} matrix_element_transpose
Standardwert: @code{false}

@c @code{matrix_element_transpose} is the operation applied to each element of 
@c a matrix when it is transposed. @code{matrix_element_mult} can be assigned 
@c any unary operator. The assigned value may be the name of an operator 
@c enclosed in quote marks, the name of a function, or a lambda expression.

@code{matrix_element_transpose} enth@"alt die Operation f@"ur die Ausf@"uhrung 
der Transponierung einer Matrix.  Der Optionsvariablen
@code{matrix_element_mult} kann ein un@"arer Operator zugewiesen werden.  Der 
zugewiesene Wert kann der Name eines Operators, einer Funktion oder ein
Lambda-Ausdruck sein.

@c When @code{matrix_element_transpose} equals @code{transpose}, the 
@c @code{transpose} function is applied to every element. When 
@c @code{matrix_element_transpose} equals @code{nonscalars}, the 
@c @code{transpose} function is applied to every nonscalar element. If some 
@c element is an atom, the @code{nonscalars} option applies @code{transpose} 
@c only if the atom is declared nonscalar, while the @code{transpose} option 
@c always applies @code{transpose}.

Hat @code{matrix_element_transpose} den Wert @code{transpose}, wird die 
Funktion @code{transpose} auf jedes Element der Matrix angewendet.  Hat
@code{matrix_element_transpose} den Wert @code{nonscalars}, wird die Funktion
@code{transpose} auf nichtskalare Elemente der Matrix angewendet.  Ist eines
der Elemente ein Atom, muss in diesem Fall das Atom als @code{nonscalar}
deklariert sein.

@c The default value, @code{false}, means no operation is applied.

Mit dem Standardwert @code{false} wird keine Operation angewendet.

@c See also @code{matrix_element_add} and @code{matrix_element_mult}.

Siehe auch @code{matrix_element_add} und @code{matrix_element_mult}.

Beispiele:

@example
(%i1) declare (a, nonscalar)$
(%i2) transpose ([a, b]);
                        [ transpose(a) ]
(%o2)                   [              ]
                        [      b       ]
(%i3) matrix_element_transpose: nonscalars$
(%i4) transpose ([a, b]);
                        [ transpose(a) ]
(%o4)                   [              ]
                        [      b       ]
(%i5) matrix_element_transpose: transpose$
(%i6) transpose ([a, b]);
                        [ transpose(a) ]
(%o6)                   [              ]
                        [ transpose(b) ]
(%i7) matrix_element_transpose: lambda ([x], realpart(x)
      - %i*imagpart(x))$
(%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                     [ 5 %i + 1  3 - 2 %i ]
(%o8)                [                    ]
                     [   7 %i       11    ]
(%i9) transpose (m);
                      [ 1 - 5 %i  - 7 %i ]
(%o9)                 [                  ]
                      [ 2 %i + 3    11   ]
@end example
@end defvr

@c IS THIS THE ONLY MATRIX TRACE FUNCTION ??

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{mattrace}
@deffn {Funktion} mattrace (@var{M})

@c Returns the trace (that is, the sum of the elements on the main diagonal) of
@c the square matrix @var{M}.

Gibt die Spur einer quadratischen Matrix @var{M} zur@"uck.

@c @code{mattrace} is called by @code{ncharpoly}, an alternative to Maxima's 
@c @code{charpoly}.
@c UMM, HOW IS THAT RELEVANT HERE ??
@c @code{load ("nchrpl")} loads this function.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{minor}
@deffn {Funktion} minor (@var{M}, @var{i}, @var{j})

@c Returns the @var{i}, @var{j} minor of the matrix @var{M}.  That is, @var{M}
@c with row @var{i} and column @var{j} removed.

Gibt den Minor zu @var{i}, @var{j} der Matrix @var{M} zur@"uck.  Die Matrix
entsteht durch Streichen der @var{i}-ten Spalte und @var{j}-ten Zeile.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{ncharpoly}
@deffn {Funktion} ncharpoly (@var{M}, @var{x})

@c Returns the characteristic polynomial of the matrix @var{M} with respect to 
@c @var{x}.  This is an alternative to Maxima's @code{charpoly}.

Gibt das charakteristische Polynom der Matrix @var{M} f@"ur die Variable @var{x}
zur@"uck.  Diese Funktion ist eine Alternative zur Funktion @code{charpoly}.

@c @code{ncharpoly} works by computing traces of powers of the given matrix,
@c which are known to be equal to sums of powers of the roots of the
@c characteristic polynomial.  From these quantities the symmetric
@c functions of the roots can be calculated, which are nothing more than
@c the coefficients of the characteristic polynomial.  @code{charpoly} works by
@c SHOULD THAT BE "m" INSTEAD OF "a" IN THE NEXT LINE ??
@c forming the determinant of @code{@var{x} * ident [n] - a}.  Thus
@c @code{ncharpoly} wins, for example, in the case of large dense matrices 
@c filled with integers, since it avoids polynomial arithmetic altogether.
@c @code{load("nchrpl")} loads this file.

Der Algorithmus von @code{ncharpoly} ist vorteilhaft gegen@"uber 
@code{charpoly}, wenn gro@ss{}e und d@"unn besetzte Matrizen vorliegen.  Das 
Kommando @code{load(nchrpl} l@"adt die Funktion.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{newdet}
@deffn {Funktion} newdet (@var{M}, @var{n})

@c Computes the determinant of the matrix or array @var{M} by the
@c Johnson-Gentleman tree minor algorithm.
@c UGH -- ARRAYS ARE SUCH A MESS
@c The argument @var{n} is the order; it is optional if @var{M} is a matrix.

Berechnet die Determinate der Matrix oder eines Arrays @var{M} mit dem
Johnson-Gentleman-Algorithmus.  Das Argument @var{n} ist die Ordnung.  F@"ur
eine Matrix ist @var{n} ein optionales Argument.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{permanent}
@deffn {Funktion} permanent (@var{M}, @var{n})

@c Computes the permanent of the matrix @var{M}.  A permanent is like a 
@c determinant but with no sign changes.

Berechnet die Permanente der Matrix @var{M}.  Die Permanente ist @"ahnlich der
Determinate, aber es fehlen die Vorzeichenwechsel.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{rank}
@deffn {Funktion} rank (@var{M})

@c Computes the rank of the matrix @var{M}.  That is, the order of the largest 
@c non-singular subdeterminant of @var{M}.

Berechnet den Rang der Matrix @var{M}.

@c STATEMENT NEEDS CLARIFICATION
@c @var{rank} may return the wrong answer if it cannot determine that a matrix
@c  element that is equivalent to zero is indeed so.

@var{rank} kann ein falsches Ergebnis geben, wenn ein Element @"aquivalent
zu Null ist, dies aber nicht von Maxima festgestellt werden kann.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{potenial}
@deffn {Funktion} potential (@var{givengradient})

The calculation makes use of the global variable @code{potentialzeroloc[0]}
which must be @code{nonlist} or of the form

@example
[indeterminatej=expressionj, indeterminatek=expressionk, ...]
@end example

the former being equivalent to the nonlist expression for all right-hand 
sides in the latter.  The indicated right-hand sides are used as the lower 
limit of integration.  The success of the integrations may depend upon their 
values and order.  @code{potentialzeroloc} is initially set to 0.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{ratmx}
@defvr {Optionsvariable} ratmx
Standardwert: @code{false}

@c When @code{ratmx} is @code{false}, determinant and matrix addition, 
@c subtraction, and multiplication are performed in the representation of the 
@c matrix elements and cause the result of matrix inversion to be left in 
@c general representation.

Hat @code{ratmx} den Wert @code{false}, werden die Berechnung einer Determinante
sowie die Operationen der Addition, Subtraktion und Multiplikation in der
allgemeinen Darstellung ausgef@"uhrt.  Das Ergebnis ist wieder eine allgemeine
Darstellung.

@c When @code{ratmx} is @code{true}, the 4 operations mentioned above are 
@c performed in CRE form and the result of matrix inverse is in CRE form. Note 
@c that this may cause the elements to be expanded (depending on the setting of 
@c @code{ratfac}) which might not always be desired.

Hat @code{ratmx} den Wert @code{true}, werden die oben genannten Operationen
in einer CRE-Darstellung ausgef@"uhrt un das Ergebnis ist in einer 
CRE-Darstellung.
@end defvr

@c --- 28.08.2010 DK -----------------------------------------------------------
@anchor{rmxchar}
@defvr {Optionsvariable} rmxchar
Standardwert: @code{]}

@c @code{rmxchar} is the character drawn on the right-hand side of a matrix.

@code{rmxchar} ist das Zeichen, das f@"ur die rechte Seite einer Matrix 
ausgegeben wird.  Siehe auch @code{lmxchar}.
@end defvr

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{row}
@deffn {Funktion} row (@var{M}, @var{i})

@c Returns the @var{i}'th row of the matrix @var{M}. The return value is a 
@c matrix.

Gibt die @var{i}-te Spalte der Matrix @var{M} zur@"uck.  Der R@"uckgabewert ist 
eine Matrix.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{scalarmatrixp}
@defvr {Optionsvariable} scalarmatrixp
Standardwert: @code{true}

@c When @code{scalarmatrixp} is @code{true}, then whenever a 1 x 1 matrix is 
@c produced as a result of computing the dot product of matrices it is 
@c simplified to a scalar, namely the sole element of the matrix.

Hat @code{scalarmatrixp} den Wert @code{true}, dann werden 1 x 1-Matrizen, die
als Ergebnis einer nicht-kommutativen Multiplikation auftreten, zu einem
Skalar vereinfacht.

@c When @code{scalarmatrixp} is @code{all}, then all 1 x 1 matrices are 
@c simplified to scalars.

Hat @code{scalarmatrixp} den Wert @code{all}, dann werden alle 1 x 1-Matrizen
zu einem Skalar vereinfacht.

@c When @code{scalarmatrixp} is @code{false}, 1 x 1 matrices are not simplified
@c to scalars.

Hat @code{scalarmatrixp} den Wert @code{false}, werden 1 x 1-Matrizen nicht zu
einem Skalar vereinfacht.
@end defvr

@c I WONDER WHAT THIS IS ABOUT

@c -----------------------------------------------------------------------------
@deffn {Funktion} scalefactors (@var{coordinatetransform})

Here coordinatetransform evaluates to the form [[expression1, expression2,
@dots{}], indeterminate1, indeterminat2, @dots{}], where indeterminate1, 
indeterminate2, etc. are the curvilinear coordinate variables and where a set of
rectangular Cartesian components is given in terms of the curvilinear
coordinates by [expression1, expression2, @dots{}].  @code{coordinates} is set
to the vector [indeterminate1, indeterminate2, @dots{}], and @code{dimension} is 
set to the length of this vector.  SF[1], SF[2], @dots{}, SF[DIMENSION] are set
to the coordinate scale factors, and @code{sfprod} is set to the product of
these scale factors.  Initially, @code{coordinates} is [X, Y, Z],
@code{dimension} is 3, and SF[1]=SF[2]=SF[3]=SFPROD=1, corresponding to 
3-dimensional rectangular Cartesian coordinates.  To expand an expression into 
physical components in the current coordinate system, there is a function with 
usage of the form
@c SOME TEXT HAS GONE MISSING HERE
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{setelmx}
@deffn {Funktion} setelmx (@var{x}, @var{i}, @var{j}, @var{M})

@c Assigns @var{x} to the (@var{i}, @var{j})'th element of the matrix @var{M},
@c and returns the altered matrix.

Weist @var{x} dem Matrixelement @code{[@var{i},@var{j}]} zu und gibt die
modifizierte Matrix zur@"uck.

@c @code{@var{M} [@var{i}, @var{j}]: @var{x}} has the same effect,
@c but returns @var{x} instead of @var{M}.

@code{@var{M}[@var{i}, @var{j}]: @var{x}} hat denselben Effekt.  In diesem Fall
wird jedoch der Wert @var{x} zur@"uckgeben und nicht die Matrix.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{similaritytransform}
@deffn  {Funktion} similaritytransform (@var{M})
@deffnx {Funktion} simtran (@var{M})

@code{similaritytransform} computes a similarity transform of the matrix 
@code{M}.  It returns a list which is the output of the @code{uniteigenvectors}
command.  In addition if the flag @code{nondiagonalizable} is @code{false} two 
global matrices @code{leftmatrix} and @code{rightmatrix} are computed.  These 
matrices have the property that @code{leftmatrix . @var{M} . rightmatrix} is a 
diagonal matrix with the eigenvalues of @var{M} on the diagonal.  If 
@code{nondiagonalizable} is @code{true} the left and right matrices are not 
computed.

If the flag @code{hermitianmatrix} is @code{true} then @code{leftmatrix} is the 
complex conjugate of the transpose of @code{rightmatrix}.  Otherwise 
@code{leftmatrix} is the inverse of @code{rightmatrix}.

@code{rightmatrix} is the matrix the columns of which are the unit eigenvectors 
of @var{M}.  The other flags (see @code{eigenvalues} and @code{eigenvectors}) 
have the same effects since @code{similaritytransform} calls the other functions
in the package in order to be able to form @code{rightmatrix}.

@code{load ("eigen")} loads this function.

@code{simtran} is a synonym for @code{similaritytransform}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sparse}
@defvr {Optionsvariable} sparse
Standardwert: @code{false}

@c When @code{sparse} is @code{true}, and if @code{ratmx} is @code{true}, then 
@c @code{determinant} will use special routines for computing sparse 
@c determinants.

Haben @code{sparse} und @code{ratmx} den Wert @code{true}, verwendet die 
Funktion @code{determinant} einen speziellen Algorithmus f@"ur d@"unn besetzte
Matrizen, um die Determinante einer Matrix zu berechnen.
@end defvr

@c --- 23.03.2013 VN -----------------------------------------------------------
@anchor{submatrix}
@deffn  {Funktion} submatrix (@var{i_1}, @dots{}, @var{i_m}, @var{M}, @var{j_1}, @dots{}, @var{j_n})
@deffnx {Funktion} submatrix (@var{i_1}, @dots{}, @var{i_m}, @var{M})
@deffnx {Funktion} submatrix (@var{M}, @var{j_1}, @dots{}, @var{j_n})

Gibt eine Kopie der Matrix @var{M} zur@"uck, in der die Zeilen 
@var{i_1}, @dots{}, @var{i_m} und Spalten @var{j_1}, @dots{}, @var{j_n} 
nicht enthalten sind.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{transpose}
@deffn {Funktion} transpose (@var{M})

@c Returns the transpose of @var{M}.

Gibt die Transponierte der Matrix @var{M} zur@"uck.

@c If @var{M} is a matrix, the return value is another matrix @var{N}
@c such that @code{N[i,j] = M[j,i]}.

Ist @var{M} eine Matrix, ist das Ergebnis eine Matrix @var{N} mit den 
Elementen @code{N[i,j] = M[j,i]}.

@c If @var{M} is a list, the return value is a matrix @var{N}
@c of @code{length (m)} rows and 1 column, such that @code{N[i,1] = M[i]}.

Ist @var{M} eine Liste, ist die R@"uckgabe eine Matrix @var{N} mit
@code{length(M)} Spalten und einer Zeile.  Die Elemente sind 
@code{N[i,1] = M[i]}.

@c Otherwise @var{M} is a symbol, and the return value is a noun expression 
@c @code{'transpose (@var{M})}.

Ansonsten wird eine Substantivform @code{'transpose(@var{M})} zur@"uckgegeben.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{triangularize}
@deffn {Funktion} triangularize (@var{M})

@c Returns the upper triangular form of the matrix @code{M}, as produced by 
@c Gaussian elimination. The return value is the same as @code{echelon},
@c except that the leading nonzero coefficient in each row is not normalized to 
@c 1.

Gibt die obere Dreiecksmatrix f@"ur die Matrix @code{M} zur@"uck, wie sie mit 
dem Gau@ss{}schen Eliminationsverfahren berechnet wird.  Die Dreiecksmatrix 
entspricht der R@"uckgabe der Funktion @code{echelon} mit dem Unterschied, dass 
die Elemente auf der Diagonalen nicht zu 1 normalisiert sind.

@c @code{lu_factor} and @code{cholesky} are other functions which yield 
@c triangularized matrices.

Mit den Funktionen @code{lu_factor} und @code{cholesky} kann ebenfalls eine
Matrix in die Dreiecksform transformiert werden.

Beispiel:

@example
(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) triangularize (M);
             [ - 1   8         5            2      ]
             [                                     ]
(%o2)        [  0   - 74     - 56         - 22     ]
             [                                     ]
             [  0    0    626 - 74 aa  238 - 74 bb ]
@end example
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{uniteigenvectors}
@deffn  {Funktion} uniteigenvectors (@var{M})
@deffnx {Funktion} ueivects (@var{M})

@c Computes unit eigenvectors of the matrix @var{M}. The return value is a list 
@c of lists, the first sublist of which is the output of the @code{eigenvalues} 
@c command, and the other sublists of which are the unit eigenvectors of the 
@c matrix corresponding to those eigenvalues respectively.

Berechnet die Einheitsvektoren der Matrix @var{M}.  Die R@"uckgabe ist eine 
Liste, die zwei weitere Listen enth@"alt.  Die erste Liste enth@"alt die 
Eigenwerte der Matrix @var{M} und deren Multiplizit@"aten.  Die zweite Liste 
enth@"alt die Einheitsvektoren.

Ansonsten entspricht @code{uniteigenvectors} der Funktion @code{eigenvectors}.

@c COPY DESCRIPTIONS OF THOSE FLAGS HERE
@c The flags mentioned in the description of the @code{eigenvectors} command 
@c have the same effects in this one as well.

@c When @code{knowneigvects} is @code{true}, the @code{eigen} package assumes 
@c that the eigenvectors of the matrix are known to the user and are stored 
@c under the global name @code{listeigvects}.  @code{listeigvects} should be 
@c set to a list similar to the output of the @code{eigenvectors} command.

@c FOLLOWING PARAGRAPH IS IN NEED OF SERIOUS CLARIFICATION
@c If @code{knowneigvects} is set to @code{true} and the list of eigenvectors is 
@c given the setting of the flag @code{nondiagonalizable} may not be correct. If
@c that is the case please set it to the correct value.  The author assumes that
@c the user knows what he is doing and will not try to diagonalize a matrix the 
@c eigenvectors of which do not span the vector space of the appropriate
@c dimension.

@c @code{load ("eigen")} loads this function.

Das Kommando @code{load(eigen)} l@"adt die Funktion.

@c @code{ueivects} is a synonym for @code{uniteigenvectors}.

@code{ueivects} ist ein Alias-Name der Funkion @code{uniteigenvectors}.
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{unitvector}
@deffn  {Funktion} unitvector (@var{x})
@deffnx {Funktion} uvect (@var{x})

@c Returns @math{@var{x}/norm(@var{x})}; this is a unit vector in the same
@c direction as @var{x}.

Gibt den Einheitsvektor @math{@var{x}/norm(@var{x})} zur@"uck.

@c @code{load ("eigen")} loads this function.

Das Kommando @code{load(eigen)} l@"adt die Funktion.

@c @code{uvect} is a synonym for @code{unitvector}.

@code{uvect} ist ein Alias-Name der Funktion @code{unitvector}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{vectorpotential}
@deffn {Funktion} vectorpotential (@var{givencurl})

Returns the vector potential of a given curl vector, in the current 
coordinate system.  @code{potentialzeroloc} has a similar role as for 
@code{potential}, but the order of the left-hand sides of the equations must 
be a cyclic permutation of the coordinate variables.
@end deffn

@c NEEDS A LOT OF WORK: MAKE SURE THAT ALL VECTOR SIMPLIFICATION FLAGS HAVE A
@c DESCRIPTION HERE

@c -----------------------------------------------------------------------------
@anchor{vectorsimp}
@deffn {Funktion} vectorsimp (@var{expr})

Applies simplifications and expansions according to the following global flags:

@verbatim
expandall         expanddot             expanddotplus
expandcross       expandcrossplus       expandcrosscross
expandgrad        expandgradplus        expandgradprod
expanddiv         expanddivplus         expanddivprod
expandcurl        expandcurlplus        expandcurlcurl 
expandlaplacian   expandlaplacianplus   expandlaplacianprod
@end verbatim

All these flags have default value @code{false}.  The @code{plus} suffix refers
to employing additivity or distributivity.  The @code{prod} suffix refers to 
the expansion for an operand that is any kind of product.

@table @code
@item expandcrosscross
Simplifies @code{p ~ (q ~ r)} to @code{(p . r)*q - (p . q)*r}.

@item expandcurlcurl
Simplifies @code{curl curl p} to @code{grad div p + div grad p}.

@item expandlaplaciantodivgrad
Simplifies @code{laplacian p} to @code{div grad p}.

@item expandcross
Enables @code{expandcrossplus} and @code{expandcrosscross}.

@item expandplus
@flushleft
Enables @code{expanddotplus}, @code{expandcrossplus}, @code{expandgradplus},
@code{expanddivplus}, @code{expandcurlplus}, and @code{expandlaplacianplus}.
@end flushleft

@item expandprod
Enables @code{expandgradprod}, @code{expanddivprod}, and 
@code{expandlaplacianprod}.
@end table

@c EXPLAIN THE IMPORT OF THIS STATEMENT
These flags have all been declared @code{evflag}.

@c SEEMS SOME TEXT HAS GONE MISSING HERE; COMMENT OUT FRAGMENT PENDING
@c RECOVERY AND/OR RECONSTRUCTION OF THIS PARAGRAPH
@c For orthogonal curvilinear coordinates, the global variables
@c COORDINATES[[X,Y,Z]], DIMENSION[3], SF[[1,1,1]], and SFPROD[1] are set
@c by the function invocation
@end deffn

@c --- 10.12.2010 DK -----------------------------------------------------------
@anchor{vect_cross}
@defvr {Optionsvariable} vect_cross
Standardwert: @code{false}

@c WHAT DOES THIS MEAN EXACTLY ??
@c When @code{vect_cross} is @code{true}, it allows DIFF(X~Y,T) to work where
@c ~ is defined in SHARE;VECT (where VECT_CROSS is set to @code{true}, anyway.)

Hat @code{vect_cross} den Wert @code{true}, werden Ausdr@"ucke, die die 
Ableitung eines Kreuzproduktes enthalten, vereinfacht.

Beispiel:

@example
(%i1) load(vect)$

(%i2) vect_cross:false;
(%o2)                         false
(%i3) diff(f(x)~g(x),x);
                        d
(%o3)                   -- (f(x) ~ g(x))
                        dx
(%i4) vect_cross:true;
(%o4)                         true
(%i5) diff(f(x)~g(x),x);
                     d                    d
(%o5)        f(x) ~ (-- (g(x))) - g(x) ~ (-- (f(x)))
                     dx                   dx
@end example
@end defvr

@c -----------------------------------------------------------------------------
@anchor{zeromatrix}
@deffn {Funktion} zeromatrix (@var{m}, @var{n})

@c Returns an @var{m} by @var{n} matrix, all elements of which are zero.

Gibt eine @var{m} x @var{n}-Matrix zur@"uck, deren Elemente alle Null sind.
@end deffn

@c --- End of file Matrices.de.texi --------------------------------------------

