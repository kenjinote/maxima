@c -----------------------------------------------------------------------------
@c File        : Expressions.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Expressions.texi revision 1.73
@c Translation : Dr. Dieter Kaiser
@c Date        : 17.10.2010
@c Revision    : 08.04.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Ausdr@"ucke::
* Substantive und Verben::
* Bezeichner::
* Funktionen und Variablen f@"ur Ausdr@"ucke::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Ausdr@"ucke, Substantive und Verben, Ausdr@"ucke, Ausdr@"ucke
@section Einf@"uhrung in Ausdr@"ucke
@c -----------------------------------------------------------------------------

Alles in Maxima, bis auf wenige Ausnahmen, sind Ausdr@"ucke.  Dazu geh@"oren 
mathematische Ausdr@"ucke wie @code{sqrt(2*a+b)} oder Kommandos wie
@code{subst(a^2,b,sin(b+1)}.  Auch Maxima-Programme sind Ausdr@"ucke.
Ausdr@"ucke bestehen aus einem Atom oder einem Operator mit seinen Argumenten.

Ein Atom kann ein Symbol, eine Zeichenkette, eine ganze Zahl oder 
eine Gleitkommazahl sein.  Jeder Ausdruck, der nicht ein Atom ist, hat die 
Darstellung @code{op(a_1, a_2, ..., a_n)}.  @code{op} ist der Operator und 
@code{a_1}, @dots{}, @code{a_n} sind die Argumente des Operators.  Die Argumente
des Operators k@"onnen Atome oder wiederum Operatoren mit Argumenten sein.

Da Maxima in Lisp programmiert ist, wird ein Ausdruck intern als eine Liste 
dargestellt, die die Gestalt @code{((op) a_1 a_2 ... a_n)} hat.  Die 
arithmetischen Operatoren "+" und "*" haben zum Beispiel die interne 
Darstellung:

@example
x+y+10  -> ((mplus) 10 $x $y)
2*x*x   -> ((mtimes) 2 $x $y)
2*(x+y) -> ((mtimes) 2 ((mplus) $x $y)
@end example

Mathematische Funktionen wie die trigonometrischen Funktionen oder die 
Logarithmusfunktion werden von Maxima intern analog dargestellt:

@example
sin(x)          -> ((%sin) $x)
log(y)          -> ((%log) $y)
2*sin(x)+log(y) -> ((mplus) ((mtimes) 2 ((%sin) $x)) ((%log) $y)) 
@end example

Mehrere Ausdr@"ucke k@"onnen zusammengefa@ss{}t werden, indem die Ausdr@"ucke 
durch Kommata getrennt und mit runden Klammern umgeben werden.

@example
(%i1) x: 3$
(%i2) (x: x+1, x: x^2);
(%o2)                          16
(%i3) (if (x > 17) then 2 else 4);
(%o3)                           4
(%i4) (if (x > 17) then x: 2 else y: 4, y+x);
(%o4)                          20
@end example

Auch Programmschleifen sind in Maxima Ausdr@"ucke.  Der R@"uckgabewert einer 
Programmschleife ist @code{done}.

@example
(%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
(%i2) y;
(%o2)                         done
@end example

Um einen anderen R@"uckgabewert als @code{done} zu erhalten, kann zum Beispiel 
der Wert der Variablen @var{x} nach dem Ende der Programmschleife ausgegeben 
werden.

@example
(%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
(%i4) y;
(%o4)                        3628800
@end example

Es gibt eine Anzahl an reservierten Namen, die nicht als Variablennamen 
verwendet werden sollten.  Ihre Verwendung kann m@"oglicherweise kryptische
Fehlermeldungen erzeugen.  Dazu geh@"oren zum Beispiel die folgenden Namen:

@verbatim
   integrate            next           from                 diff            
   in                   at             limit                sum             
   for                  and            elseif               then            
   else                 do             or                   if              
   unless               product        while                thru            
   step                                                                     
@end verbatim

@noindent
Funktionen und Variablen um einen Teilausdruck zu isolieren:

@verbatim
   isolate     disolate  isolate_wrt_times   expisolate
   part        inpart    substpart           substinpart
   inflag      piece     partswitch
   pickapart
@end verbatim

@noindent
Funktionen und Variablen f@"ur Substantive und Verben:

@verbatim
   nounify   verbify     alias     aliases
@end verbatim

@noindent
Funktionen und Variablen, um zu pr@"ufen, ob ein Teilausdruck enthalten ist und 
um eine Liste der Variablen eines Ausdrucks zu erstellen:

@verbatim
   freeof       lfreeof
   listofvars   listconstvars    listdummyvars
@end verbatim

@noindent
Funktionen und Variablen f@"ur Operatoren und Argumente:

@verbatim
   args    op    operatorp
@end verbatim

@noindent
Funktionen und Variablen f@"ur Substitutionen in Ausdr@"ucke:

@verbatim
   subst psubst sublis exptsubst opsubst
@end verbatim

@noindent
Funktionen und Variablen f@"ur die kanonische Ordnung der Argumente eines 
Ausdrucks:

@verbatim
   ordergreat    orderless    unorder
   ordergreatp   orderlessp   ordermagnitudep
@end verbatim

@noindent
Weitere Funktionen und Variablen:

@verbatim
   nterms   optimize   optimprefix   partition
@end verbatim

@c -----------------------------------------------------------------------------
@anchor{verb}
@node Substantive und Verben, Bezeichner, Einf@"uhrung in Ausdr@"ucke, Ausdr@"ucke
@section Substantive und Verben
@c -----------------------------------------------------------------------------

Operatoren und Funktionen k@"onnen als Substantiv oder Verb vorliegen.  Verben 
werden von Maxima ausgewertet.  Substantive, die in einem Ausdruck auftreten, 
werden dagegen nicht ausgewertet, sondern vereinfacht.  Die meisten 
mathematischen Funktionen sind Substantive.  Funktionen wie
@mrefcomma{limit} @mref{diff} oder @mref{integrate} sind standardm@"a@ss{}ig
Verben, die jedoch in ein Substantiv umgewandelt werden k@"onnen.  Ein Verb kann
durch den @nxref{', Quote-Operator} @code{'} oder mit der Funktion
@mref{nounify} in ein Substantiv umgewandelt werden.  Der Auswertungsschalter 
@mref{nouns} bewirkt, dass Substantive von der Funktion @mref{ev} ausgewertet 
werden.

In der internen Darstellung von Maxima erhalten Lisp-Symbole, die ein Verb 
darstellen, ein f@"uhrendes Dollarzeichen @code{$}.  Lisp-Symbole, die ein 
Substantiv darstellen, erhalten ein f@"uhrendes Prozentzeichen @code{%}.  Einige
Substantive wie @code{'integrate} oder @code{'derivative} haben eine spezielle 
Darstellung f@"ur die Ausgabe.  Standardm@"a@ss{}ig werden jedoch Substantive
und Verben identisch dargestellt.  Hat die Optionsvariable @mref{noundisp} den
Wert @code{true}, werden Substantive mit einem f@"uhrenden Hochkommata
angezeigt.

Siehe auch @mrefcomma{noun} @mrefcomma{nouns} @mref{nounify} und 
@mrefdot{verbify}

Beispiele:

@example
(%i1) foo (x) := x^2;
                                     2
(%o1)                     foo(x) := x
(%i2) foo (42);
(%o2)                         1764
(%i3) 'foo (42);
(%o3)                        foo(42)
(%i4) 'foo (42), nouns;
(%o4)                         1764
(%i5) declare (bar, noun);
(%o5)                         done
(%i6) bar (x) := x/17;
                                     x
(%o6)                    ''bar(x) := --
                                     17
(%i7) bar (52);
(%o7)                        bar(52)
(%i8) bar (52), nouns;
                               52
(%o8)                          --
                               17
(%i9) integrate (1/x, x, 1, 42);
(%o9)                        log(42)
(%i10) 'integrate (1/x, x, 1, 42);
                             42
                            /
                            [   1
(%o10)                      I   - dx
                            ]   x
                            /
                             1
(%i11) ev (%, nouns);
(%o11)                       log(42)
@end example

@c -----------------------------------------------------------------------------
@node Bezeichner, Funktionen und Variablen f@"ur Ausdr@"ucke, Substantive und Verben, Ausdr@"ucke
@section Bezeichner
@c -----------------------------------------------------------------------------

Maxima Bezeichner bestehen aus den Buchstaben des Alphabets und den 
Zahlzeichen 0 bis 9.  Sonderzeichen k@"onnen in einem Bezeichner mit einem
vorangestellten Backslash @code{\} verwendet werden, zum Beispiel @code{a\&b}.

Ein Zahlzeichen kann der erste Buchstabe eines Bezeichners sein, wenn ihm ein 
Backslash vorangestellt ist, zum Beispiel @code{\2and3}.  Zahlzeichen, die an 
anderen Stellen auftreten, muss kein Backslash vorangestellt werden, zum 
Beispiel @code{is5}.

Sonderzeichen k@"onnen mit der Funktion @mref{declare} als alphabetisch 
erkl@"art werden.  In diesem Fall muss dem Sonderzeichen kein Backslash 
vorangestellt werden, wenn es in einem Bezeichner genutzt wird.  Die Zeichen 
@code{A} bis @code{Z}, @code{a} bis @code{z} und @code{0} bis @code{9} sowie
die Zeichen @code{%} und @code{_} haben bereits die Eigenschaft alphabetisch.

Maxima unterscheidet Gro@ss{}- und Kleinschreibung.  So werden von Maxima 
@code{foo}, @code{FOO} oder @code{Foo} unterschieden.  Ein Maxima-Bezeichner 
ist ein Lisp-Symbol, dem ein Dollarzeichen @code{$} vorangestellt ist.
Lisp-Symbolen, die in Maxima verwendet werden sollen, ist ein Fragezeichen 
@code{?} vorangestellt.  Siehe das Kapitel @nref{Lisp und Maxima} f@"ur eine 
ausf@"uhrlichere Beschreibung.

Beispiele:

@example
(%i1) %an_ordinary_identifier42;
(%o1)               %an_ordinary_identifier42
(%i2) embedded\ spaces\ in\ an\ identifier;
(%o2)           embedded spaces in an identifier
(%i3) symbolp (%);
(%o3)                         true
(%i4) [foo+bar, foo\+bar];
(%o4)                 [foo + bar, foo+bar]
(%i5) [1729, \1729];
(%o5)                     [1729, 1729]
(%i6) [symbolp (foo\+bar), symbolp (\1729)];
(%o6)                     [true, true]
(%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
(%o7)                    [false, false]
(%i8) baz\~quux;
(%o8)                       baz~quux
(%i9) declare ("~", alphabetic);
(%o9)                         done
(%i10) baz~quux;
(%o10)                      baz~quux
(%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
(%o11)                [false, false, false]
(%i12) :lisp (defvar *my-lisp-variable* '$foo)
*MY-LISP-VARIABLE*
(%i12) ?\*my\-lisp\-variable\*;
(%o12)                         foo
@end example

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Ausdr@"ucke,  , Bezeichner, Ausdr@"ucke
@section Funktionen und Variablen f@"ur Ausdr@"ucke
@c -----------------------------------------------------------------------------

@c --- 13.10.2010 DK -----------------------------------------------------------
@anchor{alias}
@deffn {Funktion} alias (@var{new_name_1}, @var{old_name_1}, @dots{}, @var{new_name_n}, @var{old_name_n})

Die Funktion @code{alias} erm@"oglicht einen alternativen Alias-Namen f@"ur eine 
Maxima-Funktion, einer Variablen oder einem Array.  Der Funktion @code{alias} 
kann eine beliebige Anzahl von paarweisen Namen und Alias-Namen @"ubergeben 
werden.

@code{alias} gibt eine Liste mit den Symbolen zur@"uck, denen ein Alias-Name
zugewiesen werden konnte.  Wurde einem Symbol bereits derselbe Alias-Name 
gegeben, enth@"alt die Liste den Wert @code{false}.  Wird versucht einem Symbol,
das bereits einen Alias-Namen hat, einen neuen Alias-Namen zu geben, bricht
@code{alias} mit einer Fehlermeldung ab.

Symbole, die einen Alias-Namen erhalten haben, werden in die Systemvariable 
@code{aliases} eingetragen.  Siehe die Systemvariable @mrefdot{aliases}

Die Funktionen @mref{ordergreat} und @mref{orderless} sowie die Deklaration
eines Symbols als ein @mref{noun} mit der Funktion @mref{declare} erzeugen
automatisch Alias-Namen, die in die Liste @code{aliases} eingetragen werden.

Der Alias-Name kann mit der Funktion @mref{kill} entfernt werden.

Beispiel:

@example
(%i1) alias(mysqrt,sqrt);
(%o1)                        [sqrt]
(%i2) aliases;
(%o2)                        [sqrt]
(%i3) mysqrt(4);
(%o3)                           2
(%i4) kill(mysqrt);
(%o4)                         done
(%i5) mysqrt(4);
(%o5)                       mysqrt(4)
(%i6) aliases;
(%o6)                          []
@end example
@end deffn

@c --- 13.10.2010 DK -----------------------------------------------------------
@anchor{aliases}
@defvr {Systemvariable} aliases
Anfangswert: @code{[]}

Die Systemvariable @code{aliases} ist eine Informationsliste der Symbole, die 
einen vom Nutzer definierten Alias-Namen mit dem Kommando @code{alias} 
erhalten haben.  Weiterhin werden von den Funktionen @mref{ordergreat} und 
@mref{orderless} sowie bei der Deklaration eines Symbols als ein
@mref{noun} mit der Funktion @mref{declare} Alias-Namen generiert, die in die
Liste @code{aliases} eingetragen werden.

Siehe auch die Funktion @mref{alias} f@"ur ein Beispiel.
@end defvr

@c --- 21.03.2011 DK -----------------------------------------------------------
@anchor{allbut}
@defvr {Schl@"usselwort} allbut

Das Schl@"usselwort @code{allbut} wird bei @code{part}-Befehlen wie
@mrefcomma{part} @mrefcomma{inpart} @mrefcomma{substpart}@w{}
@mrefcomma{substinpart} @mref{dpart} und @mref{lpart} genutzt, um Indizes bei
der Auswahl von Teilausdr@"ucken auszuschlie@ss{}en.

Das Schl@"usselwort @code{allbut} kann auch zusammen mit dem Kommando
@code{kill} verwendet werden.  @code{kill(allbut(@var{a_1}, @var{a_2}, ...))}
hat denselben Effekt wie @code{kill(all)} mit der Ausnahme, dass die Symbole 
@var{a_1}, @var{a_2}, @dots{} von @code{kill} ausgenommen werden.  Siehe die 
Funktion @mrefdot{kill}

Beispiele:

@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, [2, 5]);
(%o2)                         d + a

(%i3) expr : e + d + c + b + a;
(%o3)                   e + d + c + b + a
(%i4) part (expr, allbut (2, 5));
(%o4)                       e + c + b
@end example

Das Schl@"usselwort @code{allbut} kann zusammen mit dem Kommando @code{kill}
verwendet werden.

@example
(%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
(%o1)                 [11, 22, 33, 44, 55]
(%i2) kill (allbut (cc, dd));
(%o0)                         done
(%i1) [aa, bb, cc, dd];
(%o1)                   [aa, bb, 33, 44]
@end example
@end defvr

@c --- 13.10.2010 DK -----------------------------------------------------------
@anchor{args}
@deffn {Funktion} args (@var{expr})

Die Funktion @code{args} gibt eine Liste mit den Argumenten des Hauptoperators
des Ausdrucks @var{expr} zur@"uck.

Die Anordnung der Argumente der Ergebnisliste wird von der Optionsvariablen
@code{inflag} beeinflu@ss{}t.  Hat @code{inflag} den Wert @code{true}, ist die
Anordnung entsprechend der internen Darstellung des Ausdrucks @var{expr}.
Ansonsten ist die Anordnung wie in der externen Darstellung f@"ur die Anzeige.
Siehe die Optionsvariable @mrefdot{inflag}

@code{args(@var{expr})} ist @"aquivalent zu 
@code{substpart("[", @var{expr}, 0)}.  Siehe auch @mref{substpart} und 
@mrefdot{op}

Beispiele:

@example
(%i1) args(gamma_incomplete(a,x));
(%o1)                        [a, x]
(%i2) args(x+y+z);
(%o2)                       [z, y, x]
(%i3) args(x+y+z),inflag:true;
(%o3)                       [x, y, z]
(%i4) args(x+2*a);
(%o4)                       [x, 2 a]
@end example
@end deffn

@c --- 31.03.2011 DK -----------------------------------------------------------
@anchor{atom}
@deffn {Funktion} atom (@var{expr})

Gibt den Wert @code{true} zur@"uck, wenn das Argument @var{expr} ein Atom ist.
Atome sind ganze Zahlen, Gleitkommazahlen, Zeichenketten und Symbole.  Siehe
auch die Funktionen @mref{symbolp} und @mrefdot{listp}

@c TODO: ATOM(5.0B0) IST ATOM, ABER NICHT ATOM(1/2). DAS IST INKONSISTENT.

Beispiele:

@example
(%i1) atom(5);
(%o1)                         true
(%i2) atom(5.0);
(%o2)                         true
(%i3) atom(5.0b0);
(%o3)                         true
(%i4) atom(1/2);
(%o4)                         false
(%i5) atom('a);
(%o5)                         true
(%i6) atom(2*x);
(%o6)                         false
(%i7) atom("string");
(%o7)                         true
@end example
@end deffn

@c --- 13.10.2010 DK -----------------------------------------------------------
@anchor{box}
@deffn  {Funktion} box (@var{expr})
@deffnx {Funktion} box (@var{expr}, @var{a})

Die Funktion @code{box(@var{expr})} umschlie@ss{}t den Ausdruck @var{expr} in 
der Ausgabe mit einem Rahmen, wenn @code{display2d} den Wert @code{true} hat.
Ansonsten ist der R@"uckgabewert ein Ausdruck mit @code{box} als Operator und 
@var{expr} als Argument.

@code{box(@var{expr}, @var{a})} umschlie@ss{}t @var{expr} mit einem Rahmen, der
mit einer Marke @var{a} bezeichnet ist.  Ist die Marke l@"anger als der Rahmen,
werden Zeichen abgeschnitten.

Die Funktion @code{box} wertet ihre Argumente aus.  Die eingerahmten Ausdr@"ucke
werden dagegen nicht mehr ausgewertet.

Die Optionsvariable @mref{boxchar} enth@"alt das Zeichen, das von den Funktionen
@code{box} sowie @mref{dpart} und @mref{lpart} verwendet wird, um den Rahmen
auszugeben.

Beispiele:

@example
(%i1) box (a^2 + b^2);
                            """""""""
                            " 2    2"
(%o1)                       "b  + a "
                            """""""""
(%i2) a : 1234;
(%o2)                         1234
(%i3) b : c - d;
(%o3)                         c - d
(%i4) box (a^2 + b^2);
                      """"""""""""""""""""
                      "       2          "
(%o4)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i5) box (a^2 + b^2, term_1);
                      term_1""""""""""""""
                      "       2          "
(%o5)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i6) 1729 - box (1729);
                                 """"""
(%o6)                     1729 - "1729"
                                 """"""
@end example
@end deffn

@c --- 13.10.2010 DK -----------------------------------------------------------
@anchor{boxchar}
@defvr {Optionsvariable} boxchar
Standardwert: @code{"}

Die Optionsvariable @code{boxchar} enth@"alt das Zeichen, welches von den 
Funktionen @mref{box} sowie @mref{dpart} und @mref{lpart} genutzt wird, um
einen Rahmen auszugeben.

Die Rahmen werden immer mit dem aktuellen Wert von @code{boxchar} ausgegeben.
Das Zeichen @code{boxchar} wird nicht zusammen mit dem eingerahmten Ausdruck
gespeichert.
@end defvr

@c --- 13.10.2010 DK -----------------------------------------------------------
@anchor{collapse}
@deffn  {Funktion} collapse (@var{expr})
@deffnx {Funktion} collapse ([@var{expr_1}, @var{expr_2}, @dots{}])

Komprimiert einen Ausdruck @var{expr}, indem gemeinsame Teilausdr@"ucke 
denselben Speicher nutzen.  @code{collapse} wird von der Funktion 
@code{optimize} aufgerufen.  @code{collapse} kann auch mit einer Liste 
aufgerufen werden, die mehrere Argumente enth@"alt.

@c TODO: ES FEHLT EIN BEISPIEL.

Siehe auch die Funktion @mrefdot{optimize}
@end deffn

@c --- 21.10.2010 DK -----------------------------------------------------------
@anchor{dispform}
@deffn  {Funktion} dispform (@var{expr})
@deffnx {Funktion} dispform (@var{expr}, all)

@code{dispform} formatiert den Ausdruck @var{expr} von der internen Darstellung
in eine externe Darstellung, wie sie f@"ur die Anzeige des Ausdrucks ben@"otigt 
wird.  Bei der Formatierung sind Optionsvariablen wie @mref{dispflag} und
@mref{powerdisp} wirksam.

Beispiele f@"ur die interne und externe Darstellung von Ausdr@"ucken sind:

@example
          Interne Darstellung            Externe Darstellung
------------------------------------------------------------
-x      : ((MTIMES) -1 $x)               ((MMINUS) $x)
sqrt(x) : ((MEXPT) $x ((RAT) 1 2))       ((%SQRT) $X)
a/b     : ((MTIMES) $A ((MEXPT) $B -1))  ((MQUOTIENT) $A $B)
@end example

@code{dispform(@var{expr})} gibt die externe Darstellung nur f@"ur den ersten 
Operator im Ausdruck zur@"uck.  @code{dispform(@var{expr}, all)} gibt die 
externe Darstellung aller Operatoren im Ausdruck @var{expr} zur@"uck.

Siehe auch @mrefcomma{part} @mref{inpart} und @mrefdot{inflag}

Beispiel:

Die Funktion @code{dispform} kann genutzt werden, um die Wurzelfunktion in
einem Ausdruck zu substituieren.  Die Wurzelfunktion ist nur in der externen
Darstellung eines Ausdruckes vorhanden:

@example
(%i1) expr: sqrt(5)/(5+sqrt(2));
                             sqrt(5)
(%o1)                      -----------
                           sqrt(2) + 5
(%i2) subst(f,sqrt,expr);
                             sqrt(5)
(%o2)                      -----------
                           sqrt(2) + 5
(%i3) subst(f,sqrt,dispform(expr));
                              f(5)
(%o3)                      -----------
                           sqrt(2) + 5
(%i4) subst(f,sqrt,dispform(expr,all));
                              f(5)
(%o4)                       --------
                            f(2) + 5
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{disolate}
@deffn {Funktion} disolate (@var{expr}, @var{x_1}, @dots{}, @var{x_n})

Die Funktion @code{disolate} arbeitet @"ahnlich wie die Funktion @code{isolate}.
Teilausdr@"ucke im Ausdruck @var{expr}, die die Variablen @var{x_1}, @dots{}, 
@var{x_n} nicht enthalten, werden durch Zwischenmarken @code{%t1}, @code{%t2}, 
@dots{} ersetzt.  Im Unterschied zu der Funktion @code{isolate} kann die
Funktion @code{disolate} Teilausdr@"ucke zu mehr als einer Variablen aus einem
Ausdruck isolieren.

Die Ersetzung von Teilausdr@"ucken durch Zwischenmarken kann mit der 
Optionsvariable @code{isolate_wrt_times} kontrolliert werden.  Hat die
Optionsvariable @code{isolate_wrt_times} den Wert @code{true}, werden 
Ersetzungen in Produkten ausgef@"uhrt.  Der Standardwert ist @code{false}.
Siehe @mref{isolate_wrt_times} f@"ur Beispiele.

Die Optionsvariable @mref{exptisolate} hat im Unterschied zur Funktion
@code{isolate} keinen Einfluss auf die Ersetzung von Teilausdr@"ucken durch
Zwischenmarken.

@code{disolate} wird automatisch aus der Datei
@file{share/simplification/disol.mac} geladen.  Das Kommando 
@code{demo(disol)$} zeigt Beispiele.

Siehe auch die Funktion @mrefdot{isolate}

Beispiel:

@example
(%i1) expr:a*(e*(g+f)+b*(d+c));
(%o1)               a (e (g + f) + b (d + c))
(%i2) disolate(expr,a,b,e);
(%t2)                         d + c

(%t3)                         g + f

(%o3)                   a (%t3 e + %t2 b)
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{dpart}
@deffn {Funktion} dpart (@var{expr}, @var{n_1}, @dots{}, @var{n_k})

W@"ahlt wie die Funktion @code{part} einen Teilausdruck aus, gibt aber den 
vollst@"andigen Ausdruck zur@"uck, wobei der ausgew@"ahlte Teilausdruck 
eingerahmt ist.  Der Rahmen ist Teil des zur@"uckgegebenen Ausdrucks.

Siehe auch @mrefcomma{part} @mref{inpart} und @mref{lpart} sowie @mrefdot{box}

Beispiel:

@example
(%i1) dpart (x+y/z^2, 1, 2, 1);
                             y
(%o1)                       ---- + x
                               2
                            """
                            "z"
                            """
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{exptisolate}
@defvr {Optionsvariable} exptisolate
Standardwert: @code{false}

Hat @code{exptisolate} den Wert @code{true}, dann sucht die Funktion
@code{isolate} auch in den Exponenten von Zahlen oder Symbolen nach
Teilausdr@"ucken zu einer Variablen.

Siehe die Funktion @mref{isolate} f@"ur Beispiele.
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{exptsubst}
@defvr {Optionsvariable} exptsubst
Standardwert: @code{false}

Die Optionsvariable @code{exptsubst} kontrolliert die Substitution von
Ausdr@"ucken mit der Exponentialfunktion durch die Funktionen @mref{subst} und
@mrefdot{psubst}

Beispiele:

@example
(%i1) subst(y,%e^x,%e^(a*x)),exptsubst:false;
                                a x
(%o1)                         %e
(%i2) subst(y,%e^x,%e^(a*x)),exptsubst:true;
                                a
(%o2)                          y
@end example
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{freeof}
@deffn  {Funktion} freeof (@var{x}, @var{expr})
@deffnx {Funktion} freeof (@var{x_1}, @dots{}, @var{x_n}, @var{expr})

@code{freeof(@var{x}, @var{expr})} gibt das Ergebnis @code{true} zur@"uck, wenn
das Argument @var{x} nicht im Ausdruck @var{expr} enthalten ist.  Ansonsten ist
der R@"uckgabewert @code{false}.

@code{freeof(@var{x_1}, ..., @var{x_n}, @var{expr})} gibt das Ergebnis 
@code{true} zur@"uck, wenn keines der Argumente @var{x_1}, @var{x_2}, @dots{}
im Ausdruck @var{expr} enthalten ist.

Die Argumente @var{x_1}, @dots{}, @var{x_n} k@"onnen die Namen von Funktionen 
und Variablen sein, indizierte Namen, die Namen von Operatoren oder allgemeine
Ausdr@"ucke.  Die Funktion @code{freeof} wertet die Argumente aus.

Bei der Pr@"ufung, ob ein Teilausdruck @var{x} im Ausdruck @var{expr} enthalten
ist, untersucht die Funktion @code{freeof} den Ausdruck @var{expr} in der 
vorliegenden Form (nach Auswertung und Vereinfachung) und versucht nicht 
herauszufinden, ob der Teilausdruck in einem @"aquivalenten Ausdruck enth@"alten
w@"are.

@code{freeof} ignoriert Dummy-Variablen.  Dummy-Variablen sind Variablen, die 
au@ss{}erhalb eines Ausdrucks nicht in Erscheinung treten.  Folgende 
Dummy-Variablen werden von @code{freeof} ignoriert: der Index einer Summe oder 
eines Produktes, die unabh@"angige Variable in einem Grenzwert, die 
Integrationsvariable eines bestimmten Integrals oder einer 
Laplacetransformation, formale Variablen in @mref{at}- oder
@mref{lambda}-Ausdr@"ucke, lokale Variablen eines Blocks oder einer
@mref{do}-Schleife.

Das unbestimmte Integral ist @i{nicht} frei von der Integrationsvariablen.

Beispiele:

Argumente sind Namen von Funktionen, Variablen, indizierten Variablen, 
Operatoren und Ausdr@"ucke.  @code{freeof(a, b, expr)} ist @"aquivalent zu
@code{freeof(a, expr) and freeof(b, expr)}.

@example
(%i1) expr: z^3 * cos (a[1]) * b^(c+d);
@group
                                 d + c  3
(%o1)                   cos(a ) b      z
                             1
@end group
(%i2) freeof(z, expr);
(%o2)                         false
(%i3) freeof(cos, expr);
(%o3)                         false
(%i4) freeof(a[1], expr);
(%o4)                         false
(%i5) freeof(cos (a[1]), expr);
(%o5)                         false
(%i6) freeof(b^(c+d), expr);
(%o6)                         false
(%i7) freeof("^", expr);
(%o7)                         false
(%i8) freeof(w, sin, a[2], sin (a[2]), b*(c+d), expr);
(%o8)                         true
@end example

Die Funktion @code{freeof} wertet die Argumente aus.

@example
(%i1) expr: (a+b)^5$
(%i2) c: a$
(%i3) freeof(c, expr);
(%o3)                         false
@end example

@code{freeof} betrachtet keine @"aquivalenten Ausdr@"ucke.  Vereinfachungen 
k@"onnen einen @"aquivalenten Ausdruck liefern, der jedoch den Teilausdruck 
nicht mehr enth@"alt.

@example
(%i1) expr: (a+b)^5$
(%i2) expand(expr);
          5        4       2  3       3  2      4      5
(%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
(%i3) freeof(a+b, %);
(%o3)                         true
(%i4) freeof(a+b, expr);
(%o4)                         false
@end example

Die Exponentialfunktion @code{exp(x)} wird von Maxima sofort zu @code{%e^x} 
vereinfacht.  Der Name @code{exp} der Exponentialfunktion ist daher nicht in
einem Ausdruck enthalten.

@example 
(%i5) exp(x);
                                 x
(%o5)                          %e
(%i6) freeof(exp, exp (x));
(%o6)                         true
@end example

Eine Summe ist frei von dem Index und ein bestimmtes Integral ist frei von der
Integrationsvariablen.  Ein unbestimmtes Integral ist nicht frei von der 
Integrationsvariablen.

@example
(%i1) freeof(i, 'sum (f(i), i, 0, n));
(%o1)                         true
(%i2) freeof(x, 'integrate (x^2, x, 0, 1));
(%o2)                         true
(%i3) freeof(x, 'integrate (x^2, x));
(%o3)                         false
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{inflag}
@defvr {Optionsvariable} inflag
Standardwert: @code{false}

Hat die Optionsvariable @code{inflag} den Wert @code{true}, wird von Funktionen,
die Teile eines Ausdrucks @code{expr} extrahieren, die interne Form des
Ausdrucks @code{expr} betrachtet.

Die Anordnung der Argumente der internen Darstellung unterscheidet sich zum
Beispiel f@"ur die Addition von der externen Darstellung f@"ur die Anzeige.
Daher hat @code{first(x+y)} das Ergebnis @code{x}, wenn @code{inflag} den Wert
@code{true} hat, und @code{y}, wenn @code{inflag} den Wert @code{false} hat.
Der Ausdruck @code{first(y+x)} gibt in beiden F@"allen dasselbe Ergebnis.

Hat @code{inflag} den Wert @code{true}, entsprechen die Funktionen @code{part} 
und @code{substpart} den Funktionen @code{inpart} und @code{substinpart}.

Folgende Funktionen werden von der Optionsvariablen @code{inflag} beeinflusst:
@mrefcomma{part} @mrefcomma{substpart} @mrefcomma{first} @mrefcomma{rest}@w{}
@mrefcomma{last} @mrefcomma{length} die Konstruktion @mref{for} @dots{}
@code{in}, @mrefcomma{map} @mrefcomma{fullmap} @mrefcomma{maplist}@w{}
@mrefcomma{reveal} @mrefcomma{pickapart} @mref{args} und @mrefdot{op}
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{inpart}
@deffn {Funktion} inpart (@var{expr}, @var{n_1}, @dots{}, @var{n_k})

Die Funktion @code{inpart} ist @"ahnlich wie @code{part}, arbeitet aber mit der 
internen Darstellung eines Ausdruckes und nicht mit der externen Darstellung 
f@"ur die Anzeige.  Da keine Formatierung vorgenommen wird, ist die Funktion 
@code{inpart} schneller als @code{part}.

Immer dann, wenn sich die interne und die externe Darstellung eines Ausdrucks
voneinander unterscheiden, haben die Funktionen @code{inpart} und @code{part}
verschiedene Ergebnisse.  Dies trifft zu f@"ur die Anordnung der Argumente einer
Addition, der Subtraktion und Division sowie zum Beispiel f@"ur die 
Wurzelfunktion.

Ist das letzte Argument einer @code{part}-Funktion eine Liste mit Indizes, 
werden mehrere Teilausdr@"ucke heraus gepickt.  So hat
@code{inpart(x + y + z, [1, 3])} das Ergebnis @code{z+x}.

Siehe auch @mrefcomma{part} @mref{dpart} und @mrefdot{lpart}

Beispiele:

@example
(%i1) x + y + w*z;
(%o1)                      w z + y + x
(%i2) inpart (%, 3, 2);
(%o2)                           z
(%i3) part (%th (2), 1, 2);
(%o3)                           z
(%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                  g(x + 1)
(%o4)                 limit   f(x)
                      x -> 0-
(%i5) inpart (%, 1, 2);
(%o5)                       g(x + 1)
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{isolate}
@deffn {Funktion} isolate (@var{expr}, @var{x})

Teilausdr@"ucke im Ausdruck @var{expr}, die die Variable @var{x} nicht 
enthalten, werden durch Zwischenmarken @code{%t1}, @code{%t2}, @dots{} ersetzt.
Dies kann genutzt werden, um die weitere Auswertung und Vereinfachung dieser
Teilausdr@"ucke zu verhindern.  Die Ersetzung der Teilausdr@"ucke kann durch 
eine Auswertung des Ausdrucks r@"uckg@"angig gemacht werden.

Die Ersetzung von Teilausdr@"ucken kann mit den Optionsvariablen 
@mref{exptisolate} und @mref{isolate_wrt_times} kontrolliert werden.  Hat die
Optionsvariable @code{exptisolate} den Wert @code{true}, werden Ersetzungen auch
f@"ur die Exponentiation ausgef@"uhrt.  Die Basis muss dabei eine Zahl oder ein 
Symbol wie @code{%e} sein.  Hat die Optionsvariable @code{isolate_wrt_times} den 
Wert @code{true}, werden Ersetzungen in Produkten ausgef@"uhrt.  Siehe
@code{isolate_wrt_times} f@"ur Beispiele.

Die Ersetzung von Teilausdr@"ucken f@"ur mehrere Variable kann mit der Funktion
@code{disolate} ausgef@"uhrt werden.  Siehe @mrefdot{disolate}

Beispiele:

@example
(%i1) (b+a)^4*(x*((d+c)^2+2*x)+1);
                       4                  2
(%o1)           (b + a)  (x (2 x + (d + c) ) + 1)
(%i2) isolate(%,x);

                                   2
(%t2)                       (d + c)


                                   4
(%t3)                       (b + a)

(%o3)                %t3 (x (2 x + %t2) + 1)
(%i4) ratexpand(%);
                          2
(%o4)              2 %t3 x  + %t2 %t3 x + %t3
(%i5) ev(%);
                  4  2          4        2            4
(%o5)    2 (b + a)  x  + (b + a)  (d + c)  x + (b + a)
(%i6) (b+a)*(b+a+x)^2*%e^(b+a*x+x^2);
                                       2
                                  2   x  + a x + b
(%o6)          (b + a) (x + b + a)  %e
(%i7) ev(isolate(%,x),exptisolate:true);

(%t7)                         b + a


                                 b
(%t8)                          %e

                                        2
                                   2   x  + a x
(%o8)             %t7 %t8 (x + %t7)  %e
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{isolate_wrt_times}
@defvr {Optionsvariable} isolate_wrt_times
Standardwert: @code{false}

Hat die Optionsvariable @code{isolate_wrt_times} den Wert @code{true}, f@"uhren 
die Funktionen @code{isolate} und @code{disolate} auch Ersetzungen in Produkten 
aus.

Siehe auch die Funktionen @mref{isolate} und @mrefdot{disolate}

Beispiele:

@example
(%i1) isolate_wrt_times: true$
(%i2) isolate (expand ((a+b+c)^2), c);

(%t2)                          2 a


(%t3)                          2 b


                          2            2
(%t4)                    b  + 2 a b + a

                     2
(%o4)               c  + %t3 c + %t2 c + %t4
(%i4) isolate_wrt_times: false$
(%i5) isolate (expand ((a+b+c)^2), c);
                     2
(%o5)               c  + 2 b c + 2 a c + %t4
@end example
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{listconstvars}
@defvr {Optionsvariable} listconstvars
Standardwert: @code{false}

Hat die Optionsvariable @code{listconstvars} den Wert @code{true}, werden
Konstante wie @mrefcomma{%e} @mref{%pi} und Variablen, die als konstant
deklariert sind, von der Funktion @mref{listofvars} in die Ergebnisliste
aufgenommen.  Der Standardwert von @code{listconstvars} ist @code{false} und
Konstante werden ignoriert.
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{listdummyvars}
@defvr {Optionsvariable} listdummyvars
Standardwert: @code{true}

Hat @code{listdummyvars} den Wert @code{false}, werden die Dummy-Variablen eines
Ausdrucks von der Funktion @mref{listofvars} ignoriert.  Dummy-Variablen sind
zum Beispiel der Index einer Summe, die Grenzwertvariable oder die
Integrationsvariable eines bestimmten Integrals.

Beispiele:

@example
(%i1) listdummyvars: true$
(%i2) listofvars ('sum(f(i), i, 0, n));
(%o2)                        [i, n]
(%i3) listdummyvars: false$
(%i4) listofvars ('sum(f(i), i, 0, n));
(%o4)                          [n]
@end example
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{listofvars}
@deffn {Funktion} listofvars (@var{expr})

Die Funktion @code{listofvars} gibt eine Liste der Variablen zur@"uck, die im 
Ausdruck @var{expr} enthalten sind.

Hat die Optionsvariable @mref{listconstvars} den Wert @code{true}, werden auch
Konstante wie @mrefcomma{%e} @mref{%pi} und @mref{%i} sowie als konstant
deklarierte Variable in die Liste aufgenommen.  Der Standardwert von
@code{listconstvars} ist @code{false}.

Siehe entsprechend die Optionsvariable @mref{listdummyvars} f@"ur 
Dummy-Variablen.

Beispiel:

@example
(%i1) listofvars (f (x[1]+y) / g^(2+a));
(%o1)                     [g, a, x , y]
                                  1
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{lfreeof}
@deffn {Funktion} lfreeof (@var{list}, @var{expr})

F@"ur jedes Element @var{m} der Liste @var{list} wird die Funktion
@code{freeof} aufgerufen.  @code{lfreeof} hat den R@"uckgabewert @code{true},
wenn keines der Elemente der Liste @var{list} im Ausdruck @code{expr} enthalten
ist.  Ansonsten ist der R@"uckgabewert @code{false}.

Siehe auch die Funktion @mrefdot{freeof}
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{lpart}
@deffn {Funktion} lpart (@var{label}, @var{expr}, @var{n_1}, @dots{}, @var{n_k})

Die Funktion @code{lpart} ist @"ahnlich zu @code{dpart}, verwendet aber einen
Rahmen, der mit einer Marke gekennzeichnet ist.

Siehe auch @mrefcomma{part} @mref{inpart} und @mrefdot{dpart}
@end deffn

@c --- 04.04.2011 DK -----------------------------------------------------------
@anchor{mainvar}
@defvr {Eigenschaft} mainvar

Die Deklaration einer Variablen als eine Hauptvariable mit der Funktion
@mref{declare} @"andert deren Anordnung in einem Ausdruck der kanonisch geordnet
ist.  Hauptvariable sind bez@"uglich der Funktionen @mref{ordergreatp} und
@mref{orderlessp} stets gr@"o@ss{}er als alle anderen Symbole, Konstanten und
Zahlen.

@c TODO: DIE FUNKTION PROPERTIES HAT KEINEN EINTRAG FUER MAINVAR

Beispiel:

@example
(%i1) sort([9, 1, %pi, g, t, a]);
(%o1)                 [1, 9, %pi, a, g, t]

(%i2) declare(a, mainvar)$
(%i3) sort([9, 1, %pi, g, t, a]);
(%o3)                 [1, 9, %pi, g, t, a]
@end example
@end defvr

@c --- 18.02.2011 DK -----------------------------------------------------------
@anchor{noun}
@defvr {Eigenschaft} noun

@code{noun} ist eine der Optionen des Kommandos @mref{declare}.  Wird eine
Funktion als @code{noun} deklariert, wird diese als Substantivform behandelt
und nicht ausgewertet.

Ein Symbol @code{f}, dass als @code{noun} deklariert wird, wird in die
Informationsliste @mref{aliases} eingetragen und die R@"uckgabe der Funktion
@mref{properties} enth@"alt den Eintrag @code{noun}.

Beispiel:

@example
(%i1) factor (12345678);
                             2
(%o1)                     2 3  47 14593
(%i2) declare (factor, noun);
(%o2)                         done
(%i3) factor (12345678);
(%o3)                   factor(12345678)
(%i4) ''%, nouns;
                             2
(%o4)                     2 3  47 14593
@end example
@end defvr

@c --- 18.10.2010 DK -----------------------------------------------------------
@anchor{noundisp}
@defvr {Optionsvariable} noundisp
Standardwert: @code{false}

Hat @code{noundisp} den Wert @code{true}, werden Substantivformen mit einem
vorangestelltem Hochkomma angezeigt.  Diese Optionsvariable hat immer den Wert
@code{true}, wenn die Definition von Funktionen angezeigt wird.
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{nounify}
@deffn {Funktion} nounify (@var{f})

Die Funktion @code{nounify} gibt den Namen einer Funktion @var{f} in einer 
Substantivform zur@"uck.  Der Name @var{f} ist ein Symbol oder eine
Zeichenkette.

Einige Funktionen geben eine Substantivform zur@"uck, wenn die Funktion nicht 
ausgewertet werden kann.  Wird einem Funktionsaufruf wie zum Beispiel 
@code{'f(x)} oder @code{'(f(x))} ein Hochkomma vorangestellt, wird ebenfalls 
eine Substantivform zur@"uckgegeben.

Siehe auch die Funktion @mrefdot{verbify}
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{nterms}
@deffn {Funktion} nterms (@var{expr})

Die Funktion @code{nterms} gibt die Anzahl der Terme des Ausdrucks @var{expr} 
zur@"uck, wobei der Ausdruck als vollst@"andig expandiert angenommen wird, ohne 
dass Terme gek@"urzt oder zusammengefasst werden.

Ausdr@"ucke wie @code{sin(@var{expr})}, @code{sqrt(@var{expr})} oder 
@code{exp(@var{expr})} werden dabei als ein Term gez@"ahlt.
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{op}
@deffn {Funktion} op (@var{expr})

Die Funktion @code{op} gibt den Hauptoperator des Ausdrucks @var{expr} zur@"uck.
@code{op(@var{expr})} ist @"aquivalent zu @code{part(@var{expr}, 0)}.

Ist der Hauptoperator des Ausdrucks @var{expr} ein Operator wie "+", "*" oder 
"/" wird der Name des Operators als Zeichenkette zur@"uckgegeben.  Andernfalls 
wird ein Symbol zur@"uckgegeben.

@code{op} beachtet den Wert der Optionsvariablen @mrefdot{inflag}  @code{op}
wertet die Argumente aus.  Siehe auch @mrefdot{args}

Beispiele:

@example
(%i1) stringdisp: true$
(%i2) op (a * b * c);
(%o2)                          "*"
(%i3) op (a * b + c);
(%o3)                          "+"
(%i4) op ('sin (a + b));
(%o4)                          sin
(%i5) op (a!);
(%o5)                          "!"
(%i6) op (-a);
(%o6)                          "-"
(%i7) op ([a, b, c]);
(%o7)                          "["
(%i8) op ('(if a > b then c else d));
(%o8)                         "if"
(%i9) op ('foo (a));
(%o9)                          foo
(%i10) prefix (foo);
(%o10)                        "foo"
(%i11) op (foo a);
(%o11)                        "foo"
(%i12) op (F [x, y] (a, b, c));
(%o12)                        F
                               x, y
(%i13) op (G [u, v, w]);
(%o13)                          G
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{operatorp}
@deffn  {Funktion} operatorp (@var{expr}, @var{op})
@deffnx {Funktion} operatorp (@var{expr}, [@var{op_1}, @dots{}, @var{op_n}])

Das Kommando @code{operatorp(@var{expr}, @var{op})} gibt @code{true} zur@"uck,
wenn @var{op} der Hauptoperator des Ausdrucks @var{expr} ist.

@code{operatorp(@var{expr}, [@var{op_1}, ..., @var{op_n}])} gibt @code{true} 
zur@"uck, wenn einer der Operatoren @var{op_1}, @dots{}, @var{op_n} der 
Hauptoperator des Ausdrucks @var{expr} ist.
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{option_opsubst}
@defvr {Optionsvariable} opsubst

@c TODO: DAS MUSS BESSER FORMULIERT WERDEN.

Hat die Optionsvariable @code{opsubst} den Wert @code{false}, f@"uhrt die 
Funktion @mref{subst} keine Substitution in einen Operator eines Ausdrucks aus.
Zum Beispiel hat @code{(opsubst: false, subst(x^2, r, r+r[0]))} das Ergebnis
@code{x^2+r[0]}.
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{optimize}
@deffn {Funktion} optimize (@var{expr})

Die Funktion @code{optimize} gibt einen Ausdruck zur@"uck, der dasselbe Ergebnis 
und dieselben Seiteneffekte wie @var{expr} hat, der jedoch effizienter 
ausgewertet werden kann.  Im neuen Ausdruck wird die mehrfache Berechnung 
gleicher Teilausdr@"ucke vermieden und gleiche Teilausdr@"ucke werden 
zusammengefasst.

Siehe auch die Funktion @mrefdot{collapse}

@c TODO: HIER EIN BEISPIEL ERGAENZEN.

@code{example(optimize)} zeigt ein Beispiel.
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{optimprefix}
@defvr {Optionsvariable} optimprefix
Standardwert: @code{%}

Die Optionsvariable @code{optimprefix} enth@"alt den Pr@"afix, der von der 
Funktion @mref{optimize} benutzt wird, um einen Teilausdruck zu benennen.
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{ordergreat}
@anchor{orderless}
@deffn  {Funktion} ordergreat (@var{v_1}, @dots{}, @var{v_n})
@deffnx {Funktion} orderless (@var{v_1}, @dots{}, @var{v_n})

Die Funktion @code{ordergreat} @"andert die kanonische Anordnung der Symbole so,
dass @var{v_1} > @var{v_2} > @dots{} > @var{v_n}.  Weiterhin ist @var{v_n} 
kleiner als jedes andere Symbol, das nicht in der Liste enthalten ist.

@code{orderless} @"andert die kanonische Anordnung der Symbole so, dass
@var{v_1} < @var{v_2} < @dots{} < @var{v_n}.  Weiterhin ist @var{v_n}
gr@"o@ss{}er als jedes andere Symbol, das nicht in der Liste enthalten ist.

Die durch @code{ordergreat} und @code{orderless} definierte Ordnung wird durch
@mref{unorder} wieder aufgehoben.  @code{ordergreat} und @code{orderless} 
k@"onnen jeweils nur einmal aufgerufen werden, solange nicht mit @code{unorder} 
zuvor die definierte Ordnung aufgehoben wird.

Siehe auch @mrefcomma{ordergreatp} @mref{orderlessp} und @mrefdot{mainvar}
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{ordergreatp}
@anchor{orderlessp}
@deffn  {Funktion} ordergreatp (@var{expr_1}, @var{expr_2})
@deffnx {Funktion} orderlessp (@var{expr_1}, @var{expr_2})

Die Funktion @code{ordergreatp} gibt @code{true} zur@"uck, wenn in der 
kanonischen Ordnung von Maxima @var{expr_1} gr@"o@ss{}er als @var{expr_2} ist.
Ansonsten ist das Ergebnis @code{false}.

Die Funktion @code{orderlessp} gibt @code{true} zur@"uck, wenn in der 
kanonischen Ordnung von Maxima @var{expr_1} kleiner als @var{expr_2} ist.
Ansonsten ist das Ergebnis @code{false}.

Alle Maxima-Atome und Ausdr@"ucke sind vergleichbar unter @code{ordergreatp} und
@code{orderlessp}.  Die kanonische Ordnung von Atomen ist folgenderma@ss{}en:

@flushleft
   Numerische Konstanten <
   deklarierte Konstanten <
   deklarierte Skalare <
   erstes Argument von @code{orderless} <
   weitere Argumente von @code{orderless} <
   letztes Argument von @code{orderless} <
   Variablen beginnend mit a, ... <
   Variablen beginnend mit Z <
   letzte Argument von @code{ordergreat} <
   weitere Argumente von @code{ordergreat} <
   erste Argument von @code{ordergreat} <
   deklarierte Hauptvariablen.
@end flushleft

Die Ordnung f@"ur Ausdr@"ucke, die keine Atome sind, wird von der f@"ur Atome 
abgeleitet.  F@"ur die Operatoren @code{"+"}, @code{"*"} und @code{"^"} kann die
Ordnung nicht einfach beschrieben werden.  Andere Operatoren, Funktionen und 
Ausdr@"ucke werden angeordnet nach den Argumenten, dann nach den Namen.
Bei Ausdr@"ucken mit Indizes wird der Name des Symbols als Operator und der 
Index als Argument betrachtet.

Die kanonische Ordnung der Ausdr@"ucke wird modifiziert durch die Funktionen
@mref{ordergreat} und @mref{orderless} sowie der Deklarationen
@mrefcomma{mainvar} @mref{constant} und @mrefdot{scalar}

Siehe auch @mrefdot{sort}

Beispiele:

Ordne Symbole und Konstanten.  @mref{%pi} wird nicht nach dem numerischen Wert
sortiert, sondern wie eine Konstante.

@example
(%i1) stringdisp : true;
(%o1)                         true
(%i2) sort ([%pi, 3b0, 3.0, x, X, "foo", 3, a, "bar", 4.0, 4b0]);
(%o2) [3, 3.0, 4.0, 3.0b0, 4.0b0, %pi, "bar", "foo", a, x, X]
@end example

Anwendung der Funktionen @code{ordergreat} und @code{orderless}.

@example
(%i1) sort ([M, H, K, T, E, W, G, A, P, J, S]);
(%o1)           [A, E, G, H, J, K, M, P, S, T, W]
(%i2) ordergreat (S, J);
(%o2)                         done
(%i3) orderless (M, H);
(%o3)                         done
(%i4) sort ([M, H, K, T, E, W, G, A, P, J, S]);
(%o4)           [M, H, A, E, G, K, P, T, W, J, S]
@end example

Anwendung der Deklarationen @code{mainvar}, @code{constant} und @code{scalar}.

@example
(%i1) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
(%o1)   [aa, bar, baz, bb, cc, dd, foo, quux, A1, B1, C1]
(%i2) declare (aa, mainvar);
(%o2)                         done
(%i3) declare ([baz, quux], constant);
(%o3)                         done
(%i4) declare ([A1, B1], scalar);
(%o4)                         done
(%i5) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
(%o5)   [baz, quux, A1, B1, bar, bb, cc, dd, foo, C1, aa]
@end example

Ordne nicht atomare Ausdr@"ucke.

@example
(%i1) sort ([f(1), f(2), f(2, 1), g(1), g(1, 2), g(n), f(n, 1)]);
(%o1) [f(1), g(1), g(1, 2), f(2), f(2, 1), g(n), f(n, 1)]
(%i2) sort ([foo(1), X[1], X[k], foo(k), 1, k]);
(%o2)            [1, foo(1), X , k, foo(k), X ]
                              1              k
@end example
@end deffn

@c --- 20.03.2011 DK -----------------------------------------------------------
@anchor{ordermagnitudep}
@deffn {Funktion} ordermagnitudep (@var{expr_1}, @var{expr_2})

Ist eine Aussagefunktion, die das Ergebnis @code{true} hat, wenn die Argumente
@var{expr_1} und @var{expr_2} Zahlen, Konstante oder konstante Ausdr@"ucke
repr@"asentieren und @var{expr_1} kleiner als @var{expr_2} ist.  Sind die
Argumente nicht der Gr@"o@ss{}e nach vergleichbar, wird die Ordnung durch die
Aussagefunktion @mref{orderlessp} bestimmt.

Wird die Aussagefunktion @code{ordermagnitudep} als Argument der Funktion 
@mref{sort} verwendet, werden die Elemente einer Liste nach der Gr@"o@ss{}e
sortiert.

Beispiele:

@example
(%i1) ordermagnitudep(1, 2);
(%o1)                         true
(%i2) ordermagnitudep(%e, %pi);
(%o2)                         true
(%i3) sort([%e, %pi, sin(1), 0, 1, 2, 3, 4]);
(%o3)           [0, 1, 2, 3, 4, %e, %pi, sin(1)]
(%i4) sort([%e, %pi, sin(1), 0, 1, 2, 3, 4], ordermagnitudep);
(%o4)           [0, sin(1), 1, 2, %e, 3, %pi, 4]
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{part}
@deffn {Funktion} part (@var{expr}, @var{n_1}, @dots{}, @var{n_k})

Die Funktion @code{part} gibt einen Teilausdruck des Ausdrucks @var{expr}
zur@"uck.  Der Ausdruck @var{expr} wird zuvor in das Format f@"ur die Anzeige
umgewandelt.

Der Teilausdruck wird durch die Indizes @var{n_1}, @dots{}, @var{n_k} 
ausgew@"ahlt.  Zuerst wird der Teilausdruck @var{n_1} ermittelt, von diesem der
Teilausdruck @var{n_2}, u.s.w.  Der zum Index @var{n_k} zuletzt gewonnene 
Teilausdruck ist dann das Ergebnis.

@code{part} kann auch verwendet werden, um ein Element einer Liste oder die
Zeile einer Matrix zu erhalten.

Das letzte Argument einer @code{part}-Funktion kann eine Liste mit Indizes sein.
In diesem Fall werden alle angegebenen Teilausdr@"ucke als Ergebnis
zur@"uckgegeben.  Zum Beispiel hat das Kommando @code{part(x + y + z, [1, 3])}
das Ergebnis @code{z+x}.

Die Systemvariable @mref{piece} enth@"alt den letzten Ausdruck, der bei der
Verwendung einer @code{part}-Funktion ausgew@"ahlt wurde.

Hat die Optionsvariable @mref{partswitch} den Wert @code{true}, wird @code{end}
zur@"uckgegeben, wenn versucht wurde, einen Teilausdruck zu bilden, der nicht
existiert, andernfalls wird eine Fehlermeldung ausgegeben.

Siehe auch @mrefcomma{inpart} @mrefcomma{substpart} @mrefcomma{substinpart}@w{}
@mref{dpart} und @mrefdot{lpart}
 
Beispiele:

@example
(%i1) part(z+2*y+a,2);
(%o1)                                 2 y
(%i2) part(z+2*y+a,[1,3]);
(%o2)                                z + a
(%i3) part(z+2*y+a,2,1);
(%o3)                                  2
@end example

@code{example(part)} zeigt weitere Beispiele.
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{partition}
@deffn {Funktion} partition (@var{expr}, @var{var})

Die Funktion @code{partition} gibt eine Liste mit zwei Ausdr@"ucken zur@"uck.
Ist das Argument @var{expr} ein Produkt enth@"alt das erste Element die
Faktoren, die die Variable @code{var} enthalten, und das zweite Element
enth@"alt die @"ubrigen Faktoren.  Entsprechend enth@"alt das erste Element die
Terme einer Summe oder die Elemente einer Liste, die die Variable @var{var}
enthalten, und das zweite Elemente die verbleibende Terme der Summe oder
Elemente der Liste.

@example
(%i1) partition (2*a*x*f(x), x);
(%o1)                     [2 a, x f(x)]
(%i2) partition (a+b, x);
(%o2)                      [b + a, 0]
(%i3) partition ([a, b, f(a), c], a); 
(%o3)                  [[b, c], [a, f(a)]]
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{partswitch}
@defvr {Optionsvariable} partswitch
Standardwert: @code{false}

Hat die Optionsvariable @code{partswitch} den Wert @code{true}, wird @code{end} 
zur@"uckgegeben, wenn versucht wird, einen Teilausdruck zu bilden, der nicht
existiert, andernfalls wird eine Fehlermeldung ausgegeben.
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{pickapart}
@deffn {Funktion} pickapart (@var{expr}, @var{n})

Den Teilausdr@"ucken in einer Tiefe @var{n} eines verschachtelten Ausdrucks 
werden Zwischenmarken zugewiesen.  @var{n} ist eine ganze positive Zahl.  Die 
R@"uckgabe von @code{pickapart} ist ein @"aquivalenter Ausdruck, der die 
Zwischenmarken enth@"alt.

Siehe auch @mrefcomma{part} @mrefcomma{dpart} @mrefcomma{lpart}@w{}
@mref{inpart} und @mrefdot{reveal}

Beispiele:

@example
(%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
@group
                                          2
                                     sin(x )   b + a
(%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2
@end group
(%i2) pickapart (expr, 0);

                                          2
                                     sin(x )   b + a
(%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2

(%o2)                          %t2
(%i3) pickapart (expr, 1);

(%t3)                - log(sqrt(x + 1) + 1)


                                  2
                             sin(x )
(%t4)                        -------
                                3


                              b + a
(%t5)                         -----
                                2

(%o5)                    %t5 + %t4 + %t3
(%i5) pickapart (expr, 2);

(%t6)                 log(sqrt(x + 1) + 1)


                                  2
(%t7)                        sin(x )


(%t8)                         b + a

                         %t8   %t7
(%o8)                    --- + --- - %t6
                          2     3
(%i8) pickapart (expr, 3);

(%t9)                    sqrt(x + 1) + 1


                                2
(%t10)                         x

@group
                  b + a              sin(%t10)
(%o10)            ----- - log(%t9) + ---------
                    2                    3
@end group
(%i10) pickapart (expr, 4);

(%t11)                     sqrt(x + 1)

                      2
                 sin(x )   b + a
(%o11)           ------- + ----- - log(%t11 + 1)
                    3        2
(%i11) pickapart (expr, 5);

(%t12)                        x + 1

                   2
              sin(x )   b + a
(%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                 3        2
(%i12) pickapart (expr, 6);
                  2
             sin(x )   b + a
(%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                3        2
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{piece}
@defvr {Systemvariable} piece

Die Systemvariable @code{piece} enth@"alt den letzten Ausdruck, der bei der 
Verwendung einer @code{part}-Funktion ausgew@"ahlt wurde.

Siehe auch @mref{part} und @mrefdot{inpart}
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{psubst}
@deffn  {Funktion} psubst (@var{list}, @var{expr})
@deffnx {Funktion} psubst (@var{a}, @var{b}, @var{expr})

@code{psubst(@var{a}, @var{b}, @var{expr})} ist identisch mit @code{subst}.
Siehe @mrefdot{subst}

Im Unterschied zu @code{subst} f@"uhrt die Funktion @code{psubst} Substitutionen
parallel aus, wenn das erste Argument @var{list} eine Liste mit Gleichungen ist.

Siehe auch die Funktion @mrefcomma{sublis} um Substitutionen parallel
auszuf@"uhren.

Beispiel:

Das erste Beispiel zeigt die parallele Substitution mit @code{psubst}.  Das 
zweite Beispiel zeigt das Ergebnis f@"ur die Funktion @code{subst}.  In diesem
Fall werden die Substitutionen nacheinander ausgef@"uhrt.

@example
(%i4) psubst ([a^2=b, b=a], sin(a^2) + sin(b));
(%o4)                           sin(b) + sin(a)
(%i5) subst ([a^2=b, b=a], sin(a^2) + sin(b));
(%o5)                              2 sin(a)
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{rembox}
@need 800
@deffn  {Funktion} rembox (@var{expr}, unlabelled)
@deffnx {Funktion} rembox (@var{expr}, @var{label})
@deffnx {Funktion} rembox (@var{expr})

Die Funktion @code{rembox} entfernt Rahmen aus dem Ausdruck @var{expr}.
@code{rembox(@var{expr}, unlabelled)} entfernt alle Rahmen, die keine Marke 
haben.  @code{rembox(@var{expr}, @var{label})} entfernt nur Rahmen, die mit der 
Marke @var{label} gekennzeichnet sind.  @code{rembox(@var{expr})} entfernt alle 
Rahmen.

Rahmen werden mit den Funktionen @mrefcomma{box} @mref{dpart} und
@mref{lpart} einem Ausdruck hinzugef@"ugt.

Beispiele:

@example
(%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                  a d - b c
(%o1)                sin(%pi x) + ---------
                                      2
                                     h

(%i2) dpart (dpart (expr, 1, 1), 2, 2);
                        """""""    a d - b c
(%o2)               sin("%pi x") + ---------
                        """""""      """"
                                     " 2"
                                     "h "
                                     """"

(%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                  FOO"""""""""""   BAR""""""""
                  "    """"""" "   "a d - b c"
(%o3)             "sin("%pi x")" + "---------"
                  "    """"""" "   "  """"   "
                  """"""""""""""   "  " 2"   "
                                   "  "h "   "
                                   "  """"   "
                                   """""""""""

(%i4) rembox (expr2, unlabelled);
@group
                                  BAR""""""""
                   FOO"""""""""   "a d - b c"
(%o4)              "sin(%pi x)" + "---------"
                   """"""""""""   "    2    "
                                  "   h     "
                                  """""""""""

@end group
(%i5) rembox (expr2, FOO);
@group
                                  BAR""""""""
                       """""""    "a d - b c"
(%o5)              sin("%pi x") + "---------"
                       """""""    "  """"   "
                                  "  " 2"   "
                                  "  "h "   "
                                  "  """"   "
                                  """""""""""

@end group
(%i6) rembox (expr2, BAR);
@group
                   FOO"""""""""""
                   "    """"""" "   a d - b c
(%o6)              "sin("%pi x")" + ---------
                   "    """"""" "     """"
                   """"""""""""""     " 2"
                                      "h "
                                      """"

@end group
(%i7) rembox (expr2);
                                  a d - b c
(%o7)                sin(%pi x) + ---------
                                      2
                                     h
@end example
@end deffn

@c --- 28.08.2010 DK -----------------------------------------------------------
@anchor{reveal}
@deffn {Funktion} reveal (@var{expr}, @var{depth})

Ersetzt Teile des Ausdrucks @var{expr} in der ganzzahligen Tiefe @var{depth} 
durch eine beschreibende Zusammenfassung:

@itemize @bullet
@item
Summen und Differenzen werden durch @code{Sum(@var{n})} ersetzt, wobei @var{n}
die Anzahl der Terme der Summe oder Differenz ist.

@item
Produkte werden durch @code{Product(@var{n})} ersetzt, wobei @var{n} die Anzahl
der Faktoren des Produktes ist.

@item
Exponentiationen werden durch @code{Expt} ersetzt.

@item
Quotienten werden durch @code{Quotient} ersetzt.

@item
Die Negation wird durch @code{Negterm} ersetzt.

@item
Listen werden durch @code{List(@var{n})} ersetzt, wobei @var{n} die Anzahl der 
Elemente der Liste ist.
@end itemize

Ist @var{depth} gr@"o@ss{}er oder gleich der maximalen Tiefe des Ausdrucks 
@var{expr}, gibt @code{reveal} den Ausdruck @var{expr} unver@"andert zur@"uck.

@code{reveal} wertet die Argumente aus.  @code{reveal} gibt die 
Zusammenfassung zur@"uck.

Beispiele:

@example
(%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
@group
                          2            2
                         b  - 2 a b + a
(%o1)               -------------------------
                        b + a     2 b     2 a
                    2 %e      + %e    + %e
@end group
(%i2) reveal (e, 1);
(%o2)                       Quotient
(%i3) reveal (e, 2);
                             Sum(3)
(%o3)                        ------
                             Sum(3)
(%i4) reveal (e, 3);
                     Expt + Negterm + Expt
(%o4)               ------------------------
                    Product(2) + Expt + Expt
(%i5) reveal (e, 4);
                       2                 2
                      b  - Product(3) + a
(%o5)         ------------------------------------
                         Product(2)     Product(2)
              2 Expt + %e           + %e
(%i6) reveal (e, 5);
                         2            2
                        b  - 2 a b + a
(%o6)              --------------------------
                       Sum(2)     2 b     2 a
                   2 %e       + %e    + %e
(%i7) reveal (e, 6);
                          2            2
                         b  - 2 a b + a
(%o7)               -------------------------
                        b + a     2 b     2 a
                    2 %e      + %e    + %e
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{sublis}
@deffn {Funktion} sublis (@var{list}, @var{expr})

F@"uhrt im Unterschied zu der Funktion @mref{subst} die Substitutionen der
Liste @var{list} parallel und nicht nacheinander aus.

Mit der Optionsvariablen @mref{sublis_apply_lambda} wird die Vereinfachung
von Lamda-Ausdr@"ucken kontrolliert, nachdem die Substitution ausgef@"uhrt 
wurde.

Siehe auch die Funktion @mrefcomma{psubst} um parallele Substitutionen
auszuf@"uhren.

Beispiele:

@example
(%i1) sublis ([a=b, b=a], sin(a) + cos(b));
(%o1)                    sin(b) + cos(a)
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{sublis_apply_lambda}
@need 800
@defvr {Optionsvariable} sublis_apply_lambda
Standardwert: @code{true}

Kontrolliert, ob Lambda-Ausdr@"ucke nach einer Substitution ausgewertet werden.
Hat @code{sublis_apply_lambda} den Wert @code{true} werden Lambda-Ausdr@"ucke
ausgewertet.  Ansonsten verbleiben diese nach der Substitution im Ausdruck.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{subnumsimp}
@defvr {Option variable} subnumsimp
Default value: @code{false}

If @code{true} then the functions @mref{subst} and @mref{psubst} can substitute
a subscripted variable @code{f[x]} with a number, when only the symbol @code{f}
is given.

See also @mrefdot{subst}

@example
(%i1) subst(100,g,g[x]+2);

subst: cannot substitute 100 for operator g in expression g
                                                           x
 -- an error. To debug this try: debugmode(true);

(%i2) subst(100,g,g[x]+2),subnumsimp:true;
(%o2)                          102
@end example
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{subst}
@deffn {Funktion} subst (@var{a}, @var{b}, @var{c})

Substituiert @var{a} f@"ur @var{b} in den Ausdruck @var{c}.  Das Argument 
@var{b} muss ein Atom oder ein vollst@"andiger Teilausdruck von @var{c} sein.
Zum Beispiel ist @code{x+y+z} ein vollst@"andiger Teilausdruck von
@code{2*(x+y+z)/w}, nicht aber @code{x+y}.  Hat @var{b} nicht diese Eigenschaft,
dann k@"onnen m@"oglicherweise die Funktionen @mref{substpart} oder 
@mref{ratsubst} angewendet werden.

Hat @var{b} die Form @code{e/f}, kann @code{subst(a*f, e, c)} verwendet werden.
Ist @code{b} von der Form @code{e^(1/f)}, dann kann @code{subst(a^f, e, c)}
verwendet werden.  Die Funktion @code{subst} erkennt auch den Ausdruck 
@code{x^y} in @code{x^-y}, so dass @code{subst(a, sqrt(x), 1/sqrt(x))} das
Ergebnis @code{1/a} hat.  @var{a} und @var{b} k@"onnen auch die Namen von 
Operatoren oder Funktionen sein.  Soll die unabh@"angige Variable in
Ausdr@"ucken mit Ableitungen substituiert werden, sollte die Funktion
@mref{at} verwendet werden.

@code{subst} ist der Alias-Name f@"ur @code{substitute}.

@code{subst(@var{eq_1}, @var{expr})} und @code{subst([@var{eq_1}, ..., 
@var{eq_k}], @var{expr})} sind weitere m@"ogliche Formen.  @var{eq_i} sind
Gleichungen, die angeben, welche Substitutionen auszuf@"uhren sind.  F@"ur 
jede Gleichung wird die rechte Seite der Gleichung f@"ur die linke Seite in den
Ausdruck @var{expr} substituiert.

Hat die Optionsvariable @mref{exptsubst} den Wert @code{true}, wird eine
Substitution wie @code{y} f@"ur @code{%e^x} in einem Ausdruck der Form 
@code{%e^(a*x)} nicht ausgef@"uhrt.

Hat die Optionsvariable @mxref{option_opsubst, opsubst} den Wert @code{false},
f@"uhrt die Funktion @code{subst} keine Substitution in einen Operator eines
Ausdrucks aus.  Zum Beispiel hat @code{(opsubst: false, subst(x^2, r, r+r[0]))}
das Ergebnis @code{x^2+r[0]}.

Beispiele:

@example
(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
@end example

@noindent
Weitere Beispiele werden mit @code{example(subst)} angezeigt.
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{substinpart}
@deffn {Funktion} substinpart (@var{x}, @var{expr}, @var{n_1}, @dots{}, @var{n_k})

Die Funktion @code{substinpart} ist vergleichbar mit @mrefdot{substpart}@w{}
@code{substinpart} wirkt jedoch auf die interne Darstellung des Ausdrucks 
@var{expr}.

Beispiele:

@example
(%i1) x . 'diff (f(x), x, 2);
@group
                              2
                             d
(%o1)                   x . (--- (f(x)))
                               2
                             dx
@end group
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x + 1), 0);
(%o3)                       f1(x + 1)
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{substpart}
@deffn {Funktion} substpart (@var{x}, @var{expr}, @var{n_1}, @dots{}, @var{n_k})

Substituiert @var{x} f@"ur den Teilausdruck, der mit den restlichen Argumenten 
der Funktion @code{substpart} ausgew@"ahlt wird.  Es wird der neue Ausdruck 
@var{expr} zur@"uckgegeben.  @var{x} kann auch der Name eines Operators sein,
der f@"ur einen Operator im Ausdruck @var{expr} substituiert wird.  Zum Beispiel
hat @code{substpart("+", a*b, 0)} das Ergebnis @code{b + a}).

Mit dem Wert @code{true} f@"ur die Optionsvariable @mrefcomma{inflag} verh@"alt
sich die Funktion @code{substpart} wie @mrefdot{substinpart}

Beispiele:

@example
(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
@group
                               1
(%o2)                       --------
                             3/2
                            x    + 2
@end group
(%i3) a*x + f(b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart ("+", %, 1, 0);
(%o4)                    x + f(b, y) + a
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{symbolp}
@deffn {Funktion} symbolp (@var{expr})

Gibt @code{true} zur@"uck, wenn @var{expr} ein Symbol ist, ansonsten 
@code{false}.  Das Kommando @code{symbolp(x)} ist @"aquivalent zu
@code{atom(x) and not numberp(x)}.

Siehe auch @nrefdot{Bezeichner}
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{unorder}
@deffn {Funktion} unorder ()

L@"oscht die Ordnung, die mit dem letzten Aufruf der Funktionen 
@code{ordergreat} oder @code{orderless} erzeugt wurde.

Siehe auch @mref{ordergreat} und @mrefdot{orderless}

Beispiele:

@example
(%i1) unorder();
(%o1)                          []
(%i2) b*x + a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat (a);
(%o3)                         done
(%i4) b*x + a^2;
 %th(1) - %th(3);
                             2
(%o4)                       a  + b x
(%i5) unorder();
                              2    2
(%o5)                        a  - a
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{verbify}
@deffn {Funktion} verbify (@var{f})

Gibt das Verb des Symbols @var{f} zur@"uck.  Siehe auch das Kapitel
@nrefcomma{Substantive und Verben} sowie @mref{noun} und @mrefdot{nounify}

Beispiele:

@example
(%i1) verbify ('foo);
(%o1)                          foo
(%i2) :lisp $%
$FOO
(%i2) nounify (foo);
(%o2)                          foo
(%i3) :lisp $%
%FOO
@end example
@end deffn

@c --- End of file Expressions.de.texi -----------------------------------------

