@c -----------------------------------------------------------------------------
@c File        : Equations.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Equations.texi revision 15.06.2011
@c Translation : Dr. Dieter Kaiser
@c Date        : 13.11.2010
@c Revision    : 08.07.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Funktionen und Variablen f@"ur Gleichungen::
@end menu

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Gleichungen,  , Gleichungen, Gleichungen
@section Funktionen und Variablen f@"ur Gleichungen
@c -----------------------------------------------------------------------------

@c TODO: %RNUM IST IM ENGLISCHEN MANUAL NICHT DOKUMENTIERT.

@c --- 14.11.2010 DK -----------------------------------------------------------
@anchor{%rnum}
@defvr {Optionsvariable} %rnum
Standardwert: @code{0}

Wenn notwendig erzeugen die Funktionen @mref{solve} und @mref{algsys} freie
Parameter, die in die L@"osungen eingesetzt werden.  Die Parameter haben den 
Namen @code{%r<@var{num}>}.  Die Optionsvariable @code{%rnum} enth@"alt die
Nummer @var{num}, die an den Pr@"afix @code{%r} angeh@"angt wird.  Maxima
erh@"oht @code{%rnum} automatisch.  Siehe auch die Systemvariable
@mref{%rnum_list} f@"ur eine Liste der Parameter einer L@"osung.
@end defvr

@c --- 14.11.2010 DK -----------------------------------------------------------
@anchor{%rnum_list}
@defvr {Systemvariable} %rnum_list
Standardwert: @code{[]}

@code{%rnum_list} ist die Liste der freien Parameter, die von @mref{solve} und
@mref{algsys} in L@"osungen eingesetzt werden.  Die Parameter werden der Liste
@code{%rnum_list} in der Reihenfolge hinzugef@"ugt, in der sie erzeugt werden.

Beispiele:

@example
@group
(%i1) solve ([x + y = 3], [x,y]);
(%o1)              [[x = 3 - %r1, y = %r1]]
@end group
@group
(%i2) %rnum_list;
(%o2)                       [%r1]
@end group
@group
(%i3) sol : solve ([x + 2*y + 3*z = 4], [x,y,z]);
(%o3)   [[x = - 2 %r3 - 3 %r2 + 4, y = %r3, z = %r2]]
@end group
@group
(%i4) %rnum_list;
(%o4)                     [%r2, %r3]
@end group
@group
(%i5) for i : 1 thru length (%rnum_list) do
        sol : subst (t[i], %rnum_list[i], sol)$
@end group
@group
(%i6) sol;
(%o6)     [[x = - 2 t  - 3 t  + 4, y = t , z = t ]]
                     2      1           2       1
@end group
@end example
@end defvr

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{algexact}
@defvr {Optionsvariable} algexact
Standardwert: @code{false}

Die Optionsvariable @code{algexact} kontrolliert die Funktion @mref{algsys}@w{}
folgenderma@ss{}en:

@itemize @bullet
@item
Hat @code{algexact} den Wert @code{true}, wird von der Funktion @code{algsys} 
stets @mref{solve} aufgerufen.  Findet @code{solve} keine L@"osung, wird die 
Funktion @mref{realroots} aufgerufen.

@item
Hat @code{algexact} den Wert @code{false}, wird die Funktion @code{solve} nur
f@"ur Gleichungen aufgerufen, die von mehr als einer Variablen abh@"angen und
f@"ur quadratische oder kubische Gleichungen.
@end itemize

Der Wert @code{true} f@"ur @code{algexact} garantiert nicht, dass @code{algsys}
nur exakte L@"o@-sung@-en findet.  Findet @code{algsys} keine exakten
L@"osungen, versucht @code{solve} immer N@"aherungsl@"osungen zu finden.

Beispiele:

@example
(%i1) algexact:true$

(%i2) algsys([x^5-1],[x]);
                                      sqrt(5)   5
                               sqrt(- ------- - -)
                     sqrt(5)             2      2    1
(%o2) [[x = 1], [x = ------- + ------------------- - -], 
                        4               2            4
                      sqrt(5)   5
               sqrt(- ------- - -)
     sqrt(5)             2      2    1
[x = ------- - ------------------- - -], 
        4               2            4
                      sqrt(5)   5
                 sqrt(------- - -)
       sqrt(5)           2      2    1
[x = - ------- + ----------------- - -], 
          4              2           4
                      sqrt(5)   5
                 sqrt(------- - -)
       sqrt(5)           2      2    1
[x = - ------- - ----------------- - -]]
          4              2           4

(%i3) algexact:false$

(%i4) algsys([x^5-1],[x]);
(%o4) [[x = 1], [x = - .5877852522924731 %i
 - .8090169943749475], [x = .5877852522924731 %i
 - .8090169943749475], [x = .3090169943749475
 - .9510565162951535 %i], [x = .9510565162951535 %i
 + .3090169943749475]]
@end example

Auch wenn die Optionsvariable @code{algexact} den Wert @code{true} hat, gibt
@code{algsys} numerische N@"aherungsl@"osungen zur@"uck, wenn @code{solve}
keine L@"osungen finden kann.

@example
(%i5) algexact:true$

(%i6) algsys([x^5-x^3+1],[x]);
(%o6) [[x = - 1.236505681818182], 
[x = - 0.785423103049449 %i - .3407948661970064], 
[x = 0.785423103049449 %i - .3407948661970064], 
[x = .9590477178927559 - .4283659562541893 %i], 
[x = .4283659562541893 %i + .9590477178927559]]

(%i7) solve([x^5-x^3+1],[x]);
                              5    3
(%o7)                   [0 = x  - x  + 1]
@end example

F@"ur eine quadratische Gleichung wird immer eine exakte L@"osung zur@"uckgeben.

@example
(%i8) algsys:true$

(%i9) algsys([x^2+x-1],[x]);
                 sqrt(5) - 1          sqrt(5) + 1
(%o9)      [[x = -----------], [x = - -----------]]
                      2                    2
(%i11) algsys:false$

(%i12) algsys([x^2+x-1],[x]);
                  sqrt(5) - 1          sqrt(5) + 1
(%o12)      [[x = -----------], [x = - -----------]]
                       2                    2
@end example
@end defvr

@c TODO: DOKUMENATATION ALGDELTA FEHLT

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{algepsilon}
@defvr {Optionsvariable} algepsilon
Standardwert: @code{10^8}

Kontrolliert die Genauigkeit einer numerischen L@"osung der Funktion 
@mref{algsys} f@"ur den Fall, dass die Optionsvariable @mref{realonly} den Wert
@code{true} hat, also nur die reellen L@"osungen gesucht werden.

Beispiele:

Numerische L@"osung der Gleichung @code{x^3-2} f@"ur zwei verschiedene Wert
f@"ur @code{algepsilon}.

@example
(%i1) realonly:true$
(%i2) algepsilon:10^2;
(%o2)                          100
(%i3) algsys([x^3-2],[x]);
(%o3)                  [[x = 1.26171875]]
(%i4) algepsilon: 10^8;
(%o4)                       100000000
(%i5) algsys([x^3-2],[x]);
(%o5)               [[x = 1.259921095381759]]
@end example

@code{algepsilon} hat keinen Einfluss auf die Genauigkeit der L@"osung, wenn
auch die komplexen L@"osungen gesucht werden.

@example
(%i6) realonly:false$
(%i7) algepsilon: 10^2;
(%o7)                          100
(%i8) algsys([x^3-2],[x]);
(%o8) [[x = - 1.091123635971721 %i - .6299605249474366], 
[x = 1.091123635971721 %i - .6299605249474366], 
[x = 1.259921095381759]]
@end example
@end defvr

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{algsys}
@deffn  {Funktion} algsys ([@var{expr_1}, @dots{}, @var{expr_m}], [@var{x_1}, @dots{}, @var{x_n}])
@deffnx {Funktion} algsys ([@var{eqn_1}, @dots{}, @var{eqn_m}], [@var{x_1}, @dots{}, @var{x_n}])

L@"ost ein Gleichungssystem mit den Polynomen @var{expr_1}, @dots{},
@var{expr_m} oder den Gleichungen @var{eqn_1}, @dots{}, @var{eqn_m} f@"ur die
Variablen @var{x_1}, @dots{}, @var{x_n}.  Werden Polynome @var{expr_i} als
Argument @"ubergeben, werden diese als Gleichungen @code{expr_i = 0}
interpretiert.  Die Anzahl der Gleichungen und Variablen kann verschieden sein.

@code{algsys} gibt eine Liste mit den L@"osungen zur@"uck.  Jede L@"osung ist
wiederum eine Liste mit den L@"osungen f@"ur die einzelnen Variablen @var{x_i},
die als Gleichungen angegeben sind.  Kann @code{algsys} keine L@"osung finden,
wird eine leere Liste @code{[]} zur@"uckgegeben.

Haben die L@"osungen freie Parameter, setzt @code{algsys} die Symbole
@code{%r1}, @code{%r2}, @dots{} in die L@"osungen ein.  Die freien Parameter
werden der Liste @code{%rnum_list} hinzugef@"ugt.  Siehe @mrefdot{%rnum_list}

Die Funktion @code{algsys} f@"uhrt die folgenden Schritte aus, um L@"osungen
eines Gleichungssystems zu finden:

@enumerate
@item
Die Gleichungen werden faktorisiert und in Teilsysteme @var{S_i} aufgeteilt.

@item
F@"ur jedes Teilsystem @var{S_i} werden eine Gleichung @var{E}, die den
niedrigsten von Null verschiedenen Grad hat und eine Variable @var{x}
ausgew@"ahlt.  Dann wird die Resultante der Gleichungen @var{E} und @var{E_j}
f@"ur die Variable @var{x} sowie allen verbleibenden Gleichungen @var{E_j} des
Teilsystems @var{S_i} berechnet.  Dieses Verfahren eliminiert die Variable
@var{x} und hat ein neues Teilsystem @var{S_i'} als Ergebnis.  Der Algorithmus
wiederholt dann den 1. Schritt.

@item
Besteht das Teilsystem nur noch aus einer Gleichung, hat diese Gleichung
mehrere Variablen und enth@"alt diese keine Gleitkommazahlen, dann wird 
@mref{solve} aufgerufen, um eine exakte L@"osung zu finden.

Es kann sein, dass @code{solve} keine L@"osung oder einen sehr gro@ss{}en 
Ausdruck als L@"osung findet.

Auch f@"ur Gleichungen, die nur eine Variable enthalten und die entweder linear,
quadratisch oder quartisch sind sowie keine Gleitkommazahlen enthalten, wird 
@code{solve} aufgerufen, um eine exakte L@"osung zu finden.  Trifft dies nicht 
zu, wird in dem Fall, dass die @mref{realonly} den Wert @code{true} hat, die
Funktion @mrefdot{realroots}  Ansonsten wird die Funktion @mref{allroots}@w{}
aufgerufen.  Die Funktion @code{realroots} sucht reelle L@"osungen der
Gleichung, w@"ahrend die Funktion @code{allroots} auch komplex L@"osungen sucht.

F@"ur den Fall, dass @code{realonly} den Wert @code{true} hat, wird die
Genauigkeit einer numerischen L@"osung von der Optionsvariablen
@mref{algepsilon} kontrolliert.

Hat die Optionsvariable @mref{algexact} den Wert @code{true}, wird immer die
Funktion @code{solve} aufgerufen.

@item
Zuletzt werden die erhaltenen L@"osungen in das betrachtete Teilsystem 
eingesetzt und der L@"osungsalgorithmus mit dem 1. Schritt fortgesetzt.
@end enumerate

Tritt beim L@"osen des Gleichungssystems eine Gleichung auf, die von mehreren
Variablen abh@"angt und Gleitkommazahlen enth@"alt, dann wird der Algorithmus 
mit der Meldung @code{algsys cannot solve - system too complicated."}
abgebrochen.  Ein N@"aherung mit Gleitkommazahlen kann in vorgehenden Schritten 
auftreten, wenn keine exakten L@"osungen auffindbar sind.

Ist das Argument der Funktion @mref{allroots} kein Polynom, gibt Maxima eine
Fehlermeldung aus.  Die L@"osungen eines Gleichungssystems k@"onnen sehr
gro@ss{}e Ausdr@"ucke sein.  Obwohl die L@"osung reell ist, kann die imagin@"are
Einheit @code{%i} in den L@"osungen enthalten sein.  F@"ur die weitere
Bearbeitung der L@"osungen k@"onnen die Funktionen @mref{pickapart} oder
@mref{reveal} hilfreich sein.

Beispiele:

@example
(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
@end example
@end deffn

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{allroots}
@deffn  {Funktion} allroots (@var{expr})
@deffnx {Funktion} allroots (@var{eqn})

Berechnet numerische N@"aherungen der reellen und komplexen Wurzeln 
des Polynoms @var{expr} oder der Polynomgleichung @var{eqn} mit einer Variablen.

Hat der Schalter @mref{polyfactor} den Wert @code{true}, wird das Polynom
@"uber die reellen oder komplexen Zahlen faktorisiert.

F@"ur den Fall mehrfacher Wurzeln kann @code{allroots} ungenaue Ergebnisse 
liefern.  Ist das Polynom reell, kann es sein, dass @code{allroots(%i*@var{p})})
genauere Approximationen liefern als @code{allroots (@var{p})}, da
@code{allroots} in diesem Fall einen anderen Algorithmus verwendet.

Der Z@"ahler des Arguments der Funktion @code{allroots} muss nach Anwendung der
Funktion @code{rat} ein Polynom sein und darf im Nenner h@"ochstens eine 
komplexe Zahl enthalten.  Ist das Argument der Funktion @code{allroots} kein 
Polynom, gibt Maxima eine Fehlermeldung.  Daher wird von der Funktion
@code{allroots} immer ein @"aquivalenter, jedoch faktorisierter Ausdruck
zur@"uckgegeben, wenn die Optionsvariable @mref{polyfactor} den Wert @code{true}
hat.

F@"ur komplexe Polynome wird ein Algorithmus von Jenkins und Traub verwendet 
(Algorithm 419, @i{Comm. ACM}, vol. 15, (1972), p. 97).
F@"ur reelle Polynome wird ein Algorithmus von Jenkins verwendet
(Algorithm 493, @i{ACM TOMS},vol. 1, (1975), p.178).

Beispiele:

@example
(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
@end example
@end deffn

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{bfallroots}
@deffn  {Funktion} bfallroots (@var{expr})
@deffnx {Funktion} bfallroots (@var{eqn})

Berechnet numerische N@"aherungen der reellen und komplexen Wurzeln des Polynoms 
@var{expr} oder der Polynomgleichung @var{eqn} in einer Variable.

@code{bfallroots} entspricht der Funktion @code{allroots} mit dem Unterschied,
dass die Funktion @code{bfallroots} die N@"aherungen mit gro@ss{}en
Gleitkommazahlen berechnet.  Siehe @mrefdot{allroots}

Beispiel:

Dasselbe Beispiel wie für die Funktion @code{allroots}.  Die Ergebnisse
sind gro@ss{}e Gleitkommazahlen.

@example
(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
@group
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
@end group
(%i2) soln: bfallroots(eqn);
(%o2) [x = 8.296749902129362b-1, x = - 1.015755543828121b0, 
x = 9.65962515219637b-1 %i - 4.069597231924075b-1, 
x = - 9.65962515219637b-1 %i - 4.069597231924075b-1, x = 1.0b0]
@end example
@end deffn

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{backsubst}
@defvr {Optionsvariable} backsubst
Standardwert: @code{true}

Hat @code{backsubst} den Wert @code{false}, werden die L@"osungen der Funktion
@mref{linsolve} nicht r@"ucksubstituiert.  Dies kann hilfreich sein, wenn die
R@"ucksubstitution zu sehr gro@ss{}en Ausdr@"ucken f@"uhrt.

Beispiele:

@example
(%i1) eq1 : x + y + z = 6$
(%i2) eq2 : x - y + z = 2$
(%i3) eq3 : x + y - z = 0$
(%i4) backsubst : false$
@group
(%i5) linsolve ([eq1, eq2, eq3], [x,y,z]);
(%o5)             [x = z - y, y = 2, z = 3]
@end group
(%i6) backsubst : true$
@group
(%i7) linsolve ([eq1, eq2, eq3], [x,y,z]);
(%o7)               [x = 1, y = 2, z = 3]
@end group
@end example
@end defvr

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{breakup}
@defvr {Optionsvariable} breakup
Standardwert: @code{true}

Hat die Optionsvariablen @mref{programmode} den Wert @code{false} und die
Optionsvariable @code{breakup} den Wert @code{true}, dann werden f@"ur
gemeinsame Terme in L@"osungen von kubischen und quartischen Gleichungen
Zwischenmarken erzeugt.

Beispiele:

@example
(%i1) programmode: false$
(%i2) breakup: true$
(%i3) solve (x^3 + x^2 - 1);

                        sqrt(23)    25 1/3
(%t3)                  (--------- + --)
                        6 sqrt(3)   54
Solution:

                                      sqrt(3) %i   1
                                      ---------- - -
                sqrt(3) %i   1            2        2   1
(%t4)    x = (- ---------- - -) %t3 + -------------- - -
                    2        2            9 %t3        3

@group
                                      sqrt(3) %i   1
                                    - ---------- - -
              sqrt(3) %i   1              2        2   1
(%t5)    x = (---------- - -) %t3 + ---------------- - -
                  2        2             9 %t3         3
@end group

                                   1     1
(%t6)                  x = %t3 + ----- - -
                                 9 %t3   3
(%o6)                    [%t4, %t5, %t6]
(%i6) breakup: false$
(%i7) solve (x^3 + x^2 - 1);
Solution:

             sqrt(3) %i   1
             ---------- - -
                 2        2        sqrt(23)    25 1/3
(%t7) x = --------------------- + (--------- + --)
             sqrt(23)    25 1/3    6 sqrt(3)   54
          9 (--------- + --)
             6 sqrt(3)   54

                                              sqrt(3) %i   1    1
                                           (- ---------- - -) - -
                                                  2        2    3

           sqrt(23)    25 1/3  sqrt(3) %i   1
(%t8) x = (--------- + --)    (---------- - -)
           6 sqrt(3)   54          2        2

                                            sqrt(3) %i   1
                                          - ---------- - -
                                                2        2      1
                                      + --------------------- - -
                                           sqrt(23)    25 1/3   3
                                        9 (--------- + --)
                                           6 sqrt(3)   54

            sqrt(23)    25 1/3             1             1
(%t9)  x = (--------- + --)    + --------------------- - -
            6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                 9 (--------- + --)
                                    6 sqrt(3)   54
(%o9)                    [%t7, %t8, %t9]
@end example
@end defvr

@c TODO: DAS IST EIN PAKET UND ES FUNKTIONIERT NICHT!
@c TODO: ES GIBT NOCH EIN WEITERES PAKET MIT NAMEN DIMENSON.MAC

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{dimension}
@deffn  {Funktion} dimension (@var{eqn})
@deffnx {Funktion} dimension (@var{eqn_1}, @dots{}, @var{eqn_n})

@code{dimen} ist ein Paket f@"ur die Dimensionsanalyse.  @code{load(dimen)}
l@"adt dieses Paket.  @code{demo(dimen)} zeigt eine kleine Demonstration.
@end deffn

@c TODO: FUNKTION DER VARIABLE DISPFLAG IST UNKLAR

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{dispflag}
@defvr {Optionsvariable} dispflag
Standardwert: @code{true}

@c WHAT DOES THIS MEAN ??
@c If set to @code{false} within a @code{block} will inhibit the display of 
@c output generated by the solve functions called from within the @code{block}.
@c Termination of the @code{block} with a dollar sign, $, sets @code{dispflag} 
@c to @code{false}.

Hat @code{dispflag} den Wert @code{false}, werden Ausgaben der Funktion
@code{solve} unterdr@"uckt.
@end defvr

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{funcsolve}
@deffn {Funktion} funcsolve (@var{eqn}, @var{g}(@var{t}))

Das Argument @var{eqn} ist eine Gleichung, die ein Polynom erster Ordnung in den
Funktionen @code{@var{g}(@var{t})} und @code{@var{g}(@var{t+1})} ist.
@code{funcsolve} sucht die rationale Funktion @code{@var{g}(@var{t})}, die
L@"osung der Gleichung @var{eqn} ist.

Warnung: Die Funktion ist nur sehr rudiment@"ar implementiert.  Offensichtliche
Verallgemeinerungen fehlen.

Beispiel:

@example
(%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) =
      (n - 1)/(n + 2);
                            (n + 3) f(n + 1)   n - 1
(%o1)        (n + 1) f(n) - ---------------- = -----
                                 n + 1         n + 2
(%i2) funcsolve (eqn, f(n));

Dependent equations eliminated:  (4 3)
                                   n
(%o2)                f(n) = ---------------
                            (n + 1) (n + 2)
@end example
@end deffn

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{globalsolve}
@defvr {Optionsvariable} globalsolve
Standardwert: @code{false}

Hat @code{globalsolve} den Wert @code{true}, werden den unbekannten Variablen
eines linearen Gleichungssystems die Werte der L@"osungen der Funktionen
@mref{linsolve} und @mref{solve} zugewiesen.

Hat @code{globalsolve} den Wert @code{false}, werden den unbekannten Variablen
eines linearen Gleichungssystems keine Werte zugewiesen.  Die L@"osungen werden 
als Gleichungen mit den unbekannten Variablen ausgedr@"uckt.

F@"ur andere als lineare Gleichungssysteme wird der Wert von @code{globalsolve}
ignoriert.  Die Funktion @mref{algsys} ignoriert @code{globalsolve} immer.

Beispiele:

@example
(%i1) globalsolve: true$
(%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t2)                        x : --
                                 7

                                   1
(%t3)                        y : - -
                                   7
(%o3)                     [[%t2, %t3]]
(%i3) x;
                               17
(%o3)                          --
                               7
(%i4) y;
                                 1
(%o4)                          - -
                                 7
(%i5) globalsolve: false$
(%i6) kill (x, y)$
(%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t7)                        x = --
                                 7

                                   1
(%t8)                        y = - -
                                   7
(%o8)                     [[%t7, %t8]]
(%i8) x;
(%o8)                           x
(%i9) y;
(%o9)                           y
@end example
@end defvr

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{ieqn}
@deffn {Funktion} ieqn (@var{ie}, @var{unk}, @var{tech}, @var{n}, @var{guess})

@code{inteqn} ist ein Paket zur L@"osung von Integralgleichungen zweiter 
Art der Form

@example
                       b(x)
                      /
                      [
    p(x) = q(x, p(x), I     w(x, u, p(x), p(u)) du)
                      ]
                      /
                       a(x)
@end example

und von Integralgleichungen erster Art der Form

@example
@group
            b(x)
           /
           [
    f(x) = I     w(x, u, p(u)) du
           ]
           /
            a(x)
@end group
@end example

Das Kommando @code{load(inteqn)} l@"adt das Paket.

Das erste Argument @var{ie} ist die Integralgleichung und das Argument @var{unk}
die unbekannte Funktion.  Mit dem Argument @var{tech} wird die Methode
angegeben, die zur L@"osung der Integralgleichung angewendet werden soll.
Erh@"alt das Argument @var{tech} den Wert @code{first}, wird das Ergebnis der
ersten erfolgreichen Methode zur@"uckgegeben.  Mit @code{all} werden alle
Methoden angewendet.  Das Argument @var{n} gibt die maximale Anzahl an Termen
an, die von den Methoden @code{taylor}, @code{neumann}, @code{firstkindseries}
oder @code{fredseries} verwendet werden.  @var{n} ist auch die maximale Tiefe
der Rekursion f@"ur der Differentiationsmethode.  Das Argument @var{guess} ist
der Startwert der Methoden @code{neumann} oder @code{firstkindseries}.

Die Standardwerte der Argumente sind:

@table @code
@item unk 
@code{@var{p}(@var{x})}, wobei @var{p} die erste im Integranden aufgefundene
Funktion ist, die Maxima unbekannt ist, und @var{x} die Variable ist, die im
Falle einer Integralgleichung der zweiten Art als Argument der Funktion
@var{p} au@ss{}erhalb des Integrals vorgefunden wird, oder im Falle einer 
Integralgleichung der ersten Art die einzige andere Variable neben der 
Integrationsvariable ist.  Wenn der Versuch fehlschl@"agt, die Variable @var{x}
zu finden, wird der Nutzer nach der unabh@"angigen Variablen gefragt.

@item tech
@code{first}

@item n
@code{1}

@item guess
@code{none}, bewirkt, dass der Ansatz @code{@var{f}(@var{x})} als Startwert
der L@"osungsmethoden @code{neumann} und @code{firstkindseries} verwendet wird.
@end table

Siehe @code{share/integequations/inteqn.usg} f@"ur weitere Informationen.
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{ieqnprint}
@defvr {Optionsvariable} ieqnprint
Standardwert: @code{true}

@code{ieqnprint} kontrolliert die Ausgabe des Ergebnisses der Funktion 
@mrefdot{ieqn}  Hat die Optionsvariable @code{ieqnprint} den Wert @code{true},
dann hat das Ergebnis der Funktion @code{ieqn} die Form
@code{[@var{solution}, @var{technique used}, @var{nterms}, @var{flag}]}.
Ist die L@"osung exakt, tritt das Element @code{@var{flag}} nicht auf.
Ansonsten erh@"alt das Element @code{@var{flag}} den Wert @code{approximate}
f@"ur eine nicht exakte L@"osung und den Wert @code{incomplete} f@"ur eine nicht
geschlossene L@"osung.  Wurde die L@"osung mit einer Methode gefunden, die einen
Reihenansatz verwendet, enth@"alt @var{nterms} die Anzahl der Terme der
Entwicklung.
@end defvr

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{lhs}
@deffn {Funktion} lhs (@var{expr})

Gibt die linke Seite des Ausdrucks @var{expr} zur@"uck, wenn der Operator von
@var{expr} einer der relationalen Operatoren
@code{< <= = # equal notequal >= >}, einer der Zuweisungsoperatoren
@code{:= ::= : ::} oder ein nutzerdefinierter bin@"arer Infix-Operator ist, der
mit der Funktion @mref{infix} deklariert wurde.  Die linke Seite des Ausdrucks
ist f@"ur die hier genannten Operatoren das erste Argument.

Wenn @var{expr} ein Atom ist oder sein Operator ein anderer als oben 
aufgelistet, gibt @code{lhs} den Ausdruck @var{expr} zur@"uck.  Siehe auch 
@mrefdot{rhs}

Beispiele:

@example
(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb),
       lhs (aa > bb)];
(%o4)                   [aa, aa, aa, aa]
(%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)),
       lhs (notequal (aa, bb))];
(%o5)                   [aa, aa, aa, aa]
@group
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
@end group
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
(%o10)               [foo(x), bar(y), x, x]
(%i11) infix ("][");
(%o11)                         ][
(%i12) lhs (aa ][ bb);
(%o12)                         aa
@end example
@end deffn

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{linsolve}
@deffn {Funktion} linsolve ([@var{expr_1}, @dots{}, @var{expr_m}], [@var{x_1}, @dots{}, @var{x_n}])

L@"ost das lineare Gleichungssystem mit den Gleichungen oder Polynomen
[@var{expr_1}, @dots{}, @var{expr_m}] und den Variablen [@var{x_1}, @dots{}, 
@var{x_n}].  Jede Gleichung muss ein Polynom in den angegebenen Variablen sein.

Hat die Optionsvariable @mref{globalsolve} den Wert @code{true}, werden die
L@"osungen des Gleichungssystems den angegebenen Variablen zugewiesen.

Hat die Optionsvariable @mref{backsubst} den Wert @code{false}, f@"uhrt
@code{linsolve} keine R@"ucksubstitutionen aus.  Dies kann hilfreich sein, wenn
die R@"ucksubstitution zu sehr gro@ss{}en Ausdr@"ucken f@"uhrt.

Hat die Optionsvariable @mref{linsolve_params} den Wert @code{true}, setzt
@code{linsolve} f@"ur ein unterbestimmtes Gleichungssystem freie Parameter in
die L@"osungen ein, die mit @code{%r}-Symbolen bezeichnet werden.  Siehe auch
@mref{%rnum} und @mrefdot{%rnum_list}

Hat die Optionsvariable @mref{programmode} den Wert @code{false}, werden die
L@"osungen von @code{linsolve} Zwischenmarken @code{%t} zugewiesen.  Die
Zwischenmarken werden als Liste zur@"uckgegeben.

Beispiele:

@example
(%i1) e1: x + z = y;
(%o1)                       z + x = y
(%i2) e2: 2*a*x - y = 2*a^2;
                                       2
(%o2)                   2 a x - y = 2 a
(%i3) e3: y - 2*z = 2;
(%o3)                      y - 2 z = 2
(%i4) [globalsolve: false, programmode: true];
(%o4)                     [false, true]
(%i5) linsolve ([e1, e2, e3], [x, y, z]);
(%o5)            [x = a + 1, y = 2 a, z = a - 1]
(%i6) [globalsolve: false, programmode: false];
(%o6)                    [false, false]
(%i7) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t7)                       z = a - 1

(%t8)                        y = 2 a

(%t9)                       x = a + 1
(%o9)                    [%t7, %t8, %t9]
(%i9) ''%;
(%o9)            [z = a - 1, y = 2 a, x = a + 1]
(%i10) [globalsolve: true, programmode: false];
(%o10)                    [true, false]
(%i11) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t11)                      z : a - 1

(%t12)                       y : 2 a

(%t13)                      x : a + 1
(%o13)                 [%t11, %t12, %t13]
(%i13) ''%;
(%o13)           [z : a - 1, y : 2 a, x : a + 1]
(%i14) [x, y, z];
(%o14)                 [a + 1, 2 a, a - 1]
(%i15) [globalsolve: true, programmode: true];
(%o15)                    [true, true]
(%i16) linsolve ([e1, e2, e3], '[x, y, z]);
(%o16)           [x : a + 1, y : 2 a, z : a - 1]
(%i17) [x, y, z];
(%o17)                 [a + 1, 2 a, a - 1]
@end example
@end deffn

@c DO ANY FUNCTIONS OTHER THAN linsolve RESPECT linsolvewarn ??

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{linsolvewarn}
@defvr {Optionsvariable} linsolvewarn
Standardwert: @code{true}

Hat @code{linsolvewarn} den Wert @code{true}, gibt die Funktion
@mref{linsolve} gegebenenfalls die Meldung @code{Dependent equations eliminated}
aus.
@end defvr

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{linsolve_params}
@defvr {Optionsvariable} linsolve_params
Standardwert: @code{true}

Hat @code{linsolve_params} den Wert @code{true}, setzt die Funktion
@mref{linsolve} f@"ur ein unterbestimmtes Gleichungssystem freie Parameter in
die L@"osungen ein, die mit @code{%r}-Symbolen bezeichnet werden.  Siehe auch
@mref{%rnum} und @mrefdot{%rnum_list}
@end defvr

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{multiplicities}
@defvr {Systemvariable} multiplicities
Standardwert: @code{not_set_yet}

@code{multiplicities} ist die Liste der Vielfachheiten der  
L@"osungen, die von @mrefcomma{solve} @mref{realroots} oder @mref{allroots}@w{}
zur@"uckgegeben werden.

Beispiel:

@example
(%i1) solve(x^2*(x+1)^2, x);
(%o1)                   [x = - 1, x = 0]
(%i2) multiplicities;
(%o2)                        [2, 2]
@end example
@end defvr

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{nroots}
@deffn {Funktion} nroots (@var{p}, @var{low}, @var{high})

Gibt die Anzahl der reellen Wurzeln des reellen univariaten Polynoms @var{p} im 
halboffenen Intervall @code{(@var{low}, @var{high}]} zur@"uck.
Die Grenzen des Intervalls k@"onnen auch negativ unendlich @code{minf} oder 
positiv unendlich @code{inf} sein.

@code{nroots} verwendet die Methode der Sturm-Sequenzen.

Beispiel:

@example
(%i1) p: x^10 - 2*x^4 + 1/2$
(%i2) nroots (p, -6, 9.1);
(%o2)                           4
@end example
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{nthroot}
@deffn {Funktion} nthroot (@var{p}, @var{n})

@c where p is a polynomial with integer coefficients and n is a positive integer
@c returns q, a polynomial over the integers, such that q^n=p or prints an error
@c message indicating that p is not a perfect nth power. This routine is much 
@c faster than @code{factor} or even @code{sqfr}.

Das Argument @var{p} ist ein Polynom mit ganzzahligen Koeffizienten und das
Argument @var{n} eine positive ganze Zahl.  @code{nthroot} gibt ein Polynom 
@math{q} @"uber die ganzen Zahlen zur@"uck, so dass @math{q^n = p} gilt.
Existiert kein derartiges Polynom @var{q} gibt Maxima eine Fehlermeldung aus.
@code{nthroot} ist wesentlich schneller als die Funktionen @mref{factor} oder
@mrefdot{sqfr}
@end deffn

@c --- 08.07.2011 DK -----------------------------------------------------------
@anchor{polyfactor}
@defvr {Optionsvariable} polyfactor
Standardwert: @code{false}

Hat die Optionsvariable @code{polyfactor} den Wert @code{true}, werden die
L@"osungen der Funktionen @code{allroots} und @code{bfallroots} @"uber die 
reellen Zahlen faktorisiert, wenn das Polynom reell ist, und @"uber die
komplexen Zahlen, wenn das Polynome komplex ist.

Siehe @mref{allroots} f@"ur ein Beispiel.
@end defvr

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{programmode}
@defvr {Optionsvariable} programmode
Standardwert: @code{true}

Hat @code{programmode} den Wert @code{true}, geben die Funktionen
@mrefcomma{solve} @mrefcomma{realroots} @mrefcomma{allroots}@w{}
@mref{bfallroots} und @mref{linsolve} die L@"osungen als Elemente einer Liste
zur@"uck.

Hat @code{programmode} den Wert @code{false}, werden die L@"osungen der oben 
genannten Funktionen Zwischenmarken @code{%t} zugewiesen.  Die R@"uckgabe der 
Funktionen ist in diesem Fall eine Liste der Zwischenmarken.
@end defvr

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{realonly}
@defvr {Optionsvariable} realonly
Standardwert: @code{false}

Hat @code{realonly} den Wert @code{true}, gibt @mref{algsys} nur L@"osungen
zur@"uck, die nicht die imagin@"are Einheit @code{%i} enthalten.
@end defvr

@c TODO: UEBERSETZUNG FEHLT

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{realroots}
@deffn  {Funktion} realroots (@var{expr}, @var{bound})
@deffnx {Funktion} realroots (@var{eqn}, @var{bound})
@deffnx {Funktion} realroots (@var{expr})
@deffnx {Funktion} realroots (@var{eqn})

Computes rational approximations of the real roots of the polynomial @var{expr}
or polynomial equation @var{eqn} of one variable, to within a tolerance of 
@var{bound}.  Coefficients of @var{expr} or @var{eqn} must be literal numbers;
symbol constants such as @code{%pi} are rejected.

@code{realroots} assigns the multiplicities of the roots it finds to the global 
variable @code{multiplicities}.

@code{realroots} constructs a Sturm sequence to bracket each root, and then 
applies bisection to refine the approximations.  All coefficients are converted 
to rational equivalents before searching for roots, and computations are carried
out by exact rational arithmetic.  Even if some coefficients are floating-point 
numbers, the results are rational (unless coerced to floats by the @code{float} 
or @code{numer} flags).

When @var{bound} is less than 1, all integer roots are found exactly.  When 
@var{bound} is unspecified, it is assumed equal to the global variable 
@code{rootsepsilon}.

When the global variable @code{programmode} is @code{true}, @code{realroots} 
returns a list of the form @code{[x = @var{x_1}, x = @var{x_2}, ...]}.  When 
@code{programmode} is @code{false}, @code{realroots} creates intermediate 
expression labels @code{%t1}, @code{%t2}, ..., assigns the results to them, and 
returns the list of labels.

Examples:

@example
(%i1) realroots (-1 - x + x^5, 5e-6);
                               612003
(%o1)                     [x = ------]
                               524288
(%i2) ev (%[1], float);
(%o2)                 x = 1.167303085327148
(%i3) ev (-1 - x + x^5, %);
(%o3)                - 7.396496210176905E-6
@end example

@example
(%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
(%o1)                 [x = 1, x = 2, x = 3]
(%i2) multiplicities;
(%o2)                       [5, 3, 1]
@end example
@end deffn

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{rhs}
@deffn {Funktion} rhs (@var{expr})

Gibt die rechte Seite des Ausdrucks @var{expr} 
zur@"uck, wenn der Operator von @var{expr} einer der relationalen Operatoren
@code{< <= = # equal notequal >= >}, einer der Zuweisungsoperatoren 
@code{:= ::= : ::} oder ein nutzerdefinierter bin@"arer Infixoperator ist, der
mit der Funktion @code{infix} deklariert wurde.  Die rechte Seite des Ausdrucks
ist f@"ur die hier genannten Operatoren das zweite Argument.

Ist @var{expr} ein Atom oder hat der Ausdruck @var{expr} einen anderen Operator
als oben angegeben, dann ist das Ergebnis @code{0}.  Siehe auch @mrefdot{lhs}

Beispiele:

@example
(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb),
       rhs (aa > bb)];
(%o4)                   [bb, bb, bb, bb]
(%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)),
       rhs (notequal (aa, bb))];
(%o5)                   [bb, bb, bb, bb]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
@group
(%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
(%o10)                  [2 x, 3 y, y, y]
@end group
(%i11) infix ("][");
(%o11)                         ][
(%i12) rhs (aa ][ bb);
(%o12)                         bb
@end example
@end deffn

@c --- 30.11.2010 DK -----------------------------------------------------------
@anchor{rootsepsilon}
@defvr {Optionsvariable} rootsepsilon
Standardwert: @code{1.0e-7}

@code{rootsepsilon} ist die Toleranz, die den Vertrauensbereich f@"ur die von 
der Funktion @mref{realroots} gefundenen Wurzeln festsetzt.
@end defvr

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{solve}
@deffn  {Funktion} solve (@var{expr}, @var{x})
@deffnx {Funktion} solve (@var{expr})
@deffnx {Funktion} solve ([@var{eqn_1}, @dots{}, @var{eqn_n}], [@var{x_1}, @dots{}, @var{x_n}])

L@"ost eine algebraische Gleichung @var{expr} nach der Variablen @var{x} auf.
Wenn @var{expr} keine Gleichung ist, wird die Gleichung @code{@var{expr} = 0} 
angenommen.  @var{x} kann eine Funktion wie zum Beispiel @code{f(x)}) sein oder
ein allgemeiner Ausdruck.  Ausgenommen sind Summen und Produkte.  Hat die 
Gleichung nur eine Variable, braucht diese nicht angegeben zu werden.
@var{expr} kann ein rationaler Ausdruck sein und trigonometrische Funktionen, 
Exponentialfunktionen und andere Funktionen enthalten.  Zur L@"osung wird die
folgende Methode verwendet:

@enumerate
@item
Sei @var{E} ein Ausdruck und @var{X} die Variable.  Ist @var{E} linear in 
@var{X}, dann kann die Gleichung sofort nach der Variablen @code{X} aufgel@"ost 
werden.  Hat @var{E} die Form @code{A*X^N + B}, dann ist das Ergebnis 
@code{(-B/A)^1/N)} multipliziert mit der @code{N}-ten Einheitswurzel.

@item
Ist @var{E} nicht linear in @var{X}, wird der gr@"o@ss{}te gemeinsame Teiler 
@var{N} der Exponenten der Variable @var{X} bestimmt.  Die Exponenten der 
Variablen werden durch @var{N} dividiert und die Multiplizit@"at der L@"osungen 
mit @var{N} multipliziert.  @code{solve} wird erneut f@"ur den Ausdruck 
aufgerufen.  Kann @var{E} faktorisiert werden, wird @code{solve} f@"ur jeden 
Faktor aufgerufen.  Zuletzt pr@"uft @code{solve}, ob einer der Algorithmen f@"ur
quadratische, kubische oder quartische Gleichungen angewendet werden kann.

@item
Ist @var{E} ein Polynom in einer Funktion @code{F(X)} mit @var{X} als der
Variablen, wird zun@"achst die L@"osung des Polynoms f@"ur @code{F(X)} gesucht.
Ist @var{C} eine solche L@"osung, kann die Gleichung @code{F(X)=C} gel@"ost 
werden, wenn die Umkehrfunktion zu @code{F(X)} bekannt ist.
@end enumerate

Hat die Optionsvariable @mref{breakup} den Wert @code{false}, werden die
L@"osungen von kubischen und quartischen Gleichungen nicht in gemeinsame
Teilausdr@"ucke zerlegt.

Die Systemvariable @mref{multiplicities} enth@"alt eine Liste mit den
Vielfachheiten der einzelnen L@"osungen.

@c @code{solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])}
@c solves a system of simultaneous (linear or non-linear) polynomial equations 
@c by calling @code{linsolve} or @code{algsys} and returns a list of the 
@c solution lists in the variables.  In the case of @code{linsolve} this list 
@c would contain a single list of solutions.  It takes two lists as arguments.  
@c The first list represents the equations to be solved; the second list is a
@c list of the unknowns to be determined.  If the total number of variables in 
@c the equations is equal to the number of equations, the second argument-list 
@c may be omitted.

@code{solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])}
l@"ost ein Gleichungssystem mit den Polynomen @var{eqn_1}, @dots{}, @var{eqn_n} 
f@"ur die Variablen @var{x_1}, @dots{}, @var{x_n}.  Die Polynome k@"onnen linear 
oder nichtlinear sein.  Um das System zu l@"osen, werden die Funktionen 
@mref{linsolve} oder @mref{algsys} aufgerufen.  Das Ergebnis ist eine Liste mit 
den L@"osungen.  Ist die Anzahl der Gleichungen gleich der Anzahl der Variablen 
des Systems, kann das Argument mit der Liste der Variablen entfallen.

Hat die Optionsvariable @mref{programmode} den Wert @code{false} ist, zeigt
@code{solve} die L@"osungen mit Hilfe von Zwischenmarken (@code{%t}) an und
gibt die Liste der Marken zur@"uck.

Hat die Optionsvariable @mref{globalsolve} den Wert @code{true}, werden den
unbekannten Variablen eines linearen Gleichungssystems die Werte der L@"osung
der Funktionen @mref{linsolve} und @code{solve} zugewiesen.

Beispiele:

@example
(%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

SOLVE is using arc-trig functions to get a solution.
Some solutions will be lost.
                            %pi
(%o1)                  [x = ---, f(x) = 1]
                             6
(%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
@group
                                log(125)
(%o2)                   [f(x) = --------]
                                 log(5)
@end group
(%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                      2    2
(%o3)             [4 x  - y  = 12, x y - x = 2]
(%i4) solve (%, [x, y]);
(%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

 - .1331240357358706, y = .0767837852378778

 - 3.608003221870287 %i], [x = - .5202594388652008 %i

 - .1331240357358706, y = 3.608003221870287 %i

 + .0767837852378778], [x = - 1.733751846381093, 

y = - .1535675710019696]]
(%i5) solve (1 + a*x + x^3, x);
                                       3
              sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(%o5) [x = (- ---------- - -) (--------------- - -)
                  2        2      6 sqrt(3)      2

        sqrt(3) %i   1
       (---------- - -) a
            2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

                          3
 sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(---------- - -) (--------------- - -)
     2        2      6 sqrt(3)      2

         sqrt(3) %i   1
      (- ---------- - -) a
             2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2
@group
         3
 sqrt(4 a  + 27)   1 1/3               a
(--------------- - -)    - --------------------------]
    6 sqrt(3)      2                  3
                              sqrt(4 a  + 27)   1 1/3
                           3 (--------------- - -)
                                 6 sqrt(3)      2
@end group
(%i6) solve (x^3 - 1);
@group
             sqrt(3) %i - 1        sqrt(3) %i + 1
(%o6)   [x = --------------, x = - --------------, x = 1]
                   2                     2
@end group
(%i7) solve (x^6 - 1);
           sqrt(3) %i + 1      sqrt(3) %i - 1
(%o7) [x = --------------, x = --------------, x = - 1, 
                 2                   2

                     sqrt(3) %i + 1        sqrt(3) %i - 1
               x = - --------------, x = - --------------, x = 1]
                           2                     2
(%i8) ev (x^6 - 1, %[1]);
                                      6
                      (sqrt(3) %i + 1)
(%o8)                 ----------------- - 1
                             64
(%i9) expand (%);
(%o9)                           0
(%i10) x^2 - 1;
                              2
(%o10)                       x  - 1
(%i11) solve (%, x);
(%o11)                  [x = - 1, x = 1]
(%i12) ev (%th(2), %[1]);
(%o12)                          0
@end example

Die Symbole @code{%r} bezeichnen freie Konstanten einer L@"osung.
Siehe @mref{algsys} und @mref{%rnum_list} f@"ur mehr Informationen.

@example
(%i1) solve([x+y=1,2*x+2*y=2],[x,y]);

solve: dependent equations eliminated: (2)
(%o1)                      [[x = 1 - %r1, y = %r1]]
@end example
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{solvedecomposes}
@defvr {Optionsvariable} solvedecomposes
Standardwert: @code{true}

@c OTHERWISE WHAT HAPPENS - CAN'T SOLVE POLYNOMIALS, 
@c OR SOME OTHER METHOD IS USED ??

Hat @code{solvedecomposes} den Wert @code{true}, ruft @mref{solve} die Funktion
@mref{polydecomp} auf, um Polynome zu zerlegen.
@end defvr

@c --- 13.11.2010 DK -----------------------------------------------------------
@need 800
@anchor{solveexplicit}
@defvr {Optionsvariable} solveexplicit
Standardwert: @code{false}

Hat @code{solveexplicit} den Wert @code{true}, gibt die Funktion
@mref{solve} keine impliziten L@"osungen der Form @code{F(x) = 0} zur@"uck.

Beispiel:

@example
(%i1) solveexplicit:false;
(%o1)                         false
(%i2) solve(gamma(x)*x^3-1);
                           3      1
(%o2)                    [x  = --------]
                               gamma(x)
(%i3) solveexplicit:true;
(%o3)                         true
(%i4) solve(gamma(x)*x^3-1);
(%o4)                          []
@end example
@end defvr

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{solvefactors}
@defvr {Optionsvariable} solvefactors
Standardwert: @code{true}

Hat @code{solvefactors} den Wert @code{false}, versucht die Funktion
@mref{solve} nicht, den Ausdruck zu faktorisieren.  Das Setzen der
Optionsvariable @code{solvefactors} auf den Wert @code{false} kann notwendig
sein, wenn die Faktorisierung nicht ben@"otigt wird, damit @code{solve} eine
L@"osung findet.
@end defvr

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{solvenullwarn}
@defvr {Optionsvariable} solvenullwarn
Standardwert: @code{true}

Hat @code{solvenullwarn} den Wert @code{true}, gibt die Funktion
@mref{solve} eine Warnmeldung aus, wenn keine Gleichungen oder keine Variablen
als Argument @"ubergeben wurden.

Beispiel:

@example
(%i1) solvenullwarn:true;
(%o1)                         true
(%i2) solve(x^2*y+1,[]);

solve: variable list is empty, continuing anyway.
(%o2)                          []
(%i3) solvenullwarn:false;
(%o3)                         false
(%i4) solve(x^2*y+1,[]);
(%o4)                          []
@end example
@end defvr

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{solveradcan}
@defvr {Optionsvariable} solveradcan
Standardwert: @code{false}

Hat @code{solveradcan} den Wert @code{true}, ruft @mref{solve} die Funktion
@mref{radcan} auf, um Ausdr@"ucke zu vereinfachen, die Exponentialfunktionen
und Logarithmen enthalten.
@end defvr

@c --- 13.11.2010 DK -----------------------------------------------------------
@need 800
@anchor{solvetrigwarn}
@defvr {Optionsvariable} solvetrigwarn
Standardwert: @code{true}

Hat @code{solvetrigwarn} den Wert @code{true}, gibt die Funktion
@mref{solve} eine Warnung aus, wenn inverse trigonometrische Funktionen genutzt
werden, um L@"osungen zu finden.  In diesem Fall k@"onnen L@"osungen verloren
gehen.

Beispiel:

@example
(%i1) solvetrigwarn:true;
(%o1)                         true
(%i2) solve(cos(x)+1);

solve: using arc-trig functions to get a solution.
Some solutions will be lost.
(%o2)                       [x = %pi]
(%i3) solvetrigwarn:false;
(%o3)                         false
(%i4) solve(cos(x)+1);
(%o4)                       [x = %pi]
@end example
@end defvr

@c --- End of file Equations.de.texi -------------------------------------------

