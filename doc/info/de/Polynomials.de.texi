@c -----------------------------------------------------------------------------
@c File        : Polynomials.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Polynomials.texi revision 03.07.2011
@c Translation : Dr. Dieter Kaiser
@c Date        : 11.12.2010
@c Revision    : 27.11.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Polynome::
* Funktionen und Variablen f@"ur Polynome::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Polynome, Funktionen und Variablen f@"ur Polynome, Polynome, Polynome
@section Einf@"uhrung in Polynome
@c -----------------------------------------------------------------------------

Polynome werden in einer allgemeinen Darstellung oder in einer kanonischen
Darstellung (CRE - Cannonical Rational Expressions) gespeichert.  Die 
CRE-Darstellung ist die Standardform f@"ur Operationen mit Polynomen und wird
intern von Funktionen wie @mref{factor} oder @mref{ratsimp} verwendet.

Ausdr@"ucke in einer CRE-Form sind besonders f@"ur die Darstellung von Polynomen
und rationalen Funktionen geeignet.  Die CRE-Form nimmt eine Ordnung der
Variablen an.  Polynome werden rekursiv als eine Liste definiert, die als
ersten Eintrag den Namen der Variablen und als n@"achste Eintr@"age die 
Exponenten und Koeffizienten der Variablen enthalten.  Der Koeffizient kann
eine Zahl oder wiederum ein Polynom sein.  Zum Beispiel hat das Polynom
@code{3*x^2-1} die Darstellung @code{(X 2 3 0 -1)} und das Polynom 
@code{2*x*y+x-3} die Darstellung @code{(Y 1 (X 1 2) 0 (X 1 1 0 -3))}, wenn 
@code{y} die Hauptvariable des Polynoms ist.  Ist @var{x} die Hauptvariable des
Polynoms, dann ist die Darstellung @code{(X 1 (Y 1 2 0 1) 0 -3)}.

Die Ordnung der Variablen ist in der Regel umgekehrt alphabetisch.  Die
Variablen m@"ussen keine Atome sein.  Alle Ausdr@"ucke, die nicht die Operatoren
@code{+}, @code{-}, @code{*}, @code{/} oder @code{^} enthalten, werden in einer
CRE-Darstellung als "Variable" angenommen.  Zum Beispiel sind @code{x}, 
@code{sqrt(x)} und @code{sin(x+1)} die CRE-Variablen des Ausdrucks
@code{x+sin(x+1)+2*SQRT(x)+1}.  Wird vom Nutzer keine abweichende Ordnung der 
Variablen mit der Funktion @mref{ratvars} definiert, nimmt Maxima eine 
alphabetische Ordnung der Variablen an.

Im Allgemeinen werden rationale Funktionen in einer CRE-Form dargestellt, die
keinen gemeinsamen Faktor im Z@"ahler und Nenner haben.  Die interne Darstellung
ist ein Paar von Polynomen, die jeweils den Z@"ahler und den Nenner darstellen.
Diesem Paar geht eine Liste mit der Ordnung der Variablen im Ausdruck voraus.
Ein Ausdruck in einer CRE-Form oder der CRE-Formen enth@"alt, wird in der 
Ausgabe mit dem Symbol @code{/R/} gekennzeichnet.  Mit der Funktion
@mref{rat} k@"onnen allgemeine Ausdr@"ucke in eine CRE-Form transformiert
werden.  Umgekehrt wird ein Ausdruck in einer CRE-Form mit der Funktion
@mref{ratdisrep} in eine allgemeine Form transformiert.

F@"ur die Darstellung von Taylor-Polynomen der Funktion @mref{taylor} wird eine
erweiterte CRE-Form verwendet.  In dieser Darstellung k@"onnen die Exponenten
von Polynomen auch rationale Zahlen sein.  Weiterhin k@"onnen die Koeffizienten
rationale Funktionen sein.  Die erweiterte CRE-Form enth@"alt auch Informationen
@"uber den Grad des Polynoms.  In der Ausgabe wird die erweiterte CRE-Form mit
dem Symbol @code{/T/} bezeichnet.

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Polynome,  , Einf@"uhrung in Polynome, Polynome
@section Funktionen und Variablen f@"ur Polynome
@c -----------------------------------------------------------------------------

@c --- 27.11.2011 DK -----------------------------------------------------------
@anchor{algebraic}
@defvr {Optionsvariable} algebraic
Standardwert: @code{false}

Hat die Optionsvariable @code{algebraic} den Wert @code{true}, wird beim
Umwandeln von Ausdr@"ucken in die CRE-Form und beim Rechnen mit Ausdr@"ucken
in einer CRE-Form der Ausdruck so vereinfacht, dass der Nenner frei von
algebraischen Zahlen (das sind Wurzeln von ganzen Zahlen) ist.

@need 800
Beispiele:

Im zweiten Beispiel wird der Ausdruck automatisch mit @code{sqrt(2)} erweitert,
um den Nenner frei von der algebraischen Zahl @code{sqrt(2)} zu machen.

@example
(%i1) algebraic:false;
(%o1)                         false
(%i2) rat(x^2+x)/sqrt(2);
                              2
                             x  + x
(%o2)/R/                     -------
                             sqrt(2)
(%i3) algebraic:true;
(%o3)                         true
(%i4) rat(x^2+x)/sqrt(2);
                              2
                     sqrt(2) x  + sqrt(2) x
(%o4)/R/             ----------------------
                               2
@end example
@end defvr

@c --- 27.11.2011 DK -----------------------------------------------------------
@anchor{berlefact}
@defvr {Optionsvariable} berlefact
Standardwert: @code{true}

Hat die Optionsvariable @code{berlefact} den Wert @code{false}, dann wird der
Kronecker-Al@-go@-rith@-mus von der Funktion @mref{factor} f@"ur die
Faktorisierung genutzt.  Ansonsten wird der Berlekamp-Algorithmus genutzt.  Der
Standardwert ist @code{true}.
@end defvr

@c --- 19.02.2011 DK -----------------------------------------------------------
@anchor{bezout}
@deffn {Funktion} bezout (@var{p1}, @var{p2}, @var{x})

Die R@"uckgabe ist die Sylvestermatrix der zwei Polynome @var{p1} und @var{p2}
mit der unabh@"angigen Variablen @var{x}.  Die Determinante der Sylvestermatrix
ist die Resultante der Polynome.  Die Resultante kann auch sofort mit der
Funktion @mref{resultant} berechnet werden.

Beispiele:

@example
(%i1) bezout(a*x+b, c*x^2+d, x);
                         [ b c  - a d ]
(%o1)                    [            ]
                         [  a     b   ]
(%i2) determinant(%);
                            2      2
(%o2)                      a  d + b  c
(%i3) resultant(a*x+b, c*x^2+d, x);
                            2      2
(%o3)                      a  d + b  c
@end example
@end deffn

@c --- 19.02.2011 DK -----------------------------------------------------------
@anchor{bothcoef}
@deffn {Funktion} bothcoef (@var{expr}, @var{x})

Gibt eine Liste zur@"uck, deren erstes Element der Koeffizient der Variablen
@var{x} im Ausdruck @var{expr} und deren zweites Element der verbleibende
Teil des Ausdrucks @var{expr} ist.  Das Ergebnis ist also @code{[A,B]} und es
gilt @code{@var{expr} = A * @var{x} + B}.

Die Funktion @code{bothcoef} hat den Alias-Namen @code{bothcoeff}.

Siehe auch die Funktion @mrefdot{coeff}

Beispiele:

@example
(%i1) bothcoeff(a*x+2, x);
(%o1)                        [a, 2]
(%i2) bothcoeff(x^2+a*x+2, x);
                                2
(%o2)                      [a, x  + 2]
@end example

Definition einer Funktion @code{islinear}, die die Funktion @code{bothcoeff}
nutzt, um den linearen Anteil eines Ausdrucks zu ermitteln.

@example
(%i1) islinear (expr, x) := 
         block ([c],
            c: bothcoef (rat (expr, x), x),
            is (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
@end example
@end deffn

@c --- 27.07.2013 VvN ----------------------------------------------------------
@anchor{coeff}
@deffn  {Funktion} coeff (@var{expr}, @var{x}, @var{n})
@deffnx {Funktion} coeff (@var{expr}, @var{x})

Gibt den Koeffizienten von @code{@var{x}^@var{n}} des Ausdrucks @var{expr}
zur@"uck.  Das Argument @var{expr} ist ein Polynom in der Variablen @var{x}.

Das Kommando @code{coeff(@var{expr}, @var{x}^@var{n})} ist @"aquivalent zu
@code{coeff(@var{expr}, @var{x}, @var{n})}.  Das Kommando
@code{coeff(@var{expr}, @var{x}, 0)} gibt den Teil des Ausdrucks @var{expr}
zur@"uck, der frei von der Variablen @var{x} ist.  Wenn nicht angegeben, wird
das Argument @var{n} als @code{1} angenommen.

Das Argument @var{x} kann auch eine indizierte Variable oder ein Teilausdruck
von @var{expr} sein.

@code{coeff} wendet weder die Funktion @code{expand} noch die Funktion 
@code{factor} an, um einen Ausdruck zu expandieren oder zu faktorisieren.  Daher
kann es zu anderen Ergebnissen kommen, wenn zuvor diese Funktionen angewendet 
werden.

Wird @code{coeff} auf Listen, Matrizen oder Gleichungen angewendet, wird die
Funktion auf die Elemente oder beide Seiten der Gleichung angewendet.

Siehe auch die Funktion @mrefdot{bothcoef}

Beispiele:

@code{coeff} gibt den Koeffizienten von @code{@var{x}^@var{n}} des Ausdrucks
@var{expr} zur@"uck.

@example
(%i1) coeff(b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                3
(%o1)                          b
@end example

@code{coeff(@var{expr}, @var{x}^@var{n})} ist @"aquivalent zu
@code{coeff(@var{expr}, @var{x}, @var{n})}.

@example
(%i1) coeff(c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
(%o1)                         - c
                                 3
(%i2) coeff(c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
(%o2)                         - c
                                 3
@end example

@code{coeff(@var{expr}, @var{x}, 0)} gibt den Teil des Ausdrucks @var{expr}
zur@"uck, der frei von der Variablen @var{x} ist.

@example
(%i1) coeff(a*u + b^2*u^2 + c^3*u^3, b, 0);
                            3  3
(%o1)                      c  u  + a u
@end example

@var{x} kann eine einfache Variable, eine indizierte Variable oder ein 
Teilausdruck des Ausdrucks @var{expr} sein.

@example
(%i1) coeff(h^4 - 2*%pi*h^2 + 1, h, 2);
(%o1)                        - 2 %pi
(%i2) coeff(v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
(%o2)                        - 2 %pi
(%i3) coeff (sin(1+x)*sin(x) + sin(1+x)^3*sin(x)^3, sin(1+x)^3);
                                3
(%o3)                        sin (x)
(%i4) coeff((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
(%o4)                         c - d
@end example

@code{coeff} wendet die Funktionen @code{expand} und @code{factor} nicht an.

@example
(%i1) coeff(c*(a + b)^3, a);
(%o1)                           0
(%i2) expand(c*(a + b)^3);
                 3          2        2        3
(%o2)           b  c + 3 a b  c + 3 a  b c + a  c
(%i3) coeff(%, a);
                                2
(%o3)                        3 b  c
(%i4) coeff(b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
(%o4)                           0
(%i5) factor(b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                  3
(%o5)                      (b + a)  c
(%i6) coeff(%, (a + b)^3);
(%o6)                           c
@end example

@code{coeff} wird bei Listen und Matrizen auf die Elemente und bei Gleichungen
auf die beiden Seiten angewendet.

@example
(%i1) coeff([4*a, -3*a, 2*a], a);
(%o1)                      [4, - 3, 2]
(%i2) coeff(matrix ([a*x, b*x], [-c*x, -d*x]), x);
                          [  a    b  ]
(%o2)                     [          ]
                          [ - c  - d ]
(%i3) coeff(a*u - b*v = 7*u + 3*v, u);
(%o3)                         a = 7
@end example

Die folgende Definition der Funktion @code{coeff_list} liefert eine Liste mit
den Koeffizienten, die in einem Polynom auftreten.  Neben der Funktion
@code{coeff} kommt hier die Funktion @mref{hipow} zum Einsatz, um den h@"ochsten
Exponenten zu ermitteln. @mref{rat} und @mref{ratdisrep} werden verwendet, 
um das Polynom zwischenzeitlich in die kanonische Form (CRE) zu bringen.

@example
(%i1) b : (x-y)^2;
                                       2
(%o1)                           (x - y)
(%i2) coeff_list(a, x) := (
   a : rat(a),
   reverse( makelist(ratdisrep(coeff(a, x, i)), i,0, hipow(a, x)) ))$

(%i3) coeff_list(b, x);
                                         2
(%o3)                        [1, - 2 y, y ]
@end example
@end deffn

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{content}
@deffn {Funktion} content (@var{p}, @var{x_1}, @dots{}, @var{x_n})

Gibt eine Liste zur@"uck, deren erstes Element der gr@"o@ss{}te gemeinsame 
Teiler der Koeffizienten des Polynoms @var{p} in der Variablen @var{x_n} ist 
und dessen zweites Element das durch den gr@"o@ss{}ten gemeinsamen Teiler 
dividierte Polynom ist.  Die anderen Argumente @var{x_1}, @dots{}, @var{x_n-1}
haben dieselbe Bedeutung wie f@"ur die Funktion @mrefdot{ratvars}

Beispiel:

@example
(%i1) content(2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
@end example
@end deffn

@c --- 05.07.2011 DK -----------------------------------------------------------
@anchor{denom}
@deffn {Funktion} denom (@var{expr})

Gibt den Nenner des Ausdrucks @var{expr} zur@"uck, wenn dieser ein
Quotient ist.  Ist der Ausdruck @var{expr} kein Quotient wird @var{expr}
zur@"uckgegeben.

Die Funktion @code{denom} wertet das Argument aus.  Siehe auch die Funktion
@mrefdot{num}

Beispiel:

@example
(%i1) denom(x^2/(x+1));
(%o1)                         x + 1
@end example
@end deffn

@c --- 01.12.2010 DK -----------------------------------------------------------
@anchor{divide}
@deffn {Funktion} divide (@var{p_1}, @var{p_2}, @var{x_1}, @dots{}, @var{x_n})

Berechnet den Quotienten und den Rest der Division des Polynom @var{p_1} durch
das Polynom @var{p_2} f@"ur die Variable @var{x_n}.  Die anderen Argumente
@var{x_1}, @dots{}, @var{x_n-1} haben dieselbe Bedeutung wie f@"ur die Funktion
@mrefdot{ratvars}  Das Ergebnis ist eine Liste, wobei das erste Element der
Quotient und das zweite Element der Rest ist.

Die Argumente der Funktion @code{divide} k@"onnen auch ganze Zahlen sein.

Siehe auch die Funktionen @mref{quotient} und @mrefcomma{remainder} die jeweils
den Quotienten und den Rest der Polynomdivision zur@"uckgegeben.

Beispiele:

Im zweiten Beispiel ist @code{y} die Hauptvariable des Ausdrucks.

@example
(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
@end example

@need 800
Ein Beispiel f@"ur zwei Polynome in zwei Variablen.

@example
(%i1) poly1 : sum(x^k*y^(6-k), k, 1, 5);
                  5    2  4    3  3    4  2    5
(%o1)          x y  + x  y  + x  y  + x  y  + x  y
(%i2) poly2 : sum(2*k*x^k*y^(3-k), k, 1, 3);
                          2      2        3
(%o2)                2 x y  + 4 x  y + 6 x
(%i3) divide(poly1, poly2, x);
              3        2      2          5       2  4
           4 y  + 3 x y  + 9 x  y  23 x y  + 16 x  y
(%o3)     [----------------------, ------------------]
                     54                    27
(%i4) expand(first(%)*poly2 + second(%));
                  5    2  4    3  3    4  2    5
(%o4)          x y  + x  y  + x  y  + x  y  + x  y
@end example
@end deffn

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dontfactor}
@defvr {Optionsvariable} dontfactor
Standardwert: @code{[]}

Der Optionsvariablen @code{dontfactor} kann eine Liste mit den Variablen
zugewiesen werden, bez@"uglich der ein Ausdruck nicht faktorisiert werden soll.
Weiterhin wird nicht bez@"uglich von Variablen faktorisiert, die gem@"a@ss{}
der kanonischen Ordnung der Variablen von geringerer Bedeutung sind als die
Variablen in der Liste @code{dontfactor}.

Beispiel:

Im zweiten Fall wird das Polynom nicht bez@"uglich der Variablen @var{x}
faktorisiert.

@example
(%i1) expr:expand((x+1)^3*(y+2)^2);
       3  2      2  2        2    2      3         2
(%o1) x  y  + 3 x  y  + 3 x y  + y  + 4 x  y + 12 x  y + 12 x y
                                             3       2
                                  + 4 y + 4 x  + 12 x  + 12 x + 4
(%i2) factor(expr);
                               3        2
(%o2)                   (x + 1)  (y + 2)
(%i3) dontfactor:[x];
(%o3)                          [x]
(%i4) factor(expr);
                   3      2                   2
(%o4)            (x  + 3 x  + 3 x + 1) (y + 2)
@end example
@end defvr

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{eliminate}
@deffn {Funktion} eliminate ([@var{eqn_1}, @dots{}, @var{eqn_n}], [@var{x_1}, @dots{}, @var{x_k}])

Wendet ein Subresultanten-Verfahren an, um die Variablen @var{x_1}, @dots{}, 
@var{x_k} aus den Gleichungen @var{eqn_1}, @dots{}, @var{eqn_n} zu eliminieren.
Die R@"uckgabe ist ein Gleichungssystem mit @code{@var{n} - @var{k}}
Gleichungen, wobei die @var{k}-Variablen @var{x_1}, @dots{}, @var{x_k}
eliminiert sind.

Beispiel:

@example
(%i1) eqn1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) eqn2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) eqn3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate([eqn1, eqn2, eqn3], [y,z]);
              2      4      3       2
(%o4)       [x  (45 x  + 3 x  + 11 x  + 81 x + 124)]
@end example
@end deffn

@c --- 19.02.2011 DK -----------------------------------------------------------
@anchor{ezgcd}
@deffn {Funktion} ezgcd (@var{p_1}, @var{p_2}, @var{p_3}, @dots{})

Gibt eine Liste zur@"uck, deren erstes Element der gr@"o@ss{}te gemeinsame
Teiler der Polynome @var{p_1}, @dots{}, @var{p_n} ist und deren weitere Elemente
die durch den gr@"o@ss{}ten gemeinsamen Teiler dividierten Polynome sind.  Der
gr@"o@ss{}te gemeinsame Teiler wird immer mit dem @code{ezgcd}-Algorithmus 
bestimmt.

Siehe auch die Funktionen @mrefcomma{gcd} @mref{gcdex} @mref{gcdivide} und
@mrefdot{poly_gcd}

Beispiel:

Die drei Polynome haben den gr@"o@ss{}ten gemeinsamen Teiler @code{2*x-3}.
Der gr@"o@ss{}te gemeinsame Teiler wird zuerst mit der Funktion @code{gcd}
berechnet.  Dann wird das Ergebnis der Funktion @code{ezgcd} gezeigt.

@example
(%i1) p1 : 6*x^3-17*x^2+14*x-3;
                        3       2
(%o1)                6 x  - 17 x  + 14 x - 3
(%i2) p2 : 4*x^4-14*x^3+12*x^2+2*x-3;
@group
                    4       3       2
(%o2)            4 x  - 14 x  + 12 x  + 2 x - 3
@end group
(%i3) p3 : -8*x^3+14*x^2-x-3;
                          3       2
(%o3)                - 8 x  + 14 x  - x - 3

(%i4) gcd(p1, gcd(p2, p3));
(%o4)                        2 x - 3

(%i5) ezgcd(p1, p2, p3);
                   2               3      2           2
(%o5) [2 x - 3, 3 x  - 4 x + 1, 2 x  - 4 x  + 1, - 4 x  + x + 1]
@end example
@end deffn

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{facexpand}
@defvr {Optionsvariable} facexpand
Standardwert: @code{true}

Die Optionsvariable @code{facexpand} kontrolliert, ob die irreduziblen Faktoren
der Faktorisierung mit @mref{factor} in einer expandierten oder in einer
rekursiven (CRE-Form) vorliegen.  Der Standard ist, dass die Faktoren expandiert
werden.
@end defvr

@c --- 30.06.2011 DK -----------------------------------------------------------
@anchor{factor}
@deffn  {Funktion} factor (@var{expr})
@deffnx {Funktion} factor (@var{expr}, @var{p})

@c Factors the expression @var{expr}, containing any number of variables or 
@c functions, into factors irreducible over the integers.
@c @code{factor (@var{expr}, @var{p})} factors @var{expr} over the field of 
@c rationals with an element adjoined whose minimum polynomial is @var{p}.

Faktorisiert den Ausdruck @var{expr}, der eine beliebige Zahl an Variablen 
oder Funktionen enthalten kann, in irreduzible Faktoren @"uber die ganzen 
Zahlen.  @code{factor(@var{expr}, @var{p}} faktorisiert @var{expr} @"uber den 
K@"orper der rationalen Zahlen, der um die Nullstellen des minimalen Polynoms
@var{p} erweitert ist.

@c @code{factor} uses @code{ifactors} function for factoring integers.

@code{factor} ruft die Funktion @mref{ifactors} auf, um ganze Zahlen zu 
faktorisieren.

@c @code{factorflag} if @code{false} suppresses the factoring of integer
@c factors of rational expressions.

Hat die Optionsvariable @mref{factorflag} den Wert @code{false}, wird die
Faktorisierung von ganzen Zahlen unterdr@"uckt, die im Nenner einer rationalen
Funktion auftreten.

@c @code{dontfactor} may be set to a list of variables with respect to which
@c factoring is not to occur.  (It is initially empty).  Factoring also
@c will not take place with respect to any variables which are less
@c important (using the variable ordering assumed for CRE form) than
@c those on the @code{dontfactor} list.

Der Optionsvariablen @mref{dontfactor} kann eine Liste mit den Variablen
zugewiesen werden, bez@"uglich der ein Ausdruck nicht faktorisiert werden soll.
Weiterhin wird nicht bez@"uglich von Variablen faktorisiert, die gem@"a@ss{}
der kanonischen Ordnung der Variablen von geringerer Bedeutung sind als die
Variablen in der Liste @code{dontfactor}.

@c @code{savefactors} if @code{true} causes the factors of an expression which
@c is a product of factors to be saved by certain functions in order to
@c speed up later factorizations of expressions containing some of the
@c same factors.

Hat die Optionsvariable @mref{savefactors} den Wert @code{true}, versuchen
einige Funktionen bei der Vereinfachung eine bereits vorhandene Faktorisierung
zu erhalten, um weitere Vereinfachungen zu beschleunigen.

@c @code{berlefact} if @code{false} then the Kronecker factoring algorithm will
@c be used otherwise the Berlekamp algorithm, which is the default, will
@c be used.

Hat die Optionsvariable @mref{berlefact} den Wert @code{false}, dann wird der
Kronecker-Al@-go@-rith@-mus f@"ur die Faktorisierung genutzt.  Ansonsten wird
der Berlekamp-Algorithmus genutzt.  Der Standardwert ist @code{true}.

@c @code{intfaclim} if @code{true} maxima will give up factorization of
@c integers if no factor is found after trial divisions and Pollard's rho
@c method.  If set to @code{false} (this is the case when the user calls
@c @code{factor} explicitly), complete factorization of the integer will be
@c attempted.  The user's setting of @code{intfaclim} is used for internal
@c calls to @code{factor}.  Thus, @code{intfaclim} may be reset to prevent
@c Maxima from taking an inordinately long time factoring large integers.

Hat die Optionsvariable @mref{intfaclim} den Wert @code{true}, gibt Maxima
die Faktorisierung von ganzen Zahlen auf, wenn keine Faktorisierung durch
Anwendung der Methode der Probedivision und der Pollard-Rho-Methode gefunden
werden konnten.  Hat @code{intfaclim} den Wert @code{false}, versucht Maxima
eine ganze Zahl vollst@"andig zu faktorisieren.  Der Wert der Optionsvariablen
@code{intfaclim} wird von der Funktion @code{factor} beachtet.  Mit dem Setzen
von @code{intfaclim} kann der Nutzer verhindern, dass Maxima beim Versuch sehr
gro@ss{}e ganze Zahlen zu faktorisieren, unn@"otig viel Zeit verbraucht.

Beispiele:

@example
(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
@group
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
@end group
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

@group
                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)
@end group

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
@end example

Das Polynom @code{x^4+1} l@"asst sich nicht @"uber den K@"orper der ganzen
Zahlen faktorisieren.  Wird der K@"orper um das minimale Polynom @code{a^2+1}
erweitert, ist die Faktorisierung m@"oglich.  Die Nullstellen des minimalen
Polynoms sind die imagin@"are Einheit @code{%i} und @code{-%i}.  Das Ergebnis
entspricht der Faktorisierung mit der Funktion @mrefdot{gfactor}

@example
(%i1) factor(x^4+1);
                              4
(%o1)                        x  + 1
(%i2) factor(x^4+1, a^2+1);
                          2        2
(%o2)                   (x  - a) (x  + a)
(%i3) gfactor(x^4+1);
                         2         2
(%o3)                  (x  - %i) (x  + %i)
@end example
@end deffn

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{factorflag}
@defvr {Optionsvariable} factorflag
Standardwert: @code{false}

Hat die Optionsvariable @code{factorflag} den Wert @code{false}, wird die
Faktorisierung von ganzen Zahlen unterdr@"uckt, die im Nenner einer rationalen
Funktion auftreten.

Beispiel:

@example
(%i1) factorflag:false;
(%o1)                         false
(%i2) factor(1/6*(x^2+2*x+1));
@group
                                   2
                            (x + 1)
(%o2)                       --------
                               6
@end group
(%i3) factorflag:true;
(%o3)                         true
(%i4) factor(1/6*(x^2+2*x+1));
                                   2
                            (x + 1)
(%o4)                       --------
                              2 3
@end example
@end defvr

@c --- 30.06.2011 DK -----------------------------------------------------------
@anchor{factorout}
@deffn {Funktion} factorout (@var{expr}, @var{x_1}, @var{x_2}, @dots{})

@c Rearranges the sum @var{expr} into a sum of terms of the form
@c @code{f (@var{x_1}, @var{x_2}, ...)*g} where @code{g} is a product of
@c expressions not containing any @var{x_i} and @code{f} is factored.

Gruppiert eine Summe @var{expr} in eine Summe mit Termen der Form
@code{f(@var{x_1}, @var{x_2}, ...) * g}, wobei @code{g} ein gemeinsamer Faktor
des Polynoms @code{f} ist.

Beispiele:

Das Polynom wird zuerst nach der Variablen @var{x}, dann nach @var{y} und 
zuletzt nach beiden Variablen faktorisiert.

@example
(%i1) factorout(2*a*x^2+a*x+a+a*y, x);
                                 2
(%o1)                a y + a (2 x  + x + 1)
(%i2) factorout(2*a*x^2+a*x+a+a*y, y);
                                     2
(%o2)               a (y + 1) + 2 a x  + a x
(%i3) factorout(2*a*x^2+a*x+a+a*y, y, x);
                                2
(%o3)                 a (y + 2 x  + x + 1)
@end example
@end deffn

@c --- 30.06.2011 DK -----------------------------------------------------------
@anchor{factorsum}
@deffn {Funktion} factorsum (@var{expr})

@c Tries to group terms in factors of @var{expr} which are sums into groups of 
@c terms such that their sum is factorable.  @code{factorsum} can recover the 
@c result of @code{expand ((x + y)^2 + (z + w)^2)} but it can't recover
@c @code{expand ((x + 1)^2 + (x + y)^2)} because the terms have variables in 
@c common.

Versucht Terme in @var{expr} so zu gruppieren, dass die Teilsummen
faktorisierbar sind.  @code{factorsum} kann zum Beispiel das expandierte
Polynom @code{expand ((x + y)^2 + (z + w)^2)} wieder herstellen, nicht jedoch
das expandierte Polynom @code{expand ((x + 1)^2 + (x + y)^2)}, da die Terme
gemeinsame Variablen enthalten.

Beispiele:

@example
(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum(%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
@end example
@end deffn

@c --- 30.06.2011 DK -----------------------------------------------------------
@anchor{fasttimes}
@deffn {Funktion} fasttimes (@var{p_1}, @var{p_2})

@c Returns the product of the polynomials @var{p_1} and @var{p_2} by using a 
@c special algorithm for multiplication of polynomials.  @code{p_1} and 
@c @code{p_2} should be multivariate, dense, and nearly the same size.
@c Classical multiplication is of order @code{n_1 n_2} where @code{n_1} is the 
@c degree of @code{p_1} and @code{n_2} is the degree of @code{p_2}.
@c @code{fasttimes} is of order @code{max (n_1, n_2)^1.585}.

F@"uhrt eine schnelle Multiplikation der Polynome @var{p_1} und @var{p_2} aus
und gibt das Ergebnis zur@"uck.  Der Algorithmus ist von Vorteil, wenn die
Polynome mehrere Variablen haben und die Koeffizienten dicht besetzt sind.
Sind @code{n_1} und @code{n_2} jeweils der Grad der Polynome @var{p_1} und
@var{p_2}, dann ben@"otigt die schnelle Multiplikation
@code{max(n_1, n_2)^1.585} Multiplikationen.
@end deffn

@c --- 03.07.2011 DK -----------------------------------------------------------
@anchor{fullratsimp}
@deffn  {Funktion} fullratsimp (@var{expr})
@deffnx {Funktion} fullratsimp (@var{expr}, @var{x_1}, @dots{}, @var{x_n})

@c @code{fullratsimp} repeatedly applies @code{ratsimp} followed by non-rational
@c simplification to an expression until no further change occurs, and returns 
@c the result.

@c When non-rational expressions are involved, one call to @code{ratsimp} 
@c followed as is usual by non-rational ("general") simplification may not be 
@c sufficient to return a simplified result.  Sometimes, more than one such call 
@c may be necessary.  @code{fullratsimp} makes this process convenient.

@c @code{fullratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})} takes one or more 
@c arguments similar to @code{ratsimp} and @code{rat}.

Die Funktion @code{fullratsimp} wendet die Funktion @mref{ratsimp} auf das
Argument @var{expr} solange wiederholt an, bis sich das Ergebnis nicht mehr
@"andert.  Nach jeder Anwendung von @code{ratsimp} wird der Ausdruck
zus@"atzlich vereinfacht.

Sind nicht-rationale Ausdr@"ucke in einem Ausdruck enthalten, kann der Ausdruck
m@"oglicherweise mit einem Aufruf von @code{ratsimp} nicht vollst@"andig
vereinfacht werden.  Dann kann der mehrfache Aufruf von @code{ratsimp} zu einem
besser vereinfachten Resultat f@"uhren.  Die Funktion @code{fullratsimp} ist
f@"ur solche Falle gedacht.

Die weiteren Argumente @var{x_1}, @dots{}, @var{x_n} entsprechen denen der
Funktionen @code{ratsimp} und @mrefdot{rat}

Beispiele:

@example
(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
@group
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
@end group
@end example
@end deffn

@c SPELL OUT WHAT fullratsubst DOES INSTEAD OF ALLUDING TO ratsubst AND
@c lratsubst.  THIS ITEM NEEDS MORE WORK

@c --- 03.07.2011 DK -----------------------------------------------------------
@anchor{fullratsubst}
@deffn {Funktion} fullratsubst (@var{a}, @var{b}, @var{c})

@c is the same as @code{ratsubst} except that it calls itself recursively on its
@c result until that result stops changing.  This function is useful when the 
@c replacement expression and the replaced expression have one or more variables
@c in common.

@c @code{fullratsubst} will also accept its arguments in the format of
@c @code{lratsubst}.  That is, the first argument may be a single substitution
@c equation or a list of such equations, while the second argument is the
@c expression being processed.

@c @code{load ("lrats")} loads @code{fullratsubst} and @code{lratsubst}.

Entspricht der Funktion @mref{ratsubst} mit dem Unterschied, dass die Funktion
solange rekursiv ausgef@"uhrt wird, bis sich das Ergebnis nicht mehr @"andert.
Diese Funktion kann n@"utzlich sein, wenn der Ausdruck, der eingesetzt wird,
und der zu ersetzende Ausdruck mehrere Variablen gemeinsam haben.

@code{fullratsubst} akzeptiert auch Argumente im Format der Funktion
@mrefdot{lratsubst}  Das erste Argument kann also auch eine einzelne oder eine
Liste von Gleichungen sein.  Das zweite Argument ist in diesem Fall der
Ausdruck in dem die Ersetzungen durchgef@"uhrt werden.

Mit dem Kommando @code{load(lrats)} werden die Funktionen @code{fullratsubst}
und @code{lratsubst} geladen.

Beispiele:

@example
(%i1) load ("lrats")$
@end example

@c @code{subst} can carry out multiple substitutions.
@c @code{lratsubst} is analogous to @code{subst}.

@mref{subst} kann mehrfache Substitutionen ausf@"uhren.  Die Funktion
@code{lratsubst} funktioniert analog zu der Funktion @code{subst}.

@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example

@c If only one substitution is desired, then a single
@c equation may be given as first argument.

Ist nur eine Substitution auszuf@"uhren, kann diese als eine einzelne Gleichung
angegeben werden.

@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example

@c @code{fullratsubst} is equivalent to @code{ratsubst}
@c except that it recurses until its result stops changing.

@code{fullratsubst} ist @"aquivalent zur Funktion @code{ratsubst} mit dem
Unterschied, dass die Funktion solange rekursiv angewendet wird, bis sich das
Ergebnis nicht mehr @"andert.

@example
(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
@group
                                 2
(%o6)                         a b
@end group
@end example

@c @code{fullratsubst} also accepts a list of equations or a single
@c equation as first argument.

@code{fullratsubst} akzeptiert auch eine Liste mit Gleichungen oder eine
Gleichung als erstes Argument.

@example
(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
@end example

@c @code{fullratsubst} may cause an indefinite recursion.

@code{fullratsubst} kann zu einer unendlichen Rekursion f@"uhren.

@example
(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
@end example
@end deffn

@c --- 19.02.2011 DK -----------------------------------------------------------
@anchor{gcd}
@deffn  {Funktion} gcd (@var{p_1}, @var{p_2}, @var{x_1}, @dots{})
@deffnx {Optionsvariable} gcd

@c Returns the greatest common divisor of @var{p_1} and @var{p_2}.  The flag 
@c @code{gcd} determines which algorithm is employed.  Setting @code{gcd} to 
@c @code{ez}, @code{subres}, @code{red}, or @code{spmod} selects the 
@c @code{ezgcd}, subresultant @code{prs}, reduced, or modular algorithm,
@c respectively.  If @code{gcd} @code{false} then @code{gcd (@var{p_1}, 
@c @var{p_2}, @var{x})} always returns 1 for all @var{x}.  Many functions (e.g.
@c @code{ratsimp}, @code{factor}, etc.) cause gcd's to be taken implicitly.
@c For homogeneous polynomials it is recommended that @code{gcd} equal to
@c @code{subres} be used.  To take the gcd when an algebraic is present, e.g., 
@c @code{gcd (@var{x}^2 - 2*sqrt(2)*@var{x} + 2, @var{x} - sqrt(2))}, 
@c @code{algebraic} must be @code{true} and @code{gcd} must not be @code{ez}.

Gibt den gr@"o@ss{}ten gemeinsamen Teiler der Polynome @var{p_1} und @var{p_2}
zur@"uck.  Die Argumente @var{x_1}, @dots{} sind optional und haben dieselbe
Bedeutung wie f@"ur die Funktion @mrefdot{ratvars}  Die Optionsvariable 
@code{gcd} kontrolliert, welcher Algorithmus verwendet wird und kann die
folgenden Werte annehmen:

@table @code
@item ez
ezgcd-Alogrithmus
@item subres
Subresultanten-Algorithmus
@item red
Reduzierter modularer Algorithmus
@item spmod
Modularer Algorithmus
@item false
kein Algorithmus, die R@"uckgabe ist immer 1
@end table

@c The @code{gcd} flag, default: @code{spmod}, if @code{false} will also prevent
@c the greatest common divisor from being taken when expressions are converted 
@c to canonical rational expression (CRE) form.  This will sometimes speed the 
@c calculation if gcds are not required.

Siehe auch die @mrefcomma{ezgcd} @mrefcomma{gcdex} @mrefcomma{gcdivide} und
@mrefdot{poly_gcd}

Beispiele:

@example
(%i1) p1:6*x^3+19*x^2+19*x+6; 
                        3       2
(%o1)                6 x  + 19 x  + 19 x + 6
(%i2) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                  5       4       3       2
(%o2)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
(%i3) gcd(p1, p2);
                            2
(%o3)                    6 x  + 13 x + 6
(%i4) p1/gcd(p1, p2), ratsimp;
(%o4)                         x + 1
(%i5) p2/gcd(p1, p2), ratsimp;
                              3
(%o5)                        x  + x
@end example

@c @mref{ezgcd} returns a list whose first element is the greatest common
@c divisor of the polynomials @var{p_1} and @var{p_2}, and whose remaining
@c elements are the polynomials divided by the greatest common divisor.

Die Funktion @mref{ezgcd} gibt als Ergebnis eine Liste zur@"uck, die als erstes
Element den gr@"o@ss{}ten gemeinsamen Teiler und als weitere Elemente die durch
den gr@"o@ss{}ten gemeinsamen Teiler dividierten Polynome enth@"alt.

@example
(%i6) ezgcd(p1, p2);
                    2                     3
(%o6)           [6 x  + 13 x + 6, x + 1, x  + x]
@end example
@end deffn

@c --- 19.02.2011 DK -----------------------------------------------------------
@anchor{gcdex}
@deffn  {Funktion} gcdex (@var{p_1}, @var{p_2})
@deffnx {Funktion} gcdex (@var{p_1}, @var{p_2}, @var{x})

@c Returns a list @code{[@var{a}, @var{b}, @var{u}]} where @var{u} is the 
@c greatest common divisor (gcd) of @var{f} and @var{g}, and @var{u} is equal to
@c @code{@var{a} @var{f} + @var{b} @var{g}}.  The arguments @var{f} and @var{g} 
@c should be univariate polynomials, or else polynomials in @var{x} a supplied 
@c @b{main} variable since we need to be in a principal ideal domain for this to
@c work.  The gcd means the gcd regarding @var{f} and @var{g} as univariate 
@c polynomials with coefficients being rational functions in the other 
@c variables.

Wendet den erweiterten Euklidischen Algorithmus f@"ur die beiden Polynome
@var{p_1} und @var{p_2} an und gibt eine Liste @code{[s, t, u]} mit den
Parametern @var{u}, @var{s} und @var{t} als Ergebnis zur@"uck.  Der Parameter
@var{u} ist der gr@"o@ss{}te gemeinsame Teiler der Polynome.  Die Parameter
@var{s} und @var{t} sind die Bezoutkoeffizienten, so dass gilt
@code{u = s * p_1 + t * p_2}.

Die R@"uckgabe der Funktion @code{gcdex} ist in der CRE-Form.

@c @code{gcdex} implements the Euclidean algorithm, where we have a sequence of 
@c @code{L[i]: [a[i], b[i], r[i]]} which are all perpendicular to 
@c @code{[f, g, -1]} and the next one is built as if 
@c @code{q = quotient(r[i]/r[i+1])} then @code{L[i+2]: L[i] - q L[i+1]}, and it
@c terminates at @code{L[i+1]} when the remainder @code{r[i+2]} is zero.

Siehe auch die Funktionen @mrefcomma{ezgcd} @mref{gcd} und @mrefdot{gcdivide}

Die Argumente @var{f} und @var{g} k@"onnen ganze Zahlen sein.  In diesem Falle
wird die Funktion @mref{igcdex} von der Funktion @code{gcdex} aufgerufen.

Siehe auch die Funktionen @mrefcomma{ezgcd} @mrefcomma{gcd}@w{}
@mref{gcdivide} und @mrefdot{poly_gcd}

Beispiel:

@example
(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
@end example

Im folgenden Beispiel ist die unabh@"angige Variable explizit als @var{x}
angegeben.  Ohne diese Angabe ist @var{y} die unabh@"angige Variable.

@example
(%i1) gcdex (x*(y + 1), y^2 - 1, x);
                               1
(%o1)/R/                 [0, ------, 1]
                              2
                             y  - 1
@end example
@end deffn

@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN 
@c INTEGERS ARE REFERENCED

@c --- 03.07.2011 DK -----------------------------------------------------------
@anchor{gcfactor}
@deffn {Funktion} gcfactor (@var{g})

@c Factors the Gaussian integer @var{n} over the Gaussian integers, i.e.,
@c numbers of the form @code{@var{a} + @var{b} @code{%i}} where @var{a} and
@c @var{b} are rational integers (i.e.,  ordinary integers).  Factors are
@c normalized by making @var{a} and @var{b} non-negative.

Faktorisiert die Gau@ss{}sche Zahl @var{g} @"uber die Gau@ss{}sche Zahlen.  Eine
Gau@ss{}sche Zahl @code{g} ist durch @code{g = a + b*%i} gegeben, wobei @code{a}
und @code{b} ganze Zahlen sind.  Die Faktoren werden so normalisiert, dass
@var{a} und @var{b} nicht negativ sind.

Beispiele:

@example
(%i1) gcfactor(5);
(%o1)               - %i (1 + 2 %i) (2 + %i)
(%i2) expand(%);
(%o2)                           5
(%i3) gcfactor(5+%i);
(%o3)               - %i (1 + %i) (2 + 3 %i)
(%i4) expand(%);
(%o4)                        %i + 5
@end example
@end deffn

@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN 
@c INTEGERS ARE REFERENCED

@c --- 03.07.2011 DK -----------------------------------------------------------
@anchor{gfactor}
@deffn {Funktion} gfactor (@var{expr})

@c Factors the polynomial @var{expr} over the Gaussian integers
@c (that is, the integers with the imaginary unit @code{%i} adjoined).
   @c "This is like" -- IS IT THE SAME OR NOT ??
@c This is like @code{factor (@var{expr}, @var{a}^2+1)} where @var{a} is
@c @code{%i}.

Faktorisiert das Polynom @var{expr} @"uber die Gau@ss{}schen Zahlen.  Das ist
die Faktorisierung @"uber den K@"orper der ganzen Zahlen, der um das Element
@var{%i} erweitert ist.

Die Faktorisierung der Funktion @code{gfactor} ist @"aquivalent zu
@code{factor(@var{expr}), @var{a}^2+1)} mit dem minimalen Polynom
@code{@var{a}^2+1}, das die Nullstelle @code{%i} hat.  Siehe auch
@mrefdot{factor}

Beispiel:

@example
(%i1) gfactor(x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
(%i2) factor(x^4 - 1, a^2+1);
(%o2)            (x - 1) (x + 1) (x - a) (x + a)
@end example
@end deffn

@c DESCRIBE THIS INDEPENDENTLY OF factorsum
@c THIS ITEM NEEDS MORE WORK

@c --- 03.07.2011 DK -----------------------------------------------------------
@anchor{gfactorsum}
@deffn {Funktion} gfactorsum (@var{expr})

@c is similar to @code{factorsum} but applies @code{gfactor} instead
@c of @code{factor}.

Entspricht der Funktion @mref{factorsum} mit den Unterschied, dass anstatt der
Funktion @mref{factor} die Funktion @mref{gfactor} angewendet wird, um den
Ausdruck @var{expr} zu faktorisieren.
@end deffn

@c --- 19.02.2011 DK -----------------------------------------------------------
@anchor{hipow}
@deffn {Funktion} hipow (@var{expr}, @var{x})

Gibt den gr@"o@ss{}ten Exponenten des Arguments @var{x} zur@"uck, der im
Ausdruck @var{expr} auftritt.  Treten symbolische Exponenten auf, wird ein
Ausdruck mit @code{max} zur@"uckgegeben.  Ist das Argument @var{x} nicht im
Ausdruck vorhanden, ist die R@"uckgabe @code{0}.

Die Funktion @code{hipow} betrachtet keine @"aquivalenten Ausdr@"ucke.  Daher
k@"onnen die Ausdr@"ucke @code{expand(@var{expr})} und @var{expr} ein
verschiedenes Ergebnis haben.

Siehe auch die Funktionen @mref{lopow} und @mrefdot{coeff}

@need 800
Beispiele:

@example
(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
(%i1) hipow ((x+y)^2 + (x+y)^a, x+y);
(%o1)                       max(2, a)
@end example
@end deffn

@c I SUSPECT THE FOLLOWING TEXT IS OUTDATED DUE TO CHANGES IN INTEGER FACTORING 
@c CODE

@c --- 03.07.2011 DK -----------------------------------------------------------
@anchor{intfaclim}
@defvr {Optionsvariable} intfaclim
Standardwert: @code{true}

@c If @code{true}, maxima will give up factorization of
@c integers if no factor is found after trial divisions and Pollard's rho
@c method and factorization will not be complete.

@c When @code{intfaclim} is @code{false} (this is the case when the user
@c calls @code{factor} explicitly), complete factorization will be
@c attempted.  @code{intfaclim} is set to @code{false} when factors are
@c computed in @code{divisors}, @code{divsum} and @code{totient}.
   @c ANY OTHERS ??

   @c WHAT ARE THESE MYSTERIOUS INTERNAL CALLS ?? (LET'S JUST LIST THE FUNCTIONS
   @c INVOLVED)
@c Internal calls to @code{factor} respect the user-specified value of
@c @code{intfaclim}.  Setting @code{intfaclim} to @code{true} may reduce
@c the time spent factoring large integers.

Hat die Optionsvariable @mref{intfaclim} den Wert @code{true}, gibt Maxima
die Faktorisierung von ganzen Zahlen auf, wenn keine Faktorisierung durch
Anwendung der Methode der Probedivision und der Pollard-Rho-Methode gefunden
werden konnten.

Hat @code{intfaclim} den Wert @code{false}, versucht Maxima eine ganze Zahl
vollst@"andig zu faktorisieren.  @code{intfaclim} wird von den Funktionen
@mrefcomma{divisors} @mref{divsum} und @mref{totient} auf den Wert @code{false}
gesetzt.

Der Wert der Optionsvariablen @code{intfaclim} wird von der Funktion
@code{factor} beachtet.  Mit dem Setzen von @code{intfaclim} kann der Nutzer
verhindern, dass Maxima beim Versuch sehr gro@ss{}e ganze Zahlen zu
faktorisieren, unn@"otig viel Zeit verbraucht.

@c NEED EXAMPLES HERE
@end defvr

@c --- 03.07.2011 DK -----------------------------------------------------------
@anchor{keepfloat}
@defvr {Optionsvariable} keepfloat
Standardwert: @code{false}

@c When @code{keepfloat} is @code{true}, prevents floating
@c point numbers from being rationalized when expressions which contain
@c them are converted to canonical rational expression (CRE) form.

@c Note that the function @code{solve} and those functions calling it
@c (@code{eigenvalues}, for example) currently ignore this flag, converting
@c floating point numbers anyway.

Hat die Optionsvariable @code{keepfloat} den Wert @code{true}, werden
Gleitkommazahlen nicht in rationale Zahlen umgewandelt, wenn Ausdr@"ucke mit
Gleitkommazahlen in eine CRE-Form umgewandelt werden.

Die Funktion @mref{solve} und Funktionen, die @code{solve} aufrufen, beachten
den Wert von @code{keepfloat} nicht.

Beispiele:

@example
(%i1) rat(x/2.0);

rat: replaced 0.5 by 1/2 = 0.5
                                x
(%o1)/R/                        -
                                2
(%i2) rat(x/2.0), keepfloat;
(%o2)/R/                      0.5 x
@end example

@c @code{solve} ignores @code{keepfloat}:

Die Funktion @code{solve} ignoriert den Wert der Optionsvariablen
@code{keepfloat}.

@example
(%i3) solve(1.0-x,x), keepfloat;

rat: replaced 1.0 by 1/1 = 1.0
(%o3)                        [x = 1]
@end example
@end defvr

@c --- 19.02.2011 DK -----------------------------------------------------------
@anchor{lopow}
@deffn {Funktion} lopow (@var{expr}, @var{x})

@c Returns the lowest exponent of @var{x} which explicitly appears in 
@c @var{expr}.  Thus

Gibt den kleinsten Exponenten von @var{x} zur@"uck, der im Ausdruck @var{expr}
auftritt.  Treten symbolische Exponententen auf, wird ein Ausdruck mit 
@code{min} zur@"uckgegeben.  Ist das Argument @var{x} nicht im
Ausdruck enthalten, ist die R@"uckgabe 0.

Die Funktion @code{lopow} betrachtet keine @"aquivalenten Ausdr@"ucke.  Daher
k@"onnen die Ausdr@"ucke @code{expand(@var{expr})} und @var{expr} ein
verschiedenes Ergebnis haben.

Siehe auch die Funktionen @mref{hipow} und @mrefdot{coeff}

Beispiele:

@example
(%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
(%o1)                       min(a, 2)
@end example
@end deffn

@c DESCRIBE lratsubst INDEPENDENTLY OF subst
@c THIS ITEM NEEDS MORE WORK

@c --- 05.07.2011 DK -----------------------------------------------------------
@anchor{lratsubst}
@deffn {Funktion} lratsubst (@var{L}, @var{expr})

@c is analogous to @code{subst (@var{L}, @var{expr})}
@c except that it uses @code{ratsubst} instead of @code{subst}.

Ist analog zum Kommando @code{subst (@var{L}, @var{expr})} mit dem Unterschied,
dass anstatt der Funktion @mref{subst} die Funktion @mref{ratsubst} genutzt
wird.

@c The first argument of @code{lratsubst} is an equation or a list of equations
@c identical in format to that accepted by @code{subst}.  The substitutions are
@c made in the order given by the list of equations, that is, from left to
@c right.

@c @code{load ("lrats")} loads @code{fullratsubst} and @code{lratsubst}.

Das erste Argument der Funktion @code{lratsubst} ist eine Gleichung oder eine
Liste mit Gleichungen, die dem Format der Funktion @code{subst} entsprechen.
Die Substitutionen werden in der Reihenfolge der Gleichungen der Liste von links
nach rechts ausgef@"uhrt.

Mit dem Kommando @code{lrats} werden die Funktionen @code{fullratsubst} und
@code{lratsubst} geladen.  Siehe auch die Funktion @mrefdot{fullratsubst}

Beispiele:

@example
(%i1) load (lrats)$
@end example

@c @code{subst} can carry out multiple substitutions.
@c @code{lratsubst} is analogous to @code{subst}.

@code{subst} kann mehrfache Substitutionen ausf@"uhren.  @code{lratsubst} ist
analog zu @code{subst}.

@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example

@c If only one substitution is desired, then a single
@c equation may be given as first argument.

Soll nur eine Substitution ausgef@"uhrt werden, kann eine einzelne Gleichung
als erstes Argument angegeben werden.

@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example
@end deffn

@c --- 03.08.2011 DK -----------------------------------------------------------
@anchor{modulus}
@defvr {Optionsvariable} modulus
Standardwert: @code{false}

@c When @code{modulus} is a positive number @var{p}, operations on rational
@c numbers (as returned by @code{rat} and related functions) are carried out
@c modulo @var{p}, using the so-called "balanced" modulus system in which
@c @code{@var{n} modulo @var{p}} is defined as an integer @var{k} in
@c @code{[-(@var{p}-1)/2, ..., 0, ..., (@var{p}-1)/2]} when @var{p} is odd, or
@c @code{[-(@var{p}/2 - 1), ..., 0, ...., @var{p}/2]} when @var{p} is even, such
@c that @code{@var{a} @var{p} + @var{k}} equals @var{n} for some integer
@c @var{a}.
   @c NEED EXAMPLES OF "BALANCED MODULUS" HERE

Hat die Optionsvariable @code{modulus} eine positive Zahl @var{p} als Wert,
werden Operationen f@"ur rationale Zahlen, wie von der Funktion @mref{rat} und
verwandte Funktionen, modulo @var{p} ausgef@"uhrt.

@code{@var{n}} mod @var{p} ist definiert als eine ganze Zahl, die f@"ur ungerade
@var{p} die Werte @code{[-(@var{p}-1)/2, ..., 0, ..., (@var{p}-1)/2]} annimmt
und f@"ur gerade @var{p} die Werte @code{[-(@var{p}/2 - 1), ..., 0, ....,
@var{p}/2]}, so dass  @code{@var{a} @var{p} + @var{k}} gleich @var{n} ist f@"ur
eine ganze Zahl @var{a}.

   @c WHAT CAN THIS MEAN ?? IS THE MODULUS STORED WITH THE EXPRESSION ??
   @c "... in order to get correct results" WHAT DO YOU GET IF YOU DON'T RE-RAT ??
@c If @var{expr} is already in canonical rational expression (CRE) form when
@c @code{modulus} is reset, then you may need to re-rat @var{expr}, e.g.,
@c @code{expr: rat (ratdisrep (expr))}, in order to get correct results.

Liegt ein Ausdruck @var{expr} bereits in einer CRE-Form vor und wird der Wert
der Optionsvariable @code{modulus} ge@"andert, dann sollte der Ausdruck zum
Beispiel mit dem Kommando @code{expr: rat (ratdisrep (expr))} zun@"achst in die
Standardform gebracht werden, um dann erneut in die CRE-Form umgewandelt zu
werden, um korrekte Ergebnisse zu erzielen.

@c Typically @code{modulus} is set to a prime number.
@c If @code{modulus} is set to a positive non-prime integer,
@c this setting is accepted, but a warning message is displayed.
@c Maxima will allow zero or a negative integer to be assigned to @code{modulus},
@c although it is not clear if that has any useful consequences.

Typischerweise erh@"alt die Optionsvariable @code{modulus} eine Primzahl als
Wert.  Erh@"alt @code{modulus} eine positive ganze Zahl als Wert, die nicht eine
Primzahl ist, wird die Zuweisung akzeptiert, jedoch eine Warnung ausgegeben.
Wird Null oder eine negative Zahl zugewiesen signalisiert Maxima einen Fehler.

Beispiele:

@example
(%i1) modulus:7;
(%o1)                           7
(%i2) polymod([0,1,2,3,4,5,6,7]);
(%o2)            [0, 1, 2, 3, - 3, - 2, - 1, 0]
(%i3) modulus:false;
(%o3)                         false
(%i4) poly:x^6+x^2+1;
                            6    2
(%o4)                      x  + x  + 1
(%i5) factor(poly);
                            6    2
(%o5)                      x  + x  + 1
(%i6) modulus:13;
(%o6)                          13
(%i7) factor(poly);
@group
                      2        4      2
(%o7)               (x  + 6) (x  - 6 x  - 2)
@end group
(%i8) polymod(%);
                            6    2
(%o8)                      x  + x  + 1
@end example
@end defvr

@c APPARENTLY OBSOLETE: ONLY EFFECT OF $newfac COULD BE TO CAUSE NONEXISTENT
@c FUNCTION NMULTFACT TO BE CALLED (IN FUNCTION FACTOR72 IN src/factor.lisp
@c CIRCA LINE 1400)
@c $newfac NOT USED IN ANY OTHER CONTEXT (ASIDE FROM DECLARATIONS)
@c COMMENT IT OUT NOW, CUT IT ON THE NEXT PASS THROUGH THIS FILE
@c @defvar newfac
@c Default value: @code{false}
@c 
@c When @code{newfac} is @code{true}, @code{factor} will use the new factoring
@c routines.
@c 
@c @end defvar

@c --- 05.07.2011 DK -----------------------------------------------------------
@anchor{num}
@deffn {Funktion} num (@var{expr})

@c Returns the numerator of @var{expr} if it is a ratio.
@c If @var{expr} is not a ratio, @var{expr} is returned.

@c @code{num} evaluates its argument.

Gibt den Z@"ahler des Ausdrucks @var{expr} zur@"uck, wenn dieser ein
Quotient ist.  Ist der Ausdruck @var{expr} kein Quotient wird @var{expr}
zur@"uckgegeben.

Die Funktion @code{num} wertet das Argument aus.  Siehe auch die Funktion
@mrefdot{denom}

Beispiel:

@example
(%i1) num(x^2/(x+1));
                                2
(%o1)                          x
@end example
@end deffn

@c --- 05.07.2011 DK -----------------------------------------------------------
@anchor{partfrac}
@deffn {Funktion} partfrac (@var{expr}, @var{var})

@c Expands the expression @var{expr} in partial fractions with respect to the
@c main variable @var{var}.  @code{partfrac} does a complete partial fraction
@c decomposition.

@c TODO: BESCHREIBUNG DES ALGORITHMUS IST NICHT UEBERSETZT

@c The algorithm employed is based on the fact that the
@c denominators of the partial fraction expansion (the factors of the original
@c denominator) are relatively prime.  The numerators can be written as linear
@c combinations of denominators, and the expansion falls out.

F@"uhrt f@"ur den Ausdruck @var{expr} eine vollst@"andige Partialbruchzerlegung
aus.

@example
(%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                      2       2        1
(%o1)               ----- - ----- + --------
                    x + 2   x + 1          2
                                    (x + 1)
(%i2) ratsimp (%);
                                 x
(%o2)                 - -------------------
                         3      2
                        x  + 4 x  + 5 x + 2
(%i3) partfrac (%, x);
                      2       2        1
(%o3)               ----- - ----- + --------
                    x + 2   x + 1          2
                                    (x + 1)
@end example
@end deffn

@c --- 05.07.2011 DK -----------------------------------------------------------
@anchor{polydecomp}
@deffn {Funktion} polydecomp (@var{p}, @var{x})

@c Decomposes the polynomial @var{p} in the variable @var{x}
@c into the functional composition of polynomials in @var{x}.
@c @code{polydecomp} returns a list @code{[@var{p_1}, ..., @var{p_n}]} such that

Zerlegt das Polynom @var{p} in der Variablen @var{x} in Polynome, die
miteinander verkettet das urspr@"ungliche Polynom ergeben.  @code{polydecomp}
gibt eine Liste @code{[@var{p_1}, ..., @var{p_n}]} zur@"uck, so dass der
folgende Ausdruck gleich dem Polynom @var{p} ist:

@example
lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x))
  ...))
@end example

@c is equal to @var{p}.
@c The degree of @var{p_i} is greater than 1 for @var{i} less than @var{n}.

Der Grad des Polynoms @var{p_i} ist gr@"o@ss{}er als 1 f@"ur @var{i} kleiner
als @var{n}.

@c Such a decomposition is not unique.

Eine solche Zerlegung ist nicht eindeutig.

Beispiele:

@example
(%i1) polydecomp (x^210, x);
                          7   5   3   2
(%o1)                   [x , x , x , x ]
(%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                6      4      3    2
(%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
(%i3) polydecomp (p, x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

@c The following function composes @code{L = [e_1, ..., e_n]} as functions in
@c @code{x}; it is the inverse of polydecomp:

Die folgende Funktion verkettet die Elemente der Liste
@code{L = [e_1, ..., e_n]} zu einer Funktion in der Variablen @var{x}.  Diese
Funktion ist die Inverse Operation zu der Funktion @code{polydecomp}.

@example
compose (L, x) :=
  block ([r : x], for e in L do r : subst (e, x, r), r) $
@end example

@c Re-express above example using @code{compose}:

Anwendung der Funktionen @code{compose} und @code{polydecomp}.

@example
(%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

@c Note that though @code{compose (polydecomp (@var{p}, @var{x}), @var{x})}
@c always returns @var{p} (unexpanded),
@c @code{polydecomp (compose ([@var{p_1}, ..., @var{p_n}], @var{x}), @var{x})}
@c does @i{not} necessarily return @code{[@var{p_1}, ..., @var{p_n}]}:

W@"ahrend  @code{compose (polydecomp (@var{p}, @var{x}), @var{x})} immer das
Polynom @var{p} als Ergebnis hat, hat @code{polydecomp (compose ([@var{p_1},
..., @var{p_n}], @var{x}), @var{x})} nicht notwendigerweise das Ergebnis
@code{[@var{p_1}, ..., @var{p_n}]}.

@example
(%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                          2       2
(%o4)                   [x  + 2, x  + 1]
(%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
@group
                      2       2
                     x  + 3  x  + 5
(%o5)               [------, ------, 2 x + 1]
                       4       2
@end group
@end example
@end deffn

@c --- 05.07.2011 DK -----------------------------------------------------------
@anchor{polymod}
@deffn  {Funktion} polymod (@var{p})
@deffnx {Funktion} polymod (@var{p}, @var{m})

@c Converts the polynomial @var{p} to a modular representation with respect to 
@c the current modulus which is the value of the variable @code{modulus}.

Konvertiert das Polynom @var{p} in eine modulare Darstellung bez@"uglich
dem aktuellen Modul.  Das Modul ist der Wert der Variablen @code{modulus}.

@c @code{polymod (@var{p}, @var{m})} specifies a modulus @var{m} to be used 
@c instead of the current value of @code{modulus}.

@code{polymod(@var{p}, @var{m}} konvertiert das Polynom bez@"uglich dem Modul 
@var{m}, anstatt dem aktuellen Modul @code{modulus}.

@c See @code{modulus}.

Siehe auch @mrefdot{modulus}
@end deffn

@c --- 30.06.2011 DK -----------------------------------------------------------
@anchor{powers}
@deffn {Funktion} powers (@var{expr}, @var{x})

@c Gives the powers of @var{x} occuring in @var{expr}.
@c @code{load (powers)} loads this function.

Gibt eine Liste mit den Potenzen der Variablen @var{x} zur@"uck, die im
Ausdruck @var{expr} auftreten.

Mit dem Kommando @code{load(powers)} wird die Funktion geladen.

@c HMM, THERE'S A BUNCH OF MAXIMA FUNCTIONS IN src/powers.lisp ...
@c FOR SOME REASON src/powers.lisp IS NOT PART OF THE USUAL BUILD -- STRANGE

@c HERE IS THE TEXT FROM archive/share/unknown/powers.usg -- MERGE !!!
@c THIS FUNCTION IS A GENERALISATION OF "HIPOW" AND "LOPOW"
@c IN THAT IT RETURNS A LIST OF ALL THE POWERS OF VAR OCCURING
@c IN EXPR. IT IS STILL NECESSARY TO EXPAND EXPR BEFORE APPLYING
@c POWERS (ON PAIN OF GETTING THE WRONG ANSWER).
@c 
@c THIS FUNCTION HAS MANY USES, E.G. IF YOU WANT TO FIND ALL
@c THE COEFFICIENTS OF X IN A POLYNOMIAL POLY YOU CAN USE
@c MAP(LAMBDA([POW],COEFF(POLY,X,POW)),POWERS(POLY,X));
@c AND MANY OTHER SIMILAR USEFUL HACKS.
@end deffn

@c --- 19.02.2011 DK -----------------------------------------------------------
@anchor{quotient}
@deffn  {Funktion} quotient (@var{p_1}, @var{p_2})
@deffnx {Funktion} quotient (@var{p_1}, @var{p_2}, @var{x_1}, @dots{}, @var{x_n})

Berechnet den Quotienten der Polynome @var{p_1} und @var{p_2} f@"ur die Variable
@var{x_n}.  Die anderen Variablen @var{x_1}, @dots{}, @var{x_n-1} haben dieselbe
Bedeutung wie f@"ur die Funktion @mrefdot{ratvars}

@code{quotient} gibt das erste Element des Ergebnisses der Funktion
@mref{divide} zur@"uck.

Siehe auch die Funktion @mrefdot{remainder}

Beispiel:

@example
(%i1) poly1 : x^3-2*x^2-5*x+7;
                        3      2
(%o1)                  x  - 2 x  - 5 x + 7
(%i2) poly2 : x-1;
(%o2)                         x - 1
(%i3) quotient(poly1, poly2, x);
                            2
(%o3)                      x  - x - 6
@end example
@end deffn

@c THIS ITEM CAN PROBABLY BE IMPROVED

@c --- 27.11.2011 DK -----------------------------------------------------------
@anchor{rat}
@deffn  {Funktion} rat (@var{expr})
@deffnx {Funktion} rat (@var{expr}, @var{x_1}, @dots{}, @var{x_n})

@c Converts @var{expr} to canonical rational expression (CRE) form by expanding
@c and combining all terms over a common denominator and cancelling out the
@c greatest common divisor of the numerator and denominator, as well as
@c converting floating point numbers to rational numbers within a
@c tolerance of @code{ratepsilon}.
@c The variables are ordered according
@c to the @var{x_1}, ..., @var{x_n}, if specified, as in @code{ratvars}.

Konvertiert einen Ausdruck @var{expr} in die CRE-Form.  Der Ausdruck wird so 
expandiert und gruppiert, dass alle Terme einen gemeinsamen Nenner haben und
der gr@"o@ss{}te gemeinsame Teiler gek@"urzt ist.  Weiterhin werden
Gleitkommazahlen in rationale Zahlungen umgewandelt.  Die Toleranz der
Umwandlung wird von der Optionsvariablen @mref{ratepsilon} kontrolliert.  Die
Variablen im Ausdruck werden entsprechend der Funktion @mref{ratvars}@w{}
gem@"a@ss{} der angegebenen Argumente @var{x_1}, @dots{}, @var{x_n} angeordnet.

@c @code{rat} does not generally simplify functions other than addition
@c @code{+}, subtraction @code{-}, multiplication @code{*}, division @code{/},
@c and exponentiation to an integer power, whereas @code{ratsimp} does handle
@c those cases.  Note that atoms (numbers and variables) in CRE form are not the
@c same as they are in the general form.  For example, @code{rat(x)- x} yields 
@c @code{rat(0)} which has a different internal representation than 0.

@code{rat} vereinfacht im Allgemeinen keine Ausdr@"ucke bis auf die Addition
@code{+}, Subtraktion @code{-}, Multiplikation @code{*}, Division @code{/}
und die Exponentiation @code{^} mit einer ganzen Zahl.  Dagegen f@"uhrt die
Funktion @mref{ratsimp} auch weitere Vereinfachungen aus.  Variablen und Zahlen
in einer CRE-Form sind nicht identisch mit denen in der Standardform.  Zum
Beispiel hat @code{rat(x)- x} das Ergebnis @code{rat(0)}, welches eine 
andere interne Darstellung als @code{0} hat.

   @c WHAT'S THIS ABOUT EXACTLY ??
@c When @code{ratfac} is @code{true}, @code{rat} yields a partially factored
@c form for CRE.  During rational operations the expression is maintained as
@c fully factored as possible without an actual call to the factor package.
@c This should always save space and may save some time in some computations.

@c TODO: DEN LETZTEN TEIL NICHT UEBERSETZT

@c The numerator and denominator are still made relatively prime (e.g.
@c @code{rat ((x^2 - 1)^4/(x + 1)^2)} yields @code{(x - 1)^4 (x + 1)^2)},
@c but the factors within each part may not be relatively prime.

Hat die Optionsvariable @mref{ratfac} den Wert @code{true}, wird ein Ausdruck
von der Funktion @code{rat} nur teilweise faktorisiert.  Bei der Ausf@"uhrung
von Operationen wird bleibt der Ausdruck so vollst@"andig als m@"oglich in
seiner faktorisierten Form, ohne dass eine Faktorisierung ausgef@"uhrt wird.
Damit kann Rechenzeit eingespart werden.

@c @code{ratprint} if @code{false} suppresses the printout of the message
@c informing the user of the conversion of floating point numbers to
@c rational numbers.

Hat die Optionsvariable @mref{ratprint} den Wert @code{false}, werden
Meldungen unterdr@"uckt, wenn eine Gleitkommazahl in eine rationale
umgewandelt wird.

@c @code{keepfloat} if @code{true} prevents floating point numbers from being
@c converted to rational numbers.

Hat die Optionsvariable @mref{keepfloat} den Wert @code{true}, werden
Gleitkommazahlen nicht in rationale Zahlen umgewandelt.

@c See also @code{ratexpand} and @code{ratsimp}.

Siehe auch die Funktionen @mref{ratexpand} und @mrefcomma{ratsimp} um
Ausdr@"ucke zu vereinfachen, sowie die Funktion @mrefcomma{ratdisrep} um einen
Ausdruck von einer CRE-Form in eine allgemeine Form zu transformieren.

Beispiele:

@example
(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /
      (4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
@group
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
@end group
@end example
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratalgdenom}
@defvr {Optionsvariable} ratalgdenom
Standardwert: @code{true}

@c When @code{ratalgdenom} is @code{true}, allows rationalization of
@c denominators with respect to radicals to take effect.
@c @code{ratalgdenom} has an effect only when canonical rational expressions
@c (CRE) are used in algebraic mode.

Hat die Optionsvariable @code{ratalgdenom} den Wert @code{true}, versucht
Maxima den Nenner beim Auftreten von Wurzeln rational zu machen.
@code{ratalgdenom} wirkt sich nur aus, wenn die Optionsvariable
@mref{algebraic} den Wert @code{true} hat und der Ausdruck in einer CRE-Form
vorliegt.

Beispiele:

@example
(%i1) algebraic:true$

(%i2) ratalgdenom:false$

(%i3) rat(sqrt(3)/sqrt(2));
                             sqrt(3)
(%o3)/R/                     -------
                             sqrt(2)
(%i4) ratalgdenom:true$

(%i5) rat(sqrt(3)/sqrt(2));
                         sqrt(2) sqrt(3)
(%o5)/R/                 ---------------
                                2
(%i6) algebraic:false$

(%i7) rat(sqrt(3)/sqrt(2));
                             sqrt(3)
(%o7)/R/                     -------
                             sqrt(2)
@end example
@end defvr

@c THIS ITEM NEEDS MORE WORK

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratcoef}
@deffn  {Funktion} ratcoef (@var{expr}, @var{x}, @var{n})
@deffnx {Funktion} ratcoef (@var{expr}, @var{x})

@c Returns the coefficient of the expression @code{@var{x}^@var{n}}
@c in the expression @var{expr}.
@c If omitted, @var{n} is assumed to be 1.

Gibt den Koeffizienten des Ausdrucks @code{@var{x}^@var{n}} in dem Argument
@var{expr} zur@"uck.  Wenn das Argument @var{n} nicht angegeben ist, wird
der Wert zu @code{1} angenommen.

@c The return value is free
@c (except possibly in a non-rational sense) of the variables in @var{x}.
@c If no coefficient of this type exists, 0 is returned.

Die R@"uckgabe ist frei von der Variablen @var{x}.  Existiert kein Koeffizient
@code{@var{x}^@var{n}} dann ist die R@"uckgabe @code{0}.

@c @code{ratcoef}
@c expands and rationally simplifies its first argument and thus it may
@c produce answers different from those of @code{coeff} which is purely
@c syntactic.
   @c MOVE THIS TO EXAMPLES SECTION
@c Thus @code{ratcoef ((x + 1)/y + x, x)} returns @code{(y + 1)/y} whereas
@c @code{coeff} returns 1.

@code{ratcoef} expandiert und vereinfacht das Argument @var{expr}.  Daher kann
@code{ratcoef} ein anderes Ergebnis als die Funktion @mref{coeff} haben, die
keine Vereinfachungen ausf@"uhrt.  Daher @code{ratcoef((x + 1)/y + x, x)} das
Ergebnis @code{(y + 1)/y} und nicht das Ergebnis @code{1} wie es von der
Funktion @code{coeff} zur@"uckgegeben wird.

@c @code{ratcoef (@var{expr}, @var{x}, 0)}, viewing @var{expr} as a sum,
@c returns a sum of those terms which do not contain @var{x}.
   @c "SHOULD NOT" -- WHAT DOES THIS MEAN ??
@c Therefore if @var{x} occurs to any negative powers, @code{ratcoef} should not
@c be used.

@code{ratcoef(@var{expr}, @var{x}, 0)} gibt eine Summe der Terme zur@"uck, die
die Variable @var{x} nicht enthalten.

   @c WHAT IS THE INTENT HERE ??
@c Since @var{expr} is rationally
@c simplified before it is examined, coefficients may not appear quite
@c the way they were envisioned.

Beispiele:

@example
(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
@end example
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratdenom}
@deffn {Funktion} ratdenom (@var{expr})

Gibt den Nenner des Argumentes @var{expr} zur@"uck.  @code{ratdenom} wandelt
den Ausdruck zuerst in eine CRE-Form um und gibt das Ergebnis in einer 
CRE-Form zur@"uck.

Das Argument @var{expr} wird von der Funktion @mref{rat} in eine CRE-Form
gebracht, falls @var{expr} nicht bereits in einer CRE-Form vorliegt.  Diese
Transformation kann den Ausdruck @var{expr} ver@"andern, da alle Terme @"uber
einen gemeinsamen Nenner zusammengefasst werden.

Die Funktion @mref{denom} ist vergleichbar.  @code{denom} wandelt den Ausdruck
jedoch nicht eine CRE-Form um und hat als Ergebnis einen Ausdruck in der
Standardform.  Daher k@"onnen sich die Ergebnisse von @code{ratdenom} und 
@code{denom} voneinander unterscheiden.

Beispiel:

@example
(%i1) expr: expand((x^2+2*x+3)/(x-1));
@group
                        2
                       x       2 x      3
(%o1)                 ----- + ----- + -----
                      x - 1   x - 1   x - 1
@end group
(%i2) ratdenom(expr);
(%o2)/R/                      x - 1
(%i3) denom(expr);
(%o3)                           1
@end example
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratdenomdivide}
@defvr {Optionsvariable} ratdenomdivide
Standardwert: @code{true}

@c When @code{ratdenomdivide} is @code{true},
@c @code{ratexpand} expands a ratio in which the numerator is a sum 
@c into a sum of ratios,
@c all having a common denominator.
@c Otherwise, @code{ratexpand} collapses a sum of ratios into a single ratio,
@c the numerator of which is the sum of the numerators of each ratio.

Hat die Optionsvariable @code{ratdenomdivide} den Wert @code{true}, expandiert
die Funktion @mref{ratexpand} einen Quotienten der im Z@"ahler eine Summe hat,
in eine Summe der Quotienten.  Ansonsten werden die Terme @"uber einen
gemeinsamen Nenner zusammengefasst.

Beispiele:

@example
(%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                            2
                           x  + x + 1
(%o1)                      ----------
                              2
                             y  + 7
(%i2) ratdenomdivide: true$
(%i3) ratexpand (expr);
                       2
                      x        x        1
(%o3)               ------ + ------ + ------
                     2        2        2
                    y  + 7   y  + 7   y  + 7
(%i4) ratdenomdivide: false$
(%i5) ratexpand (expr);
                            2
                           x  + x + 1
(%o5)                      ----------
                              2
                             y  + 7
(%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
@group
                                     2
                           b        a
(%o6)                    ------ + ------
                          2        2
                         b  + 3   b  + 3
@end group
(%i7) ratexpand (expr2);
                                  2
                             b + a
(%o7)                        ------
                              2
                             b  + 3
@end example
@end defvr

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratdiff}
@deffn {Funktion} ratdiff (@var{expr}, @var{x})

@c Differentiates the rational expression @var{expr} with respect to @var{x}.
@c @var{expr} must be a ratio of polynomials or a polynomial in @var{x}.
@c The argument @var{x} may be a variable or a subexpression of @var{expr}.
   @c NOT CLEAR (FROM READING CODE) HOW x OTHER THAN A VARIABLE IS HANDLED --
   @c LOOKS LIKE (a+b), 10*(a+b), (a+b)^2 ARE ALL TREATED LIKE (a+b);
   @c HOW TO DESCRIBE THAT ??

Differenziert einen rationalen Ausdruck @var{expr} nach der Variablen @var{x}.
@var{expr} muss eine rationale Funktion oder ein Polynom in der Variablen
@var{x} sein.  Das Argument @var{x} kann ein Teilausdruck des Argumentes
@var{expr} sein.

@c The result is equivalent to @code{diff}, although perhaps in a different
@c form.  @code{ratdiff} may be faster than @code{diff}, for rational
@c expressions.

Das Ergebnis ist @"aquivalent zum Ergebnis der Funktion @mrefcomma{diff}@w{}
kann aber eine andere Form haben.  F@"ur rationale Funktionen kann die
Funktion @code{ratdiff} schneller sein.

@c @code{ratdiff} returns a canonical rational expression (CRE) if @code{expr}
@c is a CRE.  Otherwise, @code{ratdiff} returns a general expression.

@code{ratdiff} gibt das Ergebnis in einer CRE-Form zur@"uck, wenn das Argument
in einer CRE-Form vorliegt.  Ansonsten ist das Ergebnis in der Standardform.

@c @code{ratdiff} considers only the dependence of @var{expr} on @var{x},
@c and ignores any dependencies established by @code{depends}.

@code{ratdiff} beachtet nur die Abh@"angigkeit des Ausdrucks von der Variablen
@var{x}.  Abh@"angigkeiten die mit der Funktion @mref{depends} definiert werden,
werden von der Funktion @code{ratdiff} ignoriert.

@c WHAT THIS IS ABOUT -- ratdiff (rat (factor (expr)), x) AND
@c ratdiff (factor (rat (expr)), x) BOTH SUCCEED COMMENTING THIS OUT UNTIL
@c SOMEONE CAN ESTABLISH SOME CRE'S FOR WHICH ratdiff FAILS
@c However, @code{ratdiff} should not be used on factored CRE forms;
@c use @code{diff} instead for such expressions.

Beispiele:

@example
(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) ratdiff (expr, x);
                    7       5       4       2
                 8 x  + 40 x  - 55 x  - 60 x  - 50
(%o2)          - ---------------------------------
                          10       5
                         x   + 10 x  + 25
(%i3) expr: f(x)^3 - f(x)^2 + 7;
                         3       2
(%o3)                   f (x) - f (x) + 7
(%i4) ratdiff (expr, f(x));
                           2
(%o4)                   3 f (x) - 2 f(x)
(%i5) expr: (a + b)^3 + (a + b)^2;
                              3          2
(%o5)                  (b + a)  + (b + a)
(%i6) ratdiff (expr, a + b);
@group
                    2                    2
(%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a
@end group
@end example
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratdisrep}
@deffn {Funktion} ratdisrep (@var{expr})

@c Returns its argument as a general expression.
@c If @var{expr} is a general expression, it is returned unchanged.

Gibt das Argument @var{expr} als einen allgemeinen Ausdruck zur@"uck.  Ist
@var{expr} bereits ein allgemeiner Ausdruck, wird dieser unver@"andert
zur@"uckgegeben.

@c Typically @code{ratdisrep} is called to convert a canonical rational
@c expression (CRE) into a general expression.

@c TODO: FOLGENDE BEMERKUNG NICHT UEBERSETZT

   @c NOT REALLY FOND OF YOU-CAN-DO-THIS-YOU-CAN-DO-THAT STATEMENTS
@c This is sometimes convenient if one wishes to stop the "contagion", or
@c use rational functions in non-rational contexts.

Im Allgemeinen wird die Funktion @code{ratdisrep} aufgerufen, um einen
Ausdruck von der CRE-Form in einen allgemeinen Ausdruck umzuwandeln.

@c See also @code{totaldisrep}.

Siehe auch die Funktion @mrefdot{totaldisrep}
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratexpand}
@deffn  {Funktion} ratexpand (@var{expr})
@deffnx {Optionsvariable} ratexpand

@c Expands @var{expr} by multiplying out products of sums and
@c exponentiated sums, combining fractions over a common denominator,
@c cancelling the greatest common divisor of the numerator and
@c denominator, then splitting the numerator (if a sum) into its
@c respective terms divided by the denominator.

Expandiert das Argument @var{expr} indem Produkte und Potenzen von Summen
ausmultipliziert, Br@"uche @"uber einen gemeinsamen Nenner dargestellt werden
und der gr@"o@ss{}te gemeinsamen Teiler heraus gek@"urzt wird.  Ist der Z@"ahler
eine Summe, wird er in seine Terme aufgespalten, die jeweils durch den Nenner
dividiert werden.

@c The return value of @code{ratexpand} is a general expression,
@c even if @var{expr} is a canonical rational expression (CRE).

Die R@"uckgabe der Funktion @code{ratexpand} ist ein allgemeiner Ausdruck, auch
wenn das Argument @var{expr} ein Ausdruck in der CRE-Form ist.

   @c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
@c The switch @code{ratexpand} if @code{true} will cause CRE
@c expressions to be fully expanded when they are converted back to
@c general form or displayed, while if it is @code{false} then they will be put
@c into a recursive form.
@c See also @code{ratsimp}.

@c TODO: DIE OPTIONSVARIABLE RATEXPAND HAT KEINEN EINFLUSS AUF DIE VEREINFACHUNG
@c       DER FUNKTION RATEXPAND. BESSER EINEN EIGENEN EINTRAG???

Die Optionsvariable @code{ratexpand} kontrolliert die Vereinfachung der Funktion
@code{ratsimp}.  Hat @code{ratexpand} den Wert @code{true}, wird ein Ausdruck
vollst@"andig ausmultipliziert. Ist der Wert @code{false}, wird der Ausdruck
nur bez@"uglich der Hauptvariablen ausmultipliziert.  Zum Beispiel hat 
@code{ratsimp((x+1)*(y+1))} das Ergebnis @code{x y + y + x + 1}, wenn
@code{ratexpand} den Wert @code{true} hat, ansonsten ist das Ergebnis
@code{(x + 1) y + x + 1}.  Siehe auch die Funktion @mrefdot{ratsimp}

@c When @code{ratdenomdivide} is @code{true},
@c @code{ratexpand} expands a ratio in which the numerator is a sum 
@c into a sum of ratios, all having a common denominator.
@c Otherwise, @code{ratexpand} collapses a sum of ratios into a single ratio,
@c the numerator of which is the sum of the numerators of each ratio.

Hat die Optionsvariable @mref{ratdenomdivide} den Wert @code{true}, expandiert
die Funktion @mref{ratexpand} einen Quotienten der im Z@"ahler eine Summe hat,
in eine Summe der Quotienten.  Ansonsten werden die Terme @"uber einen
gemeinsamen Nenner zusammengefasst.

@c When @code{keepfloat} is @code{true}, prevents floating
@c point numbers from being rationalized when expressions which contain
@c them are converted to canonical rational expression (CRE) form.

Hat die Optionsvariable @mref{keepfloat} den Wert @code{true}, werden
Gleitkommazahlen im Argument @var{expr} nicht in rationale Zahlen umgewandelt,
wenn der Ausdruck in eine CRE-Form umgewandelt wird.

Beispiele:

@example
(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
@group
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
@end group
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
@end example
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratfac}
@defvr {Optionsvariable} ratfac
Standardwert: @code{false}

@c When @code{ratfac} is @code{true}, canonical rational expressions (CRE) are
@c manipulated in a partially factored form.
@c During rational operations the expression is maintained as fully factored as
@c possible without calling @code{factor}.
@c This should always save space and may save time in some computations.

@c TODO: DAS FOLGENDE NICHT UEBERSETZT

@c The numerator and denominator are made relatively prime, for example
@c @code{rat ((x^2 - 1)^4/(x + 1)^2)} yields @code{(x - 1)^4 (x + 1)^2)},
@c but the factors within each part may not be relatively prime.

Hat die Optionsvariable @code{ratfac} den Wert @code{true}, werden Ausdr@"ucke
in einer CRE-Form nur teilweise faktorisiert.  Bei der Ausf@"uhrung
von Operationen bleibt der Ausdruck so vollst@"andig als m@"oglich in
seiner faktorisierten Form, ohne dass eine Faktorisierung mit der Funktion
@mref{factor} ausgef@"uhrt wird.  Auf diese Weise kann Rechenzeit eingespart
werden.

@c TODO: NICHT UEBERSETZT.  GEHOERT IN DAS KAPITEL TENSOREN?!

@c In the @code{ctensr} (Component Tensor Manipulation) package,
@c Ricci, Einstein, Riemann, and Weyl tensors and the scalar curvature 
@c are factored automatically when @code{ratfac} is @code{true}.
@c @i{@code{ratfac} should only be
@c set for cases where the tensorial components are known to consist of
@c few terms.}

@c The @code{ratfac} and @code{ratweight} schemes are incompatible and may not
@c both be used at the same time.

Der @mref{ratweight}-Mechanismus ist nicht kompatibel mit dem Setzen der
Variablen @code{ratfac}.
 
@c NEED EXAMPLES HERE
@end defvr

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratnumer}
@deffn {Funktion} ratnumer (@var{expr})

@c Returns the numerator of @var{expr},
@c after coercing @var{expr} to a canonical rational expression (CRE).
@c The return value is a CRE.

Gibt den Z@"ahler des Argumentes @var{expr} zur@"uck.  @code{ratnumer} wandelt
den Ausdruck zuerst in eine CRE-Form um und gibt das Ergebnis in einer 
CRE-Form zur@"uck.

   @c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
@c @var{expr} is coerced to a CRE by @code{rat}
@c if it is not already a CRE.
@c This conversion may change the form of @var{expr} by putting all terms
@c over a common denominator.

Das Argument @var{expr} wird von der Funktion @mref{rat} in eine CRE-Form
gebracht, falls @var{expr} nicht bereits in einer CRE-Form vorliegt.  Diese
Transformation kann den Ausdruck @var{expr} ver@"andern, da alle Terme @"uber
einen gemeinsamen Nenner zusammengefasst werden.

@c @code{num} is similar, but returns an ordinary expression instead of a CRE.
@c Also, @code{num} does not attempt to place all terms over a common
@c denominator, and thus some expressions which are considered ratios by
@c @code{ratnumer} are not considered ratios by @code{num}.

Die Funktion @mref{num} ist vergleichbar.  @code{num} wandelt den Ausdruck
jedoch nicht eine CRE-Form um und hat als Ergebnis einen Ausdruck in der
Standardform.  Daher k@"onnen sich die Ergebnisse von @code{ratnumer} und 
@code{num} voneinander unterscheiden.

@c NEEDS AN EXAMPLE HERE
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratp}
@deffn {Funktion} ratp (@var{expr})

@c Returns @code{true} if @var{expr} is a canonical rational expression (CRE) or
@c extended CRE, otherwise @code{false}.

Gibt das Ergebnis @code{true} zur@"uck, wenn das Argument @var{expr} in einer
CRE-Form oder einer erweiterten CRE-Form vorliegt.

@c CRE are created by @code{rat} and related functions.
@c Extended CRE are created by @code{taylor} and related functions.

CRE-Formen werden von der Funktion @mref{rat} und verwandten Funktionen erzeugt.
Erweiterte CRE-Formen werden von der Funktion @mref{taylor} und verwandten
Funktionen erzeugt.
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratprint}
@defvr {Optionsvariable} ratprint
Standardwert: @code{true}

@c When @code{ratprint} is @code{true},
@c a message informing the user of the conversion of floating point numbers
@c to rational numbers is displayed.

Hat die Optionsvariable @code{ratprint} den Wert @code{true}, gibt Maxima eine
Meldung aus, wenn eine Gleitkommazahl in eine rationale Zahl umgewandelt wird.

Beispiel:

@example
(%i1) ratprint:true;
(%o1)                         true
(%i2) rat(0.75*x);

rat: replaced 0.75 by 3/4 = 0.75
                               3 x
(%o2)/R/                       ---
                                4
(%i3) ratprint:false;
(%o3)                         false
(%i4) rat(0.75*x);
                               3 x
(%o4)/R/                       ---
                                4
@end example
@end defvr

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratsimp}
@deffn  {Funktion} ratsimp (@var{expr})
@deffnx {Funktion} ratsimp (@var{expr}, @var{x_1}, @dots{}, @var{x_n})

@c Simplifies the expression @var{expr} and all of its subexpressions,
@c including the arguments to non-rational functions.
@c The result is returned as the quotient of two polynomials in a recursive
@c form, that is, the coefficients of the main variable are polynomials in the
@c other variables.  Variables may include non-rational functions
@c (e.g., @code{sin (x^2 + 1)}) and the arguments to any such functions are also
@c rationally simplified.

Vereinfacht den Ausdruck @var{expr} und alle Teilausdr@"ucke, einschlie@ss{}lich
der nicht rationalen Anteile.  Das Ergebnis ist ein Quotient aus zwei Polynomen
in einer rekursiven Form.  In der rekursiven Form ist das Polynom nach der
Hauptvariablen vollst@"andig ausmultipliziert und ein Polynom in allen anderen
Variablen.  Variable k@"onnen auch nicht-rationale Ausdr@"ucke wie
@code{sin(x^2 + 1)} sein.

@c @code{ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})}
@c enables rational simplification with the
@c specification of variable ordering as in @code{ratvars}.

@code{ratsimp(@var{expr}, @var{x_1}, ..., @var{x_n})} vereinfacht einen Ausdruck
mit einer Ordnung der Variablen wie sie von der Funktion @mref{ratvars}@w{}
definiert wird.

@c When @code{ratsimpexpons} is @code{true}, @code{ratsimp} is applied to the
@c exponents of expressions during simplification.

Hat die Optionsvariable @mref{ratsimpexpons} den Wert @code{true}, wird
@code{ratsimp} auch auf die Exponenten von Ausdr@"ucke angewendet.

@c See also @code{ratexpand}.
@c Note that @code{ratsimp} is affected by some of the
@c flags which affect @code{ratexpand}.

Siehe auch die Funktion @mrefdot{ratexpand}  Die Funktion @code{ratsimp} wird
auch von einigen Schaltern kontrolliert, die Einfluss auf @code{ratexpand}
haben.

Beispiele:

@example
(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
@group
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
@end group
(%i4) ratsimp (%);
@group
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
@end group
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
@end example
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratsimpexpons}
@defvr {Optionsvariable} ratsimpexpons
Standardwert: @code{false}

@c When @code{ratsimpexpons} is @code{true}, @code{ratsimp} is applied to the
@c exponents of expressions during simplification.

Hat die Optionsvariable @code{ratsimpexpons} den Wert @code{true}, wird
@code{ratsimp} auch auf die Exponenten von Ausdr@"ucke angewendet.

Beispiel:

@example
(%i1) expr: x^(a+1/a);
                             a + 1/a
(%o1)                       x
(%i2) ratsimpexpons: false;
(%o2)                         false
(%i3) ratsimp(expr);
                             a + 1/a
(%o3)                       x
(%i4) ratsimpexpons: true;
(%o4)                         true
(%i5) ratsimp(expr);
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
@end example
@end defvr

@c --- 06.01.2011 DK -----------------------------------------------------------
@anchor{radsubstflag}
@defvr {Optionsvariable} radsubstflag
Standardwert: @code{false}

@c @code{radsubstflag}, if @code{true}, permits @code{ratsubst} to make 
@c substitutions such as @code{u} for @code{sqrt (x)} in @code{x}.
@c When @code{radsubstflag} is @code{true},
@c @code{ratsubst} makes substitutions for radicals in expressions
@c which don't explicitly contain them.

Hat @code{radsubstflag} den Wert @code{true}, werden Wurzeln von der Funktion
@mref{ratsubst} auch dann substituiert, wenn diese nicht explizit im Ausdruck
enthalten sind.

Beispiel:

@example
(%i1) radsubstflag: false$
(%i2) ratsubst (u, sqrt(x), x);
(%o2)                           x
(%i3) radsubstflag: true$
(%i4) ratsubst (u, sqrt(x), x);
                                2
(%o4)                          u
@end example
@end defvr

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratsubst}
@deffn {Funktion} ratsubst (@var{a}, @var{b}, @var{c})

@c Substitutes @var{a} for @var{b} in @var{c} and returns the resulting
@c expression.
   @c "ETC" SUGGESTS THE READER KNOWS WHAT ELSE GOES THERE - NOT LIKELY THE CASE
@c @var{b} may be a sum, product, power, etc.

Substituiert @var{a} f@"ur @var{b} in den Ausdruck @var{c} und gibt das Ergebnis
der Substitution zur@"uck.

   @c WHAT, EXACTLY, DOES ratsubst KNOW ??
@c @code{ratsubst} knows something of the meaning of expressions
@c whereas @code{subst} does a purely syntactic substitution.
@c Thus @code{subst (a, x + y, x + y + z)} returns @code{x + y + z}
@c whereas @code{ratsubst} returns @code{z + a}.

Im Unterschied zu @mref{subst} kann @code{ratsubst} auch Teilausdr@"ucke im
Ausdruck @var{c} substituieren.  So hat @code{subst(a, x + y, x + y + z)} das
Ergebnis @code{x + y + z} und @code{ratsubst} das Ergebnis @code{z + a}.

@c When @code{radsubstflag} is @code{true},
@c @code{ratsubst} makes substitutions for radicals in expressions
@c which don't explicitly contain them.

Hat @code{radsubstflag} den Wert @code{true}, werden Wurzeln von der Funktion
@code{ratsubst} auch dann substituiert, wenn diese nicht explizit im Ausdruck
enthalten sind.

Beispiel:

@example
(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
@group
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
@end group
(%i5) radsubstflag: false$
(%i6) ratsubst (u, sqrt(x), x);
(%o6)                           x
(%i7) radsubstflag: true$
(%i8) ratsubst (u, sqrt(x), x);
                                2
(%o8)                          u
@end example
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratvars}
@deffn  {Funktion} ratvars (@var{x_1}, @dots{}, @var{x_n})
@deffnx {Funktion} ratvars ()
@deffnx {Systemvariable} ratvars

@c Declares main variables @var{x_1}, ..., @var{x_n} for rational expressions.
@c @var{x_n}, if present in a rational expression, is considered the main
@c variable.  Otherwise, @var{x_[n-1]} is considered the main variable if
@c present, and so on through the preceding variables to @var{x_1}, which is
@c considered the main variable only if none of the succeeding variables are
@c present.

Deklariert die Variablen @var{x_1}, @dots{}, @var{x_n} zu Hauptvariablen einer
rationalen Funktion.  Ist die Variable @var{x_n} in einem Ausdruck vorhanden,
wird diese zur Hauptvariablen.  Ist @var{x_n} nicht im Ausdruck vorhanden, 
wird einer der vorhergehenden Variablen @var{x_i} zur Hauptvariablen.

@c If a variable in a rational expression is not present in the @code{ratvars}
@c list, it is given a lower priority than @var{x_1}.

Eine Variable einer rationalen Funktion, die nicht unter den @var{x_1}, @dots{},
@var{x_n} ist, erh@"alt eine geringe Priorit@"at als @var{x_1}.

@c The arguments to @code{ratvars} can be either variables or non-rational
@c functions such as @code{sin(x)}.

Die Argumente der Funktion @code{ratvars} k@"onnen auch nicht-rationale
Ausdr@"ucke wie @code{sin(x)} sein.

@c The variable @code{ratvars} is a list of the arguments of 
@c the function @code{ratvars} when it was called most recently.
@c Each call to the function @code{ratvars} resets the list.
@c @code{ratvars ()} clears the list.

Die Systemvariable @code{ratvars} enth@"alt die Liste der zuletzt mit der
Funktion @code{ratvars} zu Hauptvariablen erkl@"arten Variablen.  Jeder Aufruf
der Funktion @code{ratvars} setzt diese Liste zur@"uck.  Der Aufruf ohne
Argumente @code{ratvars()} l@"oscht die Systemvariable @code{ratvars}.
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratweight}
@deffn  {Funktion} ratweight (@var{x_1}, @var{w_1}, @dots{}, @var{x_n}, @var{w_n})
@deffnx {Funktion} ratweight ()

@c Assigns a weight @var{w_i} to the variable @var{x_i}.
@c This causes a term to be replaced by 0 if its weight exceeds the
@c value of the variable @code{ratwtlvl} (default yields no truncation).
@c The weight of a term is the sum of the products of the
@c weight of a variable in the term times its power.
@c For example, the weight of @code{3 x_1^2 x_2} is @code{2 w_1 + w_2}.
@c Truncation according to @code{ratwtlvl} is carried out only when multiplying
@c or exponentiating canonical rational expressions (CRE).

@c @code{ratweight ()} returns the cumulative list of weight assignments.

Weist der Variablen @var{x_i} ein Gewicht @var{w_i} zu.  Hat ein Term einer
rationalen Funktion ein gr@"o@ss{}eres Gewicht als der Wert der Variablen
@mref{ratwtlvl} wird der Term durch @code{0} ersetzt.  Das Gewicht eines Terms
wird anhand der mit @code{ratweight} den Variablen zugewiesenen Gewichte
ermittelt.  Die Gewichte der Variablen in einem Term werden mit der Potenz
der Variablen multipliziert und dann addiert.  Zum Beispiel hat der Term
@code{3 x_1^2 x_2} das Gewicht @code{2 w_1 + w_2}.  Terme die den Wert
von @code{ratwtlvl} @"ubersteigen, werden nur dann entfernt, wenn rationale
Funktionen in einer CRE-Form multipliziert oder potenziert werden.

@code{ratweight()} gibt die Liste der zugewiesenen Gewichte zur@"uck.

@c Note: The @code{ratfac} and @code{ratweight} schemes are incompatible and
@c may not both be used at the same time.

Der @mref{ratweight}-Mechanismus ist nicht kompatibel mit dem Setzen der
Variablen @code{ratfac}.

Beispiele:

@example
(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
@end example
@end deffn

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratweights}
@defvr {System variable} ratweights
Standardwert: @code{[]}

@c @code{ratweights} is the list of weights assigned by @code{ratweight}.
@c The list is cumulative:
@c each call to @code{ratweight} places additional items in the list.

Die Systemvariable @code{ratweights} enth@"alt die Liste der Gewichte die
Variablen mit der Funktion @mref{ratweights} zugewiesen sind.

   @c DO WE REALLY NEED TO MENTION THIS ??
@c @code{kill (ratweights)} and @code{save (ratweights)} both work as expected.

Die Gewichte k@"onnen mit dem Kommando @code{kill(ratweights)} gel@"oscht
werden.
@end defvr

@c --- 09.07.2011 DK -----------------------------------------------------------
@anchor{ratwtlvl}
@defvr {Optionsvariable} ratwtlvl
Standardwert: @code{false}

@c @code{ratwtlvl} is used in combination with the @code{ratweight}
@c function to control the truncation of canonical rational expressions (CRE).
@c For the default value of @code{false}, no truncation occurs.

Die Optionsvariable wird im Zusammenhang mit den @mref{ratweight}-Mechanismus
genutzt und kontrolliert das Entfernen von Termen einer rationalen Funktion in
einer CRE-Form, wenn deren Gewicht den Wert von @code{ratwtlvl} @"ubersteigt.
Mit dem Standardwert @code{false} werden keine Terme entfernt.
@end defvr

@c --- 19.02.2011 DK -----------------------------------------------------------
@anchor{remainder}
@deffn  {Funktion} remainder (@var{p_1}, @var{p_2})
@deffnx {Funktion} remainder (@var{p_1}, @var{p_2}, @var{x_1}, @dots{}, @var{x_n})

Berechnet den Rest der Polynomdivision von @var{p_1} und @var{p_2} f@"ur die
Variable @var{x_n}.  Die anderen Variablen @var{x_1}, @dots{}, @var{x_n-1}
haben dieselbe Bedeutung wie f@"ur die Funktion @mrefdot{ratvars}

@code{remainder} gibt das zweite Element des Ergebnisses der Funktion
@mref{divide} zur@"uck.

Siehe auch die Funktion @mrefdot{quotient}

Beispiel:

@example
(%i1) poly1 : x^3-2*x^2-5*x+7;
                        3      2
(%o1)                  x  - 2 x  - 5 x + 7
(%i2) poly2 : x^2+1;
                              2
(%o2)                        x  + 1
(%i3) remainder(poly1, poly2, x);
(%o3)                        9 - 6 x
@end example
@end deffn

@c --- 04.08.2011 DK -----------------------------------------------------------
@anchor{resultant}
@deffn  {Funktion} resultant (@var{p_1}, @var{p_2}, @var{x})

@c Computes the resultant of the two polynomials @var{p_1} and @var{p_2},
@c eliminating the variable @var{x}.  The resultant is a determinant of the
@c coefficients of @var{x} in @var{p_1} and @var{p_2}, which equals zero
@c if and only if @var{p_1} and @var{p_2} have a non-constant factor in common.

Berechnet die Resultante der Polynome @var{p_1} und @var{p_2} und eliminiert
die unabh@"angige Variable @var{x}.  Die Resultante ist die Determinante der
Sylvestermatrix f@"ur die beiden Polynome.  Das Ergebnis ist Null, wenn die
beiden Polynome @var{p_1} und @var{p_2} einen gemeinsamen Faktor haben.

@c If @var{p_1} or @var{p_2} can be factored, it may be desirable to call
@c @code{factor} before calling @code{resultant}.

K@"onnen die Polynome @var{p_1} oder @var{p_2} faktorisiert werden, kann es
von Vorteil sein, die Faktorisierung zuvor auszuf@"uhren.

@c The variable @code{resultant} controls which algorithm will be used to
@c compute the resultant.
@c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
@c @code{subres} for subresultant prs, @code{mod} for modular resultant
@c algorithm, and @code{red} for reduced prs. On most problems @code{subres}
@c should be best. On some large degree univariate or bivariate problems 
@c @code{mod} may be better.

Die Optionsvariable @code{resultant} kontrolliert, welcher Algorithmus f@"ur
die Berechnung der Resultante von Maxima genutzt wird.  Siehe die 
Optionsvariable @mxrefdot{option_resultant, resultant}

@c The function @code{bezout} takes the same arguments as @code{resultant} and
@c returns a matrix.  The determinant of the return value is the desired 
@c resultant.

Die Funktion @mref{bezout} berechnet die Sylvestermatrix der Polynome
@var{p_1} und @var{p_2}.  Die Determinante der Sylvestermatrix ist die
Resultante.

@need 800
Beispiele:

@example
(%i1) resultant(2*x^2+3*x+1, 2*x^2+x+1, x);
(%o1)                           8
(%i2) resultant(x+1, x+1, x);
(%o2)                           0
(%i3) resultant((x+1)*x, (x+1), x);
(%o3)                           0
(%i4) resultant(a*x^2+b*x+1, c*x + 2, x);
                         2
(%o4)                   c  - 2 b c + 4 a

(%i5) bezout(a*x^2+b*x+1, c*x+2, x);
                        [ 2 a  2 b - c ]
(%o5)                   [              ]
                        [  c      2    ]
(%i6) determinant(%);
(%o6)                   4 a - (2 b - c) c
@end example
@end deffn

@c --- 04.08.2011 DK -----------------------------------------------------------
@anchor{option_resultant}
@defvr {Optionsvariable} resultant
Standardwert: @code{subres}

@c The variable @code{resultant} controls which algorithm will be used to
@c compute the resultant.
@c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
@c @code{subres} for subresultant prs, @code{mod} for modular resultant
@c algorithm, and @code{red} for reduced prs. On most problems @code{subres}
@c should be best. On some large degree univariate or bivariate problems 
@c @code{mod} may be better.

Die Optionsvariable @code{resultant} kontrolliert, welcher Algorithmus f@"ur die
Berechnung der Resultante mit der Funktion @mref{resultant} von Maxima genutzt
wird.  Die m@"oglichen Werte sind:

@table @code
@item subres
Subresultanten-Algorithmus
@item mod
Modularer Resultanten-Algorithmus
@item red
Reduzierter Subresultanten-Algorithmus
@end table

Der Standwert @code{subres} ist f@"ur die meisten Probleme geeignet.  F@"ur
gro@ss{}e Polynome in einer oder zwei Variablen kann @code{mod} besser sein.
@end defvr

@c -----------------------------------------------------------------------------
@need 1000
@anchor{savefactors}
@defvr {Optionsvariable} savefactors
Standardwert: @code{false}

@c "certain functions" -- WHICH ONES ??
@c When @code{savefactors} is @code{true}, causes the factors of an
@c expression which is a product of factors to be saved by certain
@c functions in order to speed up later factorizations of expressions
@c containing some of the same factors.

Hat die Optionsvariable @code{savefactors} den Wert @code{true}, versuchen
einige Funktionen bei der Vereinfachung eine bereits vorhandene Faktorisierung
zu erhalten, um weitere Vereinfachungen zu beschleunigen.
@end defvr

@c --- 06.07.2011 DK -----------------------------------------------------------
@anchor{showratvars}
@deffn {Funktion} showratvars (@var{expr})

@c Returns a list of the canonical rational expression (CRE) variables in 
@c expression @code{expr}.
@c See also @code{ratvars}.

Gibt eine Liste mit den Variablen des Ausdrucks @var{expr} zur@"uck.  Der
Ausdruck liegt in einer CRE-Form vor.

Siehe auch die Funktion @mrefdot{ratvars}
@end deffn

@c I CAN'T TELL WHAT THIS IS SUPPOSED TO BE ABOUT

@c --- 06.07.2011 DK -----------------------------------------------------------
@anchor{sqfr}
@deffn {Funktion} sqfr (@var{expr})

@c is similar to @code{factor} except that the polynomial factors are
@c "square-free."

@c TODO: ERLAEUTERUNG QUADRATFREI NICHT UEBERSETZT

@c That is, they have factors only of degree one.  This algorithm, which is also
@c used by the first stage of @code{factor}, utilizes the fact that a polynomial
@c has in common with its n'th derivative all its factors of degree greater than
@c n.  Thus by taking greatest common divisors with the polynomial of the
@c derivatives with respect to each variable in the polynomial, all factors of
@c degree greater than 1 can be found.

Entspricht der Funktion @mref{factor} mit dem Unterschied, dass faktorisierte
Polynome quadratfrei sind.

@need 800
Beispiel:

@example
(%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                2   2
(%o1)                  (2 x + 1)  (x  - 1)
@end example
@end deffn

@c THIS ITEM STILL NEEDS WORK

@c --- 20.12.2010 DK -----------------------------------------------------------
@anchor{tellrat}
@deffn  {Funktion} tellrat (@var{p_1}, @dots{}, @var{p_n})
@deffnx {Funktion} tellrat ()

@c Adds to the ring of algebraic integers known to Maxima the elements which are
@c the solutions of the polynomials @var{p_1}, ..., @var{p_n}.  Each argument
@c @var{p_i} is a polynomial with integer coefficients.

F@"ugt dem Ring der ganzen Zahlen, die algebraische Zahlen hinzu, die L@"osungen
der minimalen Polynome @var{p_1}, @dots{}, @var{p_n} sind.  Jedes Argument
@var{p_i} ist ein Polynom, dessen Koeffizienten ganze Zahlen sind.

@c @code{tellrat (@var{x})} effectively means substitute 0 for @var{x} in
@c rational functions.

@code{tellrat(@var{x})} bedeutet, dass in einer rationalen Funktion die
Variable @var{x} mit dem Wert @code{0} substituiert wird.

@c @code{tellrat ()} returns a list of the current substitutions.

@code{tellrat()} gibt eine Liste der minimalen Polynome zur@"uck.

@c @code{algebraic} must be set to @code{true} in order for the simplification
@c of algebraic integers to take effect.

Die Optionsvariable @mref{algebraic} muss den Wert @code{true} haben, damit
die Vereinfachungen von algebraischen Zahlen ausgef@"uhrt wird.

@c Maxima initially knows about the imaginary unit @code{%i} and all roots of 
@c integers.

Maxima kennt bereits die Erweiterungen um die Imagin@"are Einheit @code{%i} und
die Wurzeln der ganzen Zahlen.

@c There is a command @code{untellrat} which takes kernels and removes
@c @code{tellrat} properties.

Die Funktion @mref{untellrat} entfernt die Eigenschaften, die mit der Funktion
@code{tellrat} definiert wurden.

@c When @code{tellrat}'ing a multivariate polynomial, e.g.,
@c @code{tellrat (x^2 - y^2)}, there would be an ambiguity as to whether to
@c substitute @code{@var{y}^2} for @code{@var{x}^2} or vice versa.  Maxima 
@c picks a particular ordering, but if the user wants to specify which, e.g.
@c @code{tellrat (y^2 = x^2)} provides a syntax which says replace
@c @code{@var{y}^2} by @code{@var{x}^2}.

Hat ein minimales Polynom mehrere Variablen, wie zum Beispiel in
@code{tellrat(x^2 - y^2)}, dann entsteht eine Mehrdeutigkeit, da Maxima nicht
ermitteln kann, ob @var{x^2} f@"ur @var{y^2} zu ersetzten ist, oder umgekehrt.
In diesem Fall kann die Syntax @code{tellrat (y^2 = x^2)} genutzt werden, die
besagt, dass @var{y^2} durch @var{x^2} zu ersetzen ist.

@c CAN'T TELL WHAT THIS IS ABOUT -- 
@c tellrat(w^3-1)$ algebraic:true$ rat(1/(w^2-w));
@c DOES NOT YIELD AN ERROR, SO WHAT IS THE POINT ABOUT ratalgdenom ??
@c When you @code{tellrat} reducible polynomials, you want to be careful not to
@c attempt to rationalize a denominator with a zero divisor.  E.g.
@c tellrat(w^3-1)$ algebraic:true$ rat(1/(w^2-w)); will give "quotient by
@c zero".  This error can be avoided by setting @code{ratalgdenom} to 
@c @code{false}.

Beispiele:

@example
(%i1) 10*(%i + 1)/(%i + 3^(1/3));
@group
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
@end group
(%i2) ev (ratdisrep (rat(%)), algebraic);
@group
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
@end group
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
@end example
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{totaldisrep}
@deffn {Funktion} totaldisrep (@var{expr})

@c Converts every subexpression of @var{expr} from canonical rational 
@c expressions (CRE) to general form and returns the result. If @var{expr} is 
@c itself in CRE form then @code{totaldisrep} is identical to @code{ratdisrep}.

Konvertiert alle Teilausdr@"ucke im Ausdruck @var{expr} von der CRE-Form in die
allgemeine Form und gibt das Ergebnis zur@"uck.  Ist @var{expr} selbst eine
CRE-Form, dann entspricht @code{totaldisrep} der Funktion @code{ratdisrep}.

@c @code{totaldisrep} may be useful for ratdisrepping expressions such as 
@c equations, lists, matrices, etc., which have some subexpressions in CRE form.

@code{totaldisrep} ist insbesondere hilfreich, wenn Gleichungen, Listen oder
Matrizen in eine allgemeine Form zu konvertieren sind.

@c NEED EXAMPLES HERE
@end deffn

@c --- 20.12.2010 DK -----------------------------------------------------------
@anchor{untellrat}
@deffn {Funktion} untellrat (@var{x_1}, @dots{}, @var{x_n})

@c Removes @code{tellrat} properties from @var{x_1}, ..., @var{x_n}.

Entfernt Eigenschaften von den Symbolen @var{x_1}, @dots{}, @var{x_n}, die mit
der Funktion @code{tellrat} zugewiesen wurden.

@c NEED EXAMPLES HERE
@end deffn

@c --- End of file Polynomials.de.texi -----------------------------------------

