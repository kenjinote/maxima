@c -----------------------------------------------------------------------------
@c File        : Database.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Database.texi revision 15.06.2011
@c Translation : Dr. Dieter Kaiser
@c Date        : 22.10.2010
@c Revision    : 20.08.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Maximas Datenbank::
* Funktionen und Variablen f@"ur Eigenschaften::
* Funktionen und Variablen f@"ur Fakten::
* Funktionen und Variablen f@"ur Aussagen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Maximas Datenbank, Funktionen und Variablen f@"ur Eigenschaften, Maximas Datenbank, Maximas Datenbank
@section Einf@"uhrung in Maximas Datenbank
@c -----------------------------------------------------------------------------

@subheading Eigenschaften

Variablen und Funktionen k@"onnen mit der Funktion @mref{declare} Eigenschaften
zugewiesen werden.  Diese Eigenschaften werden in eine Datenbank abgelegt oder
in eine von Lisp bereitgestellte Eigenschaftsliste eingetragen.  Mit der
Funktion @mref{featurep} kann gepr@"uft werden, ob ein Symbol eine bestimmte
Eigenschaft hat und mit der Funktion @mref{properties} k@"onnen alle
Eigenschaften eines Symbols angezeigt werden.  Die Funktion @mref{remove}@w{}
l@"oscht Eigenschaften aus der Datenbank oder von der Eigenschaftsliste.  Wird
mit der Funktion @mref{kill} ein Symbol entfernt, werden auch die zugewiesenen
Eigenschaften gel@"oscht.

Weiterhin k@"onnen mit den Funktionen @mref{put} und @mref{qput} beliebige
vom Nutzer vorgesehene Eigenschaften in die Eigenschaftsliste zu einem Symbol
abgelegt werden.  Mit der Funktion @mref{get} werden die Eigenschaften von
der Eigenschaftsliste gelesen und mit der Funktion @mref{rem} gel@"oscht.

Variablen k@"onnen die folgenden Eigenschaften erhalten, die in die Datenbank
eingetragen werden.

@verbatim
   constant
   integer        noninteger
   even           odd
   rational       irrational
   real           imaginary      complex
@end verbatim

Funktionen k@"onnen die folgenden Eigenschaften erhalten, die in die Datenbank
eingetragen werden.

@verbatim
   increasing     decreasing
   posfun         integervalued
@end verbatim

Die folgenden Eigenschaften k@"onnen f@"ur Funktionen definiert werden und 
wirken sich auf die Vereinfachung dieser Funktionen aus.  Diese Eigenschaften
werden in @ref{Vereinfachung} beschrieben.

@verbatim
   linear         additive       multiplicative
   outative       commutative    symmetric      
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun
@end verbatim

Weitere Eigenschaften, die Variablen und Funktionen erhalten k@"onnen, und
die in die Lisp-Eigenschaftsliste des Symbols abgelegt werden, sind.

@verbatim
   bindtest       feature        alphabetic
   scalar         nonscalar      nonarray
@end verbatim

@subheading Kontexte

Maxima verwaltet Kontexte, um Eigenschaften von Variablen und Funktionen sowie
Fakten abzulegen.  Fakten werden mit der Funktion @mref{assume} definiert und
in dem aktuellen Kontext abgelegt.  Mit @code{assume(a>10)} erh@"alt Maxima zum
Beispiel die Information, dass die Variable @code{a} gr@"o@ss{}er als @code{10}
ist.  Mit der Funktion @mref{forget} werden Fakten aus der Datenbank entfernt.
Fragt Maxima den Nutzer nach Eigenschaften von Variablen, werden die Antworten
in einem Kontext abgelegt.

Ein Kontext hat einen Namen, mit dem auf diesen Bezug genommen werden kann.
Nach dem Starten von Maxima hat der aktuelle Kontext den Namen @code{initial}.
Es kann eine beliebige Anzahl weiterer Kontexte definiert werden.  Diese
k@"onnen hierarchisch voneinander abh@"angen.  So ist der Kontext @code{initial}
ein Unterkontext zum Kontext @code{global}.  Die Fakten in einem
@"ubergeordneten Kontext sind in dem Unterkontext immer pr@"asent.  Der Kontext
@code{global} enth@"alt zum Beispiel Fakten, die von Maxima initialisiert
werden, und zus@"atzlich zu den Fakten des Kontextes @code{initial} aktiv sind.

Kontexte k@"onnen eine beliege Anzahl an Fakten aufnehmen.  Sie k@"onnen mit der
Funktion @mref{deactivate} deaktiviert werden, ohne dass die Fakten verloren
gehen und sp@"ater mit der Funktion @mref{activate} aktiviert werden, wodurch
die Fakten f@"ur Aussagefunktionen wieder zur Verf@"ugung stehen.

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Eigenschaften, Funktionen und Variablen f@"ur Fakten, Einf@"uhrung in Maximas Datenbank, Maximas Datenbank
@section Funktionen und Variablen f@"ur Eigenschaften
@c -----------------------------------------------------------------------------

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{alphabetic}
@defvr {Eigenschaft} alphabetic

Das Kommando @code{declare(string, alphabetic)} deklariert die Zeichen der 
Zeichenkette @var{string} als alphabetisch.  Das Argument @var{string} muss eine
Zeichenkette sein.  Zeichen, die als alphabetisch deklariert sind, k@"onnen in
Maxima-Bezeichnern verwendet werden.  Siehe auch @ref{Bezeichner}.

Beispiele:

Die Zeichen @code{"~"}, @code{"@@"} und @code{`} als alphabetisch erkl@"art.

@example
(%i1) xx\~yy\`\@@ : 1729;
(%o1)                         1729
(%i2) declare ("~`@@", alphabetic);
(%o2)                         done
(%i3) xx~yy`@@ + @@yy`xx + `xx@@@@yy~;
(%o3)               `xx@@@@yy~ + @@yy`xx + 1729
(%i4) listofvars (%);
(%o4)                  [@@yy`xx, `xx@@@@yy~]
@end example
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{bindtest}
@defvr {Eigenschaft} bindtest

Hat ein Symbol @var{x} die Eigenschaft @code{bindtest} und wird es ausgewertet,
ohne das dem Symbol bisher ein Wert zugewiesen wurde, signalisiert Maxima einen 
Fehler.  Siehe auch die Funktion @mrefdot{declare}

Beispiel:

@example
(%i1) aa + bb;
(%o1)                        bb + aa
(%i2) declare (aa, bindtest);
(%o2)                         done
(%i3) aa + bb;
aa unbound variable
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) aa : 1234;
(%o4)                         1234
(%i5) aa + bb;
(%o5)                       bb + 1234
@end example
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{constant}
@defvr {Eigenschaft} constant

Das Kommando @code{declare(@var{a}, constant)} deklariert ein Symbol @var{a}
als konstant.  Die Funktion @mref{constantp} hat f@"ur dieses Symbol dann das
Ergebnis @code{true}.  Die Deklaration als eine Konstante verhindert nicht, dass
dem Symbol ein Wert zugewiesen werden kann.  Siehe @mref{declare} und
@mrefdot{constantp}

Beispiel:

@example
(%i1) declare(c, constant);
(%o1)                         done
(%i2) constantp(c);
(%o2)                         true
(%i3) c : x;
(%o3)                           x
(%i4) constantp(c);
(%o4)                         false
@end example
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{constantp}
@deffn {Funktion} constantp (@var{expr})

Gibt f@"ur einen konstanten Ausdruck @var{expr} den Wert @code{true} zur@"uck,
andernfalls @code{false}.

Ein Ausdruck wird von Maxima als ein konstanter Ausdruck erkannt, wenn seine 
Argumente Zahlen sind (einschlie@ss{}lich von Zahlen in einer CRE-Darstellung), 
symbolische Konstanten wie @code{%pi}, @code{%e} und @code{%i}, 
Variablen, die einen konstanten Wert haben, Variablen, die mit 
@code{declare} als konstant deklariert sind, oder Funktionen, deren Argumente 
konstant sind.

Die Funktion @code{constantp} wertet das Argument aus.

Siehe auch die Eigenschaft @mrefdot{constant}

Beispiele:

@example
(%i1) constantp (7 * sin(2));
(%o1)                                true
(%i2) constantp (rat (17/29));
(%o2)                                true
(%i3) constantp (%pi * sin(%e));
(%o3)                                true
(%i4) constantp (exp (x));
(%o4)                                false
(%i5) declare (x, constant);
(%o5)                                done
(%i6) constantp (exp (x));
(%o6)                                true
(%i7) constantp (foo (x) + bar (%e) + baz (2));
(%o7)                                false
(%i8) 
@end example
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{declare}
@deffn {Funktion} declare (@var{a_1}, @var{p_1}, @var{a_2}, @var{p_2}, @dots{})

Weist dem Symbol @var{a_i} die Eigenschaft @var{p_i} zu.  Die Argumente
@var{a_i} und @var{p_i} k@"onnen Listen sein.  Ist @var{a_i} eine Liste, dann
erh@"alt jedes Symbol der Liste die Eigenschaft @var{p_i}.  Ist umgekehrt
@var{p_i} eine Liste mit Eigenschaften, dann erh@"alt das Symbol @var{a_i} 
diese Eigenschaften.  Entsprechend erhalten alle Symbole einer Liste @var{a_i}
die Eigenschaften einer Liste @var{p_i}.

Die Funktion @code{declare} wertet die Argumente nicht aus.  @code{declare} gibt
stets @code{done} als Ergebnis zur@"uck.

Hat ein Symbol @var{sym} die Eigenschaft @var{prop} mit der Funktion 
@code{declare} erhalten, dann hat das Kommando @code{featurep(@var{sym}, 
@var{prop})} das Ergebnis @code{true}.  Mit der Funktion @code{properties}
k@"onnen alle Eigenschaften eines Symbols angezeigt werden.

Mit der Funktion @code{declare} k@"onnen Symbole die folgenden Eigenschaften
erhalten:

@table @code
@item additive
Hat eine Funktion @code{f} die Eigenschaft @code{additive}, wird ein Ausdruck
der Form @code{f(x + y + z + ...)} zu @code{f(x) + f(y) + f(z) + ...}
vereinfacht.  Siehe @mrefdot{additive}

@item alphabetic
@var{a_i} ist eine Zeichenkette, deren Zeichen als alphabetische Zeichen 
deklariert werden.  Die Zeichen k@"onnen dann in Maxima-Bezeichnern verwendet
werden.  Siehe @mref{alphabetic} f@"ur Beispiele.

@item antisymmetric, commutative, symmetric
@var{a_i} wird als eine symmetrische, antisymmetrische oder kommutative Funktion
interpretiert.  Die Eigenschaften @code{commutative} und @code{symmetric} sind
@"aquivalent.  Siehe @mrefcomma{antisymmetric} @mref{commutative} und
@mrefdot{symmetric}

@item bindtest
Hat ein Symbol die Eigenschaft @code{bindtest} und wird es ausgewertet, ohne 
das dem Symbol bisher ein Wert zugewiesen wurde, signalisiert Maxima einen 
Fehler.  Siehe @mref{bindtest} f@"ur Beispiele.

@item constant
Hat ein Symbol die Eigenschaft @code{constant}, wird es von Maxima als eine 
Konstante interpretiert.  Siehe auch @mrefdot{constant}

@item even, odd
Erh@"alt eine Variable die Eigenschaft @code{even} oder @code{odd}, wird sie als
gerade oder ungerade interpretiert.

@item evenfun, oddfun
Erh@"alt eine Funktion oder ein Operator die Eigenschaft @code{evenfun} oder 
@code{oddfun} wird die Funktion oder der Operator von Maxima als gerade und 
ungerade interpretiert.  Diese Eigenschaft wird bei der Vereinfachung von 
Ausdr@"ucken von Maxima angewendet.  Siehe @mref{evenfun} und @mrefdot{oddfun}

@item evflag
Deklariert die Variable @code{a_i} als einen Auswertungsschalter.  W@"ahrend der
Auswertung eines Ausdrucks mit der Funktion @code{ev}, erh@"alt der 
Auswertungsschalter @code{a_i} den Wert @code{true}.  Siehe @mref{evflag} f@"ur 
Beispiele.

@item evfun
Deklariert eine Funktion @var{a_i} als eine Auswertungsfunktion.  Tritt die 
Funktion @var{a_i} als Argument der Funktion @code{ev} auf, so wird die Funktion
auf den Ausdruck angewendet.  Siehe @mref{evfun} f@"ur Beispiele.

@item feature
@var{a_i} wird als eine Eigenschaft @code{feature} interpretiert.  Andere
Symbole k@"onnen dann diese vom Nutzer definierte Eigenschaft erhalten.
Siehe @mrefdot{feature}

@item increasing, decreasing
Erh@"alt eine Funktion die Eigenschaft @code{decreasing} oder @code{increasing}, 
wird die Funktion als eine monoton steigende oder fallende Funktion
interpretiert.  Siehe @mref{decreasing} und @mrefdot{increasing}

@item integer, noninteger
@var{a_i} wird als eine ganzzahlige oder nicht-ganzzahlige Variable
interpretiert.  Siehe @mref{integer} und @mrefdot{noninteger}

@item integervalued
Erh@"alt eine Funktion die Eigenschaft @code{integervalued}, nimmt Maxima f@"ur
Vereinfachungen an, dass die Funktionen einen ganzzahligen Wertebereich hat.
F@"ur ein Beispiel siehe @mrefdot{integervalued}

@item lassociative, rassociative
@var{a_i} wird als eine rechts- oder links-assoziative Funktion interpretiert.
Siehe @mref{lassociative} und @mrefdot{rassociative}

@item linear
Entspricht der Deklaration einer Funktion als @code{outative} und
@code{additive}.  Siehe auch @mrefdot{linear}

@item mainvar
Wird eine Variable als @var{mainvar} deklariert, wird sie als eine 
"Hauptvariable" interpretiert.  Eine Hauptvariable wird vor allen Konstanten und
Variablen in einer kanonischen Ordnung eines Maxima-Ausdr@"uckes angeordnet.
Die Anordnung wird durch die Funktion @code{ordergreatp} bestimmt.  Siehe auch
@mrefdot{mainvar}

@item multiplicative
Hat eine Funktion @code{f} die Eigenschaft @code{multiplicative}, werden
Ausdr@"ucke der Form @code{@var{a_i}(x * y * z * ...)} zu
@code{@var{a_i}(x) * @var{a_i}(y) * @var{a_i}(z) * ...} vereinfacht.  Die
Vereinfachung wird nur f@"ur das erste Argument der Funktion @var{f}
ausgef@"uhrt.  Siehe @mrefdot{multiplicative}

@item nary
Erh@"alt eine Funktion oder ein Operator die Eigenschaft @code{nary}, wird die
Funktion oder der Operator bei der Vereinfachung als Nary-Funktion oder
Nary-Operator interpretiert.  Verschachtelte Ausdr@"ucke wie 
@code{foo(x, foo(y, z))} werden zum Beispiel zu @code{foo(x, y, z)} vereinfacht.
Die Deklaration @code{nary} unterscheidet sich von der Funktion @code{nary}.
W@"ahrend der Funktionsaufruf einen neuen Operator definiert, wirkt sich die 
Deklaration nur auf die Vereinfachung aus.  Siehe auch 
@mxrefdot{property_nary, nary}

@item nonarray
Hat ein Symbol @var{a_i} die Eigenschaft @code{nonarray}, wird es nicht als ein
Array interpretiert, wenn das Symbol einen Index erh@"alt.  Diese Deklaration
verhindert die mehrfache Auswertung, wenn @var{a_i} als indizierte Variable
genutzt wird.  Siehe  @mrefdot{nonarray}

@item nonscalar
@var{a_i} wird als eine nicht-skalare Variable interpretiert.  Ein Symbol wird
also als ein Vektor oder eine Matrix deklariert.  Siehe @mrefdot{nonscalar}

@item noun
@var{a_i} wird als Substantivform interpretiert.  Abh@"angig vom Kontext wird 
@var{a_i} durch @code{'@var{a_i}} oder @code{nounify(@var{a_i})} ersetzt.
Siehe auch @mrefdot{noun} f@"ur ein Beispiel.

@item outative
Ausdr@"ucke mit der Funktion @var{a_i} werden so vereinfacht, dass konstante 
Faktoren aus dem Argument herausgezogen werden.  Hat die Funktion @var{a_i} ein 
Argument, wird ein Faktor dann als konstant angesehen, wenn er ein Symbol oder 
eine deklarierte Konstante ist.  Hat die Funktion @var{a_i} zwei oder mehr 
Argumente, wird ein Faktor dann als konstant angesehen, wenn das zweite Argument
ein Symbol und der Faktor unabh@"angig vom zweiten Argument ist.  Siehe auch
@mrefdot{outative}

@item posfun
@var{a_i} wird als eine Funktion interpretiert, die nur positive Werte hat.
Siehe @mrefdot{posfun}

@item rational, irrational
@var{a_i} wird als eine rationale oder irrationale Zahl interpretiert.  Siehe
@mref{rational} und @mrefdot{irrational}

@item real, imaginary, complex
@var{a_i} wird als eine reelle, imagin@"are oder komplexe Zahl interpretiert.
Siehe @mrefcomma{real} @mref{imaginary} und @mrefdot{complex}

@item scalar
@var{a_i} wird als skalare Variable interpretiert.  Siehe @mrefdot{scalar}
@end table
@end deffn

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{decreasing}
@anchor{increasing}
@defvr  {Eigenschaft} decreasing
@defvrx {Eigenschaft} increasing

Erh@"alt eine Funktion mit der Funktion @mref{declare} die Eigenschaft 
@code{decreasing} oder @code{increasing} wird die Funktion als eine steigende 
oder fallende Funktion interpretiert.

Beispiel:

@example
(%i1) assume(a > b);
(%o1)                        [a > b]
(%i2) is(f(a) > f(b));
(%o2)                        unknown
(%i3) declare(f, increasing);
(%o3)                         done
(%i4) is(f(a) > f(b));
(%o4)                         true
@end example
@end defvr

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{even}
@anchor{odd}
@defvr  {Eigenschaften} even
@defvrx {Eigenschaften} odd

Hat eine Variable mit der Funktion @mref{declare} die Eigenschaft @code{even}
oder @code{odd} erhalten, wird sie von Maxima als gerade oder ungerade
ganze Zahl interpretiert.  Diese Eigenschaften werden jedoch nicht von den
Funktionen @mrefcomma{evenp} @mref{oddp} oder @mref{integerp} erkannt.

Siehe auch die Funktion @mrefdot{askinteger}

Beispiele:

@example
(%i1) declare(n, even);
(%o1)                         done
(%i2) askinteger(n, even);
(%o2)                          yes
(%i3) askinteger(n);
(%o3)                          yes
(%i4) evenp(n);
(%o4)                         false
@end example
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{feature}
@defvr {Eigenschaft} feature

@code{feature} ist eine Eigenschaft, die ein Symbol @var{sym} mit der Funktion
@code{declare} erhalten kann.  In diesem Fall ist das Symbol @var{sym} selbst
eine Eigenschaft, so dass das Kommando @code{declare(x, sym)} einem Symbol
@var{x} die vom Nutzer definierte Eigenschaft @code{sym} gibt.

Maxima unterscheidet Systemeigenschaften und mathematische Eigenschaften, die 
Symbole und Ausdr@"ucke haben k@"onnen.  F@"ur Systemeigenschaften siehe die 
Funktion @mrefdot{status}  F@"ur mathematische Eigenschaften siehe die 
Funktionen @mref{declare} und @mrefdot{featurep}

Beispiel:

@example
(%i1) declare (FOO, feature);
(%o1)                         done
(%i2) declare (x, FOO);
(%o2)                         done
(%i3) featurep (x, FOO);
(%o3)                         true
@end example
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{featurep}
@deffn {Funktion} featurep (@var{a}, @var{p})

Stellt fest, ob das Symbol oder der Ausdruck @var{a} die Eigenschaft @var{p} 
hat.  Maxima nutzt die Fakten der aktiven Kontexte und die definierten
Eigenschaften f@"ur Symbole und Funktionen.

@code{featurep} gibt sowohl f@"ur den Fall @code{false} zur@"uck, dass das 
Argument @var{a} nicht die Eigenschaft @var{p} hat, als auch f@"ur den Fall, 
dass Maxima dies nicht anhand der bekannten Fakten und Eigenschaften entscheiden
kann.

@code{featurep} wertet die Argumente aus.

Siehe auch @mref{declare} und @mrefdot{featurep}.

Beispiele:

@example
(%i1) declare (j, even)$
(%i2) featurep (j, integer);
(%o2)                           true
@end example
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{features}
@defvr {Systemvariable} features

Maxima kennt spezielle mathematische Eigenschaften von Funktionen und 
Variablen.

@code{declare(@var{x})}, @var{foo} gibt der Funktion oder Variablen @var{x} die
Eigenschaft @var{foo}.

@code{declare(@var{foo}, feature)} deklariert die neue Eigenschaft @var{foo}.
Zum  Beispiel deklariert @code{declare([red, green, blue], feature)} die drei 
neuen Eigenschaften @code{red}, @code{green} und @code{blue}.

@code{featurep(@var{x}, @var{foo})} hat die R@"uckgabe @code{true}, wenn @var{x} 
die Eigenschaft @var{foo} hat.  Ansonsten wird @code{false} zur@"uckgegeben.

Die Informationsliste @code{features} enth@"alt eine Liste der Eigenschaften, 
die Funktionen und Variablen erhalten k@"onnen und die in die Datenbank
eingetragen werden:

@verbatim
   integer         noninteger       even 
   odd             rational         irrational
   real            imaginary        complex
   analytic        increasing       decreasing
   oddfun          evenfun          posfun
   commutative     lassociative     rassociative
   symmetric       antisymmetric
@end verbatim

Hinzu kommen die vom Nutzer definierten Eigenschaften.

@code{features} ist eine Liste der mathematischen Eigenschaften.  Es gibt 
weitere Eigenschaften.  Siehe @mref{declare} und @mrefdot{status}
@end defvr

@c --- 16.11.2010 DK -----------------------------------------------------------
@anchor{get}
@deffn {Funktion} get (@var{a}, @var{i})

Gibt die Eigenschaft @var{i} des Symbols @var{a} zur@"uck.  Hat das Symbol
@var{a} nicht die Eigenschaft @var{i}, wird @code{false} zur@"uckgegeben.

@code{get} wertet die Argumente aus.

Beispiele:

@example
(%i1) put (%e, 'transcendental, 'type);
(%o1)                    transcendental
(%i2) put (%pi, 'transcendental, 'type)$
(%i3) put (%i, 'algebraic, 'type)$
(%i4) typeof (expr) := block ([q],
        if numberp (expr)
        then return ('algebraic),
        if not atom (expr)
        then return (maplist ('typeof, expr)),
        q: get (expr, 'type),
        if q=false
        then errcatch (error(expr,"is not numeric.")) else q)$
(%i5) typeof (2*%e + x*%pi);
x is not numeric.
(%o5)  [[transcendental, []], [algebraic, transcendental]]
(%i6) typeof (2*%e + %pi);
(%o6)     [transcendental, [algebraic, transcendental]]
@end example
@end deffn

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{integer}
@anchor{noninteger}
@defvr  {Eigenschaften} integer
@defvrx {Eigenschaften} noninteger

Hat eine Variable mit der Funktion @mref{declare} die Eigenschaft @code{integer}
oder @code{noninteger} erhalten, wird sie von Maxima als eine ganze Zahl oder 
als nicht-ganze Zahl interpretiert.  Siehe auch @mrefdot{askinteger}

Beispiele:

@example
(%i1) declare(n, integer, x, noninteger);
(%o1)                         done
(%i2) askinteger(n);
(%o2)                          yes
(%i3) askinteger(x);
(%o3)                          no
@end example
@end defvr

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{integervalued}
@defvr {Eigenschaft} integervalued

Erh@"alt eine Funktion mit @mref{declare} die Eigenschaft @code{integervalued},
nimmt Maxima f@"ur Vereinfachungen an, dass der Wertebereich der Funktion
ganzzahlig ist.

Beispiel:

@example
(%i1) exp(%i)^f(x);
                              %i f(x)
(%o1)                      (%e  )
(%i2) declare(f, integervalued);
(%o2)                         done
(%i3) exp(%i)^f(x);
                              %i f(x)
(%o3)                       %e
@end example
@end defvr

@c --- 22.11.2010 DK -----------------------------------------------------------
@anchor{nonarray}
@deffn {Eigenschaft} nonarray

@code{declare(a, nonarray)} gibt dem Symbol @var{a} die Eigenschaft nicht ein
Array zu sein.  Dies verhindert die mehrfache Auswertung, wenn das Symbol
@var{a} als indizierte Variable genutzt wird.

Beispiel:

@example
(%i1) a:'b$ b:'c$ c:'d$

(%i4) a[x];
(%o4)                          d
                                x
(%i5) declare(a, nonarray);
(%o5)                         done
(%i6) a[x];
(%o6)                          a
                                x
@end example
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{nonscalar}
@defvr {Eigenschaft} nonscalar

Hat ein Symbol die Eigenschaft @code{nonscalar}, verh@"alt es sich wie eine
Matrix oder Liste bei nicht-kommutativen Rechenoperationen.
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{nonscalarp}
@deffn {Funktion} nonscalarp (@var{expr})

Gibt @code{true} zur@"uck, wenn der Ausdruck @var{expr} kein Skalar ist.  Der
Ausdruck enth@"alt dann Matrizen, Listen oder Symbole, die als @code{nonscalar}
deklariert wurden.
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{posfun}
@defvr {Eigenschaft} posfun

@code{declare(f, posfun)} deklariert die Funktion @code{f} als eine Funktion,
die nur positive Werte annimmt.  @code{is(f(x) > 0)} gibt dann @code{true}
zur@"uck.
@end defvr

@c --- 27.05.2011 DK -----------------------------------------------------------
@anchor{printprops}
@deffn  {Funktion} printprops (@var{a}, @var{i})
@deffnx {Funktion} printprops ([@var{a_1}, @dots{}, @var{a_n}], @var{i})
@deffnx {Funktion} printprops (all, @var{i})

Zeigt die zum Kennzeichen @var{i} zugeordnete Eigenschaft des Atoms @var{a} an.
@var{i} kann einer der Werte @code{gradef}, @code{atvalue}, @code{atomgrad} oder
@code{matchdeclare} sein.  @var{a} kann sowohl eine Liste von Atomen, als auch
das Atom @code{all} sein.  In diesem Fall werden alle Atome angezeigt, die eine
Eigenschaft zum Kennzeichen @var{i} haben.

Beispiel:

@example
(%i1) gradef(f(x), 2*g(x));
(%o1)                         f(x)
(%i2) printprops(f,gradef);
                       d
                       -- (f(x)) = 2 g(x)
                       dx

(%o2)                         done
@end example
@end deffn

@c --- 20.08.2011 DK -----------------------------------------------------------
@anchor{properties}
@deffn {Funktion} properties (@var{a})

Gibt eine Liste mit den Eigenschaften zur@"uck, die das Symbol @var{a} von
Maxima oder dem Nutzer erhalten hat.  Die R@"uckgabe kann jede Eigenschaft
enthalten, die mit der Funktion @mref{declare} einem Symbol zugewiesen ist.
Diese Eigenschaften sind:

@verbatim
   linear         additive       multiplicative
   outative       commutative    symmetric      
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun
   bindtest       feature        alphabetic
   scalar         nonscalar      nonarray
   constant       integer        noninteger
   even           odd            rational
   irrational     real           imaginary
   complex        increasing     decreasing
   posfun         integervalued
@end verbatim

Die folgenden Eintr@"age beschreiben Eigenschaften, die Variablen haben
k@"onnen:

@table @code
@item value
Der Variable ist mit dem Operatoren @mref{:} oder @mref{::} ein Wert zugewiesen.
@item system value
Die Variable ist eine Optionsvariable oder Systemvariable, die von Maxima
definiert ist.
@item numer
Die Variable hat einen numerischen Wert auf der Eigenschaftsliste, der mit
der Funktion @mref{numerval} zugewiesen ist.
@item assign property
Die Variable hat eine eine Funktion auf der Eigenschaftsliste, die die Zuweisung
eines Wertes kontrolliert.
@end table

Eintr@"age, die die Eigenschaften von Funktionen beschreiben:

@table @code
@item function
Eine mit dem Operator @mref{:=} oder der Funktion @mref{define} definierte
Nutzerfunktion.
@item macro
Eine mit dem Operator @mref{::=} definierte Makrofunktion.
@item system function
Ein interne Maxima-Funktion.
@item special evaluation form
Eine Maxima-Spezialform, die die Argumente nicht auswertet.
@item transfun
Wird eine Nutzerfunktion mit @mref{translate} @"ubersetzt oder mit der Funktion
@mref{compile} kompiliert, erh@"alt sie die Eigenschaft @code{transfun}.
Interne Maxima-Funktionen, die mit dem Lisp-Makro @code{defmfun} definiert
werden, haben ebenfalls diese Eigenschaft.
@item deftaylor
F@"ur die Funktion ist eine Taylorreihenentwicklung definiert.
@item gradef
Die Funktion hat eine Ableitung.
@item integral
Die Funktion hat eine Stammfunktion.
@item distribute over bags
Ist das Argument der Funktion eine Liste, Matrix oder Gleichung so wird die
Funktion auf die Elemente oder beide Seiten der Gleichung angewendet.
@item limit function
Es existiert eine Funktion f@"ur die Behandlung spezieller Grenzwerte.
@item conjugate function
Es existiert eine Funktion, um die konjugiert komplexe Funktion f@"ur spezielle
Wertebereiche zu ermitteln.
@item mirror symmetry
Die Funktion hat die Eigenschaft der Spiegelsymmetrie.
@item complex characteristic
Es existiert eine Funktion, um den Realteil und den Imagin@"arteil der Funktion
f@"ur spezielle Wertebereiche zu ermitteln.
@item user autoload function
Die Funktion wird automatisch beim ersten Aufruf aus einer Datei geladen.  Der
Nutzer kann mit dem Funktion @mref{setup_autoload} eine solche Funktion
definieren.
@end table

Weitere Eigenschaften, die Symbole erhalten k@"onnen:

@table @code
@item operator
Das Symbol ist ein Maxima-Operator oder ein nutzerdefinierte Operator.

@item rule
Die Funktion oder der Operator haben eine Regel f@"ur die Vereinfachung.

@item alias

@item database info
Das Symbol hat Eintr@"age in Maximas Datenbank.

@item hashed array, declared array, complete array
Ein Hashed-Array, ein deklariertes Array oder ein Array dessen Elemente
einen bestimmten Typ haben.

@item array function
Eine Array-Funktion die mit dem Operator @mref{:=} definiert ist.

@item atvalue
Dem Symbol ist mit der Funktion @mref{atvalue} ein Wert an einer Stelle
zugewiesen.

@item atomgrad
F@"ur das Symbol ist mit der Funktion @mref{gradef} eine Ableitung definiert.

@item dependency
F@"ur das Symbol ist eine Abh@"angigkeit mit der Funktion @mref{depends}
definiert.

@item matchdeclare
Das Symbol ist eine mit @mref{matchdeclare} definierte Mustervariable, der eine
Aussagefunktion zugeordnet ist.

@item modedeclare
F@"ur das Symbol ist mit der Funktion @mref{mode_declare} ein Typ definiert.

@item user properties

@item context
Das Symbol bezeichnet einen Kontext.

@item activecontext
Das Symbol bezeichnet einen aktiven Kontextes.
@end table
@end deffn

@c --- 20.08.2011 DK -----------------------------------------------------------
@anchor{props}
@defvr {Systemvariable} props
Standardwert: @code{[]}

@code{props} ist eine Liste der Symbole, die vom Nutzer eine Eigenschaft
erhalten haben, die in die Lisp-Eigenschaftsliste des Symbols eingetragen wird.
Neben den Funktionen @mref{put} und @mrefcomma{qput} mit denen der Nutzer
direkt eine Eigenschaft zu einem Symbol in die Lisp-Eigenschaftsliste eintragen
kann, legen auch Maxima-Funktionen Eigenschaften zu Symbolen in der 
Eigenschaftsliste ab und tragen diese Symbole in die Systemvariable @code{props}
ein.  Zu diesen Funktionen geh@"oren zum Beispiel @mrefcomma{declare}@w{}
@mrefcomma{numerval} @mrefcomma{matchdeclare} @mrefcomma{mode_declare}@w{}
@mref{gradef} oder @mrefdot{setup_autoload}

Nach dem Start von Maxima sollte die Systemvariable @code{props} keine Symbole
enthalten.  Das ist jedoch nicht der Fall und kann als ein Fehler betrachtet
werden, der in Zukunft zu beheben ist.
@end defvr

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{propvars}
@deffn {Funktion} propvars (@var{prop})

Gibt eine Liste mit den Atomen zur@"uck, die in der Informationsliste 
@code{props} eingetragen sind und die die Eigenschaft @var{prop} haben.  Zum 
Beispiel gibt @code{propvars(atvalue)} eine Liste der Atome zur@"uck, die die 
Eigenschaft @code{atvalue} haben.
@end deffn

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{put}
@deffn {Funktion} put (@var{atom}, @var{value}, @var{indicator})

Weist den Wert @var{value} der Eigenschaft @var{indicator} des Atoms @var{atom}
zu.  @var{indicator} kann eine beliebige Eigenschaft sein und beschr@"ankt sich
nicht auf die vom System definierten Eigenschaften.  @code{put} wertet die 
Argumente aus.  @code{put} gibt @var{value} zur@"uck.

Beispiele:

@example
(%i1) put (foo, (a+b)^5, expr);
                                   5
(%o1)                       (b + a)
(%i2) put (foo, "Hello", str);
(%o2)                         Hello
(%i3) properties (foo);
(%o3)            [[user properties, str, expr]]
(%i4) get (foo, expr);
@group
                                   5
(%o4)                       (b + a)
@end group
(%i5) get (foo, str);
(%o5)                         Hello
@end example
@end deffn

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{qput}
@deffn {Funktion} qput (@var{atom}, @var{value}, @var{indicator})

Entspricht der Funktion @code{put} mit dem Unterschied, dass @code{qput} die
Argumente nicht auswertet.

Beispiele:

@example
(%i1) foo: aa$ 
(%i2) bar: bb$
(%i3) baz: cc$
(%i4) put (foo, bar, baz);
(%o4)                          bb
(%i5) properties (aa);
(%o5)                [[user properties, cc]]
(%i6) get (aa, cc);
(%o6)                          bb
(%i7) qput (foo, bar, baz);
(%o7)                          bar
(%i8) properties (foo);
(%o8)            [value, [user properties, baz]]
(%i9) get ('foo, 'baz);
(%o9)                          bar
@end example
@end deffn

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{rational}
@anchor{irrational}
@defvr  {Eigenschaft} rational
@defvrx {Eigenschaft} irrational

Hat eine Variable mit der Funktion @mref{declare} die Eigenschaft 
@code{rational} oder @code{irrational} erhalten, wird sie von Maxima als eine 
rationale Zahl oder als eine nicht rationale Zahl interpretiert.
@end defvr

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{real}
@anchor{imaginary}
@anchor{complex}
@defvr  {Eigenschaft} real
@defvrx {Eigenschaft} imaginary
@defvrx {Eigenschaft} complex

Hat eine Variable mit der Funktion @mref{declare} die Eigenschaft @code{real},
@code{imaginary} oder @code{complex} erhalten, wird sie von Maxima als eine 
reelle Zahl, imagin@"are Zahl oder als eine komplexe Zahl interpretiert.
@end defvr

@c --- 03.01.2011 DK -----------------------------------------------------------
@anchor{rem}
@deffn {Funktion} rem (@var{atom}, @var{indicator})

Entfernt die Eigenschaft @var{indicator} vom Atom @var{atom}.
@end deffn

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{remove}
@deffn  {Funktion} remove (@var{a_1}, @var{p_1}, @dots{}, @var{a_n}, @var{p_n})
@deffnx {Funktion} remove ([@var{a_1}, @dots{}, @var{a_m}], [@var{p_1}, @dots{}, @var{p_n}], @dots{})
@deffnx {Funktion} remove ("@var{a}", operator)
@deffnx {Funktion} remove (@var{a}, transfun)
@deffnx {Funktion} remove (all, @var{p})

Entfernt Eigenschaften von Atomen.

@code{remove(@var{a_1}, @var{p_1}, ..., @var{a_n}, @var{p_n})} entfernt die
Eigenschaft @code{p_k} von dem Atom @code{a_k}.

@code{remove([@var{a_1}, ..., @var{a_m}], [@var{p_1}, ..., @var{p_n}], ...)}
entfernt die Eigenschaften @var{p_1}, @dots{}, @var{p_n} von den Atomen 
@var{a_1}, @dots{}, @var{a_m}.  Es k@"onnen mehrere Paare an Listen angegeben 
werden.

@code{remove(all, @var{p})} entfernt die Eigenschaft @var{p} von allen Atomen, 
die diese Eigenschaft aufweisen.

Die zu entfernenden Eigenschaften k@"onnen vom System definierte Eigenschaften
wie @code{function}, @code{macro}, @code{mode_declare} oder nutzerdefinierte
Eigenschaften sein.

@code{remove("@var{a}", operator)} oder @code{remove("@var{a}", op)}
entfernen vom Atom @var{a} die Operatoreigenschaften, die mit den Funktionen
@mrefcomma{prefix} @mrefcomma{infix} @mrefcomma{nary} @mrefcomma{postfix}@w{}
@mref{matchfix} oder @mref{nofix} definiert wurden.  Die Namen von Operatoren
m@"ussen als eine Zeichenkette angegeben werden.

@code{remove} gibt immer @code{done} zur@"uck.
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{scalar}
@defvr {Eigenschaft} scalar

Hat ein Symbol die Eigenschaft @code{scalar}, verh@"alt es sich wie ein Skalar 
bei nicht-kommutativen Rechenoperationen.
@end defvr

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{scalarp}
@deffn {Funktion} scalarp (@var{expr})

Gibt @code{true} zur@"uck, wenn der Ausdruck @var{expr} eine Zahl, Konstante, 
ein als Skalar definiertes Symbol oder ein aus diesen Objekten zusammengesetzter
Ausdruck ist.  Der Ausdruck darf jedoch keine Liste oder eine Matrix sein.
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Fakten, Funktionen und Variablen f@"ur Aussagen, Funktionen und Variablen f@"ur Eigenschaften, Maximas Datenbank
@section Funktionen und Variablen f@"ur Fakten
@c -----------------------------------------------------------------------------

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{activate}
@deffn {Funktion} activate (@var{context_1}, @dots{}, @var{context_n})

Das Kommando @code{activate(@var{context})} aktiviert den Kontext @var{context}.
Der Funktion @code{activate} k@"onnen mehrere Kontexte @var{context_1}, @dots{},
@var{context_n} @"ubergeben werden.  Nur die Aussagen und Fakten eines aktiven
Kontextes stehen f@"ur die Auswertung von Aussagen zur Verf@"ugung.

Maxima gibt @code{done} zur@"uck, wenn der Kontext erfolgreich aktiviert werden
konnte oder wenn der Kontext bereits aktiv ist.  Wird versucht einen nicht 
existierenden Kontext zu aktivieren, gibt Maxima eine Fehlermeldung aus.

Das Kommando @code{facts()} gibt die Fakten und Aussagen des aktuellen Kontextes
aus.  Die Aussagen und Fakten anderer Kontexte k@"onnen zwar aktiv sein, sind 
aber in der R@"uckgabe von @code{facts} nicht enthalten.  Um die Aussagen und 
Fakten eines anderen als des aktuellen Kontexts auszugeben, kann das Kommando 
@code{facts(@var{context})} ausgef@"uhrt werden.

Die Systemvariable @mref{activecontexts} enth@"alt eine Liste der aktiven
Kontexte.  Siehe auch die Systemvariable @mref{contexts} f@"ur eine Liste
aller Kontexte, die Maxima kennt.
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{activecontexts}
@defvr {Systemvariable} activecontexts
Standardwert: @code{[]}

Die Systemvariable @code{activecontexts} enth@"alt eine Liste der Kontexte, die
mit der Funktion @code{activate} aktiviert wurden.  Unterkontexte sind aktiv,
ohne dass die Funktion @code{activate} aufgerufen werden muss und sind nicht in
der Liste @code{activecontexts} enthalten.  Siehe auch die Funktion
@mref{activate} f@"ur die Aktivierung eines Kontextes und die Systemvariable
@mref{contexts} f@"ur eine Liste aller vorhandenen Kontexte.
@end defvr

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{askinteger}
@deffn  {Funktion} askinteger (@var{expr}, integer)
@deffnx {Funktion} askinteger (@var{expr})
@deffnx {Funktion} askinteger (@var{expr}, even)
@deffnx {Funktion} askinteger (@var{expr}, odd)

Das Kommando @code{askinteger(@var{expr}, integer)} versucht anhand der Aussagen
und Fakten der aktiven Kontexte zu entscheiden, ob @var{expr} eine ganze Zahl
repr@"asentiert.  Kann @code{askinteger} die Frage nicht entscheiden, fragt 
Maxima den Nutzer.  Die Antwort wird dem aktuellen Kontext hinzugef@"ugt.  
@code{askinteger(@var{expr})} ist @"aquivalent zu 
@code{askinteger(@var{expr}, integer)}.

@code{askinteger(@var{expr}, even)} und @code{askinteger(@var{expr}, odd)}
versuchen zu entscheiden, ob @var{expr} eine gerade oder ungerade ganze Zahl
repr@"asentiert.  Kann Maxima dies nicht entscheiden, wird der Nutzer gefragt.
Die Antwort wird dem aktuellen Kontext hinzugef@"ugt.

Beispiele:

@example
(%i1) askinteger(n,integer);
Is n an integer?
yes;
(%o1)                          yes
(%i2) askinteger(e,even);
Is e an even number?
yes;
(%o2)                          yes
(%i3) facts();
(%o3)           [kind(n, integer), kind(e, even)]
(%i4) declare(f,integervalued);
(%o4)                         done
(%i5) askinteger(f(x));
(%o5)                          yes
@end example
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{asksign}
@deffn {Funktion} asksign (@var{expr})

Die Funktion @code{asksign} versucht zu entscheiden, ob der Ausdruck @var{expr}
einen positiven, negativen oder den Wert Null repr@"asentiert.  Kann Maxima dies
nicht feststellen, wird der Nutzer nach weiteren Informationen gefragt, um die 
Frage zu entscheiden.  Die Antworten des Nutzers werden f@"ur die laufende 
Auswertung dem aktuellen Kontext hinzugef@"ugt.  Der R@"uckgabewert der 
Funktion @code{asksign} ist @code{pos}, @code{neg} oder @code{zero} f@"ur einen
positiven, negativen oder den Wert Null.
@end deffn

@c --- 26.08.2010 DK -----------------------------------------------------------
@anchor{assume}
@deffn {Funktion} assume (@var{pred_1}, @dots{}, @var{pred_n})

F@"ugt die Aussagen @var{pred_1}, @dots{}, @var{pred_n} dem aktuellen Kontext 
hinzu.  Eine inkonsistente oder redundante Aussage wird dem Kontext nicht
hinzugef@"ugt.  @code{assume} gibt eine Liste mit den Aussagen zur@"uck, die dem
Kontext hinzugef@"ugt wurden, oder die Symbole @code{redunant} und 
@code{inconsistent}.

Die Aussagen @var{pred_1}, @dots{}, @var{pred_n} k@"onnen nur Ausdr@"ucke mit 
den relationalen Operatoren @code{"<"}, @code{"<="}, @code{equal}, 
@code{notequal}, @code{">="} und @code{">"} sein.  Aussagen k@"onnen nicht die
Operatoren @code{"="} f@"ur Gleichungen oder @code{"#"} f@"ur Ungleichungen 
enthalten.  Auch k@"onnen keine Aussagefunktionen wie @code{integerp} verwendet
werden.

Zusammengesetzte Aussagen mit dem Operator @code{and} der Form 
@code{@var{pred_1} and ... and @var{pred_n}} sind m@"oglich, nicht dagegen 
Aussagen mit dem Operator @code{or} der Form @code{@var{pred_1} or ... or 
@var{pred_n}}.  Ein Ausdruck mit dem Operator @code{not} der Form 
@code{not(@var{pred_k})} ist dann m@"oglich, wenn @var{pred_k} eine 
relationale Aussage ist.  Aussagen der Form @code{not (@var{pred_1} and
@var{pred_2})} und @code{not (@var{pred_1} or @var{pred_2})} sind dagegen nicht
m@"oglich.

Der Folgerungsmechanismus von Maxima ist nicht sehr stark.  Viele 
Schlu@ss{}folgerungen k@"onnen von Maxima nicht abgeleitet werden.  Dies ist 
eine bekannte Schw@"ache von Maxima.

@code{assume} behandelt keine Aussagen mit komplexen Zahlen.  Enth@"alt eine
Aussage eine komplexe Zahl, gibt @code{assume} den Wert @code{inconsistent}
oder @code{redunant} zur@"uck.

@code{assume} wertet die Argumente aus.

Siehe auch @mrefcomma{is} @mrefcomma{facts} @mrefcomma{forget}@w{}
@mref{context} und @mrefdot{declare}

Beispiele:

@example
(%i1) assume (xx > 0, yy < -1, zz >= 0);
(%o1)              [xx > 0, yy < - 1, zz >= 0]
(%i2) assume (aa < bb and bb < cc);
(%o2)                  [bb > aa, cc > bb]
(%i3) facts ();
(%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
(%i4) is (xx > yy);
(%o4)                         true
(%i5) is (yy < -yy);
(%o5)                         true
(%i6) is (sinh (bb - aa) > 0);
(%o6)                         true
(%i7) forget (bb > aa);
(%o7)                       [bb > aa]
(%i8) prederror : false;
(%o8)                         false
(%i9) is (sinh (bb - aa) > 0);
(%o9)                        unknown
(%i10) is (bb^2 < cc^2);
(%o10)                       unknown
@end example
@end deffn

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{assumescalar}
@defvr {Optionsvariable} assumescalar
Standardwert: @code{true}

Die Optionsvariable @code{assumescalar} kontrolliert, wie ein Ausdruck von den
arithmetischen Operatoren @code{"+"}, @code{"*"}, @code{"^"}, @code{"."} und
@code{"^^"} behandelt wird, wenn Maxima nicht ermitteln kann, ob der Ausdruck
ein Skalar oder Nicht-Skalar ist.  @code{assumescalar} hat drei m@"ogliche
Werte:

@table @code
@item false
Unbekannte Ausdr@"ucke werden als ein Nicht-Skalar behandelt.

@item true
Unbekannte Ausdr@"ucke werden als ein Skalar f@"ur die kommutativen 
arithmetischen Operatoren @code{"+"}, @code{"*"} und @code{"^"} behandelt.

@item all
Unbekannte Ausdr@"ucke werden f@"ur alle arithmetischen Operatoren als ein
Skalar behandelt.
@end table

Es ist besser Variablen als ein Skalar oder Nicht-Skalar mit der Funktion
@mref{declare} zu deklarieren, anstatt die Vereinfachung mit der 
Optionsvariablen @code{assumescalar} zu kontrollieren.  Siehe auch die 
Eigenschaften @mref{scalar} und @mref{nonscalar} sowie die Funktionen 
@mref{scalarp} und @mrefdot{nonscalarp}

Beispiele:

Maxima kann nicht ermitteln, ob das Symbol @code{x} ein Skalar oder ein
Nicht-Skalar ist.

@example
(%i1) scalarp(x);
(%o1)                         false
(%i2) nonscalarp(x);
(%o2)                         false
@end example

Hat @code{assumescalar} den Wert @code{true}, behandelt Maxima das Symbol 
@code{x} als einen Skalar f@"ur die kommutative Multiplikation.

@example
(%i3) x * [a,b,c], assumescalar:false;
(%o3)                      x [a, b, c]
(%i4) x * [a,b,c], assumescalar:true;
(%o4)                    [a x, b x, c x]
@end example

F@"ur die nicht kommutative Multiplikation behandelt Maxima das Symbol @code{x}
dann als einen Skalar, wenn @code{assumescalar} den Wert @code{all} hat.

@example
(%i5) x . [a,b,c], assumescalar:false;
(%o5)                     x . [a, b, c]
(%i6) x . [a,b,c], assumescalar:true;
(%o6)                     x . [a, b, c]
(%i7) x . [a,b,c], assumescalar:all;
(%o7)                 [x . a, x . b, x . c]
@end example
@end defvr

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{assume_pos}
@defvr {Optionsvariable} assume_pos
Standardwert: @code{false}

Die Optionsvariable @code{assume_pos} kontrolliert das Ergebnis der Funktionen
@mref{sign} und @mrefcomma{asksign} f@"ur den Fall, dass Maxima das Vorzeichen
einer Variablen oder indizierten Variablen nicht aus den aktiven Kontexten 
ermitteln kann.  Hat @code{assume_pos} den Wert @code{true}, dann wird f@"ur 
Variable oder indizierte Variable, immer das Ergebnis @code{pos} ermittelt, wenn
die Optionsvariable @code{assume_pos_pred} den Standardwert @code{false} hat und
das Vorzeichen nicht aus den aktiven Kontexten ermittelt werden kann.

Die Optionsvariable @mref{assume_pos_pred} hat den Standardwert @code{false}.
In diesem Fall werden von Maxima Variablen und indizierte Variablen als positiv
angenommen, wenn @code{assume_pos} den Wert @code{true} hat.  Der 
Optionsvariablen @mref{assume_pos_pred} kann eine Aussagefunktion mit einem
Argument zugewiesen werden.  Hat die Aussagefunktion f@"ur ein Argument 
@var{expr} das Ergebnis @code{true}, wird das Argument als positiv 
angenommen, wenn die Optionsvariable @code{assume_pos} den Wert @code{true} hat
und Maxima das Vorzeichen nicht aus den aktiven Kontexten ermitteln kann.

Die Funktionen @code{sign} und @code{asksign} versuchen das Vorzeichen eines
Ausdrucks anhand der Vorzeichen der Argumente zu ermitteln.  Sind zum Beispiel
@code{a} und @code{b} beide positiv, dann wird f@"ur den Ausdruck @code{a+b} ein
positives Vorzeichen ermittelt.  Auch wenn die Vorzeichen der Variablen @code{a}
und @code{b} nicht bekannt sind, hat daher @code{asksign(a+b)} das Ergebnis
@code{pos}, wenn @code{assume_pos} den Wert @code{true} hat, da in diesem Fall
die Variablen als positiv angenommen werden.

Es gibt jedoch keine M@"oglichkeit, alle Ausdr@"ucke grunds@"atzlich als positiv
zu erkl@"aren.  Selbst wenn der Optionsvariablen @code{assume_pos_pred} eine 
Aussagefunktion zugewiesen wird, die alle Ausdr@"ucke als positiv erkl@"art,
werden Differenzen @code{a-b} oder das Vorzeichen der Logarithmusfunktion 
@code{log(a)} nicht als positiv ermittelt.  Die Fragen der Funktion 
@code{asksign} an den Nutzer k@"onnen daher nie vollst@"andig mit dem 
Mechanismus der Optionsvariablen @code{assume_pos} unterdr@"uckt werden.

Siehe f@"ur weitere Beispiele die Optionsvariable @mrefdot{assume_pos_pred}

Beispiele:

Das Vorzeichen der Variablen @code{x} ist nicht bekannt.  Erh@"alt die
Optionsvariable @code{assume_pos} den Wert @code{true}, wird f@"ur die Variable
@code{x} und die indizierte Variable @code{x[1]} ein positives Vorzeichen
ermittelt.

@example
(%i1) sign(x);
(%o1)                          pnz
(%i2) assume_pos:true;
(%o2)                         true
(%i3) sign(x);
(%o3)                          pos
(%i4) sign(x[1]);
(%o4)                          pos
@end example

Die Vorzeichen der Variablen @code{a} und @code{b} sind nicht bekannt.  Maxima
ermittelt ein positives Vorzeichen f@"ur die Summe der Variablen.  Das
Vorzeichen der Differenz ist dagegen weiterhin nicht bekannt.

@example
(%i5) sign(a+b);
(%o5)                          pos
(%i6) sign(a-b);
(%o6)                          pnz
@end example
@end defvr

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{assume_pos_pred}
@defvr {Optionsvariable} assume_pos_pred
Standardwert: @code{false}

Der Optionsvariablen @code{assume_pos_pred} kann eine Aussagefunktion wie zum
Beispiel @mref{symbolp} oder ein Lambda-Ausdruck mit einem Argument @code{x}
zugewiesen werden.  Hat die Optionsvariable @mref{assume_pos} den Wert
@code{true}, werden Variablen, indizierte Variablen oder die Werte von 
Funktionen dann als positiv angenommen, wenn die Aussagefunktion das Ergebnis 
@code{true} hat.

Die Aussagefunktion wird intern von den Funktionen @mref{sign} und 
@mref{asksign} aufgerufen, wenn die Optionsvariable @code{assume_pos} den Wert
@code{true} hat und das Vorzeichen einer Variablen, indizierten Variablen oder
f@"ur den Wert einer Funktion nicht ermittelt werden konnte.  Gibt die
Aussagefunktion das Ergebnis @code{true} zur@"uck, wird das Argument als
positiv angenommen.

Hat die Optionsvariable @code{assume_pos_pred} den Standardwert @code{false}
werden Variablen und indizierte Variablen von Maxima als positiv angenommen,
wenn die Optionsvariable @code{assume_pos} den Wert @code{true} hat.  Das 
entspricht einer Aussagefunktion, die als @code{lambda([x], symbolp(x) or
subvarp(x))} definiert wird.

Siehe auch @mref{assume} und @mrefdot{assume_pos}

Beispiele:

Der Optionsvariablen @code{assume_pos_pred} wird der Name der Aussagefunktion
@code{symbolp} zugewiesen.  Indizierte Variablen werden nun nicht mehr als 
positiv angenommen, wie es f@"ur den Standartwert @code{false} gilt.

@example
(%i1) assume_pos: true$
(%i2) assume_pos_pred: symbolp$
(%i3) sign (a);
(%o3)                          pos
(%i4) sign (a[1]);
(%o4)                          pnz
@end example

Der Optionsvariablen @code{assume_pos_pred} wird ein Lambda-Ausdruck zugewiesen,
der f@"ur alle Argumente das Ergebnis @code{true} hat.  Die Funktion @code{sign}
ermittelt nun f@"ur Variablen, indizierte Variablen und den Werten von 
Funktionen ein positives Vorzeichen.  Dies trifft jedoch nicht f@"ur die 
Logarithmusfunktion oder eine Differenz zu.

@example
(%i1) assume_pos: true$
(%i2) assume_pos_pred: lambda([x], true);
(%o2)                   lambda([x], true)
(%i3) sign(a);
(%o3)                          pos
(%i4) sign(a[1]);
(%o4)                          pos
(%i5) sign(foo(x));
(%o5)                          pos
(%i6) sign(foo(x)+foo(y));
(%o6)                          pos
(%i7) sign(log(x));
(%o7)                          pnz
(%i8) sign(x-y);
(%o8)                          pnz
@end example
@end defvr

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{context}
@defvr {Optionsvariable} context
Standardwert: @code{initial}

Die Optionsvariable @code{context} enth@"alt den Namen des aktuellen Kontextes.
Das ist der Kontext, der die Aussagen der Funktion @mref{assume} oder die mit 
der Funktion @mref{declare} definierten Eigenschaften aufnimmt und aus dem die 
Aussagen mit der Funktion @mref{forget} oder die Eigenschaften mit der Funktion
@mref{remove} gel@"oscht werden.

Wird der Optionsvariablen @code{context} der Name eines existierenden Kontextes
zugewiesen, wird dieser zum aktuellen Kontext.  Existiert der Kontext noch 
nicht, wird er durch Aufruf der Funktion @mref{newcontext} erzeugt.

Siehe auch @mref{contexts} f@"ur eine allgemeinere Beschreibung von Kontexten.

Beispiele:

Der Standardkontext ist @code{initial}.  Es wird ein neuer Kontext
@code{mycontext} generiert, der die Aussagen und Eigenschaften aufnimmt.

@example
(%i1) context;
(%o1)                        initial
(%i2) context:mycontext;
(%o2)                       mycontext
(%i3) contexts;
(%o3)             [mycontext, initial, global]
(%i4) assume(a>0);
(%o4)                        [a > 0]
(%i5) declare(b,integer);
(%o5)                         done
(%i6) facts(mycontext);
(%o6)               [a > 0, kind(b, integer)]
@end example
@end defvr

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{contexts}
@defvr {Systemvariable} contexts
Standardwert: @code{[initial, global]}

Die Systemvariable @code{contexts} enth@"alt eine Liste der Kontexte, die 
Maxima bekannt sind.  Die Liste enth@"alt auch die nicht aktiven Kontexte.

Die Kontexte @code{global} und @code{initial} sind immer vorhanden.  Diese 
werden von Maxima initialisiert und k@"onnen nicht entfernt werden.  Der Kontext
@code{global} enth@"alt Aussagen und Fakten f@"ur Systemvariablen und
Systemfunktionen.  Mit den Funktionen @mref{newcontext} oder
@mref{supcontext} kann der Nutzer weitere Kontexte anlegen.

Die Kontexte haben eine Hierarchie.  Die Wurzel ist immer der Kontext
@code{global}, der damit ein Unterkontext aller anderen Kontexte und immer aktiv
ist.  Der Kontext @code{initial} ist anfangs leer und nimmt, sofern kein 
weiterer Kontext angelegt wurde, die Aussagen und Fakten des Nutzers auf, die 
mit den Funktionen @mref{assume} und @mref{declare} definiert werden.  Mit der
Funktion @mref{facts} k@"onnen die Aussagen und Fakten von Kontexten angezeigt
werden.

Die Verwaltung verschiedener Kontexte erm@"oglicht es, Aussagen und Fakten in
einem Kontext zusammenzustellen.  Durch das Aktivieren mit der Funktion
@mref{activate} oder Deaktivieren mit der Funktion @mref{deactivate} k@"onnen
diese Aussagen und Fakten f@"ur Maxima verf@"ugbar gemacht oder wieder
ausgeschaltet werden.

Die Aussagen und Fakten in einem Kontext bleiben so lange verf@"ugbar, bis sie 
mit den Funktionen @mref{forget} oder @mref{remove} gel@"oscht werden.
Weiterhin kann der gesamte Kontext mit der Funktion @mref{killcontext} entfernt
werden.

Beispiel:

Das folgende Beispiel zeigt wie ein Kontext @code{mycontext} angelegt wird.  Der
Kontext enth@"alt die Aussage @code{[a>0]}.  Der Kontext kann mit der Funktion
@code{activate} aktiviert werden, um die Aussage verf@"ugbar zu machen.

@example
(%i1) newcontext(mycontext);
(%o1)                       mycontext
(%i2) context;
(%o2)                       mycontext
(%i3) assume(a>0);
(%o3)                        [a > 0]
(%i4) context:initial;
(%o4)                        initial
(%i5) is(a>0);
(%o5)                        unknown
(%i6) activate(mycontext);
(%o6)                         done
(%i7) is(a>0);
(%o7)                         true
@end example
@end defvr

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{deactivate}
@deffn {Funktion} deactivate (@var{context_1}, @dots{}, @var{context_n})

Die Kontexte @var{context_1}, @dots{}, @var{context_n} werden deaktiviert.  Die
Aussagen und Fakten dieser Kontexte stehen f@"ur die Auswertung von Aussagen 
nicht mehr zur Verf@"ugung.  Die Kontexte werden nicht gel@"oscht und k@"onnen 
mit der Funktion @mref{activate} wieder aktiviert werden.

Die deaktivierten Kontexte werden aus der Liste @mref{activecontexts} entfernt.
@end deffn

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{facts}
@deffn  {Funktion} facts (@var{item})
@deffnx {Funktion} facts ()

Ist @var{item} der Name eines Kontextes, gibt @code{facts(@var{item})} eine
Liste der Aussagen und Fakten des Kontextes @code{item} zur@"uck.

Ist @var{item} nicht der Name eines Kontextes, gibt @code{facts(@var{item})} 
eine Liste mit den Aussagen und Fakten zur@"uck, die zu @var{item} im aktuellen
Kontext bekannt sind.  Aussagen und Fakten die zu einem anderen aktiven Kontext
geh@"oren einschlie@ss{}lich der Unterkontexte, sind nicht in der Liste 
enthalten.

@code{facts()} gibt eine Liste der Fakten des aktuellen Kontextes zur@"uck.

Beispiel:

@example
(%i1) context:mycontext;
(%o1)                       mycontext
(%i2) assume(a>0, a+b>0, x<0);
(%o2)               [a > 0, b + a > 0, x < 0]
(%i3) facts();
(%o3)               [a > 0, b + a > 0, 0 > x]
(%i4) facts(a);
(%o4)                  [a > 0, b + a > 0]
(%i5) facts(x);
(%o5)                        [0 > x]
(%i6) context:initial;
(%o6)                        initial
(%i7) activate(mycontext);
(%o7)                         done
(%i8) facts();
(%o8)                          []
(%i9) facts(mycontext);
(%o9)               [a > 0, b + a > 0, 0 > x]
@end example
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{forget}
@deffn  {Funktion} forget (@var{pred_1}, @dots{}, @var{pred_n})
@deffnx {Funktion} forget (@var{L})

Entfernt Aussagen, die mit @code{assume} einem Kontext hinzugef@"ugt wurden.
Die Aussagen k@"onnen Ausdr@"ucke sein, die @"aquivalent aber nicht unbedingt
identisch zu vorherigen Fakten sind.

@code{forget(@var{L})} entfernt alle Aussagen, die in der Liste @var{L}
enthalten sind.
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{is}
@deffn {Funktion} is (@var{expr})

Versucht festzustellen, ob die Aussage @var{expr} mit Hilfe der Aussagen und 
Fakten der aktiven Kontexte entschieden werden kann.

Kann die Aussage @var{expr} zu @code{true} oder @code{false} entschieden werden,
wird das entsprechende Ergebnis zur@"uckgegeben.  Andernfalls wird der 
R@"uckgabewert durch den Schalter @mref{prederror} bestimmt.  Hat 
@code{prederror} den Wert @code{true}, wird eine Fehlermeldung ausgegeben.  
Ansonsten wird @code{unknown} zur@"uckgegeben.

Siehe auch @mrefcomma{assume} @mref{facts} und @mrefdot{maybe}

Beispiele:

@code{is} wertet Aussagen aus.

@example
(%i1) %pi > %e;
(%o1)                       %pi > %e
(%i2) is (%pi > %e);
(%o2)                         true
@end example

@code{is} versucht Aussagen anhand der Aussagen und Fakten der aktiven
Kontexte zu entscheiden.

@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) assume (b > c);
(%o2)                        [b > c]
(%i3) is (a < b);
(%o3)                         false
(%i4) is (a > c);
(%o4)                         true
(%i5) is (equal (a, c));
(%o5)                         false
@end example

Wenn @code{is} eine Aussage anhand der Aussagen und Fakten der aktiven Kontexte 
nicht entscheiden kann, wird der R@"uckgabewert vom Wert des Schalters 
@code{prederror} bestimmt.

@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) prederror: true$
(%i3) is (a > 0);
Maxima was unable to evaluate the predicate:
a > 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) is (a > 0);
(%o5)                        unknown
@end example
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{killcontext}
@deffn {Funktion} killcontext (@var{context_1}, @dots{}, @var{context_n})

Das Kommando @code{killcontext(@var{context})} l@"oscht den Kontext 
@var{context}.

Ist einer der Kontexte der aktuelle Kontext, wird der erste vorhandene 
Unterkontext zum aktuellen Kontext.  Ist der erste verf@"ugbare Kontext der 
Kontext @code{global}, dann wird der Kontext @code{initial} zum aktuellen 
Kontext.  Wird der Kontext @code{initial} gel@"oscht, dann wird eine neuer 
leerer Kontext @code{initial} erzeugt.

@code{killcontext} l@"oscht einen Kontext nicht, wenn dieser ein Unterkontext 
des aktuellen Kontextes ist oder wenn der Kontext mit der Funktion 
@code{activate} aktiviert wurde.

@code{killcontext} wertet die Argumente aus.  @code{killcontext} gibt 
@code{done} zur@"uck.
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{maybe}
@deffn {Funktion} maybe (@var{expr})

Versucht festzustellen, ob die Aussage @var{expr} anhand der Aussagen und
Fakten der aktive Kontexte entschieden werden kann.

Kann die Aussage als @code{true} oder @code{false} entschieden werden, gibt 
@code{maybe} entsprechend @code{true} oder @code{false} zur@"uck.  Andernfalls
gibt @code{maybe} den Wert @code{unknown} zur@"uck.

@code{maybe} entspricht der Funktion @code{is} mit @code{prederror: false}.
Dabei wird @code{maybe} ausgef@"uhrt, ohne dass @code{prederror} einen Wert 
erh@"alt.

Siehe auch @mrefcomma{assume} @mref{facts} und @mrefdot{is}

Beispiele:

@example
(%i1) maybe (x > 0);
(%o1)                        unknown
(%i2) assume (x > 1);
(%o2)                        [x > 1]
(%i3) maybe (x > 0);
(%o3)                         true
@end example
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{newcontext}
@deffn {Funktion} newcontext (@var{name})

@code{newcontext(@var{name})} erzeugt einen neuen, leeren Kontext mit dem 
Namen @var{name}. Der neue Kontext hat den Kontext @code{global} als Subkontext
und wird zum aktuellen Kontext.

@code{newcontext} wertet seine Argumente aus.  @code{newcontext} gibt 
@code{name} zur@"uck.
@end deffn

@c --- 28.12.2010 DK -----------------------------------------------------------
@anchor{prederror}
@defvr {Optionsvariable} prederror
Standardwert: @code{false}

Hat @code{prederror} den Wert @code{true}, wird eine Fehlermeldung ausgegeben,
wenn eine Aussage mit einer @code{if}-Anweisung oder der Funktion @code{is} 
nicht zu @code{true} oder @code{false} ausgewertet werden kann.

Hat @code{prederror} den Wert @code{false}, wird f@"ur diese F@"alle 
@code{unknown} zur@"uckgegeben.

Siehe auch @mref{is} und @mrefdot{maybe}
@end defvr

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{sign}
@deffn {Funktion} sign (@var{expr})

Versucht das Vorzeichen des Ausdrucks @var{expr} auf Grundlage der Fakten der
aktuellen Datenbank zu finden.  @code{sign} gibt eine der folgende Antworten 
zur@"uck: @code{pos} (positiv), @code{neg} (negative), @code{zero} (null),
@code{pz} (positive oder null), @code{nz} (negative oder null), @code{pn}
(positiv oder negative) oder @code{pnz} (positiv, negative oder null, f@"ur den
Fall das Vorzeichen nicht bekannt ist).
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{supcontext}
@deffn  {Funktion} supcontext (@var{name}, @var{context})
@deffnx {FunKtion} supcontext (@var{name}) 

Erzeugt einen neuen Kontext, mit dem Namen @code{name}, der den Kontext 
@code{context} als einen Unterkontext enth@"alt.  Der Kontext @var{context} muss
existieren.

Wird @var{context} nicht angegeben, wird der aktuelle Kontext angenommen.
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Aussagen, , Funktionen und Variablen f@"ur Fakten, Maximas Datenbank
@section Funktionen und Variablen f@"ur Aussagen
@c -----------------------------------------------------------------------------

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{charfun}
@deffn {Funktion} charfun (@var{p})

Gibt den Wert 0 zur@"uck, wenn die Aussage @var{p} zu @code{false} ausgewertet
werden kann und den Wert 1, wenn die Auswertung @code{true} liefert.  Kann
die Aussage weder zu @code{false} oder @code{true} ausgewertet werden, wird eine
Substantiv-Form zur@"uck gegeben.

Beispiele:

@example
(%i1) charfun (x < 1);
(%o1)                    charfun(x < 1)
(%i2) subst (x = -1, %);
(%o2)                           1
(%i3) e : charfun ('"and" (-1 < x, x < 1))$
(%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
(%o4)                       [0, 1, 0]
@end example
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{compare}
@deffn {Funktion} compare (@var{x}, @var{y})

Liefert den Vergleichsoperator @var{op} (@code{<}, @code{<=}, @code{>}, 
@code{>=}, @code{=} oder @code{#}), so dass der Ausdruck @code{is(@var{x}
@var{op} @var{y})} zu @code{true} ausgewertet werden kann.  Ist eines der
Argumente eine komplexe Zahl, dann wird @code{notcomparable} zur@"uckgegeben.
Kann Maxima keinen Vergleichsoperator bestimmen, wird @code{unknown}
zur@"uckgegeben.

Beispiele:

@example
(%i1) compare (1, 2);
(%o1)                           <
(%i2) compare (1, x);
(%o2)                        unknown
(%i3) compare (%i, %i);
(%o3)                           =
(%i4) compare (%i, %i + 1);
(%o4)                     notcomparable
(%i5) compare (1/x, 0);
(%o5)                           #
(%i6) compare (x, abs(x));
(%o6)                          <=
@end example

Die Funktion @code{compare} versucht nicht festzustellen, ob der Wertebereich
einer Funktion reelle Zahlen enth@"alt.  Obwohl der Wertebereich von 
@code{acos(x^2+1)} bis auf Null keine reellen Zahlen enth@"alt, gibt 
@code{compare} das folgende Ergebnis zur@"uck:

@example
(%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
(%o1)                           <
@end example
@end deffn

@c --- 20.04.2011 DK -----------------------------------------------------------
@anchor{equal}
@deffn {Funktion} equal (@var{a}, @var{b})

Repr@"asentiert die @"Aquivalenz, das hei@ss{}t den gleichen Wert.

@code{equal} wird nicht ausgewertet oder vereinfacht.  Die Funktion
@mref{is} versucht einen Ausdruck mit @code{equal} zu einem booleschen Wert
auszuwerten.  @code{is(equal(@var{a}, @var{b}))} gibt @code{true} oder
@code{false} zur@"uck, wenn und nur wenn @var{a} und @var{b} gleich oder
ungleich sind f@"ur alle Werte ihrer Variablen, was mit @code{ratsimp(@var{a} -
@var{b})} bestimmt wird.  Gibt @mref{ratsimp} das Ergebnis 0 zur@"uck, werden
die beiden Ausdr@"ucke als @"aquivalent betracht.  Zwei Ausdr@"ucke k@"onnen
@"aquivalent sein, obwohl sie nicht syntaktisch gleich (im allgemeinen
identisch) sind.

Kann @code{is} einen Ausdruck mit @code{equal} nicht zu @code{true} oder 
@code{false} auswerten, h@"angt das Ergebnis vom Wert des globalen Flags 
@mref{prederror} ab.  Hat @code{prederror} den Wert @code{true}, gibt @code{is}
eine Fehlermeldung zur@"uck.  Ansonsten wird @code{unknown} zur@"uckgegeben.

Es gibt weitere Operatoren, die einen Ausdruck mit @code{equal} zu @code{true}
oder @code{false} auswerten k@"onnen.  Dazu geh@"oren @mrefcomma{if}@w{}
@mrefcomma{and} @mref{or} und @mrefdot{not}

Die Umkehrung von @code{equal} ist @mrefdot{notequal}

Beispiele:

@code{equal} wird von allein weder ausgewertet noch vereinfacht:

@example
(%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                        2
(%o1)            equal(x  - 1, (x - 1) (x + 1))
(%i2) equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) equal (x, y);
(%o3)                      equal(x, y)
@end example

Die Funktion @code{is} versucht, @code{equal} zu einem booleschen Wert
auszuwerten.  Der Ausdruck @code{is(equal(@var{a}, @var{b}))} gibt den Wert
@code{true} zur@"uck, when @code{ratsimp(@var{a} - @var{b})} den Wert 0 hat.
Zwei Ausdr@"ucke k@"onnen @"aquivalent sein, obwohl sie nicht syntaktisch
gleich sind.

@example
(%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
(%o1)                           0
(%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
(%o2)                         true
(%i3) is (x^2 - 1 = (x + 1) * (x - 1));
(%o3)                         false
(%i4) ratsimp (x - (x + 1));
(%o4)                          - 1
(%i5) is (equal (x, x + 1));
(%o5)                         false
(%i6) is (x = x + 1);
(%o6)                         false
(%i7) ratsimp (x - y);
(%o7)                         x - y
(%i8) is (equal (x, y));
(%o8)                        unknown
(%i9) is (x = y);
(%o9)                         false
@end example

Kann @code{is} einen Ausdruck mit @code{equal} nicht zu @code{true} oder
@code{false} vereinfachen, h@"angt das Ergebnis vom Wert des globalen Flags
@code{prederror} ab.

@example
(%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                    2             2
(%o1)             [x  + 2 x + 1, x  - 2 x - 1]
(%i2) ratsimp (aa - bb);
(%o2)                        4 x + 2
(%i3) prederror : true;
(%o3)                         true
(%i4) is (equal (aa, bb));
Maxima was unable to evaluate the predicate:
       2             2
equal(x  + 2 x + 1, x  - 2 x - 1)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) prederror : false;
(%o5)                         false
(%i6) is (equal (aa, bb));
(%o6)                        unknown
@end example

Einige weitere Operatoren werten @code{equal} und @code{notequal} zu einem
booleschen Wert aus.

@example
(%i1) if equal (y, y - 1) then FOO else BAR;
(%o1)                          BAR
(%i2) eq_1 : equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                         2                   2
(%o3)             equal(y  + 2 y + 1, (y + 1) )
(%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
(%o4)                  [false, true, true]
@end example

Da @code{not @var{expr}} den Ausdruck @var{expr} auswertet, ist 
@code{not equal(@var{a}, @var{b})} @"aquivalent zu 
@code{is(notequal(@var{a}, @var{b}))}

@example
(%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
(%o1)            [notequal(2 z, 2 z - 1), true]
(%i2) is (notequal (2*z, 2*z - 1));
(%o2)                         true
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{notequal}
@deffn {Funktion} notequal (@var{a}, @var{b})

Repr@"asentiert die Verneinung von @code{equal(@var{a}, @var{b})}.

Beispiele:

@example
(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
(%o4)                    notequal(a, b)
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) assume (a > b);
(%o6)                        [a > b]
(%i7) equal (a, b);
(%o7)                      equal(a, b)
(%i8) maybe (equal (a, b));
(%o8)                         false
(%i9) notequal (a, b);
(%o9)                    notequal(a, b)
(%i10) maybe (notequal (a, b));
(%o10)                        true
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{unknown}
@deffn {Funktion} unknown (@var{expr})

@c TODO: FORMULIERUNG?

Gibt den Wert @code{true} zur@"uck, wenn der Ausdruck @var{expr} einen Operator
oder eine Funktion enth@"alt, die nicht von Maximas Vereinfacher erkannt wird.
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{zeroequiv}
@deffn {Funktion} zeroequiv (@var{expr}, @var{v})

Testet, ob ein Ausdruck @var{expr} mit der Variablen @var{v} @"aquivalent zu 
Null ist.  Die Funktion gibt @code{true}, @code{false} oder @code{dontknow} 
zur@"uck.

@code{zeroequiv} hat Einschr@"ankungen:

@enumerate
@item
Funktionen im Ausdruck @var{expr} m@"ussen von Maxima differenzierbar und 
auswertbar sein.

@item
Hat der Ausdruck Pole auf der reellen Achse, k@"onnen Fehler auftreten.

@item
Enth@"alt der Ausdruck Funktionen, die nicht L@"osung einer 
Differentialgleichung erster Ordnung sind (zum Beispiel Bessel Funktionen), 
k@"onnen die Ergebnisse fehlerhaft sein.

@item
Der Algorithmus wertet die Funktion an zuf@"allig Punkten f@"ur ausgew@"ahlte
Teilausdr@"ucke aus.  Dies ist ein riskantes Verfahren und kann zu Fehlern 
f@"uhren.
@end enumerate

@code{zeroequiv(sin(2*x) - 2*sin(x)*cos(x), x)} hat zum Beispiel das Ergebnis 
@code{true} und  @code{zeroequiv (%e^x + x, x)} hat das Ergebnis @code{false}.
Andererseits hat @code{zeroequiv (log(a*b) - log(a) - log(b), a)} das Ergebnis
@code{dontknow}, wegen dem zus@"atzlichem Parameter @code{b}.
@end deffn

@c --- End of Database.de.texi -------------------------------------------------

