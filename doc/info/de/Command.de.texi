@c -----------------------------------------------------------------------------
@c File        : Command.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Command.texi revision 10.08.2011
@c Translation : Dr. Dieter Kaiser
@c Date        : 15.10.2010
@c Revision    : 10.08.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in die Kommandozeile::
* Funktionen und Variablen der Eingabe::
* Funktionen und Variablen der Ausgabe::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in die Kommandozeile, Funktionen und Variablen der Eingabe, Kommandozeile, Kommandozeile
@section Einf@"uhrung in die Kommandozeile
@c -----------------------------------------------------------------------------

@subheading Konsole

F@"ur Maxima sind verschiedene Nutzeroberfl@"achen erh@"altlich.  Oberfl@"achen,
die je nach Betriebssystem bereits mit der Installation von Maxima zur 
Verf@"ugung stehen, sind wxMaxima, Xmaxima, Imaxima und die Konsole.

Die Konsole (oder das Terminal) arbeitet in einem Textmodus.  F@"ur die Ausgabe 
in einem grafischen Modus mit einer men@"ugesteuerten Eingabe m@"ussen andere
Nutzeroberfl@"achen verwendet werden.

In dieser Dokumentation wird ausschlie@ss{}lich die Konsole eingesetzt, die
unter allen Betriebssystemen zur Verf@"ugung steht.  Der Nutzer kann alle
Maxima-Funktionen in einer Konsole nutzen.  Im Textmodus der Konsole
werden die Ergebnisse in der Regel in einem 2D-Modus dargestellt.  F@"ur die
Ausgabe von Funktionsgraphen werden von Maxima Hilfsprogramme wie GNUPlot
aufgerufen.

@subheading Eingabe, Auswertung, Vereinfachung und Ausgabe

Jede Eingabe des Nutzers in einer Konsole bis zur Ausgabe eines Ergebnisses auf
der Konsole kann in vier Phasen eingeteilt werden:

@enumerate
@item
Von der Tastatur oder aus einer Datei wird ein Ausdruck eingelesen und vom
Parser in eine interne Darstellung umgewandelt.  In dieser 1.@w{ }Phase werden 
inbesondere Operatoren wie "+", "/" oder "do" behandelt.

@item
Der vom Parser eingelesene Ausdruck wird von Maxima in der 2.@w{ }Phase 
ausgewertet.  Dabei werden Variablen durch ihren Wert ersetzt und Funktionen wie
die Substitution oder Integration eines Ausdrucks ausgef@"uhrt.  Das Ergebnis
dieser Phase ist ein ausgewerteter Ausdruck.

@item
Der ausgewertete Ausdruck wird in der 3.@w{ }Phase von Maxima vereinfacht.
Dabei werden Ausdr@"ucke wie @code{a+a} zu @code{2*a} oder @code{sin(%pi/2)} zu 
@code{1} vereinfacht.

@item
Das Ergebnis ist ein ausgewerteter und vereinfachter Ausdruck.  Zuletzt wird 
dieses Ergebnis in der 4.@w{ }Phase f@"ur die Anzeige vorbereitet und auf der 
Konsole ausgegeben.
@end enumerate

Der Nutzer kann auf jede einzelne Phase Einflu@ss{} nehmen.  Verschiedene 
Kapitel der Dokumentation befassen sich mit diesen M@"oglichkeiten.  In diesem 
Kapitel werden die Kommandos und M@"oglichkeiten zusammengestellt, die sich mit 
der Eingabe und Ausgabe auf der Konsole befassen.  In @ref{Auswertung} wird
beschrieben wie auf die Auswertung und in @ref{Vereinfachung} wie auf die
Vereinfachung einer Eingabe Einfluss genommen werden kann.

@subheading Marken

Maxima speichert alle Eingaben in den Marken @code{%i} und die Ausgaben in den
Marken @code{%o} ab.  Die Marken erhalten eine laufende Nummer.  Weiterhin
erzeugen einige Funktionen Zwischenmarken @code{%t}.  Andere Systemvariablen
speichern das letzte Ergebnis oder die letzte Eingabe ab.  Folgende Symbole
bezeichnen Variablen und Funktionen f@"ur die Verwaltung der Marken:

@verbatim
   __          _        
   %           %%           %th
   inchar      linechar     outchar
   linenum     nolabels
@end verbatim

@subheading Informationslisten

Maxima verwaltet Informationslisten.  Die verf@"ugbaren Informationslisten sind 
in der Systemvariablen @mref{infolists} enthalten.  In diesem Kapitel werden die
Informationslisten @mrefcomma{labels} @mref{values} und 
@mref{myoptions} erl@"autert.  Wird eine Optionsvariable vom Nutzer gesetzt,
kontrolliert die Optionsvariable @mref{optionset} die Ausgabe weiterer
Informationen.  Folgende Symbole bezeichnen Variablen und Funktionen f@"ur
Informationslisten und Optionsvariablen:

@verbatim
   infolists     labels        values 
   myoptions     optionset
@end verbatim

Weitere Informationslisten, die in anderen Kapiteln erl@"autert werden, sind:

@verbatim
   functions      arrays         macros
   rules          aliases        dependencies 
   gradefs        props          let_rule_packages
   structures     namespaces  
@end verbatim

@subheading L@"oschen und R@"ucksetzen

Um eine Maxima-Umgebung herzustellen, in der keine Variablen oder Funktionen
definiert sind, oder um einzelne Zuweisungen, Eigenschaften oder Definitionen
zu entfernen, kennt Maxima die folgenden Funktionen:

@verbatim
   kill     reset     reset_verbosely
@end verbatim

@subheading Weitere Kommandos der Kommandozeile

Mit den Symbolen @mref{?} und @mref{??} kann Dokumentation abgerufen werden.
Wird @code{?} einem Bezeichner als Pr@"afix vorangestellt, wird der Bezeichner 
als Lisp-Symbol interpretiert.  Mit weiteren Kommandos kann eine Maxima-Sitzung
beendet oder zu einer Lisp-Sitzung gewechselt werden.  Das Zeichen f@"ur die 
Eingabeaufforderung einer Unterbrechung kann ge@"andert werden.  Die Zeit f@"ur 
jede einzelne Berechnung kann angezeigt werden und die Ergebnisse einer Sitzung 
k@"onnen wiederholt ausgegeben werden.  Maxima kennt hierf@"ur die folgenden 
Symbole:

@verbatim
   ?            ??
   playback     prompt     showtime
   quit         to_lisp
@end verbatim

Die Funktionen @mref{read} und @mref{readonly} geben Ausdr@"ucke auf der Konsole
aus und lesen dann die Eingabe des Nutzers ein:

@verbatim
   read               readonly
@end verbatim

@subheading Ausgabe auf der Konsole

F@"ur die Ausgabe werden Ausdr@"ucke von einer internen Darstellung in eine
externe Darstellung transformiert.  Zum Beispiel hat die Eingabe @code{sqrt(x)}
eine interne Darstellung, die dem Ausdruck @code{x^(1/2)} entspricht.  F@"ur die
Ausgabe wird die interne Darstellung in einen Ausdruck transformiert, die der
Ausgabe @code{sqrt(x)} entspricht.  Dieses Verhalten wird von der
Optionsvariablen @mref{sqrtdispflag} kontrolliert.  Siehe @ref{Ausdr@"ucke}
f@"ur Funktionen, die die interne und externe Darstellung von Ausdr@"ucken
unterscheiden.

Folgende Optionsvariablen und Symbole kontrollieren die Ausgabe auf der Konsole:

@verbatim
   %edispflag         absboxchar       display2d
   display_format_internal             exptdispflag
   expt               nexpt            ibase
   linel              lispdisp         negsumdispflag
   obase              pfeformat        powerdisp
   sqrtdispflag       stardisp         ttyoff
@end verbatim

Mit folgenden Funktionen kann die Ausgabe auf der Konsole formatiert werden:

@verbatim
   disp               display          dispterms
   grind              ldisp            ldisplay
   print
@end verbatim

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen der Eingabe, Funktionen und Variablen der Ausgabe, Einf@"uhrung in die Kommandozeile, Kommandozeile
@section Funktionen und Variablen der Eingabe
@c -----------------------------------------------------------------------------

@c --- 14.02.2011 DK -----------------------------------------------------------
@anchor{;}
@defvr {Operator} ;

Mit dem Semikolon @code{;} wird die Eingabe eines Maxima-Ausdrucks auf der
Konsole und in einer Datei abgeschlossen.  Es k@"onnen mehrere Ausdr@"ucke mit
einem Semikolon als Abschluss auf einer Zeile eingegeben werden.  Siehe auch
@mrefdot{$}

Beispiele:

@example
(%i1) a:10;
(%o1)                          10
(%i2) a+b;
(%o2)                        b + 10
(%i3) x:10; x+y;
(%o3)                          10
(%o4)                        y + 10
@end example
@end defvr

@c --- 14.02.2011 DK -----------------------------------------------------------
@anchor{$}
@defvr {Operator} $

Das Dollarzeichen schlie@ss{}t wie das Semikolon die Eingabe eines Ausdruckes
auf der Konsole und in einer Datei ab.  Im Unterschied zum Semikolon wird die
Ausgabe des Ergebnisses unterdr@"uckt.  Das Ergebnis wird jedoch weiterhin
einer Ausgabemarke @mxref{outchar,%o} zugewiesen und die Systemvariable 
@mref{%} enth@"alt das Ergebnis.  Siehe auch @mrefdot{;}

Beispiele:

@example
(%i1) expand((a+b)^2)$

(%i2) %;
                          2            2
(%o2)                    b  + 2 a b + a
(%i3) a:10$ a+b$

(%i5) %o3;
(%o5)                          10
(%i6) %o4;
(%o6)                        b + 10
@end example
@end defvr

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{__}
@defvr {Systemvariable} __
@ifinfo
@vrindex Aktuelle Eingabe
@end ifinfo

W@"ahrend einer laufenden Auswertung enth@"alt die Systemvariable @code{__} den
zuletzt vom Parser eingelesenen Ausdruck @var{expr}.  Der Ausdruck @var{expr}
wird der Systemvariablen @code{__} vor der Auswertung und Vereinfachung
zugewiesen.

Die Systemvariable @code{__} wird von den Funktionen @mref{batch} und
@mref{load} erkannt.  Wird eine Datei mit der Funktion @code{batch}
ausgef@"uhrt, hat @code{__} dieselbe Bedeutung wie bei der Eingabe in einer 
Kommandozeile.  Wird eine Datei mit dem Namen @code{filename} mit der Funktion 
@code{load} geladen, enth@"alt @code{__} den Ausdruck 
@code{load(@var{filename})}.  Das ist die letzte Eingabe in der Kommandozeile.

Siehe auch die Systemvariablen @mref{_} und @mrefdot{%}

Beispiele:

@example
(%i1) print ("I was called as: ", __)$
I was called as:  print(I was called as, __) 

(%i2) foo (__);
(%o2)                     foo(foo(__))

(%i3) g (x) := (print ("Current input expression =", __), 0)$
(%i4) [aa : 1, bb : 2, cc : 3]$
(%i5) (aa + bb + cc)/(dd + ee + g(x))$

                            cc + bb + aa
Current input expression = -------------- 
                           g(x) + ee + dd
@end example
@end defvr

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{_}
@defvr {Systemvariable} _
@ifinfo
@vrindex Letzte Eingabe
@end ifinfo

Die Systemvariable @code{_} enth@"alt den zuletzt eingegebenen Ausdruck 
@var{expr}.  Der Ausdruck @var{expr} wird der Systemvariablen @code{_} vor der 
Auswertung und Vereinfachung zugewiesen.

Die Systemvariable @code{_} wird von den Funktionen @mref{batch} und
@mref{load} erkannt.  Wird eine Datei mit der Funktion @code{batch}@w{}
ausgef@"uhrt, hat @code{_} dieselbe Bedeutung wie bei der Eingabe in einer
Kommandozeile.  Wird eine Datei mit der Funktion @code{load} geladen, enth@"alt
@code{_} das zuletzt in der Kommandozeile eingegebene Kommando.

Siehe auch die Systemvariablen @mref{__} und @mrefdot{%}

Beispiele:

Die Funktion @mref{cabs} wird ausgewertet und nicht vereinfacht.  Das Beispiel
zeigt, dass die Systemvariable @code{_} den zuletzt eingelesenen Ausdruck vor
der Auswertung enth@"alt.

@example
(%i1) cabs(1+%i);
(%o1)                        sqrt(2)
(%i2) _;
(%o2)                     cabs(%i + 1)
@end example

Die Funktion @mref{abs} vereinfacht einen Ausdruck.  Wird der Inhalt der 
Systemvariablen @code{_} ausgegeben, wird das f@"ur die Ausgabe vereinfachte
Ergebnis angezeigt.  Mit der Funktion @mref{string} wird der Inhalt der 
Systemvariablen @code{_} vor der Ausgabe in ein Zeichenkette umgewandelt, um 
den nicht vereinfachten Wert sichtbar zu machen.

@example
(%i3) abs(1+%i);
(%o3)                        sqrt(2)
(%i4) _;
(%o4)                        sqrt(2)
(%i5) abs(1+%i);
(%o5)                        sqrt(2)
(%i6) string(_);
(%o6)                       abs(1+%i)
@end example
@end defvr

@c --- 21.10.2010 DK -----------------------------------------------------------
@anchor{%}
@defvr {Systemvariable} %
@ifinfo
@vrindex Letzte Ausgabe
@end ifinfo

Die Systemvariable @code{%} enth@"alt das Ergebnis des zuletzt von Maxima
ausgewerteten und vereinfachten Ausdrucks.  @code{%} enh@"alt das letzte 
Ergebnis auch dann, wenn die Ausgabe des Ergebnisses durch Abschluss der Eingabe
mit einem Dollarzeichen @mref{$} unterdr@"uckt wurde.

Die Systemvariable @code{%} wird von den Funktionen @mref{batch} und
@mref{load} erkannt.  Wird eine Datei mit der Funktion @code{batch}
ausgef@"uhrt, hat @code{%} dieselbe Bedeutung wie bei der Eingabe in einer
Kommandozeile.  Wird eine Datei mit der Funktion @code{load} geladen, enth@"alt
@code{%} das letzte Ergebnis des Ausdrucks, der auf der Konsole eingegeben
wurde.

Siehe auch die Systemvariablen @mrefcomma{_} @mref{__} und @mrefdot{%th}
@end defvr

@c --- 27.07.2013 VvN ----------------------------------------------------------
@anchor{%%}
@defvr {Systemvariable} %%
@ifinfo
@vrindex Letztes Ergebnis in zusammengesetzten Anweisungen
@end ifinfo

In zusammengesetzten Ausdr@"ucken, wie in Ausdr@"ucken mit @mref{block} oder
@mref{lambda} oder in Ausdr@"ucken der Gestalt @code{(@var{s_1}, ..., @var{s_n})},
enth@"alt die Systemvariable @code{%%} das Ergebnis des 
vorhergehenden Ausdrucks.  F@"ur den ersten Ausdruck oder au@ss{}erhalb eines
zusammengesetzten Ausdrucks ist @code{%%} nicht definiert.

Die Systemvariable @code{%%} wird von @mref{batch} und @mref{load} erkannt und
hat dieselbe Bedeutung wie bei der Eingabe in der Konsole.  Siehe auch die 
Systemvariable @mref{%} und die Funktion @mrefdot{%th}

Beispiele:

Auf die im ersten Ausdruck berechnete Stammfunktion wird im zweiten Ausdruck
mit @code{%%} Bezug genommen, um das Integral an der oberen und unteren Grenze
auszuwerten.

@example
@group
(%i1) block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
                               21
(%o1)                          --
                               2
@end group
@end example

Ein zusammengesetzter Ausdruck kann weitere zusammengesetzte Ausdr@"ucke 
enthalten.  @code{%%} enth@"alt dabei jeweils das Ergebnis des letzten 
Ausdrucks.  Das folgende Beispiel hat das Ergebnis @code{7*a^n}.

@example
(%i3) block (block (a^n, %%*42), %%/6);
                                 n
(%o3)                         7 a
@end example

Der Wert der Systemvariablen @code{%%} kann nach einer Unterbrechung mit dem 
Kommando @mref{break} inspiziert werden.  In diesem Beispiel hat die
Systemvariable @code{%%} den Wert 42.

@example
(%i4) block (a: 42, break ())$
Entering a Maxima break point. Type 'exit;' to resume.
_%%;
42
_
@end example
@end defvr

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{%th}
@deffn {Funktion} %th (@var{n})
@ifinfo
@fnindex n-te vorhergehende Ausgabe
@end ifinfo

Die Funktion @code{%th} liefert das n-te vorhergehende Ergebnis.  Dies ist dann
n@"utzlich, wenn wie in Batch-Dateien die absolute Zeilennummer der letzten
Ausgabemarken nicht bekannt ist.

Die Funktion @code{%th} wird von den Funktionen @mref{batch} und 
@mref{load} erkannt.  Wird eine Datei mit @code{batch} ausgef@"uhrt, hat
@code{%th} dieselbe Bedeutung wie bei der Eingabe in der Konsole.  Wird eine
Datei mit der Funktion @code{load} geladen, enth@"alt @code{%th} das letzte 
Ergebnis der Eingabe in der Konsole.

Siehe auch @mref{%} und @mrefdot{%%}

Beispiel:

Das Beispiel zeigt, wie die letzten 5 eingegebenen Werte mit der Funktion 
@code{%th} aufsummiert werden.

@example
(%i1) 1;2;3;4;5;
(%o1)                           1
(%o2)                           2
(%o3)                           3
(%o4)                           4
(%o5)                           5
(%i6) block (s: 0, for i:1 thru 5 do s: s + %th(i), s);
(%o6)                          15
@end example
@end deffn

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{?}
@deffn {Spezielles Symbol} ?
@ifinfo
@fnindex Erhalte Dokumentation
@end ifinfo

Wird dem Namen einer Funktion oder Variablen ein @code{?} als Pr@"afix
vorangestellt, wird der Name als ein Lisp-Symbol interpretiert.  Zum Beispiel 
bedeutet @code{?round} die Lisp-Funktion @code{ROUND}.  Siehe
@ref{Lisp und Maxima} f@"ur weitere Ausf@"uhrungen zu diesem Thema.

Die Eingabe @code{? word} ist eine Kurzschreibweise f@"ur das Kommando 
@code{describe("word")}.  Das Fragezeichen muss am Anfang einer Eingabezeile 
stehen, damit Maxima die Eingabe als eine Anfrage nach der Dokumentation
interpretiert.  Siehe auch @mrefdot{describe}
@end deffn

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{??}
@deffn {Spezielles Symbol} ??
@ifinfo
@fnindex Erhalte Dokumentation (ungenaue Suche)
@end ifinfo

Die Eingabe @code{?? word} ist eine Kurzschreibweise f@"ur das Kommando 
@code{describe("word", inexact)}.  Die Fragezeichen m@"ussen am Anfang einer 
Eingabezeile stehen, damit Maxima die Eingabe als eine Anfrage nach der 
Dokumentation interpretiert.  Siehe auch @mrefdot{describe}
@end deffn

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{inchar}
@need 1000
@defvr {Optionsvariable} inchar
Standardwert: @code{%i}

Die Optionsvariable @code{inchar} enth@"alt den Pr@"afix der Eingabemarken.
Maxima erzeugt die Eingabemarken automatisch aus dem Pr@"afix @code{inchar} und
der Zeilennummer @mrefdot{linenum}

Der Optionsvariablen @code{inchar} kann eine Zeichenkette oder ein Symbol 
zugewiesen werden, die auch mehr als ein Zeichen haben k@"onnen.  Da Maxima 
intern nur das erste Zeichen ber@"ucksichtigt, sollten sich die Pr@"afixe
@code{inchar}, @code{outchar} und @code{linechar} im ersten Zeichen voneinander
unterscheiden.  Ansonsten funktionieren einige Kommandos wie zum Beispiel 
@code{kill(inlabels)} nicht wie erwartet.

Siehe auch die Funktion und Systemvariable @mref{labels} sowie die
Optionsvariablen @mref{outchar} und @mrefdot{linechar}

Beispiele:

@example
(%i1) inchar: "input";
(%o1)                         input
(input2) expand((a+b)^3);
                     3        2      2      3
(%o2)               b  + 3 a b  + 3 a  b + a
(input3)
@end example
@end defvr

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{infolists}
@defvr {Systemvariable} infolists

Die Systemvariable @code{infolists} enth@"alt eine Liste der Informationslisten,
die Maxima zur Verf@"ugung stellt.  Diese sind:

@table @code
@item labels
Enth@"alt die Marken @code{%i}, @code{%o} und @code{%t}, denen bisher ein 
Ausdruck zugewiesen wurde.

@item values
Enth@"alt die vom Nutzer mit den Operatoren @mref{:} oder @mref{::} definierten
Variablen.

@item functions
Enth@"alt die vom Nutzer mit dem Operator @mref{:=} oder der Funktion
@mref{define} definierten Funktionen.

@item arrays
Enth@"alt die mit den Operatoren @code{:}, @code{::} oder @code{:=} definierten
Arrays oder Array-Funktionen.

@item macros
Enth@"alt die vom Nutzer mit dem Operator @mref{::=} definierten Makros.

@item myoptions
Enth@"alt die Optionsvariablen, die vom Nutzer bisher einen neuen Wert erhalten
haben.

@item rules
Enth@"alt die vom Nutzer mit den Funktionen @mrefcomma{tellsimp}@w{}
@mrefcomma{tellsimpafter} @mref{defmatch} oder @mref{defrule}@w{}
definierten Regeln.

@item aliases
Enth@"alt die Symbole, die einen vom Nutzer definierten Alias-Namen mit der
Funktion @mref{alias} erhalten haben.  Weiterhin erzeugen die Funktionen
@mref{ordergreat} und @mref{orderless} sowie eine Deklaration als
@mref{noun} mit der Funktion @mref{declare} Alias-Namen, die in die Liste
eingetragen werden.

@item dependencies
Enth@"alt alle Symbole, f@"ur die mit den Funktionen @mref{depends} oder
@mref{gradef} eine Abh@"angigkeit definiert ist.

@item gradefs
Enth@"alt die Funktionen, f@"ur die der Nutzer mit der Funktion
@mref{gradef} eine Ableitung definiert hat.

@item props
Enth@"alt die Symbole, die eine Eigenschaft mit der Funktion
@mref{declare} erhalten haben.

@item let_rule_packages
Enth@"alt die vom Nutzer definierten @mref{let}-Regeln.

@c TODO: BESCHREIBUNG DER LISTE STRUCTURES FEHLT.

@end table
@end defvr

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{kill}
@deffn  {Funktion} kill (@var{a_1}, @dots{}, @var{a_n})
@deffnx {Funktion} kill (labels)
@deffnx {Funktion} kill (inlabels, outlabels, linelabels)
@deffnx {Funktion} kill (@var{n})
@deffnx {Funktion} kill ([@var{m}, @var{n}])
@deffnx {Funktion} kill (values, functions, arrays, @dots{})
@deffnx {Funktion} kill (all)
@deffnx {Funktion} kill (allbut (@var{a_1}, @dots{}, @var{a_n}))

Die Funktion @code{kill} entfernt alle Zuweisungen (Werte, Funktionen, Arrays 
oder Regeln) und Eigenschaften von den Argumenten @var{a_1}, @dots{}, @var{a_n}.
Ein Argument @var{a_k} kann ein Symbol oder ein einzelnes Array-Element sein.
Ist @var{a_k} ein einzelnes Array-Element, entfernt @code{kill} die Zuweisungen
an dieses Element, ohne die anderen Elemente des Arrays zu beeinflussen.

@code{kill} kennt verschiedene spezielle Argumente, die auch kombiniert werden 
k@"onnen wie zum Beispiel @code{kill(inlabels, functions, allbut(foo, bar))}.

@code{kill(labels)} entfernt alle Zuweisungen an Eingabe-, Ausgabe- und 
Zwischenmarken.  @code{kill(inlabels)} entfernt nur die Zuweisungen an 
Eingabemarken, die mit dem aktuellen Wert von @mref{inchar} beginnen.
Entsprechend entfernt @code{kill(outlabels)} die Zuweisungen an die 
Ausgabemarken, die mit dem aktuellen Wert von @mref{outchar} beginnen und
@code{kill(linelabels)} die Zuweisungen an die Zwischenmarken, die mit dem
aktuellen Wert von @mref{linechar} beginnen.

@code{kill(@var{n})}, wobei @var{n} eine ganze Zahl ist, entfernt die 
Zuweisungen an die @var{n} letzten Eingabe- und Ausgabemarken.
@code{kill([@var{m}, @var{n}])} entfernt die Zuweisungen an die Eingabe- und 
Ausgabemarken mit den Nummern von @var{m} bis @var{n}.

@code{kill(@var{infolist})}, wobei @var{infolist} eine Informationsliste wie zum
Beispiel @mrefcomma{values} @mref{functions} oder @mref{arrays} ist, entfernt
die Zuweisungen an allen Eintr@"agen der Liste @var{infolist}.  Siehe auch
@mrefdot{infolists}

@code{kill(all)} entfernt die Zuweisungen an die Eintr@"age in s@"amtlichen
Informationslisten.  @code{kill(all)} setzt keine Optionsvariablen auf ihre
Standardwerte zur@"uck.  Siehe die Funktion @mrefcomma{reset} um
Optionsvariablen auf ihre Standwerte zur@"uckzusetzen.

@code{kill(allbut(@var{a_1}, ..., @var{a_n}))} entfernt alle Zuweisungen bis 
auf Zuweisungen an die Variablen @var{a_1}, @dots{}, @var{a_n}.
@code{kill(allbut(@var{infolist}))} entfernt alle Zuweisungen bis auf denen in 
der Informationsliste @var{infolist}.

@code{kill(@var{symbol})} entfernt s@"amtliche Zuweisungen und Eigenschaften
des Symbols @w{@var{symbol}}.  Im Gegensatz dazu entfernen
@mrefcomma{remvalue} @mrefcomma{remfunction} @mref{remarray} und
@mref{remrule} jeweils eine spezielle Eigenschaft eines Symbols.

@code{kill} wertet die Argumente nicht aus.  Der
@nxref{'', Quote-Quote-Operator} @code{''} kann die Auswertung erzwingen.
@code{kill} gibt immer @code{done} zur@"uck.
@end deffn

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{labels}
@deffn  {Funktion} labels (@var{symbol})
@deffnx {Systemvariable} labels

Die Funktion @code{labels} gibt eine Liste der Eingabe-, Ausgabe- und 
Zwischenmarken zur@"uck, die mit dem Argument @var{symbol} beginnen.
Typischerweise ist @var{symbol} der Wert von
@mrefcomma{inchar} @mref{outchar} oder @mrefdot{linechar}  Dabei kann das
Prozentzeichen fortgelassen werden.  So haben zum Beispiel die Kommandos
@code{labels(i)} und @code{labels(%i)} dasselbe Ergebnis.

Wenn keine Marke mit @var{symbol} beginnt, gibt @code{labels} eine leere Liste 
zur@"uck.

Die Funktion @code{labels} wertet das Argument nicht aus.  Mit dem
@nxref{'', Quote-Quote-Operator} @code{''} kann die Auswertung erzwungen
werden.  Zum Beispiel gibt das Kommando @code{labels(''inchar)} die Marken
zur@"uck, die mit dem aktuellen Buchstaben f@"ur die Eingabemarken beginnen.

Die Systemvariable @code{labels} ist eine Informationsliste, die die Eingabe-, 
Ausgabe- und Zwischenmarken enth@"alt.  In der Liste sind auch die Marken
enthalten, die vor einer @"Anderung von @code{inchar}, @code{outchar} oder 
@code{linechar} erzeugt wurden.

Standardm@"a@ss{}ig zeigt Maxima das Ergebnis jeder Eingabe an, wobei dem
Ergebnis eine Ausgabemarke hinzugef@"ugt wird.  Die Anzeige der Ausgabe wird
durch die Eingabe eines abschlie@ss{}enden @mref{$} (Dollarzeichen) statt eines
@mref{;} (Semikolon) unterdr@"uckt.  Dabei wird eine Ausgabemarke erzeugt und
das Ergebnis zugewiesen, jedoch nicht angezeigt.  Die Marke kann aber in der 
gleichen Art und Weise wie bei angezeigten Ausgabemarken referenziert werden.
Siehe auch @mrefcomma{%} @mref{%%} und @mrefdot{%th}

Einige Funktionen erzeugen Zwischenmarken.  Die Optionsvariable 
@mref{programmode} kontrolliert, ob zum Beispiel @mref{solve} und einige andere
Funktionen Zwischenmarken erzeugen, anstatt eine Liste von Ausdr@"ucken 
zur@"uckzugeben.  Andere Funktionen wie zum Beispiel @mref{ldisplay} erzeugen
stets Zwischenmarken.

Siehe auch @mrefdot{infolists}
@end deffn

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{linechar}
@defvr {Optionsvariable} linechar
Standardwert: @code{%t}

Die Optionsvariable @code{linechar} enth@"alt den Pr@"afix der Zwischenmarken.
Maxima generiert die Zwischenmarken automatisch aus @code{linechar}.

Der Optionsvariablen @code{linechar} kann eine Zeichenkette oder ein Symbol 
zugewiesen werden, die auch mehr als ein Zeichen haben k@"onnen.  Da Maxima 
intern nur das erste Zeichen ber@"ucksichtigt, sollten sich die Pr@"afixe 
@mrefcomma{inchar} @mref{outchar} und @code{linechar} im ersten Zeichen
voneinander unterscheiden.  Ansonsten funktionieren einige Kommandos wie
@code{kill(inlabels)} nicht wie erwartet.

Die Ausgabe von Zwischenmarken kann mit verschiedenen Optionsvariablen 
kontrolliert werden.  Siehe @mref{programmode} und @mrefdot{labels}
@end defvr

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{linenum}
@defvr {Systemvariable} linenum

Enth@"alt die Zeilennummer der aktuellen Ein- und Ausgabemarken.  Die
Zeilennummer wird von Maxima automatisch erh@"oht.  Siehe auch
@mrefcomma{labels} @mref{inchar} und @mrefdot{outchar}
@end defvr

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{myoptions}
@defvr {Systemvariable} myoptions

@code{myoptions} ist eine Informationsliste, die die Optionsvariablen enth@"alt,
die vom Nutzer w@"ahrend einer Sitzung ge@"andert wurden.  Die Variable 
verbleibt in der Liste, auch wenn sie wieder auf den Standardwert
zur@"uckgesetzt wird.
@end defvr

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{nolabels}
@defvr {Optionsvariable} nolabels
Standardwert: @code{false}

Hat @code{nolabels} den Wert @code{true}, werden die Eingabe- und Ausgabemarken 
zwar angezeigt, ihnen werden aber keine Eingaben und Ergebnisse zugewiesen und
sie werden nicht der Informationsliste @code{labels} hinzugef@"ugt.  Andernfalls
werden den Marken die Eingabe und die Ergebnisse zugewiesen und in die
Informationsliste @code{labels} eingetragen.

Zwischenmarken @code{%t} werden durch @code{nolabels} nicht beeinflusst.  Den
Marken werden unabh@"angig vom Wert, den @code{nolabels} hat, Zwischenergebnisse
zugewiesen und sie werden in die Informationsliste @code{labels} eingetragen.

Siehe auch @mrefdot{labels}
@end defvr

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{optionset}
@defvr {Optionsvariable} optionset
Standardwert: @code{false}

Hat @code{optionset} den Wert @code{true}, gibt Maxima eine Meldung aus, wenn 
einer Optionsvariablen ein Wert zugewiesen wird.

Beispiel:

@example
(%i1) optionset:true;
assignment: assigning to option optionset
(%o1)                         true
(%i2) gamma_expand:true;
assignment: assigning to option gamma_expand
(%o2)                         true
@end example
@end defvr

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{outchar}
@defvr {Optionsvariable} outchar
Standardwert: @code{%o}

Die Optionsvariable @code{outchar} enth@"alt den Pr@"afix der Ausgabemarken.
Maxima generiert die Ausgabemarken automatisch aus @code{outchar} und 
@mrefdot{linenum}

Der Optionsvariablen @code{outchar} kann eine Zeichenkette oder ein Symbol 
zugewiesen werden, die auch mehr als ein Zeichen haben k@"onnen.  Da Maxima 
intern nur das erste Zeichen ber@"ucksichtigt, sollten sich die Pr@"afixe 
@mrefcomma{inchar} @code{outchar} und @mref{linechar} im ersten Zeichen
voneinander unterscheiden.  Ansonsten funktionieren einige Kommandos wie
@code{kill(inlabels)} nicht wie erwartet.

Siehe auch @mrefdot{labels}

Beispiele:

@example
(%i1) outchar: "output";
(output1)                    output
(%i2) expand((a+b)^3);
                     3        2      2      3
(output2)           b  + 3 a b  + 3 a  b + a
(%i3) 
@end example
@end defvr

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{playback}
@deffn  {Funktion} playback ()
@deffnx {Funktion} playback (@var{n})
@deffnx {Funktion} playback ([@var{m}, @var{n}])
@deffnx {Funktion} playback ([@var{m}])
@deffnx {Funktion} playback (input)
@deffnx {Funktion} playback (slow)
@deffnx {Funktion} playback (time)
@deffnx {Funktion} playback (grind)

Zeigt Eingaben, Ergebnisse und Zwischenergebnisse an, ohne diese neu zu 
berechnen.  @code{playback} zeigt nur die Eingaben und Ergebnisse an, die Marken
zugewiesen wurden.  Andere Ausgaben, wie zum Beispiel durch
@mrefcomma{print} @mref{describe} oder Fehlermeldungen, werden nicht angezeigt.
Siehe auch @mrefdot{labels}

@code{playback()} zeigt s@"amtliche Eingaben und Ergebnisse an, die bis dahin
erzeugt wurden.  Ein Ergebnis wird auch dann angezeigt, wenn die Ausgabe mit 
@mref{$} unterdr@"uckt war.

@code{playback(@var{n})} zeigt die letzten @var{n} Ausdr@"ucke an.  Jeder 
Eingabe-, Ausgabe- und Zwischenausdruck z@"ahlt dabei als ein Ausdruck.
@code{playback([@var{m}, @var{n}])} zeigt die Eingabe-, Ausgabe- und 
Zwischenausdr@"ucke mit den Zahlen von @var{m} bis einschlie@ss{}lich @var{n} 
an.  @code{playback([@var{m}])} ist @"aquivalent zu @code{playback([@var{m}, 
@var{m}])}.  Die Ausgabe ist ein Paar von Ein- und Ausgabeausdr@"ucken.

@code{playback(input)} zeigt s@"amtliche Eingabeausdr@"ucke an, die bis dahin 
erzeugt wurden.

@code{playback(slow)} macht nach jeder Ausgabe eine Pause und wartet auf eine
Eingabe.  Dieses Verhalten ist vergleichbar mit der Funktion @mrefdot{demo}

@code{playback(time)} zeigt f@"ur jeden Ausdruck die f@"ur die Berechnung
ben@"otigte Zeit an.

@code{playback(grind)} zeigt die Eingabeausdr@"ucke in dem gleichen Format an,
wie die Funktion @code{grind}.  Ausgabeausdr@"ucke werden von der Option
@code{grind} nicht beeinflusst.  Siehe auch @mrefdot{grind}

Die Argumente k@"onnen kombiniert werden, wie zum Beispiel im folgenden
Kommando @code{playback([5, 10], grind, time, slow)}.

@code{playback} wertet die Argumente nicht aus.  @code{playback} gibt stets 
@code{done} zur@"uck.
@end deffn

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{prompt}
@defvr {Optionsvariable} prompt
Standardwert: @code{_}

Die Optionsvariable @code{prompt} enth@"alt das Zeichen f@"ur die
Eingabeaufforderung der Funktionen @mref{demo} und @mref{playback} sowie
nach einer Unterbrechung, wie zum Beispiel durch das Kommando @mrefdot{break}
@end defvr

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{quit}
@deffn {Funktion} quit ()

Das Kommando @code{quit()} beendet eine Maxima-Sitzung.

Mit der Tastatureingabe @kbd{control-c} oder @code{Strg-c} kann in der Konsole
die Verarbeitung abgebrochen werden.  Stan@-dard@-m@"a@ss{}ig wird die
Maxima-Sitzung fortgesetzt.  Hat die globale Lisp-Variable
@code{*debugger-hook*} den Wert @code{nil}, wird der Lisp-Debugger gestartet.
Siehe @ref{Fehlersuche}.
@end deffn

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{read}
@deffn {Funktion} read (@var{expr_1}, @dots{}, @var{expr_n})

Gibt die Ausdr@"ucke @var{expr_1}, @dots{} @var{expr_n} auf der Konsole aus, 
liest sodann einen Ausdruck von der Konsole ein und wertet diesen aus.  Die 
Eingabe des Ausdrucks wird mit den Zeichen @mref{;} oder @mref{$} beendet.

Siehe auch @mrefdot{readonly}

Beispiele:

@example
(%i1) foo: 42$ 
(%i2) foo: read ("foo is", foo, " -- enter new value.")$
foo is 42  -- enter new value.
(a+b)^3;
(%i3) foo;
                                     3
(%o3)                         (b + a)
@end example
@end deffn

@c --- 28.08.2010 DK -----------------------------------------------------------
@anchor{readonly}
@deffn {Funktion} readonly (@var{expr_1}, @dots{}, @var{expr_n})
 
Gibt die Ausdr@"ucke @var{expr_1}, @dots{} @var{expr_n} auf der Konsole aus, 
liest sodann einen Ausdruck von der Konsole ein und gibt den eingelesenen 
Ausdruck zur@"uck ohne diesen auszuwerten.  Die Eingabe des Ausdrucks wird mit 
den Zeichen @mref{;} oder @mref{$} beendet.

Siehe auch @mrefdot{read}

Beispiele:

@example
(%i1) aa: 7$
(%i2) foo: readonly ("Enter an expression:");
Enter an expression: 
2^aa;
                                  aa
(%o2)                            2
(%i3) foo: read ("Enter an expression:");
Enter an expression: 
2^aa;
(%o3)                            128
@end example
@end deffn

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{reset}
@deffn {Funktion} reset ()

@code{reset()} setzt globale Maxima- und Lisp-Variablen und Optionen auf ihre 
Standardwerte zur@"uck.  Maxima legt eine interne Liste mit den Standardwerten 
von globalen Variablen an.  Alle Variablen, die in dieser Liste enthalten sind, 
werden auf ihre Standardwerte zur@"uckgesetzt.  Nicht alle globalen Variablen 
sind mit ihren Standwerten in diese Liste eingetragen.  Daher kann @code{reset} 
die Anfangswerte stets nur unvollst@"andig wiederherstellen.

@code{reset(@var{arg_1, ..., arg_n})} setzt die Variablen @var{arg_1}, @dots{}, 
@var{arg_n} auf ihren Standardwert zur@"uck.

@code{reset} gibt eine Liste mit den Variablen zur@"uck, die auf ihren
Standardwert zur@"uckgesetzt wurden.  Ist die Liste leer, wurden keine Variablen
zur@"uckgesetzt.

Siehe auch @mrefdot{reset_verbosely}
@end deffn

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{reset_verbosely}
@deffn  {Funktion} reset_verbosely ()
@deffnx {Funktion} reset_verbosely (@var{arg_1}, @dots{}, @var{arg_n})

Entspricht der Funktion @code{reset}.  Im Unterschied zu @code{reset} wird zu
jeder Variable, die zur@"uckgesetzt wird, zus@"atzlich der Standardwert
angezeigt.

Siehe @mrefdot{reset}
@end deffn

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{showtime}
@defvr {Optionsvariable} showtime
Standardwert: @code{false}

Hat @code{showtime} den Wert @code{true}, werden die interne Rechenzeit und die 
gesamte verstrichene Zeit zu jeder Ausgabe angezeigt.

Die Rechenzeit wird unabh@"angig vom Wert der Optionsvariablen @code{showtime}
nach jeder Auswertung eines Ausdruckes in den Ausgabemarken abgespeichert.
Daher k@"onnen die Funktionen @mref{time} und @mref{playback} die Rechenzeit
auch dann anzeigen, wenn @code{showtime} den Wert @code{false} hat.

Siehe auch @mrefdot{timer}
@end defvr

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{to_lisp}
@deffn {Funktion} to_lisp ()

Wechselt zu einer Lisp-Sitzung.  @code{(to-maxima)} wechselt von der 
Lisp-Sitzung zur@"uck in die Maxima-Sitzung.

Beispiel:

Definiere eine Funktion und wechsle zu Lisp.  Die Definition wird von der 
Eigenschaftsliste gelesen.  Dann wird die Definition der Funktion geholt, 
faktorisiert und in der Variablen @code{$result} gespeichert.  Die Variable 
kann nach der R@"uckkehr in Maxima genutzt werden.

@example
(%i1) f(x):=x^2+x;
                                  2
(%o1)                    f(x) := x  + x
(%i2) to_lisp();
Type (to-maxima) to restart, ($quit) to quit Maxima.
MAXIMA> (symbol-plist '$f)
(MPROPS (NIL MEXPR ((LAMBDA) ((MLIST) $X) 
                             ((MPLUS) ((MEXPT) $X 2) $X))))
MAXIMA> (setq $result ($factor (caddr (mget '$f 'mexpr))))
((MTIMES SIMP FACTORED) $X ((MPLUS SIMP IRREDUCIBLE) 1 $X))
MAXIMA> (to-maxima)
Returning to Maxima
(%o2)                         true
(%i3) result;
(%o3)                       x (x + 1)
@end example
@end deffn

@c --- 08.09.2010 DK -----------------------------------------------------------
@anchor{values}
@defvr {Systemvariable} values
Anfangswert: @code{[]}

@code{values} ist eine Informationsliste, die die Variablen enth@"alt, die vom
Nutzer mit den Operatoren @mref{:} oder @mref{::} einen Wert erhalten haben.
Wird der Wert einer Variablen mit den Kommandos @mrefcomma{kill}@w{}
@mref{remove} oder @mref{remvalue} entfernt, wird die Variable von der Liste
@code{values} entfernt.

Siehe auch @mref{functions} f@"ur die Informationsliste mit den vom Nutzer 
definierten Funktionen sowie @mrefdot{infolists}

Beispiele:

@c TODO: DAS FOLGENDE IST NICHT UEBERSETZT.

@c First, @code{values} shows the symbols @code{a}, @code{b}, and @code{c}, but 
@c not @code{d}, it is not bound to a value, and not the user function @code{f}.
@c The values are removed from the variables. @code{values} is the empty list.

@example
(%i1) [a:99, b::a-90, c:a-b, d, f(x):= x^2];
                                           2
(%o1)              [99, 9, 90, d, f(x) := x ]
(%i2) values;
(%o2)                       [a, b, c]
(%i3) [kill(a), remove(b,value), remvalue(c)];
(%o3)                   [done, done, [c]]
(%i4) values;
(%o4)                          []
@end example
@end defvr

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen der Ausgabe, , Funktionen und Variablen der Eingabe, Kommandozeile
@section Funktionen und Variablen der Ausgabe
@c -----------------------------------------------------------------------------

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{%edispflag}
@defvr {Optionsvariable} %edispflag
Standardwert: @code{false}

Hat @code{%edispflag} den Wert @code{true}, zeigt Maxima die Exponentiation von
@mref{%e} mit einem negativen Exponenten als Quotienten an.  Siehe auch die
Optionsvariable @mrefdot{exptdispflag}

Beispiel:

@example
(%i1) %e^-10;
                               - 10
(%o1)                        %e
(%i2) %edispflag:true$
(%i3) %e^-10;
                               1
(%o3)                         ----
                                10
                              %e
@end example
@end defvr

@c --- 28.08.2010 --------------------------------------------------------------
@anchor{absboxchar}
@defvr {Optionsvariable} absboxchar
Standardwert: @code{!}

Die Optionsvariable @code{absboxchar} enth@"alt das Zeichen, das von Maxima
benutzt wird, um den Betrag eines Ausdruckes anzuzeigen, der mehr als eine
Zeile ben@"otigt.

Beispiel:

@example
(%i1) abs((x^3+1));
                            ! 3    !
(%o1)                       !x  + 1!
@end example
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{disp}
@deffn {Funktion} disp (@var{expr_1}, @var{expr_2}, @dots{})

Ist @"ahnlich wie die Funktion @mrefdot{display}  Die Funktion @code{disp}
zeigt jedoch keine Gleichungen sondern nur die Ergebnisse der Ausdr@"ucke
@var{expr_1}, @var{expr_2}, @dots{} an.

Siehe auch die Funktionen @mrefcomma{ldisp} @mref{display} und @mrefdot{print}

Beispiele:

@example
(%i1) b[1,2]:x-x^2$
(%i2) x:123$
(%i3) disp(x, b[1,2], sin(1.0));
                               123

                                  2
                             x - x

                        .8414709848078965

(%o3)                         done
@end example
@end deffn

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{display}
@deffn {Funktion} display (@var{expr_1}, @var{expr_2}, @dots{})

Die Variablen oder Ausdr@"ucke @var{expr_i} werden als eine Gleichung 
ausgegeben.  Die linke Seite der Gleichung ist die Variable oder der Ausdruck 
@var{expr_i} und die rechte Seite der Wert der Variablen oder das Ergebnis des 
Ausdrucks.  Die Argumente k@"onnen Variable, indizierte Variable oder Funktionen
sein.

Siehe auch die Funktionen @mrefcomma{ldisplay} @mref{disp} und @mrefdot{ldisp}

Beispiele:

@example
(%i1) b[1,2]:x-x^2$
(%i2) x:123$
(%i3) display(x, b[1,2], sin(1.0));
                             x = 123

                                      2
                         b     = x - x
                          1, 2

                  sin(1.0) = .8414709848078965

(%o3)                         done
@end example
@end deffn

@c --- 10.08.2010 DK -----------------------------------------------------------
@anchor{display2d}
@defvr {Optionsvariable} display2d
Standardwert: @code{true}

Hat @code{display2d} den Wert @code{false}, werden Ausdr@"ucke auf der Konsole
linear und nicht zweidimensional angezeigt.

Siehe auch die Optionsvariable @mrefcomma{leftjust} um Formeln linksb@"undig
auszugeben.

Beispiel:

@example
(%i1) x/(x^2+1);
                               x
(%o1)                        ------
                              2
                             x  + 1
(%i2) display2d:false$
(%i3) x/(x^2+1);
(%o3) x/(x^2+1)
@end example
@end defvr

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{display_format_internal}
@defvr {Optionsvariable} display_format_internal
Standardwert: @code{false}

Hat @code{display_format_internal} den Wert @code{true}, werden Ausdr@"ucke 
f@"ur die Anzeige nicht in die externe Darstellung transformiert.  Die Ausgabe 
erfolgt wie in der internen Darstellung.  Das entspricht der R@"uckgabe der 
Funktion @mrefdot{inpart}

Siehe die Funktion @mref{dispform} f@"ur Beispiele, die den Unterschied zwischen
der internen und der externen Darstellung zeigen.
@end defvr

@c --- 23.10.2010 --------------------------------------------------------------
@anchor{dispterms}
@deffn {Funktion} dispterms (@var{expr})

Der Ausdruck @var{expr} wird zeilenweise ausgegeben.  Auf der ersten Zeile wird
der Operator des Ausdrucks @var{expr} ausgegeben.  Dann werden die Argumente des
Operators zeilenweise ausgegeben.  Dies kann n@"utzlich sein, wenn ein Ausdruck 
sehr lang ist.

Beispiel:

@example
(%i1) dispterms(2*a*sin(x)+%e^x);

+

2 a sin(x)

  x
%e

(%o1)                         done
@end example
@end deffn

@c --- 23.10.2010 --------------------------------------------------------------
@anchor{expt}
@anchor{ncexpt}
@defvr  {Spezielles Symbol} expt (@var{a}, @var{b})
@defvrx {Spezielles Symbol} ncexpt (@var{a}, @var{b})

Ist ein Exponentialausdruck zu lang, um ihn als @code{@var{a}^@var{b}} 
anzuzeigen, wird stattdessen @code{expt(@var{a}, @var{b})} angezeigt.
Entsprechend wird statt @code{@var{a}^^@var{b}}, @code{ncexpt(@var{a}, @var{b})}
angezeigt.  @code{expt} und @code{ncexpt} sind keine Funktionen und erscheinen 
nur in der Ausgabe.
@end defvr

@c --- 21.08.2010 --------------------------------------------------------------
@anchor{exptdispflag}
@defvr {Optionsvariable} exptdispflag
Standardwert: @code{true}

Hat die Optionsvariable @code{exptdispflag} den Wert @code{true}, werden
Ausdr@"ucke mit einem negativen Exponenten als Quotient angezeigt.  Siehe auch
die Optionsvariable @mrefdot{%edispflag}

Beispiele:

@example
(%i1) exptdispflag:true;
(%o1)                         true
(%i2) 10^-x;
                                1
(%o2)                          ---
                                 x
                               10
(%i3) exptdispflag:false;
(%o3)                         false
(%i4) 10^-x;
                                - x
(%o4)                         10
@end example
@end defvr

@c --- 28.08.2010 DK -----------------------------------------------------------
@anchor{grind}
@deffn {Funktion} grind (@var{expr})
@deffnx {Optionsvariable} grind

Die Funktion @code{grind} gibt den Ausdruck @var{expr} auf der Konsole in einer
Form aus, die f@"ur die Eingabe in Maxima geeignet ist.  @code{grind} gibt 
@code{done} zur@"uck.

Ist @var{expr} der Name einer Funktion oder eines Makros, gibt @code{grind}
die Definition der Funktion oder des Makros aus.

Siehe auch die Funktion @mrefcomma{string} die einen Ausdruck als eine
Zeichenkette zur@"uckgibt.

Hat die Optionsvariable @code{grind} den Wert @code{true}, haben die Ergebnisse
der Funktionen @mref{stringout} und @code{string} dasselbe Format wie die 
Funktion @code{grind}.  Ansonsten werden keine spezielle Formatierungen
von diesen Funktionen vorgenommen.  Der Standardwert der Optionsvariablen
@code{grind} ist @code{false}.

@code{grind} kann auch ein Argument der Funktion @mref{playback} sein.  In
diesem Fall gibt @code{playback} die Eingabe im gleichen Format wie die Funktion
@code{grind} aus.

@code{grind} wertet das Argument aus.

Beispiele:

@example
(%i1) aa + 1729;
(%o1)                       aa + 1729
(%i2) grind (%);
aa+1729$
(%o2)                         done
(%i3) [aa, 1729, aa + 1729];
(%o3)                 [aa, 1729, aa + 1729]
(%i4) grind (%);
[aa,1729,aa+1729]$
(%o4)                         done
(%i5) matrix ([aa, 17], [29, bb]);
                           [ aa  17 ]
(%o5)                      [        ]
                           [ 29  bb ]
(%i6) grind (%);
matrix([aa,17],[29,bb])$
(%o6)                         done
(%i7) set (aa, 17, 29, bb);
(%o7)                   @{17, 29, aa, bb@}
(%i8) grind (%);
@{17,29,aa,bb@}$
(%o8)                         done
(%i9) exp (aa / (bb + 17)^29);
@group
                                aa
                            -----------
                                     29
                            (bb + 17)
(%o9)                     %e
@end group
(%i10) grind (%);
%e^(aa/(bb+17)^29)$
(%o10)                        done
(%i11) expr: expand ((aa + bb)^10);
@group
         10           9        2   8         3   7         4   6
(%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
         5   5         6   4         7   3        8   2
 + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
        9        10
 + 10 aa  bb + aa
@end group
(%i12) grind (expr);
@group
bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
     +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
     +10*aa^9*bb+aa^10$
(%o12)                        done
@end group
(%i13) string (expr);
(%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
+252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
bb+aa^10
@end example
@end deffn

@c --- 28.08.2010 DK -----------------------------------------------------------
@anchor{ibase}
@defvr {Optionsvariable} ibase
Standardwert: @code{10}

@code{ibase} enth@"alt die Basis der ganzen Zahlen, welche von Maxima eingelesen
werden.

@code{ibase} kann eine ganze Zahl zwischen 2 und einschlie@ss{}lich 36 
zugewiesen werden.  Ist @code{ibase} gr@"o@ss{}er als 10, werden die Zahlen 0 
bis 9 und die Buchstaben A, B, C, @dots{} f@"ur die Darstellung der Zahl in der 
Basis @code{ibase} herangezogen.  Gro@ss{}e und kleine Buchstaben werden nicht 
unterschieden.  Die erste Stelle muss immer eine Ziffer sein, damit Maxima den 
eingelesenen Ausdruck als eine Zahl interpretiert.

Gleitkommazahlen werden immer zur Basis 10 interpretiert.

Siehe auch @mrefdot{obase}

Beispiele:

@code{ibase} ist kleiner als 10.

@example
(%i1) ibase : 2 $
(%i2) obase;
(%o2)                          10
(%i3) 1111111111111111;
(%o3)                         65535
@end example

@code{ibase} ist gr@"o@ss{}er als 10.  Die erste Stelle muss eine Ziffer sein.

@example
(%i1) ibase : 16 $
(%i2) obase;
(%o2)                          10
(%i3) 1000;
(%o3)                         4096
(%i4) abcd;
(%o4)                         abcd
(%i5) symbolp (abcd);
(%o5)                         true
(%i6) 0abcd;
(%o6)                         43981
(%i7) symbolp (0abcd);
(%o7)                         false
@end example

Wird eine ganze Zahl mit einem Dezimalpunkt beendet, wird die Zahl als 
Gleitkommazahl interpretiert.

@example
(%i1) ibase : 36 $
(%i2) obase;
(%o2)                          10
(%i3) 1234;
(%o3)                         49360
(%i4) 1234.;
(%o4)                         1234
@end example
@end defvr

@c --- 23.10.2010 --------------------------------------------------------------
@anchor{ldisp}
@deffn {Funktion} ldisp (@var{expr_1}, @dots{}, @var{expr_n})

Die Ausdr@"ucke @var{expr_1}, @dots{}, @var{expr_n} werden auf der Konsole 
ausgegeben.  Dabei wird jedem Ausdruck eine Zwischenmarke zugewiesen.  Die Liste
der Zwischenmarken wird als Ergebnis zur@"uckgegeben.

Siehe auch die Funktionen @mrefcomma{disp} @mref{display} und @mrefdot{ldisplay}

@example
@group
(%i1) e: (a+b)^3;
                                   3
(%o1)                       (b + a)
@end group
(%i2) f: expand (e);
                     3        2      2      3
(%o2)               b  + 3 a b  + 3 a  b + a
(%i3) ldisp (e, f);
                                   3
(%t3)                       (b + a)

                     3        2      2      3
(%t4)               b  + 3 a b  + 3 a  b + a

(%o4)                      [%t3, %t4]
(%i4) %t3;
                                   3
(%o4)                       (b + a)
(%i5) %t4;
                     3        2      2      3
(%o5)               b  + 3 a b  + 3 a  b + a
@end example
@end deffn

@c --- 23.10.2010 --------------------------------------------------------------
@anchor{ldisplay}
@deffn {Funktion} ldisplay (@var{expr_1}, @dots{}, @var{expr_n})

Die Ausdr@"ucke @var{expr_1}, @dots{}, @var{expr_n} werden als eine Gleichung
der Form @code{lhs = rhs} ausgegeben.  @code{lhs} ist eines der Argumente der
Funktion @code{ldisplay} und @code{rhs} ist der Wert oder das Ergebnis des
Argumentes.  Im Unterschied zur Funktion @code{display} wird jeder Gleichung
eine Zwischenmarke zugewiesen, die als Liste zur@"uckgegeben werden.

Siehe auch @mrefcomma{display} @mref{disp} und @mrefdot{ldisp}

Beispiele:

@example
(%i1) e: (a+b)^3;
                                   3
(%o1)                       (b + a)
(%i2) f: expand (e);
                     3        2      2      3
(%o2)               b  + 3 a b  + 3 a  b + a
(%i3) ldisplay (e, f);
                                     3
(%t3)                     e = (b + a)

                       3        2      2      3
(%t4)             f = b  + 3 a b  + 3 a  b + a

(%o4)                      [%t3, %t4]
(%i4) %t3;
                                     3
(%o4)                     e = (b + a)
(%i5) %t4;
                       3        2      2      3
(%o5)             f = b  + 3 a b  + 3 a  b + a
@end example
@end deffn

@c --- 10.08.2011 DK -----------------------------------------------------------
@anchor{leftjust}
@defvr {Optionsvariable} leftjust
Standardwert: @code{false}

Hat die Optionsvariable @code{leftjust} den Wert @code{true}, werden Formeln
linksb@"undig und nicht zentriert ausgegeben.

Siehe auch die Optionsvariable @mrefcomma{display2d} um zwischen der 
1D- und 2D-Anzeige umzuschalten.

Beispiel:

@example
(%i1) expand((x+1)^3);
                        3      2
(%o1)                  x  + 3 x  + 3 x + 1
(%i2) leftjust:true$
(%i3) expand((x+1)^3);
       3      2
(%o3) x  + 3 x  + 3 x + 1
@end example
@end defvr

@c --- 23.10.2010 --------------------------------------------------------------
@need 800
@anchor{linel}
@defvr {Optionsvariable} linel
Standardwert: @code{79}

Die Optionsvariable @code{linel} enth@"alt die Anzahl der Zeichen einer Zeile
der Ausgabe.  @code{linel} k@"onnen beliebige positive ganze Zahlen zugewiesen
werden, wobei sehr kleine oder gro@ss{}e Werte unpraktisch sein k@"onnen.  Text,
der von internen Funktionen ausgegeben wird, wie Fehlermeldungen oder Ausgaben
der Hilfe, werden von @code{linel} nicht beeinflusst.
@end defvr

@c --- 21.08.2010 --------------------------------------------------------------
@anchor{lispdisp}
@defvr {Optionsvariable} lispdisp
Standardwert: @code{false}

Hat die Optionsvariable @code{lispdisp} den Wert @code{true}, werden 
Lisp-Symbole mit einem vorangestelltem Fragezeichen @code{?} angezeigt.

Beispiele:

@example
(%i1) lispdisp: false$
(%i2) ?foo + ?bar;
(%o2)                       foo + bar
(%i3) lispdisp: true$
(%i4) ?foo + ?bar;
(%o4)                      ?foo + ?bar
@end example
@end defvr

@c --- 23.10.2010 --------------------------------------------------------------
@anchor{negsumdispflag}
@defvr {Optionsvariable} negsumdispflag
Standardwert: @code{true}

Hat @code{negsumdispflag} den Wert @code{true}, wird eine Differenz mit zwei
Argumenten @code{x - y} als @code{x - y} und nicht als @code{-y + x} angezeigt.
Hat @code{negsumdispflag} den Wert @code{false}, wird die Differenz als
@code{-y + x} angezeigt.
@end defvr

@c --- 28.08.2010 DK -----------------------------------------------------------
@anchor{obase}
@need 800
@defvr {Optionsvariable} obase
Standardwert: @code{10}

@code{obase} enth@"alt die Basis f@"ur ganze Zahlen f@"ur die Ausgabe von
Maxima.  @code{obase} kann eine ganze Zahl zwischen 2 und einschlie@ss{}lich 36
zugewiesen werden.  Ist @code{obase} gr@"o@ss{}er als 10, werden die Zahlen 0 
bis 9 und die Buchstaben A, B, C, @dots{} f@"ur die Darstellung der Zahl in der 
Basis @code{obase} herangezogen.  Gro@ss{}e und kleine Buchstaben werden nicht 
unterschieden.  Die erste Stelle ist immer eine Ziffer.

Siehe auch @mrefdot{ibase}

Beispiele:

@example
(%i1) obase : 2;
(%o1)                          10
(%i2) 2^8 - 1;
(%o10)                      11111111
(%i3) obase : 8;
(%o3)                          10
(%i4) 8^8 - 1;
(%o4)                       77777777
(%i5) obase : 16;
(%o5)                          10
(%i6) 16^8 - 1;
(%o6)                       0FFFFFFFF
(%i7) obase : 36;
(%o7)                          10
(%i8) 36^8 - 1;
(%o8)                       0ZZZZZZZZ
@end example
@end defvr

@c --- 21.08.2010 --------------------------------------------------------------
@anchor{pfeformat}
@defvr {Optionsvariable} pfeformat
Standardwert: @code{false}

Hat die Optionsvariable @code{pfeformat} den Wert @code{true}, werden Br@"uche
mit ganzen Zahlen auf einer Zeile mit dem Zeichen @code{/} dargestellt.  Ist
der Nenner eine ganze Zahl, wird dieser als @code{1/n} vor den Ausdruck 
gestellt.

Beispiele:

@example
(%i1) pfeformat: false$
(%i2) 2^16/7^3;
                              65536
(%o2)                         -----
                               343
(%i3) (a+b)/8;
                              b + a
(%o3)                         -----
                                8
(%i4) pfeformat: true$ 
(%i5) 2^16/7^3;
(%o5)                       65536/343
(%i6) (a+b)/8;
(%o6)                      1/8 (b + a)
@end example
@end defvr

@c --- 27.01.2011 DK -----------------------------------------------------------
@anchor{powerdisp}
@defvr {Optionsvariable} powerdisp
Standardwert: @code{false}

Hat @code{powerdisp} den Wert @code{true}, werden die Terme einer Summe mit
steigender Potenz angezeigt.  Der Standardwert ist @code{false} und die Terme
werden mit fallender Potenz angezeigt.

Beispiele:

@example
(%i1) powerdisp:true;
(%o1)                         true
(%i2) x^2+x^3+x^4;
                           2    3    4
(%o2)                     x  + x  + x
(%i3) powerdisp:false;
(%o3)                         false
(%i4) x^2+x^3+x^4;
                           4    3    2
(%o4)                     x  + x  + x
@end example
@end defvr

@c --- 23.10.2010 DK -----------------------------------------------------------
@anchor{print}
@deffn {Funktion} print (@var{expr_1}, @dots{}, @var{expr_n})

Wertet die Argumente @var{expr_1}, @dots{}, @var{expr_n} nacheinander von links 
nach rechts aus und zeigt die Ergebnisse an.  @code{print} gibt das Ergebnis des 
letzten Arguments als Ergebnis zur@"uck.  @code{print} erzeugt keine 
Zwischenmarken.

Siehe auch @mrefcomma{display} @mrefcomma{disp} @mref{ldisplay} und 
@mrefdot{ldisp}  Siehe @mrefcomma{printfile} um den Inhalt einer Datei 
anzuzeigen.

Beispiele:

@example
(%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
      radcan (log (a^10/b)))$
            3        2      2      3
(a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is 

                                              10 log(a) - log(b) 
(%i2) r;
(%o2)                  10 log(a) - log(b)
(%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
      radcan (log (a^10/b)))$
                           (a+b)^3 is
@group

                     3        2      2      3
                    b  + 3 a b  + 3 a  b + a
@end group

                         log (a^10/b) is

                       10 log(a) - log(b)
@end example
@end deffn

@c --- 21.08.2010 --------------------------------------------------------------
@anchor{sqrtdispflag}
@defvr {Optionsvariable} sqrtdispflag
Standardwert: @code{true}

Hat die Optionsvariable den Wert @code{false}, wird die Wurzelfunktion als
Exponentiation mit dem Exponenten @code{1/2} angezeigt.
@end defvr

@c --- 21.08.2010 --------------------------------------------------------------
@anchor{stardisp}
@defvr {Optionsvariable} stardisp
Standardwert: @code{false}

Hat die Optionsvariable @code{stardisp} den Wert @code{true}, wird die 
Multiplikation mit einem Stern @code{*} angezeigt.
@end defvr

@c --- 21.08.2010 --------------------------------------------------------------
@anchor{ttyoff}
@defvr {Optionsvariable} ttyoff
Standardwert: @code{false}
 
Hat die Optionsvariable @code{ttyoff} den Wert @code{true}, werden Ergebnisse
nicht angezeigt.  Die Ergebnisse werden weiter berechnet und sie werden 
Marken zugewiesen.  Siehe @mrefdot{labels}

Textausgaben von Funktionen, wie Fehlermeldungen und Ausgaben der Hilfe mit
@mref{describe} werden nicht beeinflusst.
@end defvr

@c --- Ende Command.de.texi ----------------------------------------------------

