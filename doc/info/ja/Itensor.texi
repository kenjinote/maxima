@c RECOMMEND REVISE TEXT THROUGHOUT TO LOSE NOTION OF TIME RELATIVE TO PRESENT
@c LOOK FOR "NOW", "OLD", "NEW", "RECENT", "EARLIER", DATES

@c RERUN EXAMPLES WITH ADDT'L WHITESPACE IN INPUT TO AID LEGIBILITY

@menu
* Introduction to itensor::
* Functions and Variables for itensor::
@end menu

@c -----------------------------------------------------------------------------
@node Introduction to itensor, Functions and Variables for itensor, itensor, itensor
@section Introduction to itensor
@c -----------------------------------------------------------------------------

Maximaは、記号的なテンソル操作を２つの異なったタイプで実装しています:
成分テンソル操作(@code{ctensor}パッケージ)と添字テンソル操作(@code{itensor}パッケージ)。

注意せよ: 以下の'新しいテンソル表記'に関するノートを参照してください。

成分テンソル操作は、
幾何学的テンソルオブジェクトが配列または行列で表現されることを意味します。
縮約や共変微分のようなテンソル演算は実際に、
@code{do}文を伴う繰り返し用(ダミー)添字上の和によって実行されます。
すなわち、配列や行列に記憶された適切なテンソル成分上で陽に演算を実行します。

添字テンソル操作は、
共変、反変、そして微分添字の関数としてテンソルを表現することで実装されています。
縮約や共変微分のようなテンソル演算は、
対応する成分よりむしろ添字それ自身を操作することで実行されます。

Riemann幾何の文脈での微分的、代数的、解析的処理へのこれらの２つのアプローチは、
ユーザーの問題の個々の性質と難しさを通してだけ明らかにされる様々な利点と欠点を持ちます。
しかしながら、２つの実装の以下の特性を心にとどめて置くべきです:

成分を陽に使ったテンソルとテンソル演算の表現は、
@code{ctensor}を使いやすくします。
軽量の指定と、帰納されたテンソルと不変量の計算は容易です。
Maximaの強力な整理能力すべてはいつでも使えますが、
入り組んだ関数的、座標依存性を持つ複雑な計量は、簡単に、サイズが極端で、構造が隠された式に
至ります。
さらに、たくさんの計算は、増大する中間式を含み、プログラムが完了前に終了する原因となります。
経験を通して、ユーザーはこれらの難しさの多くを避けることができます。

テンソルとテンソル演算が添字上の記号演算を使って表される特別な方法のために、
成分表現では処理できなかった式が、時々、
@code{itensor}の中の対称オブジェクトに関する特別なルーチンを使うことで、
たいそう整理することができます。
この方法で、大きな式の構造がもっと明白になるかもしれません。
他方で、
@code{itensor}の中の特別な添字表現のために、
いくつかの場合、
ユーザーは、計量の指定や関数の定義、微分された「添字付き」オブジェクトの評価に
難しさを見いだすかもしれません。

@code{itensor}パッケージは、添字付き変数に関する微分を実行できます。
それは、ラグランジアンとハミルトニアン形式を扱う時にパッケージを使うことができます。
(添字付き)場の変数に関する場のラグランジアンを微分することが可能なので、
Maximaを、対応するEuler-Lagrange方程式を添字形式で得るのに使うことができます。
これらの方程式は、
@code{ic_convert}関数を使って、成分テンソル(@code{ctensor})プログラムに翻訳することができ、
それは場の方程式を個別の座標表現で解くことや、
ハミルトニアン形式の運動方程式を計算し直すことを可能にします。
２つの包括的な例として、@code{einhil.dem}と@code{bradic.dem}を参照してください。
最初の@code{einhil.dem}は、
斉次で等方的な場合(Friedmann方程式)と
球対称で静的な場合(Schwarzschild解)に
のEinsteinの場テンソルを得るために
Einstein-Hilbert作用を使います。
二番目の@code{bradic.dem}は、
Brans-Dicke重力理論の作用からFriedmann方程式を計算する方法を示し、
理論のスカラー場に関連したハミルトニアンも演繹します。

@opencatbox
@category{Tensors}
@category{Share packages}
@category{Package itensor}
@closecatbox

@c -----------------------------------------------------------------------------
@subsection New tensor notation
@c -----------------------------------------------------------------------------

Maximaの@code{itensor}パッケージの初期のバージョンは、
時々、間違った添字順序に至る表記を使いました。
例えば、以下を考えてください:

@example
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                 i l  j k
(%t3)                           g    g    a
                                           i j
(%i4) ishow(contract(%))$
                                      k l
(%t4)                                a
@end example

@code{a}が偶然対称テンソルでなければ、
この結果は間違っています
これが起こる理由は、
@code{itensor}は正しく共変添字と反変添字の集合の中の順序を保つけれども、
一旦、添字が上がったり、下がったりすると、
添字の他の集合に関する位置が失われるからです。

この問題を避けるため、
存在する表記と完全に互換性を残し、相互に使うことが可能な新しい表記が開発されました。
この表記では、反変添字は、共変添字リストの中の適切な位置に挿入されますが、
マイナス記号が前に付けられます。
現在、@code{contract}や@code{ishow}のような関数は、
この新しい添字表記に通じており、
テンソルを適切に処理することができます。

この新しい表記では、以前の例は正しい結果をもたらします:

@example
(%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                 i l       j k
(%t5)                           g    a    g
                                      i j
(%i6) ishow(contract(%))$
                                      l k
(%t6)                                a
@end example

現在、
この表記を使う唯一のコードは、@code{lc2kdt}関数です。
数値添字に頼らずLevi-Civita記号を決定するために計量テンソルを用いる時、
この表記を通じて、一貫した結果を達成します。

このコードはできたばかりなので、おそらくバグを含みます。
「古い」テンソル表記を使った何かを壊さないことを確認するためにテストされている一方、
「新しい」テンソルが
特定の関数や特徴と相互運営するのに失敗する相当な可能性があります。
これらのバグは、出会った時修正されるでしょう。それまでは、利用者責任！


@c -----------------------------------------------------------------------------
@subsection Indicial tensor manipulation
@c -----------------------------------------------------------------------------

添字テンソル操作パッケージは@code{load(itensor)}でロードできます。
デモも利用可能です: @code{demo(tensor)}を試してください。

@code{itensor}では、
テンソルは「添字付きオブジェクト」として表されます。
これは
共変、反変、微分添字を表す添字の3つのグループの関数です。
共変添字は添字付きオブジェクトの最初の引数としてリストで指定され、
半変添字は二番目の引数としてリストで指定されます。
もし添字付きオブジェクトが添字のグループのいずれかを欠いているなら、
空のリスト@code{[]}が対応する引数として与えられます。
例えば、@code{g([a,b],[c])}は、
２つの共変添字@code{(a,b)}と１つの反変添字(@code{c})を持ち、微分添字を持たない
@code{g}と呼ばれる添字付きオブジェクトを表します。

もし存在するなら、微分添字は、テンソルを表すシンボル関数の追加の引数として添えられます。
それらは、ユーザーによって陽に指定されたり、ある座標変数に関する微分の処理の中で生成されたりします。
常微分は可換なので、
フレーム計量が使われることを示す@code{iframe_flag}が@code{true}に設定されない限り、
微分添字はアルファベット順に並び替えられます。
この標準オーダーは、Maximaが、例えば、@code{t([a],[b],i,j)}が@code{t([a],[b],j,i)}と同じだと認識することを可能にします。
添字付きオブジェクトの引数として現れない添字の座標に関する
添字付きオブジェクトの微分は、通常ゼロをもたらします。
これは、Maximaが添字付きオブジェクトで表されたテンソルが対応する座標に陰に依存するかもしれないことを知らないためです。
@code{itensor}現在のMaxima関数@code{diff}を修正したことで、
そうでなければ記述されない限り、Maximaは、添字付きオブジェクトすべてが微分の任意の変数に依存することを現在仮定します。
これは、和の慣例が微分添字に拡張されることを可能にします。
@code{itensor}は微分添字を上げる能力を所有しないこと、そしてそれらは常に共変として扱われることに注意すべきです。

以下の関数が添字付きオブジェクトを操作するためにテンソルパッケージの中で利用可能です。
現在、整理ルーチンに関して、添字付きオブジェクトがデフォルトで対称性を持たないことを仮定します。
これは、変数@code{allsym[false]}を@code{true}に設定することで上書きすることができます。
これによって、すべての添字付きオブジェクトを共変添字のリストと反変添字のリストに関して完全に対称に扱うようになります。

@code{itensor}パッケージは、一般にテンソルを不透明なオブジェクトとして扱います。
テンソル等式は、代数ルール、特に対称性と縮約ルールに基づいて操作されます。
加えて、@code{itensor}パッケージは、共変微分、曲率、ねじれ率を理解します。
計算は、@code{iframe_flag}変数の設定に依存して動枠の計量に関して実行されます。

以下のサンプルセッションは、
@code{itensor}パッケージをロードし、計量名を指定し、いくつかの簡単な計算を実行する仕方を
例示します。

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
(%i4) ishow(g([k,l],[]))$
(%t4)                               e p
                                       k l
(%i5) ishow(diff(v([i],[]),t))$
(%t5)                                  0
(%i6) depends(v,t);
(%o6)                               [v(t)]
(%i7) ishow(diff(v([i],[]),t))$
                                    d
(%t7)                               -- (v )
                                    dt   i
(%i8) ishow(idiff(v([i],[]),j))$
(%t8)                                v
                                      i,j
(%i9) ishow(extdiff(v([i],[]),j))$
(%t9)                             v    - v
                                   j,i    i,j
                                  -----------
                                       2
(%i10) ishow(liediff(v,w([i],[])))$
                               %3          %3
(%t10)                        v   w     + v   w
                                   i,%3    ,i  %3
(%i11) ishow(covdiff(v([i],[]),j))$
                                              %4
(%t11)                        v    - v   ichr2
                               i,j    %4      i j
(%i12) ishow(ev(%,ichr2))$
                %4 %5
(%t12) v    - (g      v   (e p       + e   p     - e p       - e    p
        i,j            %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                         + e p       + e   p    ))/2
                                              i %5,j    ,j  i %5
(%i13) iframe_flag:true;
(%o13)                               true
(%i14) ishow(covdiff(v([i],[]),j))$
                                             %6
(%t14)                        v    - v   icc2
                               i,j    %6     i j
(%i15) ishow(ev(%,icc2))$
                                             %6
(%t15)                        v    - v   ifc2
                               i,j    %6     i j
(%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
             %6 %7                    %6 %7
(%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                    %6    j %7 i             %6    i j %7      i,j

                                             %6 %7
                                        - ifg      v   ifb      )/2
                                                    %6    %7 i j
(%i17) ishow(canform(s([i,j],[])-s([j,i])))$
(%t17)                            s    - s
                                   i j    j i
(%i18) decsym(s,2,0,[sym(all)],[]);
(%o18)                               done
(%i19) ishow(canform(s([i,j],[])-s([j,i])))$
(%t19)                                 0
(%i20) ishow(canform(a([i,j],[])+a([j,i])))$
(%t20)                            a    + a
                                   j i    i j
(%i21) decsym(a,2,0,[anti(all)],[]);
(%o21)                               done
(%i22) ishow(canform(a([i,j],[])+a([j,i])))$
(%t22)                                 0
@end example

@c end concepts itensor

@c -----------------------------------------------------------------------------
@node Functions and Variables for itensor,  , Introduction to itensor, itensor
@section Functions and Variables for itensor
@subsection Managing indexed objects
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{dispcon}
@deffn  {関数} dispcon (@var{tensor_1}, @var{tensor_2}, ...)
@deffnx {関数} dispcon (all)

@code{defcon}に与えられたような引数の縮約プロパティを表示します。
@code{dispcon (all)}は、定義された縮約プロパティすべてを表示します。

@opencatbox
@category{Display functions}
@closecatbox

@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} entertensor (@var{name})

プロンプトによって、
任意の数のテンソル添字や微分添字を持つ@var{name}と呼ばれる添字付きオブジェクトを生成することを許す関数です。
単一添字または(nullもありえる)添字のリストが容認可能な入力です。
(@code{covdiff}の下の例を参照してください。)

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} changename (@var{old}, @var{new}, @var{expr})

@var{expr}の中の@var{old}と呼ばれるすべての添字付きオブジェクトの名前を@var{new}に変えます。
@var{old}はシンボルまたは形式@code{[@var{name}, @var{m}, @var{n}]}のリストであり得ます。
後者の場合、@var{m}個の共変添字と@var{n}個の反変添字を持つ
@var{name}と呼ばれるそれらの添字付きオブジェクトだけが@var{new}にリネームされます。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@deffn {関数} listoftens

テンソル式の中のすべてのテンソルを添字が完備した形でリストします。
例えば、

@example

(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$
                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} ishow (@var{expr})

下付き添字としての共変添字と上付き添字としての反変添字を持つように
添字付きオブジェクトを持つ形で@var{expr}を表示します。
微分添字は、共変添字からコンマで区切られた下付き添字として表示されます。
(このドキュメント至る所の例を参照してください。)

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} indices (@var{expr})

2つの要素のリストを返します。
以下の例が例示するように、
一番目は、@var{expr}の中の自由添字(一度だけ現れるもの)のリストです。
二番目は、@var{expr}の中のダミー添字(正確に二回現れるもの)のリストです。

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);
(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

@end example

同じ添字を二回以上含むテンソル積は構文的に認められていません。
@code{indices}は、これらの式を合理的な方法で扱おうとします;
しかしながら、そんな非合法な式上で動くようにコールされた時、その振る舞いは未定義と考えなければいけません。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn  {関数} rename (@var{expr})
@deffnx {関数} rename (@var{expr}, @var{count})

もしオプションの二番目の引数が省略されたら、
@var{expr}と同値な、
しかし、各項に対して、集合@code{[%1, %2,...]}から選ばれたダミー添字を持つ式を返します。
そうでなければ、ダミー添字は@var{count}の値で始まるようインデックスされます。
積の中のそれぞれのダミー添字は異なります。
和に関しては、@code{rename}は各項毎にカウンタが再設定されるように和の中の各項上で作用します。
この方法で、@code{rename}はテンソル整理器として利用できます。
加えて、
(もし@code{allsym}が@code{true}なら、)
添字は、
@code{flipflag}の値に依存して共変または反変添字に関して、
英数字順に並び替えられます。
もし@code{flipflag}が@code{false}なら、
添字は反変添字の順に従ってリネームされます。
もし@code{flipflag}が@code{true}なら、
リネームは共変添字の順に従って起こるでしょう。
２つのリネームの組み合わせた効果が、それ自身によって、
どちらか１つよりも更に式を簡単にすることがしばしば起こります。

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;
(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
(%i4) expr:ishow(%)$
@group
       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %5      %4 %6      %7 r
@end group
(%i5) flipflag:true;
(%o5)                                true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;
(%o7)                                false
(%i8) rename(%th(2));
(%o8)                                  0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

        %1 %2  %3 %4      %6         %5         %7        u
     - g      g      ichr2      ichr2      ichr2     ichr2
                          %1 %3      %2 %6      %4 r      %5 %7
@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c THIS FUNCTION IS IN THE SHARE PACKAGE itensor.lisp
@c MOVE THIS DESCRIPTION TO Itensor.texi

@c -----------------------------------------------------------------------------
@anchor{show}
@deffn {関数} show (@var{expr})
下付き添字として共変インデックス、上付き添字として反変インデックスを持つよう、
インデックスされたオブジェクトと一緒に@code{expr}を表示します。
微分インデックスは下付き添字として表示され、
コンマによって共変インデックスと区別されます。

@opencatbox
@category{Package itensor}
@category{Display functions}
@closecatbox

@end deffn

@c -----------------------------------------------------------------------------
@defvr {オプション変数} flipflag

デフォルト: @code{false}.
もし@code{false}なら反変添字の順に従って、
そうでなければ、共変添字の順に従って、
添字がリネームされます。

もし@code{flipflag}が@code{false}なら、
@code{rename}は
左から右に現れるよう反変添字のリストを形成します
(もし@code{true}なら共変添字について同様に)。
リストの最初のダミー添字は@code{%1}に、次は@code{%2}にというように、リネームされます。
そして、@code{rename}の後、並び替えが起こります。
(@code{rename}の下の例を参照してください。)

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {関数} defcon (@var{tensor_1})
@deffnx {関数} defcon (@var{tensor_1}, @var{tensor_2}, @var{tensor_3})
@var{tensor_1}に、
@var{tensor_1}と@var{tensor_2}の積の縮約が
適切な添字を持つ@var{tensor_3}に帰着するという
プロパティを与えます。
もし引数が@var{tensor_1}１つだけ与えれたなら、
, then the contraction of the product of 
適切な添字を持つ任意の添字付きオブジェクト(@code{my_tensor}とします)との@var{tensor_1}の積の縮約はその名前、すなわち、@code{my_tensor}と、実行された縮約を反映した添字の新しい集合を持つ添字付きオブジェクトをもたらします。
例えば、もし@code{imetric:g}なら、@code{defcon(g)}は
計量テンソルとの縮約を通して添字の上げ下げを実行します。
１つ以上の@code{defcon}を同じ添字付きオブジェクトに関して与えることができます;
特定の縮約に関して適用する最新のものが使われます。
@code{contractions}は、
@code{defcon}で縮約プロパティを与えられたそれら添字付きオブジェクトのリストです。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} remcon (@var{tensor_1}, ..., @var{tensor_n})
@deffnx {関数} remcon (all)
@var{tensor_1}, ..., @var{tensor_n}からすべての縮約プロパティを取り除きます。
@code{remcon(all)}は、すべての添字付きオブジェクトから
すべての縮約プロパティを取り除きます。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} contract (@var{expr})

和と積の任意の組み合わせであり得る
@var{expr}に関して
テンソル縮約を実行します。
この関数は
@code{defcon}関数に与えられた情報を使います。
最高の結果として、
@code{expr}は完全に展開されなければいけません。
もし項の分母の中に変数がないなら、
@code{ratexpand}は
和の積やべきを展開する
最速の方法です。
もしGCD消去が不要なら、
@code{gcd}スイッチは@code{false}でなければいけません。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} indexed_tensor (@var{tensor})

値に関する美しい姿が既に
@code{ichr1}, @code{ichr2}, @code{icurvature}とともにあるように存在する
@var{tensor}に成分を割り当てる前に実行されなければいけません。
@code{icurvature}の下の例を参照してください。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} components (@var{tensor}, @var{expr})

@var{tensor}の成分の値を与える式@var{expr}に添字値を割り当てることを許します。
その添字のすべてとともに起こるときはいつでも、これらは自動的にテンソルに代入されます。
テンソルは、形式@code{t([...],[...])}でなければいけません。
ここで形式@code{t([...],[...])}の中のリストのいずれかは空であり得えます。
@var{expr}は、
@var{tensor}と同じ自由添字を持つ他のオブジェクトを含む任意の添字付き式であり得ます。
成分がダミー添字を含む計量テンソルへ値を割り当てるのに使われる時、
複数のダミー添字の生成を避けるようにこれらの添字を定義するように注意しなければいけません。
この割り当ての削除は関数@code{remcomps}に与えられます。

It is important to keep in mind that 
@code{components}はテンソル価についてだけ知る必要があり、特別な添字順序について知る必要がないことを覚えておくことは重要です。
このように、成分を、例えば、@code{x([i,-j],[])}, @code{x([-j,i],[])}または
@code{x([i],[j])}すべてに割り当てることは、同じ結果、
すなわち、
価@code{(1,1)}を持つ@code{x}と名付けられたテンソルに割り当てられた
成分を生成します。

成分を、4つの方法で添字付き式に割り当てることができます。
そのうちの2つは@code{components}コマンドの使用を含みます:

1) 添字付き式として。例えば:

@example
(%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p

@end example

2) 行列として:

@example

(%i5) lg:-ident(4)$lg[1,1]:1$lg;
@group
                            [ 1   0    0    0  ]
                            [                  ]
                            [ 0  - 1   0    0  ]
(%o5)                       [                  ]
                            [ 0   0   - 1   0  ]
                            [                  ]
                            [ 0   0    0   - 1 ]
@end group
(%i6) components(g([i,j],[]),lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([1,1],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1
@end example

3) 関数として。Maxima関数を使って、添字に基づいたテンソルの成分を指定することができます。
例えば、以下のコードは、
もし@code{h}が同じ数の共変添字と反変添字を持ち、微分添字を持たないなら、@code{kdelta}を@code{h}に割り当て、そうでなければ、@code{g}を割り当てます:

@example

(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l
@end example

4) Maximaのパターンマッチング機能、特に@code{defrule}と@code{applyb1}コマンド
を使って:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
@group
                                    i m
(%t5)                              m    m
                                         i n
@end group
(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n
@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@deffn {関数} remcomps (@var{tensor})

@code{components}関数で割り当てられたすべての値を
@var{tensor}からアンバインドします。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c NEED LIST OF ARGUMENTS HERE

@c -----------------------------------------------------------------------------
@deffn {関数} showcomps (@var{tensor})

@code{components}コマンドを使って作られたように
テンソルの成分割り当てを表示します。
以下の例で明示されるように、
行列が、@code{components}を使って
添字テンソルに割り当てられている時、
この関数は特に役に立ちます:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) load(itensor);
(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false

@end example

@code{showcomps}コマンドは
2よりも高い階数のテンソルの成分も表示することができます。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} idummy ()

Increments 
@code{icounter}を1つ増やし、
形式@code{%n}の添字を値として返します。ここでnは正の整数です。
これは式を形成する際必要なダミー添字が既に使用中の添字とぶつからないことを保証します。
(@code{indices}の下の例を参照してください。)

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@defvr {オプション変数} idummyx
デフォルト値: @code{%}

ダミー添字の接頭辞です。
(@code{indices}の下の例を参照してください。)

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {オプション変数} icounter
デフォルト値: @code{1}

テンソルパッケージで次のダミー添字を生成する際使われる数値接尾を決定します。
接頭辞はオプション@code{idummy} (デフォルト: @code{%})で決定されます。

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {関数} kdelta (@var{L1}, @var{L2})
共変添字のリスト@var{L1}と反変添字のリスト@var{L2}を使って
@code{itensor}パッケージで定義された
一般化されたKroneckerのデルタ関数です。
@code{kdelta([i],[j])}は通常のKroneckerデルタを返します。
コマンド@code{ev(@var{expr},kdelta)}は
@code{kdelta([],[])}を多様体の次元に含む
式の評価をもたらします。

この表記法の乱用となることですが、
@code{itensor}は
@code{kdelta}が2つの共変添字だけ、または、2つの反変添字だけを持つことも許し、
事実上、共(反)変「単位行列」を供給します。
これは厳密にはプログラミング目的としてみなされ、
@code{kdelta([i,j],[])}が有効なテンソルオブジェクトだということを意味するつもりではありません。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} kdels (@var{L1}, @var{L2})

いくつかの計算で使われる、対称化されたKroneckerデルタ。
例えば:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} levi_civita (@var{L})
もしリスト@var{L}が整数の偶置換から成るなら1を返し、
@var{L}が奇置換なら成るなら-1を返し、
@var{L}のいくつかの添字が繰り返しなら0を返す
置換(別名Levi-Civita)テンソルです。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} lc2kdt (@var{expr})
Levi-Civitaシンボルを含む式を整理し、可能ならこれらをKroneckerデルタ式に変換します。
この関数と単にLevi-Civitaシンボルを評価することの主な違いは、
直接評価はしばしば数値添字を含むKronecker式に帰着することです。
これは、更なる整理を妨げるので、しばしば望ましくないことです。
@code{lc2kdt}関数はこの問題を避けて、
@code{rename}や@code{contract}を使って更に容易に整理される式をもたらします。

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l
@end example

@code{lc2kdt}関数は時々計量テンソルを利用します。
もし前もって計量テンソルが@code{imetric}で定義されていなかったなら、
これはエラーになります。

@example

(%i7) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([],[k,l])*a([j,k],[]))$
@group
                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
@end group
(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g    
                    %3             %4               %3
              k
        kdelta  ) a
              %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i    l i  j
(%t11)                           a    - g    a
                                              j
@end example


@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c HMM, WHICH CATEGORY DOES THIS FALL INTO -- FUNCTION, VARIABLE, OTHER ??

@c -----------------------------------------------------------------------------
@deffn {関数} lc_l

未評価のLevi-Civitaシンボル(@code{levi_civita})を含む式のために使われる整理ルール。
@code{lc_u}と組み合わせて、
たくさんの式を、@code{levi_civita}の評価より、より効率的に整理するのに使うことができます。

例えば:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) canform(contract(expand(applyb1(el1,lc_l,lc_u))));
(%t4)                                  0
(%i5) canform(contract(expand(applyb1(el2,lc_l,lc_u))));
(%t5)                                  0

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c HMM, WHICH CATEGORY DOES THIS FALL INTO -- FUNCTION, VARIABLE, OTHER ??

@c -----------------------------------------------------------------------------
@deffn {関数} lc_u

未評価のLevi-Civitaシンボル(@code{levi_civita})を含む式のために使われる整理ルール。
@code{lc_l}と組み合わせて、
たくさんの式を、@code{levi_civita}の評価より、より効率的に整理するのに使うことができます。
詳しくは、@code{lc_l}を参照してください。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} canten (@var{expr})
名前を変えて(@code{rename}を参照してください)、ダミー添字を置換することで、
@var{expr}を整理します。
@code{rename}は
微分がないテンソル積の和に制限されます。
本当に限定されていて、
もし@code{canform}が要求された整理を実行する能力がない時だけ使われるはずです。

@code{canten}関数は、
引数が添字が完全に対称な式の時だけ数学的に正確な結果を返します。
この理由から、@code{canten}は、
もし@code{allsym}が@code{true}に設定されてないなら
エラーを返します。


@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} concan (@var{expr})
@code{canten}に似ていますが、添字縮約も実行します。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@subsection Tensor symmetries
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@defvr {オプション変数} allsym

デフォルト: @code{false}。
もし@code{true}なら、すべての添字付きオブジェクトは共変、反変添字のすべてに関して対称と仮定されます。
もし@code{false}なら、これらの添字に関して、いかなる種類の対称性も仮定されません。
@code{iframe_flag}が@code{true}に設定されない限り、
微分添字はいつも対称と取られます。

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {関数} decsym (@var{tensor}, @var{m}, @var{n}, [@var{cov_1}, @var{cov_2}, ...], [@var{contr_1}, @var{contr_2}, ...])

@var{m}個の共変添字と@var{n}個の反変添字を持つ@var{tensor}に関する
対称プロパティを宣言します。
@var{cov_i}と@var{contr_i}は
それぞれ、共変添字と反変添字の間の対称関係を表す擬似関数です。
これらは
contravariant indices respectively.  These are of the form
形式@code{symoper(@var{index_1}, @var{index_2},...)}を取ります。
ここで@code{symoper}は
@code{sym}, @code{anti}もしくは@code{cyc}のいずれかで、
 and the 
@var{index_i}は
@var{tensor}の添字の位置を示す整数です。
これは、@var{tensor}が@var{index_i}に関してそれぞれ対称、反対称、巡回であると宣言します。
@code{symoper(all)}も対称条件に従う添字すべてを示す有効な形式です。
例えば、
5つの共変添字を持つオブジェクト@code{b}が与えられたとして、
@code{decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])}は、
@code{b}が一番目と二番目の共変添字に対して対称であり、三番目、四番目の共変添字に対して反対称であり、反変添字すべてに対して巡回的であると宣言します。
対称宣言のリストのどれかは空であり得ます。
式整理を実行する関数は
以下の例で示すように@code{canform}です。

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract( expand( a([i1, j1, k1], [])
           *kdels([i, j, k], [i1, j1, k1])))$
(%i3) ishow(expr)$
@group
(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
@end group
(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} remsym (@var{tensor}, @var{m}, @var{n})
@var{m}個の共変添字と@var{n}個の反変添字を持つ@var{tensor}から
すべての対称プロパティを取り除きます。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} canform (@var{expr})
@deffnx {関数} canform (@var{expr}, @var{rename})
ダミー添字をリネームして、
それらに課せられた対称条件によって指令されたようにすべての添字を並べ替えることで、
@var{expr}を整理します。
もし@code{allsym}が@code{true}なら、
すべての添字は対称と仮定され、
そうでなければ、@code{decsym}宣言が提供する対称情報が使われます。
ダミー添字は@code{rename}関数に関するものと同じ方法でリネームされます。
@code{canform}が大きな式に適用される時、
計算にかなりの時間が費やされるかもしれません。
この時間は最初に式に対して@code{rename}をコールすることで短くできます。
@code{decsym}の下の例も参照してください。
注意: @code{canform}は
いつも数学的に正しい結果を返しますが、
式を最も簡単な形式に完全に整理できないかもしれません。

オプションの二番目のパラメータ@var{rename}は、
もし@code{false}に設定されたなら、リネームを抑制します。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@subsection Indicial tensor calculus
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@deffn {関数} diff (@var{expr}, @var{v_1}, [@var{n_1}, [@var{v_2}, @var{n_2}] ...])

@code{itensor}のための能力に関して拡張された
通常のMaxima微分関数です。
It takes the derivative of 
@var{v_1}に関して @var{n_1}階、
@var{v_2}に関して @var{n_2}階、
という@var{expr}の微分を取ります。
テンソルパッケージでは、
@var{v_i}が1から変数 @code{dim}の値までの整数であるように
関数が修正されています。
これによって、
微分がリスト @code{vect_coords}の @var{v_i}番目の要素に関して実行されます。
もし
@code{vect_coords}がアトム変数にバインドされているなら、
@var{v_i}が下付きしたその変数が
微分変数として使われます。
これは
座標名や、@code{x[1]}, @code{x[2]}, ... のような下付き名の配列を使うことを可能にします。

更なる拡張は、
添字付き変数に関する微分を計算する能力を@code{diff}に追加します。
特にテンソルパッケージは
計量テンソルと、計量テンソルやその一階微分、二階微分に関する微分を含む
式を微分する方法を知っています。
この能力は
重力理論のLagrange形式を考える時、
特に役に立ちます。
作用原理からEinsteinテンソルと場の方程式を演繹することを可能にします。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} idiff (@var{expr}, @var{v_1}, [@var{n_1}, [@var{v_2}, @var{n_2}] ...])
添字微分。
独立変数に関して微分する@code{diff}と異なり、
@code{idiff)}は座標に関して微分するのにつかうことができます。
添字付きオブジェクトに関して，
結果的に、これは
@var{v_i}を微分添字として追加することになります。
@code{iframe_flag}が @code{true}に設定されていない限り
続いて，微分添字が並び替えられます。

@code{idiff}は計量テンソルの行列式も微分することができます。
従って、もし @code{imetric}が
@code{G}にバインドされていたら、
@code{idiff(determinant(g),k)}は
ダミー添字 @code{%i}が適当に選ばれて
@code{2 * determinant(g) * ichr2([%i,k],[%i])}を返します。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} liediff (@var{v}, @var{ten})

ベクトル場 @var{v}に対してテンソル式 @var{ten}のLie微分を計算します。
@var{ten}は任意の添字付きテンソル式でなければいけません;
@var{v}はベクトル場の(添字なしの)名前でなければいけません。
例えば:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                          %1  k        %1  k      %1  k
                      + (v   b      - b   v    + v   b   ) a
                              ,%1 l    ,l  ,%1    ,l  ,%1   i j

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} rediff (@var{ten})

テンソル式 @var{ten}の中の@code{idiff}コマンドすべてを評価します。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} undiff (@var{expr})

@var{expr}と同値な、
添字付きオブジェクトの微分すべてが@code{idiff}関数の名詞形で置き換えられた
式を返します。
引数はもし微分が実行されていたらその添字付きオブジェクトをもたらします。
微分された添字付きオブジェクトを
@var{expr}を生じるある関数定義で置き換えて、
@code{ev(@var{expr}, idiff)}で微分を実行したい時、
これは役に立ちます。


@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} evundiff (@var{expr})

@code{undiff}の実行と同値ですが、@code{ev}と @code{rediff}が続きます。

この演算のポイントは
微分形式で直接評価できない式を簡単に評価することです。
例えば、以下はエラーをもたらします:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]:
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

しかし、もし @code{icurvature}は名詞形で入っているなら、
@code{evundiff}を使って評価できます:

@example
(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

             l              l         %1           l           %1
      + ichr2        + ichr2     ichr2      + ichr2       ichr2
             i j,k m        %1 k      i j,m        %1 k,m      i j
@end example

注意: Maximaの以前のバージョンでは、
Christoffel記号の微分形式も評価できませんでした。
これは現在修正されています。
だから @code{evundiff}はもはやこのような式に関しては不要です:

@example
(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} flush (@var{expr}, @var{tensor_1}, @var{tensor_2}, ...)
@var{expr}において、
微分添字を持たない @var{tensor_i}をすべて0にします。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} flushd (@var{expr}, @var{tensor_1}, @var{tensor_2}, ...)
@var{expr}において、
微分添字を持つ @var{tensor_i}をすべて0にします。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} flushnd (@var{expr}, @var{tensor}, @var{n})
以下の例で例示されるように、
@var{expr}において、
@var{n}以上の微分添字を持つ微分されたオブジェクト @var{tensor}をすべて0にします。
@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} coord (@var{tensor_1}, @var{tensor_2}, ...)

@var{tensor_i}に、
その名前が@var{tensor_i}の1つである反変ベクトルの微分がKroneckerデルタをもたらす
座標微分プロパティを与えます。
例えば、
もし @code{coord(x)}が実行されたら、
@code{idiff(x([],[i]),j)}は @code{kdelta([i],[j])}を与えます。
@code{coord}はこのプロパティを持つ添字付きオブジェクトすべてのリストです。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} remcoord (@var{tensor_1}, @var{tensor_2}, ...)
@deffnx {関数} remcoord (all)

@code{tensor_i}から
関数 @code{coord}がもたらした座標微分プロパティを削除します。
@code{remcoord(all)}は添字付きオブジェクトすべてからこのプロパティを削除します。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} makebox (@var{expr})
@code{show}と同じように @var{expr}を表示します;
しかし、
@var{expr}に現れるテンソル d'Alembert演算子はすべて記号 @code{[]}を使って示されます。
例えば、 @code{[]p([m],[n])}は
@code{g([],[i,j])*p([m],[n],i,j)}を表します。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} conmetderiv (@var{expr}, @var{tensor})

計量テンソルの共変と反変形式両方(現在の制約)の常微分を含む式を整理します。
例えば、 以下に見られるように、
@code{conmetderiv}は
反変計量テンソルの微分をChristoffelシンボルに結びつけます:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c
@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} simpmetderiv (@var{expr})
@deffnx {関数} simpmetderiv (@var{expr}[, @var{stop}])

計量テンソルの微分の積を含む式を整理します。
特に、 @code{simpmetderiv}は2つの恒等式を知っています:

@example

   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d

@end example

従って、

@example

   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
@end example

と

@example

  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j

@end example

これはChristoffel記号の対称性の結果です。

@code{simpmetderiv}関数はオプションパラメータを1つ取ります。
それは、与えられた時、
積式の中の最初にうまくいった代入の後、関数が停止するようにします。
@code{simpmetderiv}関数は
``正準''順序を積添字に適用する方法を決めるグローバル変数 @var{flipflag}も利用します。

まとめると、
これらの機能は
そうでなければ遂行困難か不可能な強力な式整理を達成するのに使うことができます。
これは、
縮約式を得るために@code{simpmetderiv}の部分的な整理の特長を明示的に使う
以下の例を通じて例示されます:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d

@end example

Weylテンソルの縮約を整理するために
@code{simpmetderiv}と @code{conmetderiv}を一緒に使う例として、
@code{weyl.dem}も参照してください。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} flush1deriv (@var{expr}, @var{tensor})

@var{expr}において、
微分添字を1つだけ持つ @var{tensor}をすべて0にします。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@subsection Tensors in curved spaces
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@deffn {関数} imetric (@var{g})
@deffnx {システム変数} imetric

変数 @code{imetric:@var{g}}を割り当てることで計量を指定します。
加えて、
コマンド @code{defcon(@var{g}),defcon(@var{g}, @var{g}, kdelta)}を実行することで
計量 @var{g}の縮約プロパティが設定されます。
(デフォルトではバインドされていない)変数 @code{imetric}は
@code{imetric(@var{g})}コマンドが割り当てる計量にバインドされます。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} idim (@var{n})
計量の次元を設定します。
与えられた次元でLevi-Civita記号の反対称プロパティも初期化します。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} ichr1 ([@var{i}, @var{j}, @var{k}])
以下の定義を介して第一種Christoffel記号をもたらします。
@example
       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
@end example
@noindent
特定の計量で Christoffel記号を評価するには、
@code{chr2}の下の例のように
変数 @code{imetric}が名前を割り当てられなければいけません。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} ichr2 ([@var{i}, @var{j}], [@var{k}])
以下の定義を介して第二種Christoffel記号をもたらします。
@example
                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} icurvature ([@var{i}, @var{j}, @var{k}], [@var{h}])
第二種Christoffel記号(@code{ichr2})を使った
Riemann曲率テンソルをもたらします。
以下の表記法が使われます:
@example
            h             h            h         %1         h
  icurvature     = - ichr2      - ichr2     ichr2    + ichr2
            i j k         i k,j        %1 j      i k        i j,k
                            h          %1
                     + ichr2      ichr2
                            %1 k       i j
@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} covdiff (@var{expr}, @var{v_1}, @var{v_2}, ...)
第二種Christoffel記号(@code{ichr2})を使って、
変数 @var{v_i}に対する
@var{expr}の共変微分をもたらします。
これらを評価するには、
@code{ev(@var{expr},ichr2)}を使わなければ行けません。

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the covariant indices: [i,j];
Enter a list of the contravariant indices: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k
(%t3)     - a     ichr2    - a     ichr2    + a
             i %1      j s    %1 j      i s    i j,s

             k     %1
      + ichr2     a
             %1 s  i j
(%i4) imetric:g;
(%o4)                                  g
(%i5) ishow(ev(%th(2),ichr2))$
         %1 %4  k
        g      a     (g       - g       + g      )
                i %1   s %4,j    j s,%4    j %4,s
(%t5) - ------------------------------------------
                            2
@group
    %1 %3  k
   g      a     (g       - g       + g      )
           %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
                       2
    k %2  %1
   g     a    (g        - g        + g       )
          i j   s %2,%1    %1 s,%2    %1 %2,s     k
 + ------------------------------------------- + a
                        2                         i j,s
@end group
(%i6)
@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} lorentz_gauge (@var{expr})
反変添字と同一の微分添字を持つ @var{expr}の中で
添字付きオブジェクトすべてに0を代入することで、
Lorentz条件を課します。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} igeodesic_coords (@var{expr}, @var{name})

@var{expr}内の、未微分 Christoffel記号と
計量テンソルの一階微分を消すようにします。
@code{igeodesic_coords}関数での @var{name}は
(もし @var{expr})の中で現れるなら)
計量 @var{name}を参照します。
一方で、接続係数は
名前 @code{ichr1}か @code{ichr2}でコールされなければいけません。
以下の例は、
@code{igeodesic_coords}関数を使った、
Riemann曲率テンソルが満たす巡回恒等式の検証を例示します。

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u     
(%t2) - ichr2      - ichr2     ichr2    + ichr2      
             r t,s        %1 s      r t        r s,t 

                                              u         %1
                                       + ichr2     ichr2
                                              %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t

                                             u            u
                                      - ichr2      + ichr2
                                             r t,s        r s,t
(%i5) canform(%);
(%o5)                                  0

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@subsection Moving frames
@c -----------------------------------------------------------------------------

今ではMaximaは
動標構(moving frame)を使って計算を実行する能力があります。
これらは直交標構(テトラド、四脚場)か任意系であり得ます。

標構(frame)を使うには、
最初に@code{iframe_flag}を @code{true}に設定しなければいけません。
これにより、
計算内で、
Christoffel記号, @code{ichr1}と @code{ichr2}が
もっと一般的な標構(frame)の接続係数
@code{icc1}と @code{icc2}に置き換えられることになります。
特に、
@code{covdiff}と @code{icurvature}の振る舞いが変わります。

系は2つのテンソルで定義されます:
逆標枠場 (@code{ifri}, 双対基底四脚場)と
標構計量(frame metric) @code{ifg}。
標構計量は直交標構の単位行列、すなわち、
Minkowski時空での直交標構のLorentz計量です。
逆標枠場は標構基底(単位ベクトル)を定義します。
標枠と標構計量に縮約プロパティが定義されます。

@code{iframe_flag}がtrueなら、
たくさんの @code{itensor}式が、
@code{imetric}が上付き添字と下付き添字に関して定義する計量の代わりに
標構計量 @code{ifg}を使います。

重要: 変数 @code{iframe_flag}を @code{true}に設定することは
@code{defcon}や @code{imetric}のコールによって定義された計量の縮約プロパティを
未定義に戻しません。
もし標枠場が使われるなら、
@code{imetric}関数を呼び出さず、
変数 @code{imetric}に名前を割り当てて計量を定義することが最良です。


Maximaはこれら2つのテンソルを使って、
接続係数 (@code{icc1}と @code{icc2})の一部を形成する
標構係数 (@code{ifc1}と @code{ifc2})を定義します。
以下の例がそれを例示します:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                               %1     i       i
(%t4)                         v   ifc2     + v
                                      %1 j    ,j
(%i5) ishow(ev(%,ifc2))$
                          %1    i %2                i
(%t5)                    v   ifg     ifc1        + v
                                         %1 j %2    ,j
(%i6) ishow(ev(%,ifc1))$
@group
            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t6)      -------------------------------------------------- + v
                                   2                             ,j
@end group
(%i7) ishow(ifb([a,b,c]))$
                                                   %3    %4
(%t7)               (ifri        - ifri       ) ifr   ifr
                         a %3,%4       a %4,%3     b     c

@end example

もし @code{iframe_bracket_form}フラグが @code{false}に設定されているなら
標構ブラケット(frame bracket) (@code{ifb})を計算するのに代わりの方法が使われます:

@example

(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                                %6    %5        %5      %6
(%t8)              ifri     (ifr   ifr     - ifr     ifr  )
                       a %5     b     c,%6      b,%6    c

@end example

@c -----------------------------------------------------------------------------
@deffn {関数} iframes ()

Maximaのこのバージョン以来、
@code{ifr}と @code{ifri}に関する縮約恒等式がいつも定義されます。
as is the frame bracket (@code{ifb}), 
この関数は何もしません。

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {変数} ifb

標構ブラケット(frame bracket)。
標構計量の接続係数への寄与が標構ブラケットを使って表されます:

@example

          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2

@end example

標構ブラケット自身は
標枠と標構計量を使って定義されます。
@code{frame_bracket_form}の値に依存して
2つの代わりの計算方法が使われます。
もし true (デフォルト)か、もし @code{itorsion_flag}が @code{true}なら:

@example

          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e


@end example

そうでないなら:

@example

             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr


@c -----------------------------------------------------------------------------
@defvr {変数} icc1

第一種接続係数。
@code{itensor}では、以下のように定義されます。

@example

icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc

@end example

この式では、
もし @code{iframe_flag}が trueなら、
Christoffel記号 @code{ichr1}が
標構接続係数 @code{ifc1}に置き換えられます。
もし @code{itorsion_flag}が @code{false}なら、
 @code{ikt1}は省略されます。
もし標構基底が使われるなら、
ねじれが標構ブラケットの一部として既に計算されているので、
その時にも @code{ikt1}は省略されます。
最後に、
@code{inonmet_flag}が @code{false}なら、
@code{inmc1}は存在しません。

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} icc2

第二種接続係数。
@code{itensor}では、以下のように定義されます。

@example

    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab

@end example

この式では、
もし @code{iframe_flag}が trueなら、
Christoffel記号 @code{ichr2}が
標構接続係数 @code{ifc2}に置き換えられます。
もし @code{itorsion_flag}が @code{false}なら、
 @code{ikt2}は省略されます。
もし標構基底が使われるなら、
ねじれが標構ブラケットの一部として既に計算されているので、
その時にも @code{ikt1}は省略されます。
最後に、
@code{inonmet_flag}が @code{false}なら、
@code{inmc1}は存在しません。

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} ifc1

(Ricci回転係数としても知られている)第一種標構係数。
このテンソルは
標構計量の第一種接続係数への寄与を表します。
以下のように定義されます:

@example

          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2


@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} ifc2

第二種標構係数。
このテンソルは標構計量の第一種接続係数への寄与を表します。
必要に応じて、標構ブラケット (@code{ifb})の、
適切な上付き、下付き添字での置換として定義されます:

@example

    c       cd
ifc2   = ifg   ifc1
    ab             abd

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@defvr {変数} ifr

標枠。
標構計量(@code{ifg})を形成するために
逆標構場 (@code{ifri})を
縮約します。

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} ifri

逆標構場。
(双対基底ベクトル)標構基底を指定します。
標構計量と一緒に、
標構に基づいた計算すべての基底を形成します。

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} ifg

標構計量。
@code{kdelta}のデフォルトですが、
@code{components}を使って変えることができます。

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} ifgi

逆標構計量。
標構計量 (@code{ifg})を @code{kdelta}に縮約します。

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {オプション変数} iframe_bracket_form
デフォルト値: @code{true}

標構ブラケット (@code{ifb})が如何に計算されるか指定します。

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@subsection Torsion and nonmetricity
@c -----------------------------------------------------------------------------

Maximaは今では、ねじれと非計量性を考慮することができます。
フラグ @code{itorsion_flag}が @code{true}に設定されている時、
ねじれの寄与が
接続係数に加えられます。
同様に、
フラグ @code{inonmet_flag}が trueの時、
非計量性成分が含まれます。

@c -----------------------------------------------------------------------------
@defvr {変数} inm

非計量性ベクトル。
共形非計量性は計量テンソルの共変微分を通して定義されます。
@code{inonmet_flag}が @code{true}に設定されている時
通常零の計量テンソルの共変微分は以下のように評価されます:

@example

g     =- g  inm
 ij;k     ij   k

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} inmc1

非計量ベクトル成分の共変置換。
以下のように定義されます:

@example

           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

@end example

(もし標構計量を使うなら、@code{ifg}を @code{g}に代入します。)

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} inmc2

非計量ベクトル成分の反変置換。
もし @code{inonmet_flag}が @code{true}なら
接続係数で使われます。
以下のように定義されます:

@example

                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2

@end example

(もし標構計量を使うなら、@code{ifg}を @code{g}に代入します。)

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} ikt1

(コントーションとしても知られる)ねじれテンソルの共変置換。
以下のように定義されます:

@example

                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

@end example

(もし標構計量を使うなら、@code{ifg}を @code{g}に代入します。)

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} ikt2

(コントーションとしても知られる)ねじれテンソルの共変置換。
以下のように定義されます:

@example

    c     cd
ikt2   = g   ikt1
    ab           abd

@end example

(もし標構計量を使うなら、@code{ifg}を @code{g}に代入します。)

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {変数} itr

ねじれテンソル。
以下の例で例示されるように、
ねじれを伴う計量に関してスカラー関数上の繰り返される共変微分は計算されません:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@subsection Exterior algebra
@c -----------------------------------------------------------------------------

@code{itensor}パッケージは
完全反対称共変テンソル場上の
演算を実行できます。
回数 (0,L)の完全反対称テンソル場は
微分L形式に対応します。
これらのオブジェクト上で、
外積やウェッジ積として知られる乗算が定義されます。

不運にも、
すべての作者がウェッジ積の定義に同意しません。
何人の作者は反対称の概念に対応した定義を好みます:
これらの仕事では、
2つのベクトル場のウェッジ積は
例えば、以下のように定義されます。

@example
            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
@end example

もっと一般的に、
p形式や q形式の積は以下のように定義されます。

@example
                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
@end example

ここで、 @code{D}はKroneckerのデルタを表します。

しかし、他の作者は容積要素の概念に対応する
``幾何的''定義を好みます:

@example
a  /\ a  = a a  - a a
 i     j    i j    j i
@end example

そいて、一般的な場合，

@example
                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
@end example

@code{itensor}はテンソル代数パッケージなので、
これら2つの定義の前者がより自然なもののようです。
しかし、多くの応用は後者の定義を使います。
このジレンマを解決するに、
ウェッジ積の振る舞いを制御するフラグが実装されました:
もし @code{igeowedge_flag}が @code{false} (デフォルト)なら、
前者の "テンソル的"定義が使われ、
層でないなら，後者の"幾何的"定義が適用されます。

@defvr {演算子} ~
@ifinfo
@fnindex Wedge product
@end ifinfo

ウェッジ積演算子は
ティルデ @code{~}で示されれます。
これは二項演算子です。
引数は、
スカラ、階数1の共変テンソル、
共変添字すべてに関して反対称と宣言された階数 @code{l}の共変テンソルを含む式
でなければいけません。

以下の例のように、
ウェッジ積演算子の振る舞いは
@code{igeowedge_flag}
フラグで制御されます:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
@end example

@opencatbox
@category{Package itensor}
@category{Operators}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {演算子} |
@ifinfo
@fnindex Contraction with a vector
@end ifinfo

縦線 @code{|}は
"ベクトルの縮約"二項演算子を示します。
完全反対称共変テンソルが反変ベクトルと縮約される時、
結果は、どの添字が縮約に使われるかに関わらず同じです。
このように、
添字に無関係な方法で縮約演算子を定義することが可能です。

@code{itensor}パッケージでは、
ベクトルとの縮約は常に
文字通りの並べ順で最初の添字に対して実行されます。
これは
@code{|}演算子を含む式のより良い整理を保証します。
例えば:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
@end example

@code{|}演算子で使われるテンソルは
は共変添字に対して完全反対称と宣言されなければいけないことが
本質的であることに注意してください。
そうでないなら、結果は正しくありません。

@opencatbox
@category{Package itensor}
@category{Operators}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {関数} extdiff (@var{expr}, @var{i})

添字 @var{i}に対する
@var{expr}の外積を計算します。
外微分は形式的に
偏微分演算子のウェッジ積で微分形式として定義されます。
そんなように、
演算子も
@code{igeowedge_flag}の設定で制御されます。
例えば:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                    - (a      - a      + a     )
                             k j,i    k i,j    j i,k

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {関数} hodge (@var{expr})

@var{expr}のHodge双対を計算します。
例えば:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g       
                                                     %1 %106
                             g        g        g      A         /6
                              %2 %107  %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108

@end example

@opencatbox
@category{Package itensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {オプション変数} igeowedge_flag
デフォルト値: @code{false}

ウェッジ積と外微分の振る舞いを制御します。
@code{false} (デフォルト)に設定された時、
微分形式の概念は
完全反対称共変テンソル場のそれに対応します。
@code{true}に設定された時、
微分形式は容積要素の概念に一致します。

@opencatbox
@category{Package itensor}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@subsection Exporting TeX expressions
@c -----------------------------------------------------------------------------

@code{itensor}パッケージは
テンソル式をTexにエクスポートするための限定サポートを提供します。
@code{itensor}式は関数コールとして現れるので、
いつもの Maxima @code{tex}コマンドは
期待された出力を生成しません。
代わりに@code{tentex}コマンドを試すことができます。
これは、テンソル式を適切に添字が付けられたTeXオブジェクトに翻訳しようとします。

@c -----------------------------------------------------------------------------
@deffn {関数} tentex (@var{expr})

以下の例のように、
@code{tentex}関数を使うには、
最初に@code{tentex}をロードしなければいけません:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) load(tentex);
(%o2)       /share/tensor/tentex.lisp
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2
            j k      m1 l        j l      m1 k        j l,k

                                                      i
                                               + ichr2
                                                      j k,l
(%i5) tentex(%)$
$$\Gamma_@{j\,k@}^@{m_1@}\,\Gamma_@{l\,m_1@}^@{i@}-\Gamma_@{j\,l@}^@{m_1@}\,
 \Gamma_@{k\,m_1@}^@{i@}-\Gamma_@{j\,l,k@}^@{i@}+\Gamma_@{j\,k,l@}^@{i@}$$
@end example

コンパイルエラーに導かれるTeX式でのパーセント符号の出現を避けるための、
@code{idummyx}割り当ての使用に注意してください。

注意せよ: このバージョンの@code{tentex}関数は幾分実験的です。

@opencatbox
@category{Package itensor}
@category{TeX output}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@subsection Interfacing with ctensor
@c -----------------------------------------------------------------------------

@code{itensor}パッケージは
@code{ctensor}パッケージの文脈で実行することができる
Maximaコードを生成する能力があります。
この仕事を実行する関数は @code{ic_convert}です。

@c -----------------------------------------------------------------------------
@deffn {関数} ic_convert (@var{eqn})

@code{itensor}方程式 @var{eqn}を
@code{ctensor}割り当て文に変換します。
添字付きオブジェクトが配列に変換される一方で、
ダミー添字上の暗黙の和は明示的にされます。

(配列下付き添字は添字付きオブジェクトの反変添字が続く共変の順です。)
添字付きオブジェクトの微分は、
微分添字で下に添えられた @code{ct_coords}に対して取られる @code{diff}の名詞形に
置き換えられます。
Christoffel記号 @code{ichr1}と @code{ichr2}は
それぞれ、@code{lcs}と @code{mcs}に翻訳されます。
もし @code{metricconvert}が @code{true}なら、
2つの共変(反変)添字を持つ計量はすべて
@code{lg} (@code{ug})にリネームされます。
更に、 自由添字すべての上で足される@code{do}ループが導入されます。
なので、
ただ @code{ev}するだけで
変換される割り当て分を評価することができます。
以下の例はこの関数の特長を例示します。

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)
      *b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
@end example

@opencatbox
@category{Package itensor}
@category{Package ctensor}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@subsection Reserved words
@c -----------------------------------------------------------------------------

以下の Maximaワードは @code{itensor}パッケージで内部的に使われているので、
再定義してはいけません:

@c REFORMAT THIS TABLE USING TEXINFO MARKUP
@example
  Keyword    Comments
  ------------------------------------------
  indices2() Internal version of indices()
  conti      Lists contravariant indices
  covi       Lists covariant indices of a indexed object
  deri       Lists derivative indices of an indexed object
  name       Returns the name of an indexed object
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc
@end example

