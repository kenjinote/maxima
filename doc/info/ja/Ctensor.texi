@menu
* Introduction to ctensor::
* Functions and Variables for ctensor::
@end menu

@node Introduction to ctensor, Functions and Variables for ctensor, ctensor, ctensor
@section Introduction to ctensor

@code{ctensor}は、成分テンソル操作パッケージです。
@code{ctensor}パッケージを使うには、@code{load(ctensor)}をタイプしてください。
@code{ctensor}と対話的セッションを始めるには、@code{csetup()}をタイプしてください。
最初に、多様体の次元を指定するよう尋ねられます。
もし次元が、2, 3, 4のいずれかなら、
座標のリストがそれぞれ、@code{[x,y]}, @code{[x,y,z]}, @code{[x,y,z,t]}に設定されます。
これらの名前は、座標の新しいリストを(以下で記述する)変数@code{ct_coords} に
割り当てることで変えることができ、ユーザーは、これについて尋ねられます。
座標名が他のオブジェクト定義と衝突することを避けるように、注意が払われなければいけません。

次に、ユーザーは計量を直接、または順序位置(ordinal position)を指定してファイルから、入力します。
@c NO SUCH FILE !
@c As an example of a file of common metrics, see @code{share/tensor/metrics.mac}.
計量は行列@code{lg}に保存されます。
最後に、計量の逆元が計算され、
行列@code{ug}に保存されます。
すべての計算を冪級数で実行するオプションがあります。

サンプルプロトコルは、
例として、(Schwarzschild解に至る)Einsteinの真空方程式を導出する問題に適用される
静的な球対称計量(標準座標)に関して、以下のように開始されます。
@code{ctensor}の関数の多くは例のように標準計量に対して表示されます。

@example
(%i1) load(ctensor);
(%o1)      /share/tensor/ctensor.mac
(%i2) csetup();
Enter the dimension of the coordinate system:
4;
Do you wish to change the coordinate names?
n;
Do you want to
1. Enter a new metric?

2. Enter a metric from a file?

3. Approximate a metric with a Taylor series?
1;

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;
Row 1 Column 1:
a;
Row 2 Column 2:
x^2;
Row 3 Column 3:
x^2*sin(y)^2;
Row 4 Column 4:
-d;

Matrix entered.
Enter functional dependencies with the DEPENDS function or 'N' if none
depends([a,d],x);
Do you wish to see the metric?
y;
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
                          [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%o2)                                done
(%i3) christof(mcs);
                                            a
                                             x
(%t3)                          mcs        = ---
                                  1, 1, 1   2 a

                                             1
(%t4)                           mcs        = -
                                   1, 2, 2   x

                                             1
(%t5)                           mcs        = -
                                   1, 3, 3   x

                                            d
                                             x
(%t6)                          mcs        = ---
                                  1, 4, 4   2 d

                                              x
(%t7)                          mcs        = - -
                                  2, 2, 1     a

                                           cos(y)
(%t8)                         mcs        = ------
                                 2, 3, 3   sin(y)

                                               2
                                          x sin (y)
(%t9)                      mcs        = - ---------
                              3, 3, 1         a

(%t10)                   mcs        = - cos(y) sin(y)
                            3, 3, 2

                                            d
                                             x
(%t11)                         mcs        = ---
                                  4, 4, 1   2 a
(%o11)                               done

@end example

@opencatbox
@category{Tensors}
@category{Share packages}
@category{Package ctensor}
@closecatbox

@c end concepts ctensor
@node Functions and Variables for ctensor,  , Introduction to ctensor, ctensor

@section Functions and Variables for ctensor

@subsection Initialization and setup

@deffn {関数} csetup ()
パッケージを初期化し、ユーザーに計量を対話的に入力可能にする
@code{ctensor}(成分テンソル)パッケージの関数
より詳細は@code{ctensor}を参照してください。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} cmetric (@var{dis})
@deffnx {関数} cmetric ()
計量の逆元を計算し、将来の計算のためパッケージを設定する
@code{ctensor}(成分テンソル)パッケージの関数

もし@code{cframe_flag}が@code{false}なら、
関数は逆計量@code{ug}を(ユーザー定義の)行列@code{lg}から計算します。
計量の行列式も計算され、変数@code{gdet}に保存されます。
更に、パッケージは計量が対角的か調べ、結果に従って@code{diagmetric}の値を設定します。
もしオプション引数@var{dis}が渡されて、それが@code{false}でないなら、
ユーザーは計量の逆元を見るように促されます。

もし@code{cframe_flag}が@code{true}なら、
関数は@code{fri} (逆標構行列)と@code{lfg}(標構計量)の値が定義されていると考えます。
これらから、標構行列@code{fr}と逆標構計量@code{ufg}が計算されます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} ct_coordsys (@var{coordinate_system}, @var{extra_arg})
@deffnx {関数} ct_coordsys (@var{coordinate_system})
あらかじめ定義された座標系と計量を設定します。
引数@var{coordinate_system}は以下のシンボルのいずれかです:

@example

 SYMBOL             Dim Coordinates     Description/comments
 ------------------------------------------------------------------
 cartesian2d           2  [x,y]             Cartesian 2D 座標系
 polar                 2  [r,phi]           極座標系
 elliptic              2  [u,v]             楕円座標系
 confocalelliptic      2  [u,v]             共焦点楕円座標
 bipolar               2  [u,v]             二極座標系
 parabolic             2  [u,v]             放物座標系
 cartesian3d           3  [x,y,z]           Cartesian 3D 座標系
 polarcylindrical      3  [r,theta,z]       円筒z極2D
 ellipticcylindrical   3  [u,v,z]           円筒z楕円2D
 confocalellipsoidal   3  [u,v,w]           共焦点楕円
 bipolarcylindrical    3  [u,v,z]           円筒z二極2D
 paraboliccylindrical  3  [u,v,z]           円筒z放物2D
 paraboloidal          3  [u,v,phi]         Paraboloidal coords.
 conical               3  [u,v,w]           円錐座標
 toroidal              3  [u,v,phi]         環状座標
 spherical             3  [r,theta,phi]     球座標系
 oblatespheroidal      3  [u,v,phi]         偏球座標系
 oblatespheroidalsqrt  3  [u,v,phi]
 prolatespheroidal     3  [u,v,phi]         長形球座標系
 prolatespheroidalsqrt 3  [u,v,phi]
 ellipsoidal           3  [r,theta,phi]     楕円体座標系
 cartesian4d           4  [x,y,z,t]         Cartesian 4D 座標系
 spherical4d           4  [r,theta,eta,phi] 球 4D 座標系
 exteriorschwarzschild 4  [t,r,theta,phi]   Schwarzschild 計量
 interiorschwarzschild 4  [t,z,u,v]         内部 Schwarzschild 計量
 kerr_newman           4  [t,r,theta,phi]   荷電軸対称計量
@end example

@code{coordinate_system}は
座標変数を含むリストが続く変換関数のリストでもあり得ます。
例えば、
以下のように球計量を指定できます:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o2)                                done
(%i3) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o3)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
(%i4) ct_coords;
(%o4)                           [r, theta, phi]
(%i5) dim;
(%o5)                                  3

@end example

@code{cframe_flag}が @code{true}の時
変換関数も使うことができます:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) cframe_flag:true;
(%o2)                                true
(%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o3)                                done
(%i4) fri;
(%o4)
 [cos(phi)cos(theta) -cos(phi) r sin(theta) -sin(phi) r cos(theta)]
 [                                                                ]
 [sin(phi)cos(theta) -sin(phi) r sin(theta)  cos(phi) r cos(theta)]
 [                                                                ]
 [    sin(theta)           r cos(theta)                0          ]

(%i5) cmetric();
(%o5)                                false
(%i6) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o6)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]

@end example

オプションの引数 @var{extra_arg}は以下のいずれかです:
@c LOOKING AT share/tensor/ctensor.mac CIRCA LINE 837, misner IS RECOGNIZED ALSO; WHAT EFFECT DOES IT HAVE ??

@code{cylindrical}は @code{ct_coordsys}に追加の極座標を結びつけるように言います。

@code{minkowski}は @code{ct_coordsys}に
負の計量符号を持つ追加の座標を結びつけるように言います。

@code{all}は @code{ct_coordsys}に
計量を設定した後、
@code{cmetric}と @code{christof(false)}をコールするように言います。

@c GLOBAL VARIABLE verbose IS USED IN ctensor.mac IN JUST THIS ONE CONTEXT
もしグローバル変数 @code{verbose}が @code{true}に設定されているなら、
@code{ct_coordsys}は、
 @code{cframe_flag}の値に依存して、
@code{dim}, @code{ct_coords}と、 @code{lg}か @code{lfg}のいずれかと
@code{fri}の値を表示します。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} init_ctensor ()
@code{ctensor}パッケージを初期化します。

@code{init_ctensor}関数は@code{ctensor}パッケージを再初期化します。
それは@code{ctensor}が使う配列、行列すべてを削除し、
フラグすべてをリセットし、
@code{dim}を4にリセットし、
標構計量を Lorentz標構にリセットします。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn


@subsection The tensors of curved space

@code{ctensor}パッケージの
主な目的は曲がった空間(時間)のテンソル、
最も顕著には一般相対性理論で使われるテンソルを計算することです。

計量基底が使われる時、
@code{ctensor}は以下のテンソルを計算できます:

@example

 lg  -- ug
   \      \
    lcs -- mcs -- ric -- uric
              \      \       \
               \      tracer - ein -- lein
                \
                 riem -- lriem -- weyl
                     \
                      uriem


@end example

@code{ctensor}は動標構を使って機能することもできます。
@code{cframe_flag}が @code{true}に設定されている時、
以下のテンソルを計算できます:

@example

 lfg -- ufg
     \
 fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
      \                       |  \      \       \
       lg -- ug               |   weyl   tracer - ein -- lein
                              |\
                              | riem
                              |
                              \uriem

@end example

@deffn {関数} christof (@var{dis})
@code{ctensor} (成分テンソル)パッケージの関数。
各種Christoffel記号を計算します。
引数 @var{dis}は
どの結果をすぐに表示するか決めます。
第一種と第二種Christoffel記号は
それぞれ配列 @code{lcs[i,j,k]}と @code{mcs[i,j,k]}に格納され、
最初の2つの添字に対して対称と定義されます。
もし @code{christof}の引数が @code{lcs}か @code{mcs}なら
それぞれ、@code{lcs[i,j,k]}か @code{mcs[i,j,k]}の固有の非零値が
表示されます。
もし引数が @code{all}なら、
@code{lcs[i,j,k]}と @code{mcs[i,j,k]}の固有の非零値が表示されます。
もし引数が @code{false}なら、
要素の表示はされません。
配列要素 @code{mcs[i,j,k]}は
最後の添字が反変であるような方法で定義されます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} ricci (@var{dis})
@code{ctensor} (成分テンソル)パッケージの関数。
@code{ricci}は
Ricciテンソルの共変(対称)成分 @code{ric[i,j]}を計算します。
もし引数 @var{dis}が @code{true}なら、
非零成分が表示されます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} uricci (@var{dis})
この関数は最初にRicciテンソルの共変成分 @code{ric[i,j]}を計算します。
そして、混合 Ricciテンソルが反変計量テンソルを使って計算されます。
もし引数 @var{dis}の値が @code{true}なら
これらの(添字 @code{i}は共変で、添字 @code{j}は反変の)混合成分 @code{uric[i,j]} 
は直接表示されます。
そうでないなら、 @code{ricci(false)}は
結果を表示することなく、単に配列 @code{uric[i,j]}の要素を計算します。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} scurvature ()
与えられた計量を持つ Riemannian多様体の
(Ricciテンソルを縮約することで得られる)スカラ曲率を返します。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} einstein (@var{dis})
@code{ctensor} (成分テンソル)パッケージの関数。
@code{einstein}は、
(関数 @code{christof}と @code{ricci}を使って)
Christoffel記号と Ricciテンソルを得られた後、
混合 Einsteinテンソルを計算します。
もし引数 @var{dis}が @code{true}なら、
混合 Einsteinテンソル @code{ein[i,j]}の非零値が表示されます。
ここで @code{j}は反変添字です。
変数 @code{rateinstein}は
これらの成分上の有理整理をもたらします。
もし @code{ratfac}が @code{true}なら、
成分は因数分解もされます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} leinstein (@var{dis})
共変 Einsteinテンソル。
@code{leinstein}は
配列 @code{lein}に共変 Einsteinテンソルの値を格納します。
共変 Einsteinテンソルは、
計量テンソルを掛けることで
混合 Einsteinテンソル @code{ein}から計算されます。
もし引数 @var{dis}が @code{true}なら、
共変 Einsteinテンソルの非零値が表示されます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} riemann (@var{dis})
@code{ctensor} (成分テンソル)パッケージの関数。
@code{riemann}は
与えられた計量と対応するChristoffel記号から
Riemann曲率テンソルを計算します。
以下の添字慣例が使われます:

@example
                l      _l       _l       _l   _m    _l   _m
 R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                ijk     ij,k     ik,j     mk   ij    mj   ik
@end example

この表記法は
@code{itensor}パッケージとその @code{icurvature}関数で使われる表記法と
一致しています。
もしオプション引数 @var{dis}が @code{true}なら、
固有の非零成分 @code{riem[i,j,k,l]}が表示されます。
Einsteinテンソルと同様に
ユーザーが設定する様々なスイッチが
Riemannテンソルの成分の整理を制御します。
もし @code{ratriemann}が @code{true}なら、
有理整理がされます。
もし @code{ratfac}が @code{true}なら、
成分のそれぞれは因数分解もされます。

もし変数 @code{cframe_flag}が @code{false}なら、
Riemannテンソルは
Christoffel記号から直接計算されます。
もし @code{cframe_flag}が @code{true}なら、
共変 Riemannテンソルは
標構場係数から最初に計算されます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} lriemann (@var{dis})
共変 Riemannテンソル (@code{lriem[]}).

配列 @code{lriem}として
共変 Riemannテンソルを計算します。
もし引数 @var{dis}が @code{true}なら、
固有の非零値が表示されます。

もし変数 @code{cframe_flag}が @code{true}なら、
共変 Riemannテンソルは
標構場係数から直接計算されます。
そうでないなら、
(3,1) Riemannテンソルが最初に計算されます。

添字順序の情報は @code{riemann}を参照してください。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} uriemann (@var{dis})
配列要素 @code{uriem[i,j,k,l]}として
Riemann曲率テンソルの反変成分を計算します。
もし @var{dis}が @code{true}なら、これらが表示されます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} rinvariant ()
テンソル
@example
lriem[i,j,k,l]*uriem[i,j,k,l].
@end example
を縮約することで得られるKretschmann不変量 (@code{kinvariant})を形成します。

このオブジェクトは非常に大きくなるかもしれないので、
自動的には整理されません。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} weyl (@var{dis})
Weylの共形テンソルを計算します。
もし引数 @var{dis}が @code{true}なら、
非零成分 @code{weyl[i,j,k,l]}がユーザーに表示されます。
そうでないなら、これらの成分は
単に計算され、格納されます。
もしスイッチ @code{ratweyl}が @code{true}に設定されているなら、
成分は有理整理されます;
もし @code{ratfac}が @code{true}なら、
結果は因数分解もされます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@subsection Taylor series expansion

@code{ctensor}パッケージは
結果が Taylor級数近似であると仮定することで、結果を切り詰める機能を持ちます。
この振る舞いは @code{ctayswitch}変数で制御されます;
trueに設定されている時、 
結果を整理する際に
@code{ctensor}は内部的に関数 @code{ctaylor}を利用します。

以下の @code{ctensor}関数が @code{ctaylor}関数を呼び出します:

@example

    Function     Comments
    ---------------------------------
    christof()   For mcs only
    ricci()
    uricci()
    einstein()
    riemann()
    weyl()
    checkdiv()
@end example

@deffn {関数} ctaylor ()

@code{ctaylor}関数は、
@code{taylor}を使ってその後@code{ratdisrep}をコールすることで
引数をTaylor級数に変換することで、
引数を切り詰めます。
これは
展開変数 @code{ctayvar}に関してより高い項を落とす合わせ効果を持ちます。
落とす項の次数は@code{ctaypov}で定義されます;
級数展開が実行される点は
@code{ctaypt}で指定されます。

例として、
Minkowski計量の置換である簡単な計量を考えます。
追加の制約なしでは、
対角計量でさえ
はるかに複雑すぎるEinsteinテンソルの式を生成します:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) derivabbrev:true;
(%o3)                                true
(%i4) ct_coords:[t,r,theta,phi];
(%o4)                         [t, r, theta, phi]
(%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],
                [0,0,0,r^2*sin(theta)^2]);
                        [ - 1  0  0         0        ]
                        [                            ]
                        [  0   1  0         0        ]
                        [                            ]
(%o5)                   [          2                 ]
                        [  0   0  r         0        ]
                        [                            ]
                        [              2    2        ]
                        [  0   0  0   r  sin (theta) ]
(%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                            [ h11   0    0    0  ]
                            [                    ]
                            [  0   h22   0    0  ]
(%o6)                       [                    ]
                            [  0    0   h33   0  ]
                            [                    ]
                            [  0    0    0   h44 ]
(%i7) depends(l,r);
(%o7)                               [l(r)]
(%i8) lg:lg+l*h;
      [ h11 l - 1      0          0                 0            ]
      [                                                          ]
      [     0      h22 l + 1      0                 0            ]
      [                                                          ]
(%o8) [                        2                                 ]
      [     0          0      r  + h33 l            0            ]
      [                                                          ]
      [                                    2    2                ]
      [     0          0          0       r  sin (theta) + h44 l ]
(%i9) cmetric(false);
(%o9)                                done
(%i10) einstein(false);
(%o10)                               done
(%i11) ntermst(ein);
[[1, 1], 62]
[[1, 2], 0]
[[1, 3], 0]
[[1, 4], 0]
[[2, 1], 0]
[[2, 2], 24]
[[2, 3], 0]
[[2, 4], 0]
[[3, 1], 0]
[[3, 2], 0]
[[3, 3], 46]
[[3, 4], 0]
[[4, 1], 0]
[[4, 2], 0]
[[4, 3], 0]
[[4, 4], 46]
(%o12)                               done

@end example

しかし、もしこの例を
変数 @code{l}に対して線形という近似として
再研鑽するなら、
もっと簡潔な式を得ます:

@example

(%i14) ctayswitch:true;
(%o14)                               true
(%i15) ctayvar:l;
(%o15)                                 l
(%i16) ctaypov:1;
(%o16)                                 1
(%i17) ctaypt:0;
(%o17)                                 0
(%i18) christof(false);
(%o18)                               done
(%i19) ricci(false);
(%o19)                               done
(%i20) einstein(false);
(%o20)                               done
(%i21) ntermst(ein);
[[1, 1], 6]
[[1, 2], 0]
[[1, 3], 0]
[[1, 4], 0]
[[2, 1], 0]
[[2, 2], 13]
[[2, 3], 2]
[[2, 4], 0]
[[3, 1], 0]
[[3, 2], 2]
[[3, 3], 9]
[[3, 4], 0]
[[4, 1], 0]
[[4, 2], 0]
[[4, 3], 0]
[[4, 4], 9]
(%o21)                               done
(%i22) ratsimp(ein[1,1]);
                         2      2  4               2     2
(%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                              r               r r

                            2               2      4    2
              - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                       r r                r



@end example

この能力は
例えば、
重力源から遠く、弱い場極限で取り組む時に
役に立つかもしれません。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn


@subsection Frame fields

変数 @code{cframe_flag}が trueに設定している時、
@code{ctensor}パッケージは
動標構(moving frame)を使って計算を実行します。

@deffn {関数} frame_bracket (@var{fr}, @var{fri}, @var{diagframe})
標構(frame)ブラケット (@code{fb[]}).

以下の定義に従って標構ブラケットを計算します:

@example
   c          c         c        d     e
ifb   = ( ifri    - ifri    ) ifr   ifr
   ab         d,e       e,d      a     b
@end example

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@subsection Algebraic classification

@code{ctensor}の(2004年11月時点で)新しい特長は
4次元時空計量のPetrov分類を計算する能力です。
この機能のデモンストレーションは、
ファイル @code{share/tensor/petrov.dem}参照してください。

@deffn {関数} nptetrad ()
Newman-Penroseヌルテトラド(null tetrad) (@code{np})と上付き添字対応物
 (@code{npi})を計算します。
例えば、 @code{petrov}を参照してください。

ヌルテトラドは
計量符号 (-,+,+,+)を持つ4次元直交標構計量が使われいるという仮定の上で
構成されます。
ヌルテトラドの成分は、
以下のように、
逆標構行列に関係します:

@example

np  = (fri  + fri ) / sqrt(2)
  1       1      2

np  = (fri  - fri ) / sqrt(2)
  2       1      2

np  = (fri  + %i fri ) / sqrt(2)
  3       3         4

np  = (fri  - %i fri ) / sqrt(2)
  4       3         4

@end example

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} psi (@var{dis})
5つの Newman-Penrose係数 @code{psi[0]}...@code{psi[4]}を計算します。
もし @code{dis}が @code{true}に設定されているなら、
係数が表示されます。
例は @code{petrov}を参照してください。

これらの係数は
座標基底に関して、Weylテンソルから計算されます。
もし標構基底が使われるなら、
最初にWeylテンソルが座標基底に変換されます。
座標基底は計算に関して高価な手続きであり得ます。
この理由で、
いくつかの場合、
Weylテンソルを計算する前に
まず座標基底を使うことはより都合がいいかも知れません。
しかし、
Newman-Penroseヌルテトラドを構成することは標構基底を要求することに注意してください。
それ故に、
重要な一連の計算は、標構基底で始めることができます。
標構基底は、後で (@code{cmetric}が自動的に計算する) @code{lg}と
 @code{ug}を計算するのに使われます。
この時点で、
Christoffel記号を計算し始める前に
@code{cframe_flag}を falseに設定することで
座標基底に戻ることができます。
後の段階で標構基底に変えることは、
標構基底で計算したいくつか、座標基底でのいくつかと
2つを識別する方法がないまま、テンソルの混ざった状態で終わるかもしれないので、
矛盾する結果をもたらすかもしれません。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} petrov ()
@code{psi[0]}...@code{psi[4]}で特徴付けられる
計量のPetrov分類を計算します。

例えば、以下は
Kerr計量の Petrov分類を得る方法を例示します:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) ug:invert(lg)$
(%i5) weyl(false);
(%o5)                                done
(%i6) nptetrad(true);
(%t6) np =

[ sqrt(r - 2 m)           sqrt(r)                                 ]
[---------------   ---------------------    0            0        ]
[sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                          ]
[                                                                 ]
[ sqrt(r - 2 m)            sqrt(r)                                ]
[---------------  - ---------------------   0            0        ]
[sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                         ]
[                                                                 ]
[                                          r      %i r sin(theta) ]
[       0                    0          -------   --------------- ]
[                                       sqrt(2)       sqrt(2)     ]
[                                                                 ]
[                                          r       %i r sin(theta)]
[       0                    0          -------  - ---------------]
[                                       sqrt(2)        sqrt(2)    ]

                             sqrt(r)         sqrt(r - 2 m)
(%t7) npi = matrix([- ---------------------,---------------, 0, 0],
                      sqrt(2) sqrt(r - 2 m) sqrt(2) sqrt(r)

          sqrt(r)            sqrt(r - 2 m)
[- ---------------------, - ---------------, 0, 0],
   sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

           1               %i
[0, 0, ---------, --------------------],
       sqrt(2) r  sqrt(2) r sin(theta)

           1                 %i
[0, 0, ---------, - --------------------])
       sqrt(2) r    sqrt(2) r sin(theta)

(%o7)                                done
(%i7) psi(true);
(%t8)                              psi  = 0
                                      0

(%t9)                              psi  = 0
                                      1

                                          m
(%t10)                             psi  = --
                                      2    3
                                          r

(%t11)                             psi  = 0
                                      3

(%t12)                             psi  = 0
                                      4
(%o12)                               done
(%i12) petrov();
(%o12)                                 D

@end example

Petrov分類関数は以下の文献で発表されたアルゴリズムに基づいています。

"Classifying geometries in general relativity: III Classification in practice"
by Pollney, Skea, and d'Inverno, Class. Quant. Grav. 17 2885-2902 (2000).

いくつかの簡単なテストケースを除いて、
2004年12月19日時点、実装はテストされていなく、
エラーを含みそうです。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn


@subsection Torsion and nonmetricity

@code{ctensor}は
ねじれ係数と非計量性係数を計算し、接続係数内に含める能力を持ちます。

ねじれ係数はゆーざーが供給するテンソル @code{tr}から計算されます。
@code{tr}は階数 (2,1)テンソルでなければいけません。
これから、
ねじれ係数 @code{kt}は以下の公式に従って計算されます:

@example

              m          m      m
       - g  tr   - g   tr   - tr   g
          im  kj    jm   ki     ij  km
kt   = -------------------------------
  ijk                 2


  k     km
kt   = g   kt
  ij         ijm

@end example

混合添字テンソルだけが計算され、配列 @code{kt}に格納されることに注意してください。

非計量性係数はユーザーが供給する非計量性ベクトル @code{nm}から計算されます。
これから、
非計量性係数 @code{nmc}は以下のように計算されます:

@example

             k    k        km
       -nm  D  - D  nm  + g   nm  g
   k      i  j    i   j         m  ij
nmc  = ------------------------------
   ij                2

@end example

ここで、DはKroneckerのデルタを表します。

@code{ctorsion_flag}が @code{true}に設定されている時、
@code{kt}の値が
@code{christof}で計算された
混合添字付き接続係数から引かれ、
@code{mcs}に格納されます。
同様に、もし @code{cnonmet_flag}が @code{true}に設定されているなら、
@code{nmc}の値が
混合添字付き接続係数から引かれます。

もし必要なら、 @code{christof}は、
@code{kt}と @code{nm}を計算するために
関数 @code{contortion}と @code{nonmetricity}をコールします。

@deffn {関数} contortion (@var{tr})

ねじれテンソル @var{tr}から(2,1)コントーション(contortion)係数を計算します。


@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} nonmetricity (@var{nm})

非計量性ベクトル @var{nm}から(2,1)非計量性係数を計算します。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn



@subsection Miscellaneous features

@deffn {関数} ctransform (@var{M})
任意の平方対称行列 @var{M}上で座標変換を実行する
@code{ctensor} (成分テンソル)パッケージの関数。
ユーザーは変換を定義する函数を入力しなければいけません。
(以前@code{transform}と呼ばれていました。)

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} findde (@var{A}, @var{n})

@var{n}次元の平方配列 @var{A}要素に対応する
独自の(unique)微分方程式(式)のリストを返します。
現在、 @var{n}は2か3を指定できます
@code{deindex}は
これらの独自の微分方程式に従う
@var{A}の添字を含む
グローバルリストです。
2次元配列であるEinsteinテンソル (@code{ein})に関して、
もし以下の例で計量に関して計算するなら、
@code{findde}は以下の独立微分方程式を与えます:


@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) dim:4;
(%o3)                                  4
(%i4) lg:matrix([a, 0, 0, 0], [ 0, x^2, 0, 0],
                              [0, 0, x^2*sin(y)^2, 0], [0,0,0,-d]);
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
(%o4)                     [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%i5) depends([a,d],x);
(%o5)                            [a(x), d(x)]
(%i6) ct_coords:[x,y,z,t];
(%o6)                            [x, y, z, t]
(%i7) cmetric();
(%o7)                                done
(%i8) einstein(false);
(%o8)                                done
(%i9) findde(ein,2);
                                            2
(%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x
        x                     x x         x        x    x

                                              2          2
                          + 2 a d d   - 2 a  d , a  x + a  - a]
                                   x       x      x
(%i10) deindex;
(%o10)                     [[1, 1], [2, 2], [4, 4]]
@end example

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} cograd ()
スカラ関数の
共変勾配を計算します。
@code{contragrad}が以下で例示する例のように
ユーザーは対応するベクトル名を選べます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} contragrad ()

スカラ関数の反変勾配を計算します。
Computes the contravariant gradient of a scalar function allowing
@c "vector^F2name^F*" LOOKS LIKE IT NEEDS TO BE FIXED UP, NOT SURE HOW THOUGH
Schwarzschild計量に関する以下の例が例示するように
ユーザーは対応するベクトル名を選べます:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(f,r);
(%o4)                               [f(r)]
(%i5) cograd(f,g1);
(%o5)                                done
(%i6) listarray(g1);
(%o6)                            [0, f , 0, 0]
                                      r
(%i7) contragrad(f,g2);
(%o7)                                done
(%i8) listarray(g2);
                               f  r - 2 f  m
                                r        r
(%o8)                      [0, -------------, 0, 0]
                                     r
@end example

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} dscalar ()
依存性が関数に宣言されるとすぐ、
スカラ関数のテンソルd'Alembert演算子を計算します。
例えば:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(p,r);
(%o4)                               [p(r)]
(%i5) factor(dscalar(p));
@group
                          2
                    p    r  - 2 m p    r + 2 p  r - 2 m p
                     r r           r r        r          r
(%o5)               --------------------------------------
                                       2
                                      r
@end group
@end example

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} checkdiv ()

ベクトル場(発散)の対応するn個の成分を印字することで
(最初の添字が共変でなければいけない)混合二階テンソルの共変発散を計算します。
ここでn = @code{dim}です。
もし関数の引数が @code{g}なら、
Einsteinテンソルの発散が形成され、零にならなければいけません。
加えて、発散(ベクトル)は
配列名 @code{div}を与えられます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} cgeodesic (@var{dis})
@code{ctensor} (成分テンソル)パッケージの関数。
@code{cgeodesic}は
与えられた計量での運動の測地方程式を計算します。
それらは配列 @code{geod[i]}に格納されます。
もし引数 @var{dis}が @code{true}なら、
これらの方程式が表示されます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn


@deffn {関数} bdvac (@var{f})

Brans- Dicke重力理論の
真空場の方程式の
共変成分を生成します。
スカラ場は引数 @var{f}で指定されます。
@var{f}は、
例えば、@code{'p(x)}のように、
関数依存性を持つ(クォートされた)関数名でなければいけません。

二階共変場テンソルの成分は配列 @code{bd}で表されます。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} invariant1 ()

R^2の不変密度に関する
混合Euler- Lagrangeテンソル(場の方程式)を生成します。
場の方程式は @code{inv1}と名付けられた配列の成分です。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} invariant2 ()

*** NOT YET IMPLEMENTED ***

@code{ric[i,j]*uriem[i,j]}の不変密度に関する
混合Euler- Lagrangeテンソル(場の方程式)を生成します。
場の方程式は @code{inv2}と名付けられた配列の成分です。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn
@deffn {関数} bimetric ()

*** NOT YET IMPLEMENTED ***

Rosenの二計量(bimetric)理論の場の方程式を生成します。
場の方程式は @code{rosen}と名付けられた配列の成分です。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@subsection Utility functions

@deffn {関数} diagmatrixp (@var{M})

もし @var{M}が対角行列か対角 (2D) 配列なら
@code{true}を返します。

@opencatbox
@category{Package ctensor}
@category{Predicate functions}
@closecatbox

@end deffn

@deffn {関数} symmetricp (@var{M})

もし @var{M}が対称行列か対称 (2D) 配列なら
@code{true}を返します。

@opencatbox
@category{Package ctensor}
@category{Predicate functions}
@closecatbox

@end deffn

@deffn {関数} ntermst (@var{f})
ユーザーに
二重に下付き添字テンソル(配列) @var{f}の「サイズ」のquick pictureを与えます。
二番目の要素が
一番目の要素が指定する成分のNTERMSに対応する2つの要素のリストを印字します。
この方法で、
非零式をすばやく見つけて整理を試みることが可能です。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} cdisplay (@var{ten})
多次元配列で表されるように、
テンソル @var{ten}の要素すべてを表示します。
他のタイプの変数はもちろん、
階数0と1のテンソルが
@code{ldisplay}を使ったように表示されます。
階数2のテンソルは
2次元行列として表示され、
より高い階数のテンソルは2次元行列のリストとして表示されます。
例えば、
Schwarzschild計量のRiemannテンソルは以下のように見ることができます:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) riemann(false);
(%o4)                                done
(%i5) cdisplay(riem);
          [ 0               0                   0           0     ]
          [                                                       ]
          [                              2                        ]
          [      3 m (r - 2 m)   m    2 m                         ]
          [ 0  - ------------- + -- - ----      0           0     ]
          [            4          3     4                         ]
          [           r          r     r                          ]
          [                                                       ]
riem    = [                                m (r - 2 m)            ]
    1, 1  [ 0               0              -----------      0     ]
          [                                     4                 ]
          [                                    r                  ]
          [                                                       ]
          [                                           m (r - 2 m) ]
          [ 0               0                   0     ----------- ]
          [                                                4      ]
          [                                               r       ]

                                [    2 m (r - 2 m)       ]
                                [ 0  -------------  0  0 ]
                                [          4             ]
                                [         r              ]
                     riem     = [                        ]
                         1, 2   [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]

                                [         m (r - 2 m)    ]
                                [ 0  0  - -----------  0 ]
                                [              4         ]
                                [             r          ]
                     riem     = [                        ]
                         1, 3   [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]

                                [            m (r - 2 m) ]
                                [ 0  0  0  - ----------- ]
                                [                 4      ]
                                [                r       ]
                     riem     = [                        ]
                         1, 4   [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]

                               [       0         0  0  0 ]
                               [                         ]
                               [       2 m               ]
                               [ - ------------  0  0  0 ]
                    riem     = [    2                    ]
                        2, 1   [   r  (r - 2 m)          ]
                               [                         ]
                               [       0         0  0  0 ]
                               [                         ]
                               [       0         0  0  0 ]

             [     2 m                                         ]
             [ ------------  0        0               0        ]
             [  2                                              ]
             [ r  (r - 2 m)                                    ]
             [                                                 ]
             [      0        0        0               0        ]
             [                                                 ]
  riem     = [                         m                       ]
      2, 2   [      0        0  - ------------        0        ]
             [                     2                           ]
             [                    r  (r - 2 m)                 ]
             [                                                 ]
             [                                         m       ]
             [      0        0        0         - ------------ ]
             [                                     2           ]
             [                                    r  (r - 2 m) ]

                                [ 0  0       0        0 ]
                                [                       ]
                                [            m          ]
                                [ 0  0  ------------  0 ]
                     riem     = [        2              ]
                         2, 3   [       r  (r - 2 m)    ]
                                [                       ]
                                [ 0  0       0        0 ]
                                [                       ]
                                [ 0  0       0        0 ]

                                [ 0  0  0       0       ]
                                [                       ]
                                [               m       ]
                                [ 0  0  0  ------------ ]
                     riem     = [           2           ]
                         2, 4   [          r  (r - 2 m) ]
                                [                       ]
                                [ 0  0  0       0       ]
                                [                       ]
                                [ 0  0  0       0       ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [ m          ]
                               3, 1   [ -  0  0  0 ]
                                      [ r          ]
                                      [            ]
                                      [ 0  0  0  0 ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [    m       ]
                               3, 2   [ 0  -  0  0 ]
                                      [    r       ]
                                      [            ]
                                      [ 0  0  0  0 ]

                               [   m                      ]
                               [ - -   0   0       0      ]
                               [   r                      ]
                               [                          ]
                               [        m                 ]
                               [  0   - -  0       0      ]
                    riem     = [        r                 ]
                        3, 3   [                          ]
                               [  0    0   0       0      ]
                               [                          ]
                               [              2 m - r     ]
                               [  0    0   0  ------- + 1 ]
                               [                 r        ]

                                    [ 0  0  0    0   ]
                                    [                ]
                                    [ 0  0  0    0   ]
                                    [                ]
                         riem     = [            2 m ]
                             3, 4   [ 0  0  0  - --- ]
                                    [             r  ]
                                    [                ]
                                    [ 0  0  0    0   ]

                                [       0        0  0  0 ]
                                [                        ]
                                [       0        0  0  0 ]
                                [                        ]
                     riem     = [       0        0  0  0 ]
                         4, 1   [                        ]
                                [      2                 ]
                                [ m sin (theta)          ]
                                [ -------------  0  0  0 ]
                                [       r                ]

                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                     riem     = [ 0        0        0  0 ]
                         4, 2   [                        ]
                                [         2              ]
                                [    m sin (theta)       ]
                                [ 0  -------------  0  0 ]
                                [          r             ]

                              [ 0  0          0          0 ]
                              [                            ]
                              [ 0  0          0          0 ]
                              [                            ]
                   riem     = [ 0  0          0          0 ]
                       4, 3   [                            ]
                              [                2           ]
                              [         2 m sin (theta)    ]
                              [ 0  0  - ---------------  0 ]
                              [                r           ]

           [        2                                             ]
           [   m sin (theta)                                      ]
           [ - -------------         0                0         0 ]
           [         r                                            ]
           [                                                      ]
           [                         2                            ]
           [                    m sin (theta)                     ]
riem     = [        0         - -------------         0         0 ]
    4, 4   [                          r                           ]
           [                                                      ]
           [                                          2           ]
           [                                   2 m sin (theta)    ]
           [        0                0         ---------------  0 ]
           [                                          r           ]
           [                                                      ]
           [        0                0                0         0 ]

(%o5)                                done

@end example

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@deffn {関数} deleten (@var{L}, @var{n})
@var{n}番目の要素を削除した@var{L}から成る新しいリストを返します。

@opencatbox
@category{Package ctensor}
@closecatbox
@end deffn

@subsection Variables used by @code{ctensor}


@defvr {オプション変数} dim
デフォルト値: 4

@code{ctensor} (成分テンソル)パッケージのオプション。
@code{dim}は
デフォルト4の多様体の次元です。
コマンド @code{dim: n}は
次元を任意の別の値 @code{n}に再設定します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} diagmetric
デフォルト値: @code{false}

@code{ctensor} (成分テンソル)パッケージのオプション。
もし @code{diagmetric}が @code{true}なら、
特殊なルーチンが
計量の対角性を考慮して
(計量テンソルを明示的に含む)幾何的オブジェクトすべてを
計算します。
もちろん、実行時間短縮になります。
注意: 
もし対角計量が指定されたら、
@code{csetup}は自動的にこのオプションを設定します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} ctrgsimp

テンソルを計算する時、三角関数整理を使うようにします。
現在、
@code{ctrgsimp}は
動標構を含む計算だけに影響します。

@opencatbox
@category{Package ctensor}
@category{Simplification flags and variables}
@closecatbox

@end defvr

@defvr {オプション変数} cframe_flag

計算を
ホロノミック(holonomic)計量と対比して動標構に関係して実行するようにします。
標構は逆標構配列 @code{fri}と標構計量 @code{lfg}で定義されます。
Cartesian標構を使う計算に関して、
@code{lfg}は適切な次元の単位行列でなければいけません;
Lorentz標構での計算に関して、
@code{lfg}は適切な符号を持たなければいけません。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} ctorsion_flag

コントーションテンソルが
接続係数の計算に含まれるようにします。
コントーションテンソル自体は
ユーザーが提供するテンソル @code{tr}から
@code{contortion}によって計算されます。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} cnonmet_flag

非計量性係数が
接続係数の計算に含まれるようにします。
コントーションテンソルは
ユーザーが提供する非計量性ベクトル @code{nm}から
関数 @code{nonmetricity}によって計算されます。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} ctayswitch

もし @code{true}に設定されているなら、
いくつかの @code{ctensor}計算が
Taylor級数展開を使って実行されるようにします。
現在、 @code{christof}, @code{ricci}, @code{uricci}, @code{einstein},
@code{weyl}がこの設定を考慮します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} ctayvar

 @code{ctayswitch}が @code{true}に設定されているなら
Taylor級数展開で使われる変数。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} ctaypov

@code{ctayswitch}が @code{true}に設定されている時
Taylor級数展開で使われる最大べき数

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} ctaypt

@code{ctayswitch}が @code{true}に設定されている時
Taylor級数展開が実行される点。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {システム変数} gdet

計量テンソル @code{lg}の行列式。
@code{cframe_flag}が @code{false}に設定されている時、
@code{cmetric}によって計算されます。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} ratchristof

@code{christof}が有理整理を適用するようにします。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} rateinstein
デフォルト値: @code{true}

もし @code{true}なら、
Einsteinテンソルの非零成分上で
有理整理が実行されます;
もし
@code{ratfac}が @code{true}なら、
成分は因数分解もされます。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr
@defvr {オプション変数} ratriemann
デフォルト値: @code{true}

Riemannテンソルの整理を制御するスイッチの1つです;
もし @code{true}なら、
有理整理がされます;
もし @code{ratfac}が @code{true}なら、
成分それぞれは因数分解もされます。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} ratweyl
デフォルト値: @code{true}

もし @code{true}なら、
このスイッチは,
@code{weyl}関数が
Weylテンソルの値に有理整理を適用するようにします。
もし@code{ratfac}が @code{true}なら、
成分は因数分解もされます。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} lfg
共変標構計量。
デフォルトでは、
符号 (+,+,+,-)を持つ4次元Lorentz標構に初期化されます。
@code{cframe_flag}が @code{true}の時使われます。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} ufg
逆標構計量。
@code{cframe_flag}が @code{true}に設定されているなら、
@code{cmetric}がコールされた時
@code{lfg}から計算されます。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} riem
(3,1) Riemannテンソル。
関数 @code{riemann}が呼び出された時計算されます。
添字順序についての情報については、
@code{riemann}の記述を参照してください。

もし @code{cframe_flag}が @code{true}なら、
@code{riem}は
共変Riemannテンソル @code{lriem}から計算されます。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} lriem

共変Riemannテンソル。
@code{lriemann}が計算します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} uriem

反変Riemannテンソル。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} ric

混合Ricciテンソル。
@code{ricci}が計算します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} uric

反変Ricciテンソル。
@code{ricci}が計算します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} lg

計量テンソル。
このテンソルは
他の計算が実行される前に
(@code{dim}掛け @code{dim}行列として)指定されなければいけません。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} ug

計量テンソルの逆元。
@code{cmetric}が計算します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} weyl

Weylテンソル。
@code{weyl}が計算します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} fb

@code{frame_bracket}によって計算される、
標構ブラケット係数。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} kinvariant

Kretchmann不変量。
@code{rinvariant}が計算します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} np

Newman-Penroseヌルテトラド。
@code{nptetrad}が計算します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} npi

上付き添字 Newman-Penroseヌルテトラド。
@code{nptetrad}が計算します。
@code{ug.np}として定義されます。
積 @code{np.transpose(npi)}は定数です:

@example
(%i39) trigsimp(np.transpose(npi));
                              [  0   - 1  0  0 ]
                              [                ]
                              [ - 1   0   0  0 ]
(%o39)                        [                ]
                              [  0    0   0  1 ]
                              [                ]
                              [  0    0   1  0 ]
@end example

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {変数} tr

ユーザーが提供するねじれを表す階数3のテンソル
@code{contortion}が使います。

@opencatbox
@category{Package ctensor}
@closecatbox
@end defvr

@defvr {変数} kt

コントーションテンソル。
@code{contortion}が @code{tr}から計算します。

@opencatbox
@category{Package ctensor}
@closecatbox
@end defvr

@defvr {変数} nm

ユーザーが提供する非計量性ベクトル。
@code{nonmetricity}が使います。

@opencatbox
@category{Package ctensor}
@closecatbox
@end defvr

@defvr {変数} nmc

@code{nonmetricity}が @code{nm}から計算する
非計量性係数。


@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {システム変数} tensorkill

テンソルパッケージが初期化されたかを示す変数。
@code{csetup}が設定し使います。
@code{init_ctensor}が再設定します。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@defvr {オプション変数} ct_coords
デフォルト値: @code{[]}

@code{ctensor} (成分テンソル)パッケージのオプション。
@code{ct_coords}は座標のリストを含みます。
関数 @code{csetup}がコールされる時通常定義される一方、
割り当て @code{ct_coords: [j1, j2, ..., jn]}で座標を再定義できます。
ここで、jは新しい座標名です。
@code{csetup}も参照してください。

@opencatbox
@category{Package ctensor}
@closecatbox

@end defvr

@subsection Reserved names

@code{ctensor}パッケージによって
以下の名前が内部的に使われます。
なので再定義してはいけません:

@example
  Name         Description
  ---------------------------------------------------------------------
  _lg()        Evaluates to lfg if frame metric used, lg otherwise
  _ug()        Evaluates to ufg if frame metric used, ug otherwise
  cleanup()    Removes items drom the deindex list
  contract4()  Used by psi()
  filemet()    Used by csetup() when reading the metric from a file
  findde1()    Used by findde()
  findde2()    Used by findde()
  findde3()    Used by findde()
  kdelt()      Kronecker-delta (not generalized)
  newmet()     Used by csetup() for setting up a metric interactively
  setflags()   Used by init_ctensor()
  readvalue()
  resimp()
  sermet()     Used by csetup() for entering a metric as Taylor-series
  txyzsum()
  tmetric()    Frame metric, used by cmetric() when cframe_flag:true
  triemann()   Riemann-tensor in frame base, used when cframe_flag:true
  tricci()     Ricci-tensor in frame base, used when cframe_flag:true
  trrc()       Ricci rotation coefficients, used by christof()
  yesp()
@end example


@subsection Changes

2004年11月に @code{ctensor}パッケージは広範囲に渡って書き直されました。
多くの関数と変数は、パッケージにMacsymaの商用版との互換性を持たせるために、
リネームされました。


@example
  New Name     Old Name        Description
  ---------------------------------------------------------------------
  ctaylor()    DLGTAYLOR()     Taylor-series expansion of an expression
  lgeod[]      EM              Geodesic equations
  ein[]        G[]             Mixed Einstein-tensor
  ric[]        LR[]            Mixed Ricci-tensor
  ricci()      LRICCICOM()     Compute the mixed Ricci-tensor
  ctaypov      MINP            Maximum power in Taylor-series expansion
  cgeodesic()  MOTION          Compute geodesic equations
  ct_coords    OMEGA           Metric coordinates
  ctayvar      PARAM           Taylor-series expansion variable
  lriem[]      R[]             Covariant Riemann-tensor
  uriemann()   RAISERIEMANN()  Compute the contravariant Riemann-tensor
  ratriemann   RATRIEMAN       Rational simplif. of the Riemann-tensor
  uric[]       RICCI[]         Contravariant Ricci-tensor
  uricci()     RICCICOM()      Compute the contravariant Ricci-tensor
  cmetric()    SETMETRIC()     Set up the metric
  ctaypt       TAYPT           Point for Taylor-series expansion
  ctayswitch   TAYSWITCH       Taylor-series setting switch
  csetup()     TSETUP()        Start interactive setup session
  ctransform() TTRANSFORM()    Interactive coordinate transformation
  uriem[]      UR[]            Contravariant Riemann-tensor
  weyl[]       W[]             (3,1) Weyl-tensor

@end example

