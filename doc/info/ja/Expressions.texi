@menu
* Introduction to Expressions::
* Nouns and Verbs::
* Identifiers::
* Inequality::
* Functions and Variables for Expressions::
@end menu

@c -----------------------------------------------------------------------------
@node Introduction to Expressions, Nouns and Verbs, Expressions, Expressions
@section Introduction to Expressions
@c -----------------------------------------------------------------------------

変数名として使えないたくさんの予約語があります。
これらを使うと、不可解な構文法エラーの原因となります。

@example
integrate            next           from                 diff            
in                   at             limit                sum             
for                  and            elseif               then            
else                 do             or                   if              
unless               product        while                thru            
step                                                                     
@end example

Maximaのほとんどのものは式です。
括弧で囲み、コンマで区切ることで、式の列が構成できます。
これは、@b{C}言語の@i{コンマ式}に似ています。

@example
(%i1) x: 3$
(%i2) (x: x+1, x: x^2);
(%o2)                          16
(%i3) (if (x > 17) then 2 else 4);
(%o3)                           4
(%i4) (if (x > 17) then x: 2 else y: 4, y+x);
(%o4)                          20
@end example

ループが返す値はあまり役に立たない@code{done}ですが、Maximaではループでさえ式です。

@example
(%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
(%i2) y;
(%o2)                         done
@end example

ところが、本当に欲しいものは、たぶん、実際に値を戻す@i{コンマ式}の３番目の項を含むことで得られます。

@example
(%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
(%i4) y;
(%o4)                        3628800
@end example

@c -----------------------------------------------------------------------------
@node Nouns and Verbs, Identifiers, Introduction to Expressions, Expressions
@section Nouns and Verbs
@c -----------------------------------------------------------------------------

Maximaは「名詞(Noun)」演算子と「動詞(Verb)」演算子を区別します。
動詞は実行される演算子です。
名詞は式の中で、実行されずシンボルとして現れる演算子です。
デフォルトでは、関数名は動詞です。
動詞は、関数名をクォートすることで、また、@mref{nounify}関数を適用することで、
名詞に変えることができます。
名詞は、@mref{verbify}関数を適用することで動詞に変えることができます。
評価フラグ@mref{nouns}は、@mref{ev}を式の中の名詞を評価するようにします。

動詞形は、対応するLispシンボル上では、先頭のドル記号@code{$}で区別されます。
対照的に、
名詞形は、対応するLispシンボル上では、先頭のパーセント記号@code{%}で区別されます。
@code{'integrate}や（@code{diff}が返す）@code{'derivative}のように、
いくつかの名詞は特別な表示プロパティを持ちますが、ほとんどは特別な表示を持ちません。
デフォルトでは、表示される時、関数の名詞と動詞形は同一です。
グローバルフラグ@code{noundisp}は、
Maximaに、先頭のクォートマーク@code{'}で名詞形を表示させます。

@mref{noun}, @mref{nouns}, @mref{nounify}, や@mref{verbify}も参照してください。

例:

@c ===beg===
@c foo (x) := x^2;
@c foo (42);
@c 'foo (42);
@c 'foo (42), nouns;
@c declare (bar, noun);
@c bar (x) := x/17;
@c bar (52);
@c bar (52), nouns;
@c integrate (1/x, x, 1, 42);
@c 'integrate (1/x, x, 1, 42);
@c ev (%, nouns);
@c ===end===
@example
(%i1) foo (x) := x^2;
                                     2
(%o1)                     foo(x) := x
(%i2) foo (42);
(%o2)                         1764
(%i3) 'foo (42);
(%o3)                        foo(42)
(%i4) 'foo (42), nouns;
(%o4)                         1764
(%i5) declare (bar, noun);
(%o5)                         done
(%i6) bar (x) := x/17;
                                     x
(%o6)                    ''bar(x) := --
                                     17
(%i7) bar (52);
(%o7)                        bar(52)
(%i8) bar (52), nouns;
                               52
(%o8)                          --
                               17
(%i9) integrate (1/x, x, 1, 42);
(%o9)                        log(42)
(%i10) 'integrate (1/x, x, 1, 42);
                             42
                            /
                            [   1
(%o10)                      I   - dx
                            ]   x
                            /
                             1
(%i11) ev (%, nouns);
(%o11)                       log(42)
@end example

@opencatbox
@category{Evaluation}
@category{Nouns and verbs}
@closecatbox

@c -----------------------------------------------------------------------------
@node Identifiers, Inequality, Nouns and Verbs, Expressions
@section Identifiers
@c -----------------------------------------------------------------------------

Maximaの識別子は、アルファベット文字と、0から9までの数詞と、
バックスラッシュ@code{\}文字に続く任意の特別文字で構成されます。

もしバックスラッシュが先行するなら、数詞は、識別子の最初の文字となることができます。
２番目や後の文字の数詞は、バックスラッシュが先行する必要はありません。

文字は、@code{declare}関数によってアルファベットと宣言することができます。
もし宣言されたら、識別子の中でバックスラッシュで先行する必要はありません。
アルファベット文字は、@code{A}から@code{Z}まで, @code{a}から @code{z}まで, @code{%},と@code{_}が初期設定です。

Maximaは大文字小文字を区別します。
識別子@code{foo}, @code{FOO}, と@code{Foo}は別の物です。
この点に関して@ref{Lisp and Maxima}を参照してください。

Maximaの識別子は、ドル記号@code{$}で始まるLispのシンボルです。
Maximaの中で現れる時、他の任意のLispシンボルは、クエスチョンマーク@code{?}で始まります。
この点に関して@ref{Lisp and Maxima}を参照してください。

例:

@c ===beg===
@c %an_ordinary_identifier42;
@c embedded\ spaces\ in\ an\ identifier;
@c symbolp (%);
@c [foo+bar, foo\+bar];
@c [1729, \1729];
@c [symbolp (foo\+bar), symbolp (\1729)];
@c [is (foo\+bar = foo+bar), is (\1729 = 1729)];
@c baz\~quux;
@c declare ("~", alphabetic);
@c baz~quux;
@c [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
@c :lisp (defvar *my-lisp-variable* '$foo)
@c ?\*my\-lisp\-variable\*;
@c ===end===
@example
(%i1) %an_ordinary_identifier42;
(%o1)               %an_ordinary_identifier42
(%i2) embedded\ spaces\ in\ an\ identifier;
(%o2)           embedded spaces in an identifier
(%i3) symbolp (%);
(%o3)                         true
(%i4) [foo+bar, foo\+bar];
(%o4)                 [foo + bar, foo+bar]
(%i5) [1729, \1729];
(%o5)                     [1729, 1729]
(%i6) [symbolp (foo\+bar), symbolp (\1729)];
(%o6)                     [true, true]
(%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
(%o7)                    [false, false]
(%i8) baz\~quux;
(%o8)                       baz~quux
(%i9) declare ("~", alphabetic);
(%o9)                         done
(%i10) baz~quux;
(%o10)                      baz~quux
(%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
(%o11)                [false, false, false]
(%i12) :lisp (defvar *my-lisp-variable* '$foo)
*MY-LISP-VARIABLE*
(%i12) ?\*my\-lisp\-variable\*;
(%o12)                         foo
@end example

@opencatbox
@category{Syntax}
@closecatbox

@c -----------------------------------------------------------------------------
@node Inequality, Functions and Variables for Expressions, Identifiers, Expressions
@section Inequality
@c -----------------------------------------------------------------------------

Maximaは、不等式演算子@code{<}, @code{<=}, @code{>=}, @code{>}, @code{#}, @code{notequal}を持ちます。
条件式の記述に関しては、@code{if}を参照してください。

@c -----------------------------------------------------------------------------
@node Functions and Variables for Expressions,  , Inequality, Expressions
@section Functions and Variables for Expressions
@c -----------------------------------------------------------------------------

@c NEEDS WORK, ESPECIALLY EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{alias}
@deffn {関数} alias (@var{new_name_1}, @var{old_name_1}, @dots{}, @var{new_name_n}, @var{old_name_n})

(利用者もしくはシステム)関数や変数、配列等に対して別名を与えます。
任意の偶数個の引数を取ります。

@opencatbox
@category{Declarations and inferences}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{aliases}
@defvr {システム変数} aliases
デフォルト値: @code{[]}

@code{aliases}は、
(@mref{alias}, @mref{ordergreat}, @mref{orderless}関数によって、もしくは、
@mref{declare}で
アトムを@mref{noun}に宣言することで、設定される)
ユーザー定義のエーリアスを持つ
アトムのリストです。

@opencatbox
@category{Declarations and inferences}
@category{Global variables}
@closecatbox
@end defvr

@c NEEDS TO BE REWORKED. NOT CONVINCED THIS SYMBOL NEEDS ITS OWN ITEM
@c (SHOULD BE DESCRIBED IN CONTEXT OF EACH FUNCTION WHICH RECOGNIZES IT)

@c -----------------------------------------------------------------------------
@anchor{allbut}
@defvr {キーワード} allbut

@code{part}コマンド(すなわち、@mref{part},@mref{inpart},@mref{substpart},
@mref{substinpart},@mref{dpart}, @mref{lpart})と共に動作します。例えば、

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, [2, 5]);
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, [2, 5]);
(%o2)                         d + a
@end example

一方、

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, allbut (2, 5));
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, allbut (2, 5));
(%o2)                       e + c + b
@end example

@mref{kill}も@code{allbut}を認識します。

@c ===beg===
@c [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
@c kill (allbut (cc, dd));
@c [aa, bb, cc, dd];
@c ===end===
@example
(%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
(%o1)                 [11, 22, 33, 44, 55]
(%i2) kill (allbut (cc, dd));
(%o0)                         done
(%i1) [aa, bb, cc, dd];
(%o1)                   [aa, bb, 33, 44]
@end example

@code{kill(allbut(@var{a_1}, @var{a_2}, ...))}は、
シンボル@var{a_1}, @var{a_2}, @dots{}をキルしないよう除外して
@code{kill(all)}を実行します。

@end defvr

@c THE FUNCTION APRPOS IS MOVED TO THE FILE HELP.TEXI

@c -----------------------------------------------------------------------------
@anchor{args}
@deffn {関数} args (@var{expr})

@code{expr}の引数のリストを返します。
ここで、@code{expr}アトム以外のいかなる種類の式を取り得ます。
トップレベル演算子の引数だけが抽出されます;
@code{expr}の部分式は、要素として、または、引数のリストの要素の部分式として現れます。

リストの中の項目の順序は、グローバルフラグ@mref{inflag}に依存するかもしれません。

@code{args (@var{expr})}は、@code{substpart ("[", @var{expr}, 0)}と同値です。
@mref{substpart}と@mref{op}も参照してください。

@c NEEDS EXAMPLES
@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c REPHRASE
@c SPLIT OFF EXAMPLES INTO EXAMPLE SECTION

@c -----------------------------------------------------------------------------
@anchor{atom}
@deffn {関数} atom (@var{expr})

もし @var{expr}がアトム(すなわち、数や名前や文字)なら、
 @code{true}、そうでなければ @code{false}を返します。
例えば、 @code{atom(5)}は @code{true}ですが、
(@code{a[1]}と @code{x}はバインドされていないと仮定して) @code{atom(a[1])}や @code{atom(sin(x))}は @code{false}です。

@opencatbox
@category{Expressions}
@category{Predicate functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{box}
@deffn  {関数} box (@var{expr})
@deffnx {関数} box (@var{expr}, @var{a})

枠で囲んだ@var{expr}を返します。
返り値は、演算子として@code{box}を持ち、引数として@var{expr}を持つ式です。
@code{display2d}が@code{true}の時、ディスプレイ上に枠が描かれます。

@code{box (@var{expr}, @var{a})}は、
シンボル@var{a}でラベルされた枠で@var{expr}を囲みます。
もし枠の幅より長ければ、ラベルは切りつめられます。

@code{box}は引数を評価します。
しかしながら、枠に入れられた式は中身に評価されないので、
枠に入れられた式は、計算から効果的に除外されます。

@mref{boxchar}は、@code{box}, @mref{dpart}, @mref{lpart}関数において
枠を描くのに使われる文字です。

例:

@c ===beg===
@c box (a^2 + b^2);
@c a : 1234;
@c b : c - d;
@c box (a^2 + b^2);
@c box (a^2 + b^2, term_1);
@c 1729 - box (1729);
@c boxchar: "-";
@c box (sin(x) + cos(y));
@c ===end===
@example
(%i1) box (a^2 + b^2);
                            """""""""
                            " 2    2"
(%o1)                       "b  + a "
                            """""""""
(%i2) a : 1234;
(%o2)                         1234
(%i3) b : c - d;
(%o3)                         c - d
(%i4) box (a^2 + b^2);
                      """"""""""""""""""""
                      "       2          "
(%o4)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i5) box (a^2 + b^2, term_1);
                      term_1""""""""""""""
                      "       2          "
(%o5)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i6) 1729 - box (1729);
                                 """"""
(%o6)                     1729 - "1729"
                                 """"""
(%i7) boxchar: "-";
(%o7)                           -
(%i8) box (sin(x) + cos(y));
                        -----------------
(%o8)                   -cos(y) + sin(x)-
                        -----------------
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{boxchar}
@defvr {オプション変数} boxchar
デフォルト値: @code{"}

@code{boxchar}は、@mref{box}, @mref{dpart}, @mref{lpart}関数において
枠を描くのに使われる文字です。

式の中の枠すべては、@code{boxchar}の現在値で描かれます;
描画文字は枠式に保存されていません。

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS CLARIFICATION !!!

@c -----------------------------------------------------------------------------
@anchor{collapse}
@deffn {関数} collapse (@var{expr})

共通の（すなわち等しい）部分式の全てを共用と（すなわち、同じセルを使用）させることで、
@var{expr}を縮約し、スペースを節約します。
(@code{collapse}は、@code{optimize}コマンドによって使われるサブルーチンです。）
例えば，@code{collapse}をコールすることは、
@mref{save}ファイルに積んだ後役に立つかもしれません。
@code{collapse ([@var{expr_1}, ..., @var{expr_n}])}を使うことで、いくつかの式を
一緒に縮約できます。
同様に、@code{collapse (listarray ('A))}を実行することで、配列@code{A}の要素を縮約できます。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{disolate}
@deffn {関数} disolate (@var{expr}, @var{x_1}, @dots{}, @var{x_n})

ユーザーに１つ以上の変数を同時にisolate可能にさせることを除いて、
@code{isolate (@var{expr}, @var{x})}に似ています。
例えば、もし多重積分の中で変数を変えようとしていて、それが２つ以上の積分変数を含んだ変数変換なら、これは役立つかもしれません。
この関数は、@file{simplification/disol.mac}から自動ロードされます。
@code{demo("disol")$}でデモが入手可能です。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{dispform}
@deffn  {関数} dispform (@var{expr})
@deffnx {関数} dispform (@var{expr}, all)

@var{expr}の外部表現を返します。

@code{dispform(@var{expr})}は、主（トップレベル）演算子に関して外部表現を返します。
@code{dispform(@var{expr}, all)}は、@var{expr}の中の演算子すべてに関して
外部表現を返します。

@mref{part}, @mref{inpart}, @mref{inflag}も参照してください。

例:

@code{- x}の内部表現は、「-1掛ける@code{x}」ですが、
外部表現は、「マイナス@code{x}」です。

@c ===beg===
@c - x;
@c ?format (true, "~S~%", %);
@c dispform (- x);
@c ?format (true, "~S~%", %);
@c ===end===
@example
(%i1) - x;
(%o1)                          - x
(%i2) ?format (true, "~S~%", %);
((MTIMES SIMP) -1 $X)
(%o2)                         false
(%i3) dispform (- x);
(%o3)                          - x
(%i4) ?format (true, "~S~%", %);
((MMINUS SIMP) $X)
(%o4)                         false
@end example

@code{sqrt(x)}の内部表現は、「@code{x}の1/2乗」ですが、
外部表現は、「@code{x}の平方根」です。

@c ===beg===
@c sqrt (x);
@c ?format (true, "~S~%", %);
@c dispform (sqrt (x));
@c ?format (true, "~S~%", %);
@c ===end===
@example
(%i1) sqrt (x);
(%o1)                        sqrt(x)
(%i2) ?format (true, "~S~%", %);
((MEXPT SIMP) $X ((RAT SIMP) 1 2))
(%o2)                         false
(%i3) dispform (sqrt (x));
(%o3)                        sqrt(x)
(%i4) ?format (true, "~S~%", %);
((%SQRT SIMP) $X)
(%o4)                         false
@end example

オプション引数@code{all}の使用。

@c ===beg===
@c expr : sin (sqrt (x));
@c freeof (sqrt, expr);
@c freeof (sqrt, dispform (expr));
@c freeof (sqrt, dispform (expr, all));
@c ===end===
@example
(%i1) expr : sin (sqrt (x));
(%o1)                     sin(sqrt(x))
(%i2) freeof (sqrt, expr);
(%o2)                         true
(%i3) freeof (sqrt, dispform (expr));
(%o3)                         true
(%i4) freeof (sqrt, dispform (expr, all));
(%o4)                         false
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{dpart}
@deffn {関数} dpart (@var{expr}, @var{n_1}, @dots{}, @var{n_k})

@mref{part}と同じ部分式を選択しますが、
その部分式を値として返すだけの代わりに、
枠の中に表示されて選択された部分式を持つ式全体を返します。
枠は実際に式の一部です。

@example
(%i1) dpart (x+y/z^2, 1, 2, 1);
                             y
(%o1)                       ---- + x
                               2
                            """
                            "z"
                            """
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{exptisolate}
@defvr {オプション変数} exptisolate
デフォルト値: @code{false}

@c WHAT DOES THIS MEAN EXACTLY ??
@code{exptisolate}が@code{true}の時、
@code{isolate (expr, var)}は、
@code{var}を含む(@code{%e}のような)アトムの指数を検査します。

@c NEED EXAMPLES HERE
@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{exptsubst}
@defvr {オプション変数} exptsubst
デフォルト値: @code{false}

@code{exptsubst}が@code{true}の時、
@code{%e^(a x)}の中の@code{%e^x}へ@code{y}を代入するような代入を許します。

@c NEED EXAMPLES HERE
@opencatbox
@category{Exponential and logarithm functions}
@category{Expressions}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{freeof}
@deffn {関数} freeof (@var{x_1}, @dots{}, @var{x_n}, @var{expr})

もし@var{x_1}と等しい@var{expr}の部分式がないか、
@var{x_1}が@var{expr}の中でダミー変数としてのみ現れるか、
@var{x_1}が@var{expr}の中で任意の演算子の名詞形でも動詞形でもないなら、
@code{freeof (@var{x_1}, @var{expr})}は、@code{true}を返します。
そうでなければ、@code{false}を返します。

@code{freeof (@var{x_1}, ..., @var{x_n}, @var{expr})}は、
@code{freeof (@var{x_1}, @var{expr})かつ、
...かつfreeof (@var{x_n}, @var{expr})}と同値です。

引数@var{x_1}, @dots{}, @var{x_n} は、
関数や変数の名前、添字付き名前、（ダブルクォートでくくられた）演算子、もしくは一般式
を取り得ます。
@code{freeof}は引数を評価します。

@code{freeof}は、そのままは（整理と評価の後）@var{expr}上でのみ演算し、
ある同値の表現が違った結果を与えるかどうかを決定しようとはしません。
特に、整理は、同値ですが、@var{expr}の原型とは違った要素を含む異なる式を生成するかもしれません。

もし式の外部にバインドを持たなければ、変数は、式の中のダミー変数です。
@code{freeof}によって認識されたダミー変数は、
和や積のインデックス、@mref{limit}の中の極限変数、
@mref{integrate}の定積分形の中の積分変数、
@mref{laplace}の中のオリジナル変数、
@mref{at}式の中の形式変数、
@mref{lambda}式の中の引数です。

@code{integrate}の不定積分形は、積分変数から自由では@i{ありません}。

例:

引数は、関数、変数、添字付き名前、演算子、式の名前です。
@code{freeof (a, b, expr)}は
@code{freeof (a, expr) and freeof (b, expr)}と同値です。

@example
(%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                 d + c  3
(%o1)                   cos(a ) b      z
                             1
(%i2) freeof (z, expr);
(%o2)                         false
(%i3) freeof (cos, expr);
(%o3)                         false
(%i4) freeof (a[1], expr);
(%o4)                         false
(%i5) freeof (cos (a[1]), expr);
(%o5)                         false
(%i6) freeof (b^(c+d), expr);
(%o6)                         false
(%i7) freeof ("^", expr);
(%o7)                         false
(%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
(%o8)                         true
@end example

@code{freeof}は引数を評価します。

@example
(%i1) expr: (a+b)^5$
(%i2) c: a$
(%i3) freeof (c, expr);
(%o3)                         false
@end example

@code{freeof}は、同値の式を考慮しません。
整理は、同値ですが異なる式を生成します。

@example
(%i1) expr: (a+b)^5$
(%i2) expand (expr);
          5        4       2  3       3  2      4      5
(%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
(%i3) freeof (a+b, %);
(%o3)                         true
(%i4) freeof (a+b, expr);
(%o4)                         false
(%i5) exp (x);
                                 x
(%o5)                          %e
(%i6) freeof (exp, exp (x));
(%o6)                         true
@end example

和や定積分はダミー変数から自由です。
不定積分は積分変数から自由ではありません。

@example
(%i1) freeof (i, 'sum (f(i), i, 0, n));
(%o1)                         true
(%i2) freeof (x, 'integrate (x^2, x, 0, 1));
(%o2)                         true
(%i3) freeof (x, 'integrate (x^2, x));
(%o3)                         false
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{inflag}
@defvr {オプション変数} inflag
デフォルト値: @code{false}

@code{inflag}が@code{true}の時、
部分抽出のための関数は、@code{expr}の内部形式を検査します。

整理器は式を再順序付けすることに注意してください。
例えば、
もし@code{inflag}が@code{true}なら、
@code{first (x + y)}は、@code{x}を返し、
もしif @code{inflag}が@code{false}なら、@code{y}を返します。
(@code{first (y + x)}は同じ結果を与えます。)

また、@code{inflag}を@code{true}に設定し、@mref{part}や@mref{substpart}をコールすることは、
@mref{inpart}や@mref{substinpart}をコールすることと同じです。

@code{inflag}の設定に影響される関数は以下の通りです:
@mref{part}, @mref{substpart}, @mref{first}, @mref{rest}, @mref{last}, @mref{length}, @mref{for} ... @code{in}構成子,
@mref{map}, @mref{fullmap}, @mref{maplist}, @mref{reveal}, @mref{pickapart}。

@c NEED EXAMPLES HERE
@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{inpart}
@deffn {関数} inpart (@var{expr}, @var{n_1}, ..., @var{n_k})

@code{part}に似ていますが、表示形式ではなく内部表現上で機能し、
フォーマットが実行されないのでより速いかもしれません。
（内部形式での変数の順序はしばしば表示形式でのそれと異なるので）
和や積の中の部分式の順序や、
（以下の演算子は式から取り除かれるので）単項マイナス、引き算、割り算を扱う際の部分式の順序
に関して注意が必要です。
@code{part (x+y, 0)}や@code{inpart (x+y, 0)}は、
@code{+}を返しますが、
演算子を参照するため、"で囲まれたものになります。
例えば、@code{... if inpart (%o9,0) = "+" then ...}.

例:

@example
(%i1) x + y + w*z;
(%o1)                      w z + y + x
(%i2) inpart (%, 3, 2);
(%o2)                           z
(%i3) part (%th (2), 1, 2);
(%o3)                           z
(%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                  g(x + 1)
(%o4)                 limit   f(x)
                      x -> 0-
(%i5) inpart (%, 1, 2);
(%o5)                       g(x + 1)
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{isolate}
@deffn {関数} isolate (@var{expr}, @var{x})
和であり、中間式ラベル(それらは@code{%t1}, @code{%t2}, ...のようなアトムなシンボルです)
で置き換えられた@var{x}を含まない部分式を含む@var{expr}を返します。
興味のある変数を含まない部分式の不必要な展開を避けるのに、これはしばしば役立ちます。
中間ラベルは部分式にバインドされているので、
それらが現れた式を評価することで、それらをすべて元に代入することができます。

もし@mref{exptisolate} (デフォルト値: @code{false})が@code{true}なら、
@code{isolate}は、@var{x}を含むか、(@code{%e}のような)アトムの指数を検査します。

もし@code{isolate_wrt_times}が@code{true}なら、
@code{isolate}は積に関してもisolateします。
@mref{isolate_wrt_times}を参照してください。

サンプルを見るには、@code{example (isolate)}を実行してください。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{isolate_wrt_times}
@defvr {オプション変数} isolate_wrt_times
デフォルト値: @code{false}

@code{isolate_wrt_times}が@code{true}の時,
@code{isolate}は、積に関してもisolateします。
例えば、スイッチの両方の設定を比較すると、

@example
(%i1) isolate_wrt_times: true$
(%i2) isolate (expand ((a+b+c)^2), c);

(%t2)                          2 a


(%t3)                          2 b


                          2            2
(%t4)                    b  + 2 a b + a

                     2
(%o4)               c  + %t3 c + %t2 c + %t4
(%i4) isolate_wrt_times: false$
(%i5) isolate (expand ((a+b+c)^2), c);
                     2
(%o5)               c  + 2 b c + 2 a c + %t4
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{listconstvars}
@defvr {オプション変数} listconstvars
デフォルト値: @code{false}

@code{listconstvars}が@code{true}の時、
@mref{listofvars}は、@code{%e}, @code{%pi}, @code{%i}や
定数と宣言された任意の変数を、
もしそれらが、@code{listofvars}がコールされた式の中で現れたなら、
戻り値のリストの中に含みます。
デフォルトはこれらを省略します。

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{listdummyvars}
@defvr {オプション変数} listdummyvars
デフォルト値: @code{true}

@code{listdummyvars}が@code{false}の時、
式の中の「ダミー変数」は、@mref{listofvars}が返すリストの中に含まれません。
（「ダミー変数」の意味は@mref{freeof}で与えられているものです。
「ダミー変数」は、和や積のインデックスや、極限変数、定積分変数のように数学的なものです。）

例:

@example
(%i1) listdummyvars: true$
(%i2) listofvars ('sum(f(i), i, 0, n));
(%o2)                        [i, n]
(%i3) listdummyvars: false$
(%i4) listofvars ('sum(f(i), i, 0, n));
(%o4)                          [n]
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{listofvars}
@deffn {関数} listofvars (@var{expr})

@var{expr}の中の変数のリストを返します。

もし@mref{listconstvars}が@code{true}なら、
@code{listofvars}は、@code{%e}, @code{%pi}, @code{%i}や
定数と宣言された任意の変数を、
もしそれらが、@var{expr}の中で現れたなら、
戻り値のリストの中に含みます。
デフォルトはこれらを省略します。

変数のリストのなかの「ダミー変数」を除外したり含めたりするには、オプション変数 @mref{listdummyvars}も参照してください。

@example
(%i1) listofvars (f (x[1]+y) / g^(2+a));
(%o1)                     [g, a, x , y]
                                  1
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{lfreeof}
@deffn {関数} lfreeof (@var{list}, @var{expr})

@var{list}のそれぞれのメンバー@var{m}に関して、
@code{freeof (@var{m}, @var{expr})}をコールします。
もし@code{freeof}のコールのいずれかが@code{false}を返すなら、
@code{false}を返し、そうでなければ、@code{true}を返します。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{lpart}
@deffn {関数} lpart (@var{label}, @var{expr}, @var{n_1}, @dots{}, @var{n_k})

@code{dpart}に似ていますが、ラベルされた枠を使います。
ラベルされた枠は、@code{dpart}によって生成されたものに似ていますが、
トップラインの中での名前を持ちます。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{mainvar}
@defvr {宣言} mainvar

変数を@code{mainvar}に宣言することができます。
アトムに関する順序付けスケールは本質的に以下の通りです:
数 < 定数 (例えば、@code{%e}, @code{%pi}) < スカラー < 他の変数 < mainvars。
例えば、@code{(declare (x, mainvar), expand ((x+y)^4))}を伴う
@code{expand ((X+Y)^4)}。
（上の特長を使うことを選択したなら注意が必要なことに注意してください。
例えば、もし、
@code{mainvar}である@code{x}を含む式を、@code{mainvar}でない@code{x}を含む式から引くなら、
もし打ち消しが起こるようにするなら、
例えば@code{ev (expr, simp)}のような再整理が必要かもしれません。
また、@code{mainvar}である@code{x}を含む式を保存するなら、
@code{x}もまた保存すべきです。）

@opencatbox
@category{Declarations and inferences}
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{noun}
@defvr {宣言} noun

@code{noun}は、@mref{declare}コマンドのオプションの１つです。
関数を「名詞」に宣言するのに使います。
「名詞」は、自動的には評価されないことを意味します。

@opencatbox
@category{Nouns and verbs}
@closecatbox
@end defvr

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{noundisp}
@defvr {オプション変数} noundisp
デフォルト値: @code{false}

@code{noundisp}が@code{true}の時、
名詞は、単一クォートで表示されます。
このスイッチは、関数定義を表示する時には、常に@code{true}です。

@opencatbox
@category{Display flags and variables}
@category{Nouns and verbs}
@closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{nounify}
@deffn {関数} nounify (@var{f})

関数名@var{f}の名詞形を返します。
もし動詞関数の名前をまるで名詞のように参照したいなら、これが必要とされます。
もしある引数に関して関数が評価されないなら、
いくつかの動詞関数は名詞形を返すことに注意してください。
これは、クォートに関数コールが続く時、返される形式でもあります。

@mref{verbify}も参照してください。

@opencatbox
@category{Nouns and verbs}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{nterms}
@deffn {関数} nterms (@var{expr})

もし完全に展開されて、項の打ち消しや結合が起こらない場合の、@var{expr}が持つ
項の数を返します。
@code{sin (@var{expr})}, @code{sqrt (@var{expr})}, @code{exp (@var{expr})},
 などのような式は、
@var{expr}が（もしそれが和なら）
どんなにたくさんの項を持とうと、１項と数えます。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{op}
@deffn {関数} op (@var{expr})

式@var{expr}のメインの演算子を返します。
@code{op (@var{expr})}は@code{part (@var{expr}, 0)}と同値です。

@code{op}は、
もしメインの演算子が組み込みもしくはユーザー定義の前置、二項もしくはn項中置、後置、マッチフィックスもしくは無項演算子なら、文字列を返します。
そうでなければ、
もし@var{expr}が添字付き関数式なら、
@code{op}は添字付き関数を返します;
この場合、戻り値はアトムではありません。
そうでなければ、
@var{expr}は配列関数もしくは通常の関数式であり、
@code{op}はシンボルを返します。

@code{op}はグローバルフラグ@mref{inflag}の値を見ています。

@code{op}は引数を評価します。

@mref{args}も参照してください。

例:

@c ===beg===
@c stringdisp: true$
@c op (a * b * c);
@c op (a * b + c);
@c op ('sin (a + b));
@c op (a!);
@c op (-a);
@c op ([a, b, c]);
@c op ('(if a > b then c else d));
@c op ('foo (a));
@c prefix (foo);
@c op (foo a);
@c op (F [x, y] (a, b, c));
@c op (G [u, v, w]);
@c ===end===
@example
(%i1) stringdisp: true$
(%i2) op (a * b * c);
(%o2)                          "*"
(%i3) op (a * b + c);
(%o3)                          "+"
(%i4) op ('sin (a + b));
(%o4)                          sin
(%i5) op (a!);
(%o5)                          "!"
(%i6) op (-a);
(%o6)                          "-"
(%i7) op ([a, b, c]);
(%o7)                          "["
(%i8) op ('(if a > b then c else d));
(%o8)                         "if"
(%i9) op ('foo (a));
(%o9)                          foo
(%i10) prefix (foo);
(%o10)                        "foo"
(%i11) op (foo a);
(%o11)                        "foo"
(%i12) op (F [x, y] (a, b, c));
(%o12)                        F
                               x, y
(%i13) op (G [u, v, w]);
(%o13)                          G
@end example

@opencatbox
@category{Expressions}
@category{Operators}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{operatorp}
@deffn {関数} operatorp (@var{expr}, @var{op})
@deffnx {関数} operatorp (@var{expr}, [@var{op_1}, @dots{}, @var{op_n}])

もし@var{op}が@var{expr}の演算子に等しければ、
@code{operatorp (@var{expr}, @var{op})}は@code{true}を返します。

もしある要素@var{op_1}, ..., @var{op_n}が@var{expr}に等しければ、
@code{operatorp (@var{expr}, [@var{op_1}, @dots{}, @var{op_n}])}は@code{true}を返します。

@opencatbox
@category{Operators}
@category{Predicate functions}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{option_opsubst}
@defvr {オプション変数} opsubst
デフォルト値: @code{true}

@code{opsubst}が@code{false}の時、
@mref{subst}は、式の中の演算子に代入を試みません。
例えば、
@code{(opsubst: false, subst (x^2, r, r+r[0]))}は機能します。

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{optimize}
@deffn {関数} optimize (@var{expr})

@var{expr}と同じ値と副作用を生成する式を返しますが、
共通の部分式の再計算を避けることによってより効率的に行います。
@code{optimize}は、共通の部分式すべてが共用されるように引数を縮約する副作用も持ちます。
例を見るには、@code{example (optimize)}を実行してください。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn


@c -----------------------------------------------------------------------------
@anchor{optimprefix}
@defvr {オプション変数} optimprefix
デフォルト値: @code{%}

@code{optimprefix}は@mref{optimize}コマンドによって生成されたシンボルのために
使われる前置です。

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{ordergreat}
@anchor{orderless}
@deffn {関数} ordergreat (@var{v_1}, @dots{}, @var{v_n})
@deffnx {関数} orderless (@var{v_1}, @dots{}, @var{v_n})

@code{ordergreat}は、
@var{v_1}が@var{v_2}に続き、@var{v_2}は、@dots{}, @var{v_n}に続き、
そして@var{v_n}は 引数として言及されなかった他の任意のシンボルに続くというように、
Maximaの式の標準の順序付けを変えます。

@code{orderless}は、
@var{v_1}が@var{v_2}に先行し、@var{v_2}は、@dots{}, @var{v_n}に先行し、
そして@var{v_n}は 引数として言及されなかった他の任意のシンボルに先行するというように、
Maximaの式の標準の順序付けを変えます。

@code{ordergreat}や@code{orderless}によって確立される順序は、
@mref{unorder}によって解消されます。
@code{ordergreat}や@code{orderless}は、
@code{unorder}がコールされるまで、
それぞれ一度だけコールすることができます;
@code{ordergreat}の@code{orderless}の最後のコールだけが効果を持ちます。

@mref{ordergreatp}も参照してください。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{ordergreatp}
@anchor{orderlessp}
@deffn {関数} ordergreatp (@var{expr_1}, @var{expr_2})
@deffnx {関数} orderlessp (@var{expr_1}, @var{expr_2})

もしMaximaの式の標準の順序付けの中で、@var{expr_1}が@var{expr_2}に続くなら、
@code{ordergreatp}は、@code{true}を返し、
そうでなければ、@code{false}を返します。

もしMaximaの式の標準の順序付けの中で、@var{expr_1}が@var{expr_2}に先行するなら、
@code{orderlessp}は、@code{true}を返し、
そうでなければ、@code{false}を返します。

Maximaのアトムや式のすべては、@code{ordergreatp}と@code{orderlessp}の下で比較可能です。これらの述語論理が推移的でないような式の孤立した例はあるけれども; それはバグです。

アトム（シンボル、数リテラル、文字列）の標準の順序付けは以下の通りです。

(整数と浮動小数点)は以下に先行
(多倍長浮動小数点)は以下に先行
(宣言された定数)は以下に先行
(文字列)は以下に先行
(宣言されたスカラー)は以下に先行
(@mref{orderless}の最初の引数)は以下に先行
 @dots{}は以下に先行
(@code{orderless}の最後の引数)
は以下に先行
(他のシンボル)
は以下に先行
(@mref{ordergreat}の最後の引数)は以下に先行
 @dots{}は以下に先行
(@code{ordergreat}の最初の引数)は以下に先行
(宣言されたメイン変数)

アトムでない式に関して、標準の順序付けはアトムの順序付けから演繹されます。
組み込みの@code{+} @code{*} @code{^}演算子に関しては、
順序付けは簡単にはまとめられません。
他の組み込み演算子と他の半数や演算子、式すべてに関しては、
（最初の引数から始めて）それらの引数によって順序付けされ、
それから演算子や関数の名前によって順序付けされます。
添字付き式の場合、
添字付きのシンボルは演算子と、添字は引数と考えられます。

式の標準の順序付けは、関数@mref{ordergreat}と@mref{orderless}と、
@mref{mainvar}, @mref{constant}, @code{scalar}宣言によって変更されます。

@mref{sort}も参照してください。

例:

通常のシンボルや定数の順序付け。
@code{%pi}は数値に従って順序付けされないことに注意してください。

@c ===beg===
@c stringdisp : true;
@c sort ([%pi, 3b0, 3.0, x, X, "foo", 3, a, 4, "bar", 4.0, 4b0]);
@c ===end===
@example
(%i1) stringdisp : true;
(%o1)                         true
(%i2) sort([%pi, 3b0, 3.0, x, X, "foo", 3, a, 4, "bar", 4.0, 4b0]);
(%o2) [3, 3.0, 4, 4.0, 3.0b0, 4.0b0, %pi, "bar", "foo", a, x, X]
@end example

@code{ordergreat}、@code{orderless}関数の効果。

@c ===beg===
@c sort ([M, H, K, T, E, W, G, A, P, J, S]);
@c ordergreat (S, J);
@c orderless (M, H);
@c sort ([M, H, K, T, E, W, G, A, P, J, S]);
@c ===end===
@example
(%i1) sort ([M, H, K, T, E, W, G, A, P, J, S]);
(%o1)           [A, E, G, H, J, K, M, P, S, T, W]
(%i2) ordergreat (S, J);
(%o2)                         done
(%i3) orderless (M, H);
(%o3)                         done
(%i4) sort ([M, H, K, T, E, W, G, A, P, J, S]);
(%o4)           [M, H, A, E, G, K, P, T, W, J, S]
@end example

@code{mainvar}, @code{constant}, @code{scalar}宣言の効果

@c ===beg===
@c sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
@c declare (aa, mainvar);
@c declare ([baz, quux], constant);
@c declare ([A1, B1], scalar);
@c sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
@c ===end===
@example
(%i1) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
(%o1)   [aa, bar, baz, bb, cc, dd, foo, quux, A1, B1, C1]
(%i2) declare (aa, mainvar);
(%o2)                         done
(%i3) declare ([baz, quux], constant);
(%o3)                         done
(%i4) declare ([A1, B1], scalar);
(%o4)                         done
(%i5) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
(%o5)   [baz, quux, A1, B1, bar, bb, cc, dd, foo, C1, aa]
@end example

アトムでない式の順序付け

@c ===beg===
@c sort ([1, 2, n, f(1), f(2), f(2, 1), g(1), g(1, 2), g(n), 
@c        f(n, 1)]);
@c sort ([foo(1), X[1], X[k], foo(k), 1, k]);
@c ===end===
@example
(%i1) sort ([1, 2, n, f(1), f(2), f(2, 1), g(1), g(1, 2), g(n),
             f(n, 1)]);
(%o1) [1, 2, f(1), g(1), g(1, 2), f(2), f(2, 1), n, g(n), 
                                                         f(n, 1)]
(%i2) sort ([foo(1), X[1], X[k], foo(k), 1, k]);
(%o2)            [1, foo(1), X , k, foo(k), X ]
                              1              k
@end example

@opencatbox
@category{Expressions}
@category{Predicate functions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{part}
@deffn {関数} part (@var{expr}, @var{n_1}, @dots{}, @var{n_k})

@code{expr}の表示形式のパーツを返します。
@code{expr}の最初のパーツ@var{n_1}、それから、パーツ@var{n_2}などなど、
結果は、@code{expr}のパーツ@var{n_1}のパーツ@var{n_2}の, ...パーツ@var{n_k}です。
もし添字が指定されないなら、@code{expr}を返します。

@code{part}はリストの要素や行列の行を得るのに使うことができます。

@c "If the last argument to a part function" => FOLLOWING APPLIES TO OTHER FUNCTIONS ??
@c ATTEMPT TO VERIFY; IF SO, COPY THIS COMMENTARY TO DESCRIPTIONS OF OTHER FUNCTIONS
もし@code{part}関数の最後の引数がインデックスのリストなら、
それぞれがリストのインデックスに対応するいくつかの部分式が抽出されます。
従って、@code{part (x + y + z, [1, 3])}は@code{z+x}です。

@mref{piece}は、@code{part}関数を使ったとき、選択された最後の式を保持します。
それは関数の実行中にセットされ、以下で示すように、関数自身の中で参照されることもあります。

もし@mref{partswitch}が@code{true}に設定されているなら、
式の選択されたパーツが存在しないとき、@code{end}が返されます。
そうでなければ、エラーメッセージが出力されます。

@mref{inpart}, @mref{substpart}, @mref{substinpart}, @mref{dpart}, @mref{lpart}も参照してください。

例:

@c ===beg===
@c part(z+2*y+a,2);
@c part(z+2*y+a,[1,3]);
@c part(z+2*y+a,2,1);
@c ===end===
@example
(%i1) part(z+2*y+a,2);
(%o1)                                 2 y
(%i2) part(z+2*y+a,[1,3]);
(%o2)                                z + a
(%i3) part(z+2*y+a,2,1);
(%o3)                                  2
@end example

@code{example (part)}でさらに例を見ることができます。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{partition}
@deffn {関数} partition (@var{expr}, @var{x})

２つの式のリストを返します。
それらは、
(1)（積なら）@var{expr}の因子、（和なら）@var{expr}項、
もしくは、（リストなら）@var{x}を含まないリストと、
(2)@var{x}を含む因子、項、リスト、
です。

例:

@example
(%i1) partition (2*a*x*f(x), x);
(%o1)                     [2 a, x f(x)]
(%i2) partition (a+b, x);
(%o2)                      [b + a, 0]
(%i3) partition ([a, b, f(a), c], a); 
(%o3)                  [[b, c], [a, f(a)]]
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS EXAMPLE

@c -----------------------------------------------------------------------------
@anchor{partswitch}
@defvr {オプション変数} partswitch
デフォルト値: @code{false}

@code{partswitch}が@code{true}の時、
式の選択された部分が存在しない時、@code{end}が返されます。
そうでない時は、エラーメッセージが出力されます。

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{pickapart}
@deffn {関数} pickapart (@var{expr}, @var{n})

中間式ラベルを、深さが整数@var{n}での@var{expr}の部分式に割り当てます。
より大きなもしくは小さな深さでの部分式はラベルに割り当てられません。
@code{pickapart}は、元の式@var{expr}と同値の中間式の項による式を返します。

@mref{part}, @mref{dpart}, @mref{lpart}, @mref{inpart}, 
@mref{reveal}も参照してください。

例:

@example
(%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                          2
                                     sin(x )   b + a
(%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2
(%i2) pickapart (expr, 0);
@group
                                          2
                                     sin(x )   b + a
(%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2
@end group
(%o2)                          %t2
(%i3) pickapart (expr, 1);

(%t3)                - log(sqrt(x + 1) + 1)


                                  2
                             sin(x )
(%t4)                        -------
                                3


                              b + a
(%t5)                         -----
                                2

(%o5)                    %t5 + %t4 + %t3
(%i5) pickapart (expr, 2);

(%t6)                 log(sqrt(x + 1) + 1)


                                  2
(%t7)                        sin(x )


(%t8)                         b + a

                         %t8   %t7
(%o8)                    --- + --- - %t6
                          2     3
(%i8) pickapart (expr, 3);

(%t9)                    sqrt(x + 1) + 1


                                2
(%t10)                         x

                  b + a              sin(%t10)
(%o10)            ----- - log(%t9) + ---------
                    2                    3
(%i10) pickapart (expr, 4);

(%t11)                     sqrt(x + 1)
@group
                      2
                 sin(x )   b + a
(%o11)           ------- + ----- - log(%t11 + 1)
                    3        2
@end group
(%i11) pickapart (expr, 5);

(%t12)                        x + 1

                   2
              sin(x )   b + a
(%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                 3        2
(%i12) pickapart (expr, 6);
                  2
             sin(x )   b + a
(%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                3        2
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{piece}
@defvr {システム変数} piece

@code{part}関数を使った時選択された最後の式を返します。
@c WHAT DOES THIS MEAN EXACTLY ??
関数の実行中に設定され、関数そのものの中で参照されることもあります。

@c NEED "SEE ALSO" TO POINT TO LIST OF ALL RELEVANT FUNCTIONS

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{psubst}
@deffn  {関数} psubst (@var{list}, @var{expr})
@deffnx {関数} psubst (@var{a}, @var{b}, @var{expr})

@code{psubst(@var{a}, @var{b}, @var{expr})}は@code{subst}に似ています。
@code{subst}を参照してください。


@code{subst}とは違って、
もし最初の引数@var{list}が等式のリストなら、
関数@code{psubst}は平行代入します。

並列代入するには、@mref{sublis}も参照してください。

例:

最初の例は、
@code{psubst}を使った平行代入を示します。
二番目の例は、
関数@code{subst}での結果を示します。それは逐次代入します。

@c ===beg===
@c psubst ([a^2=b, b=a], sin(a^2) + sin(b));
@c subst ([a^2=b, b=a], sin(a^2) + sin(b));
@c ===end===
@example
(%i4) psubst ([a^2=b, b=a], sin(a^2) + sin(b));
(%o4)                           sin(b) + sin(a)
(%i5) subst ([a^2=b, b=a], sin(a^2) + sin(b));
(%o5)                              2 sin(a)
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{rembox}
@deffn  {関数} rembox (@var{expr}, unlabelled)
@deffnx {関数} rembox (@var{expr}, @var{label})
@deffnx {関数} rembox (@var{expr})
@var{expr}から枠を取り除きます。

@code{rembox (@var{expr}, unlabelled)}は、
@var{expr}からラベルされていない枠すべてを取り除きます。

@code{rembox (@var{expr}, @var{label})}は、
@var{label}を負う枠のみを取り除きます。

@code{rembox (@var{expr})}は、ラベルされているか否か問わず、
枠すべてを取り除きます。

枠は、@mref{box}, @mref{dpart}, @mref{lpart}関数によって描画されます。

例:

@c ===beg===
@c expr: (a*d - b*c)/h^2 + sin(%pi*x);
@c dpart (dpart (expr, 1, 1), 2, 2);
@c expr2: lpart (BAR, lpart (FOO, %, 1), 2);
@c rembox (expr2, unlabelled);
@c rembox (expr2, FOO);
@c rembox (expr2, BAR);
@c rembox (expr2);
@c ===end===
@example
(%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
@group
                                  a d - b c
(%o1)                sin(%pi x) + ---------
                                      2
                                     h
@end group
(%i2) dpart (dpart (expr, 1, 1), 2, 2);
                        """""""    a d - b c
(%o2)               sin("%pi x") + ---------
                        """""""      """"
                                     " 2"
                                     "h "
                                     """"
(%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                  FOO"""""""""""   BAR""""""""
                  "    """"""" "   "a d - b c"
(%o3)             "sin("%pi x")" + "---------"
                  "    """"""" "   "  """"   "
                  """"""""""""""   "  " 2"   "
                                   "  "h "   "
                                   "  """"   "
                                   """""""""""
(%i4) rembox (expr2, unlabelled);
                                  BAR""""""""
                   FOO"""""""""   "a d - b c"
(%o4)              "sin(%pi x)" + "---------"
                   """"""""""""   "    2    "
                                  "   h     "
                                  """""""""""
(%i5) rembox (expr2, FOO);
                                  BAR""""""""
                       """""""    "a d - b c"
(%o5)              sin("%pi x") + "---------"
                       """""""    "  """"   "
                                  "  " 2"   "
                                  "  "h "   "
                                  "  """"   "
                                  """""""""""
(%i6) rembox (expr2, BAR);
                   FOO"""""""""""
                   "    """"""" "   a d - b c
(%o6)              "sin("%pi x")" + ---------
                   "    """"""" "     """"
                   """"""""""""""     " 2"
                                      "h "
                                      """"
(%i7) rembox (expr2);
                                  a d - b c
(%o7)                sin(%pi x) + ---------
                                      2
                                     h
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{reveal}
@deffn {関数} reveal (@var{expr}, @var{depth})

指定された整数@var{depth}の@var{expr}の部分を
記述的な要約で
置き換えます。

@itemize @bullet
@item
和と差分は、@code{Sum(@var{n})}で置き換えられます。
ここで、@var{n}は、和のオペランドの数です。
@item
積は@code{Product(@var{n})}で置き換えられます。
ここで、@var{n}は、積のオペランドの数です。
@item
指数は、@code{Expt}で置き換えられます。
@item
商は、@code{Quotient}で置き換えられます。
@item
単項マイナスは、@code{Negterm}で置き換えられます。
@item
リストは@code{List(@var{n})}で置き換えられます
ここで、@var{n}はリストの要素の数です。
@end itemize

@var{depth}が@var{expr}の最大深さ以上の時、
@code{reveal (@var{expr}, @var{depth})}は、@var{expr}をそのまま返します。

@code{reveal}は、引数を評価します。
@code{reveal}は、要約された式を返します。

例:

@example

@c ===beg===
@c e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
@c reveal (e, 1);
@c reveal (e, 2);
@c reveal (e, 3);
@c reveal (e, 4);
@c reveal (e, 5);
@c reveal (e, 6);
@c ===end===
(%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                          2            2
                         b  - 2 a b + a
(%o1)               -------------------------
                        b + a     2 b     2 a
                    2 %e      + %e    + %e
(%i2) reveal (e, 1);
(%o2)                       Quotient
(%i3) reveal (e, 2);
                             Sum(3)
(%o3)                        ------
                             Sum(3)
(%i4) reveal (e, 3);
@group
                     Expt + Negterm + Expt
(%o4)               ------------------------
                    Product(2) + Expt + Expt
@end group
(%i5) reveal (e, 4);
                       2                 2
                      b  - Product(3) + a
(%o5)         ------------------------------------
                         Product(2)     Product(2)
              2 Expt + %e           + %e
(%i6) reveal (e, 5);
                         2            2
                        b  - 2 a b + a
(%o6)              --------------------------
                       Sum(2)     2 b     2 a
                   2 %e       + %e    + %e
(%i7) reveal (e, 6);
                          2            2
                         b  - 2 a b + a
(%o7)               -------------------------
                        b + a     2 b     2 a
                    2 %e      + %e    + %e
@end example

@opencatbox
@category{Expressions}
@category{Display functions}
@closecatbox
@end deffn

@c NEEDS EXPANSION, CLARIFICATION, MORE EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{sublis}
@deffn {関数} sublis (@var{list}, @var{expr})

式に対して多重平行代入を行います。
@var{list}は等式のリストです。
等式の左辺はアトムでなければいけません。

変数@code{sublis_apply_lambda}は@code{sublis}の後の式整理を制御します。

平行代入を行うには、@code{psubst}も参照してください。

例:

@c ===beg===
@c sublis ([a=b, b=a], sin(a) + cos(b));
@c ===end===
@example
(%i1) sublis ([a=b, b=a], sin(a) + cos(b));
(%o1)                    sin(b) + cos(a)
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sublis_apply_lambda}
@defvr {オプション変数} sublis_apply_lambda
デフォルト値: @code{true}

@code{lambda}の代入が@code{sublis}が使われた後の式整理の中で適用されるか
、もしくは、ユーザーが、ものに適用されるように@mref{ev}を実行しなければいけないかを決めます。
@code{true}は適用を意味します。

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{subnumsimp}
@defvr {オプション変数} subnumsimp
デフォルト値: @code{false}

もし@code{true}なら、シンボル@code{f}が与えられた時だけ、
関数@code{subst}と@code{psubst}は添字付き変数@code{f[x]}に数を代入できます。

@code{subst}も参照してください。

@example
(%i1) subst(100,g,g[x]+2);

subst: cannot substitute 100 for operator g in expression g
                                                           x
 -- an error. To debug this try: debugmode(true);

(%i2) subst(100,g,g[x]+2),subnumsimp:true;
(%o2)                          102
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS CLARIFICATION, MORE EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{subst}
@deffn {関数} subst (@var{a}, @var{b}, @var{c})

@var{c}の中の@var{b}に@var{a}を代入します。
@var{b}はアトムもしくは@var{c}の完全な部分式でなければなりません。
例えば、@code{x+y+z}は@code{2*(x+y+z)}の完全な部分式である一方、@code{x+y}は完全な部分式ではありません。
@var{b}がこれらの性質を持たない時は、@mref{substpart}もしくは@mref{ratsubst}が使える時があります（下記参照）。
代わりに、もし@var{b}が@code{e/f}形式なら、@code{subst (a*f, e, c)}が使えますし、
もし@var{b}が@code{e^(1/f)}形式なら、@code{subst (a^f, e, c)}が使えます。
@code{subst}コマンドは@code{x^-y}の中の@code{x^y}も認識するので、
@code{subst (a, sqrt(x), 1/sqrt(x))}は@code{1/a}を出力します。
@var{a}と@var{b}はダブルクォート@code{"}で囲まれた式の演算子でも、関数名でも問題ありません。
導関数形式の独立変数に代入したいなら、@code{at}関数（下記参照）を使うべきです。

@c UMM, REVERSE THIS AND MOVE IT TO substitute ??
@code{subst}は@code{substitute}のエーリアスです。

コマンド@code{subst (@var{eq_1}, @var{expr})}もしくは@code{subst ([@var{eq_1}, ..., @var{eq_k}], @var{expr})}も許されている形式です。
@var{eq_i}はされるべき代入を指示する等式です。
それぞれの等式において、右辺が、式@var{expr}の中の左辺に代入されます。
等式は、@var{expr}に、左から右へ逐次に代入されます。
平行代入するには、関数@code{sublis}と@code{psubst}を参照してください。

@mref{exptsubst}が@code{true}なら、
@code{%e^(a*x)}の中の@code{%e^x}が@code{y}に置き換えられるような代入が許されます。

@c WHAT IS THIS ABOUT ??
@code{opsubst}が@code{false}の時、
@code{subst}は式の演算子への代入を行いません。
例えば、@code{(opsubst: false, subst (X^2, r, r+r[9]))}は意図通り動作します。

例:

@c ===beg===
@c subst (a, x+y, x + (x+y)^2 + y);
@c subst (-%i, %i, a + b*%i);
@c ===end===
@example
(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
@end example

代入は、等式のリストに関して逐次になされます。
これを並列代入と比較してください。

@c ===beg===
@c subst([a=b, b=c], a+b);
@c sublis([a=b, b=c], a+b);
@c ===end===
@example
(%i3) subst([a=b, b=c], a+b);
(%o3)                                 2 c
(%i4) sublis([a=b, b=c], a+b);
(%o4)                                c + b
@end example

@noindent
もっと例を見るには、@code{example (subst)}を実行してください。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION
@anchor{substinpart}
@deffn {関数} substinpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})

@mref{substpart}と同様ですが、@code{substinpart}は@var{expr}の内部表現上で
働きます。

例:

@c ===beg===
@c x . 'diff (f(x), x, 2);
@c substinpart (d^2, %, 2);
@c substinpart (f1, f[1](x + 1), 0);
@c ===end===
@example
(%i1) x . 'diff (f(x), x, 2);
                              2
                             d
(%o1)                   x . (--- (f(x)))
                               2
                             dx
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x + 1), 0);
(%o3)                       f1(x + 1)
@end example

もし@code{part}関数の最後の引数がインデックスのリストなら、
複数の部分式が選ばれます。それぞれはリストのインデックスに対応します。
例えば、

@c ===beg===
@c part (x + y + z, [1, 3]);
@c ===end===
@example
(%i1) part (x + y + z, [1, 3]);
(%o1)                         z + x
@end example

@code{part}関数を使った時、@mref{piece}は、最後の式の値を保持します。
関数の実行の間に設定され、以下で示すように関数自身の中で参照されることもあります。
もし@mref{partswitch}が@code{true}に設定されたら、
式の選択された部分が存在しない時には@code{end}が返されます。
そうでなければ、エラーメッセージが出力されます。

@c ===beg===
@c expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
@c part (expr, 2, [1, 3]);
@c sqrt (piece/54);
@c substpart (factor (piece), expr, [1, 2, 3, 5]);
@c expr: 1/x + y/x - 1/z;
@c substpart (xthru (piece), expr, [2, 3]);
@c ===end===
@example
(%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
              3         2       2            3
(%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
(%i2) part (expr, 2, [1, 3]);
                                  2
(%o2)                         54 y
(%i3) sqrt (piece/54);
(%o3)                        abs(y)
(%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                               3
(%o4)               (3 y + 2 x)  + y + x + 1
(%i5) expr: 1/x + y/x - 1/z;
                             1   y   1
(%o5)                      - - + - + -
                             z   x   x
(%i6) substpart (xthru (piece), expr, [2, 3]);
                            y + 1   1
(%o6)                       ----- - -
                              x     z
@end example

また、
オプション @mref{inflag}を @code{true}に設定し
@mref{part}か @mref{substpart}をコールすることは
@code{inpart}か @code{substinpart}をコールすることと同じです。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION

@c -----------------------------------------------------------------------------
@anchor{substpart}
@deffn {関数} substpart (@var{x}, @var{expr}, @var{n_1}, @dots{}, @var{n_k})

@var{x}を、残りの引数を@code{part}に食わせた結果の部分式に代入します。
@var{expr}の新しい値を返します。
@var{x}は@var{expr}の演算子に代入される演算子でも問題ありません。
いくつかの場合、@var{x}はダブルクォート@code{"}で囲まれる必要があります。
（例えば、@code{substpart ("+", a*b, 0)}は@code{b + a}を返します。）

例:

@c ===beg===
@c 1/(x^2 + 2);
@c substpart (3/2, %, 2, 1, 2);
@c a*x + f(b, y);
@c substpart ("+", %, 1, 0);
@c ===end===
@example
(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
                               1
(%o2)                       --------
                             3/2
                            x    + 2
(%i3) a*x + f(b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart ("+", %, 1, 0);
(%o4)                    x + f(b, y) + a
@end example

また、オプション@mref{inflag}を@code{true}に設定し、
@mref{part}や@code{substpart}をコールすることは、
@code{inpart}や@mref{substinpart}をコールすることと同じになります。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{symbolp}
@deffn {関数} symbolp (@var{expr})

もし@var{expr}がシンボルなら@code{true}、そうでないなら@code{false}を返します。
事実上、@code{symbolp(x)}は、述語論理@code{atom(x) and not numberp(x)}と同値です。

@c FOLLOWING REALLY WANTS TO BE @xref{Identiifers} BUT THAT
@c LEAVES THE UNPLEASANT RESIDUE *Note ...:: IN THE OUTPUT OF describe
@ref{Identifiers}も参照してください。

@opencatbox
@category{Predicate functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{unorder}
@deffn {関数} unorder ()

順序付けコマンド@code{ordergreat}と@code{orderless}の最後の使用で生成されたエーリアシングを使用不可にします。
@code{ordergreat}と@code{orderless}は、
@code{unorder}を呼び出さずに、一回以上使えないかもしれません。
@code{unorder}は、
@code{ordergreat}と@code{orderless}で導入されたエーリアスに
元のシンボルを式に再代入しません。
それ故に、@code{unorder}の実行後、以前の式にエーリアスが現れます。
 
@code{ordergreat}と@code{orderless}も参照してください。

例s:

@code{ordergreat(a)}はシンボル@code{a}のエーリアスを導入します。
それ故に、
@code{%o2}と@code{%o4}の違いは消えません。
@code{unorder}はシンボル@code{a}を再代入しないし、
出力@code{%o7}にエーリアスが現れます。

@c ===beg===
@c unorder();
@c b*x + a^2;
@c ordergreat (a);
@c b*x + a^2;
@c  %th(1) - %th(3);
@c unorder();
@c %th(2);
@c ===end===
@example
(%i1) unorder();
(%o1)                          []
(%i2) b*x+a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat(a);
(%o3)                         done
(%i4) b*x+a^2;
                             2
(%o4)                       a  + b x
(%i5) %th(1)-%th(3);
                              2    2
(%o5)                        a  - a
(%i6) unorder();
(%o6)                          [a]
(%i7) %th(2);
                                2    2
(%o7)                      _101a  - a
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{verbify}
@deffn {関数} verbify (@var{f})

関数名@var{f}の動詞形を返します。
@code{verb}, @code{noun}, @code{nounify}も参照してください。

例:

@c ===beg===
@c verbify ('foo);
@c :lisp $%
@c nounify (foo);
@c :lisp $%
@c ===end===
@example
(%i1) verbify ('foo);
(%o1)                          foo
(%i2) :lisp $%
$FOO
(%i2) nounify (foo);
(%o2)                          foo
(%i3) :lisp $%
%FOO
@end example

@opencatbox
@category{Nouns and verbs}
@closecatbox
@end deffn
