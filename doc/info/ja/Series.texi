@menu
* Sums and Products::
* Introduction to Series::      
* Functions and Variables for Series::
* Poisson series::
@end menu

@c -----------------------------------------------------------------------------
@node Sums and Products, Introduction to Series, Sums Products and Series, Sums Products and Series
@section Sums and Products
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{bashindices}
@deffn {関数} bashindices (@var{expr})
それぞれの和や積に独自のインデックスを与えることで、
式@var{expr}を変換します。
これは、
和や積と一緒に機能する時
@code{changevar}によりよい精度を与えます。
独自のインデックスの形式は@code{j@var{number}}です。
量@var{number}は、@code{gensumnum}に参照することで決定されます。
これを、ユーザーは変更することができます。
例えば、@code{gensumnum:0$}はそれを再設定します。

@opencatbox
@category{Sums and products}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{lsum}
@deffn {関数} lsum (@var{expr}, @var{x}, @var{L})

@var{L}の中のそれぞれの要素@var{x}に関する@var{expr}の和を表します。
もし引数@var{L}がリストに評価されなければ、名詞形@code{'lsum}が返されます。

例:

@c ===beg===
@c lsum (x^i, i, [1, 2, 7]);
@c lsum (i^2, i, rootsof (x^3 - 1, x));
@c ===end===
@example
(%i1) lsum (x^i, i, [1, 2, 7]);
                            7    2
(%o1)                      x  + x  + x
(%i2) lsum (i^2, i, rootsof (x^3 - 1, x));
@group
                     ====
                     \      2
(%o2)                 >    i
                     /
                     ====
                                   3
                     i in rootsof(x  - 1, x)
@end group
@end example

@opencatbox
@category{Sums and products}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{intosum}
@deffn {関数} intosum (@var{expr})

和の外側の掛け算因子を内側に移動します。
もし外側の式でインデックスが使われているなら、
関数は、@code{sumcontract}に関してするのと同じように、合理的なインデックスを見つけようとします。
これは、本質的に、和の@code{outative}プロパティの逆の考えですが、
このプロパティを取り除かず、ただ無視するだけであることに注意してください。

@c WHAT ARE THESE CASES ??
いくつかの場合、
@code{intosum}の前に、@code{scanmap (multthru, @var{expr})}が必要になるかもしれません。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{product}
@deffn {関数} product (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

インデックス@var{i}が@var{i_0}から@var{i_1}まで変えた@var{expr}の値の積を返します。
名詞形@code{'product}は、大文字Πとして表示されます。

@code{product}は、@var{expr}と下限上限@var{i_0}、@var{i_1}を評価し、
@code{product}は、インデックス@var{i}をクォートします（評価しません）。

もし上限と下限が整数差だけ違うなら、
@var{expr}は、インデックス@var{i}のそれぞれの値に関して評価され、
結果は陽な積です。

そうでなければ、インデックスの範囲は不定です。
積を整理するためにいくつかの規則が適用されます。
グローバル変数@code{simpproduct}が@code{true}の時、
更なる規則が適用されます。
いくつかの場合、式整理は、積でない結果を出力します;
そうでなければ、結果は名詞形@code{'product}です。

@code{nouns}と@code{evflag}も参照してください。

例:

@c ===beg===
@c product (x + i*(i+1)/2, i, 1, 4);
@c product (i^2, i, 1, 7);
@c product (a[i], i, 1, 7);
@c product (a(i), i, 1, 7);
@c product (a(i), i, 1, n);
@c product (k, k, 1, n);
@c product (k, k, 1, n), simpproduct;
@c product (integrate (x^k, x, 0, 1), k, 1, n);
@c product (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===

@example
(%i1) product (x + i*(i+1)/2, i, 1, 4);
(%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
(%i2) product (i^2, i, 1, 7);
(%o2)                       25401600
(%i3) product (a[i], i, 1, 7);
(%o3)                 a  a  a  a  a  a  a
                       1  2  3  4  5  6  7
(%i4) product (a(i), i, 1, 7);
(%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
(%i5) product (a(i), i, 1, n);
                             n
                           /===\
                            ! !
(%o5)                       ! !  a(i)
                            ! !
                           i = 1
(%i6) product (k, k, 1, n);
                               n
                             /===\
                              ! !
(%o6)                         ! !  k
                              ! !
                             k = 1
(%i7) product (k, k, 1, n), simpproduct;
(%o7)                          n!
(%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                             n
                           /===\
                            ! !    1
(%o8)                       ! !  -----
                            ! !  k + 1
                           k = 1
(%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                              15  40
(%o9)                        a   b
@end example

@opencatbox
@category{Sums and products}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{simpsum}
@defvr {オプション変数} simpsum
デフォルト値: @code{false}

@code{simpsum}が@code{true}の時、
@code{sum}の結果は、整理されます。
この整理は、時々、閉形式を生成することができるかもしれません。
もし@code{simpsum}が@code{false}もしくは、もしクォートされた形@code{'sum}が使われたなら、
値は、数学で使われるΣ表示の表現である和の名詞形です。

@opencatbox
@category{Sums and products}
@category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{sum}
@deffn {関数} sum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

インデックス@var{i}が@var{i_0}から@var{i_1}まで変えた@var{expr}の値の和を返します。
名詞形@code{'sum}は、大文字Σとして表示されます。

@code{sum}は、被和@var{expr}と下限上限@var{i_0}、@var{i_1}を評価し、
@code{sum}は、インデックス@var{i}をクォートします（評価しません）。

もし上限と下限が整数差だけ違うなら、
被和@var{expr}は、インデックス@var{i}のそれぞれの値に関して評価され、
結果は陽な和です。

そうでなければ、インデックスの範囲は不定です。
積を整理するためにいくつかの規則が適用されます。
グローバル変数@code{simpsum}が@code{true}の時、
更なる規則が適用されます。
いくつかの場合、式整理は、和でない結果を出力します;
そうでなければ、結果は名詞形@code{'sum}です。

@code{evflag}(評価フラグ) @code{cauchysum}が@code{true}の時、
和の積は、コーシー積として表現されます。
コーシー積では、内側の和のインデックスは、独立に変化するのではなく、外側の和のインデックスの関数になります。

グローバル変数@code{genindex}は、
和の次のインデックスを生成するのに使われるアルファベット前置です。

@code{gensumnum}は、
自動生成されるインデックスが必要な時、
和の次のインデックスを生成するのに使われる数値接尾です。
@code{gensumnum}が@code{false}の時,
自動生成されるインデックスは、接尾なしの@code{genindex}のみです。

@code{sumcontract}, @code{intosum}, @code{bashindices}, @code{niceindices},
@code{nouns}, @code{evflag}, @code{zeilberger}も参照してください。

例:

@c ===beg===
@c sum (i^2, i, 1, 7);
@c sum (a[i], i, 1, 7);
@c sum (a(i), i, 1, 7);
@c sum (a(i), i, 1, n);
@c sum (2^i + i^2, i, 0, n);
@c sum (2^i + i^2, i, 0, n), simpsum;
@c sum (1/3^i, i, 1, inf);
@c sum (1/3^i, i, 1, inf), simpsum;
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
@c sum (integrate (x^k, x, 0, 1), k, 1, n);
@c sum (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===

@example
(%i1) sum (i^2, i, 1, 7);
(%o1)                          140
(%i2) sum (a[i], i, 1, 7);
(%o2)           a  + a  + a  + a  + a  + a  + a
                 7    6    5    4    3    2    1
(%i3) sum (a(i), i, 1, 7);
(%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
(%i4) sum (a(i), i, 1, n);
                            n
                           ====
                           \
(%o4)                       >    a(i)
                           /
                           ====
                           i = 1
(%i5) sum (2^i + i^2, i, 0, n);
                          n
                         ====
                         \       i    2
(%o5)                     >    (2  + i )
                         /
                         ====
                         i = 0
(%i6) sum (2^i + i^2, i, 0, n), simpsum;
                              3      2
                   n + 1   2 n  + 3 n  + n
(%o6)             2      + --------------- - 1
                                  6
(%i7) sum (1/3^i, i, 1, inf);
                            inf
                            ====
                            \     1
(%o7)                        >    --
                            /      i
                            ====  3
                            i = 1
(%i8) sum (1/3^i, i, 1, inf), simpsum;
                                1
(%o8)                           -
                                2
(%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                              inf
                              ====
                              \     1
(%o9)                      30  >    --
                              /      2
                              ====  i
                              i = 1
(%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                  2
(%o10)                       5 %pi
(%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                            n
                           ====
                           \       1
(%o11)                      >    -----
                           /     k + 1
                           ====
                           k = 1
(%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
          10    9    8    7    6    5    4    3    2
(%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a
@end example

@opencatbox
@category{Sums and products}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{sumcontract}
@deffn {関数} sumcontract (@var{expr})
定数だけ異なる上限と下限を持つ足し算の和すべてを結合します。
結果は、
そんな和のそれぞれの集合が、この和を形成するよう抽出されなければならないすべての適切な余分の項に加えられた１つの和を含む式です。
@code{sumcontract}は、互換性のある和すべてを結合し、
可能なら和の１つからインデックスの１つを使い、もし供給されたどれもが使えないなら、合理的なインデックスを形成するよう試みます。

@c WHEN IS intosum NECESSARY BEFORE sumcontract ??
@code{sumcontract}の前に、@code{intosum (@var{expr})}を実行する必要があるかもしれません。

@opencatbox
@category{Sums and products}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sumexpand}
@defvr {オプション変数} sumexpand
デフォルト値: @code{false}

@code{sumexpand}が@code{true}の時、
和の積と、指数和は、入れ子の和に整理されます。

@code{cauchysum}も参照してください。

例:

@example
(%i1) sumexpand: true$
(%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
@group
                     m      n
                    ====   ====
                    \      \
(%o2)                >      >     f(i1) g(i2)
                    /      /
                    ====   ====
                    i1 = 0 i2 = 0
@end group
(%i3) sum (f (i), i, 0, m)^2;
                     m      m
                    ====   ====
                    \      \
(%o3)                >      >     f(i3) f(i4)
                    /      /
                    ====   ====
                    i3 = 0 i4 = 0
@end example

@opencatbox
@category{Sums and products}
@category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@node Introduction to Series, Functions and Variables for Series, Sums and Products, Sums Products and Series
@section Introduction to Series
@c -----------------------------------------------------------------------------

Maximaは、微分可能な関数の級数を見つけるために、
関数@code{taylor}と@code{powerseries}を含みます。
ある級数の閉形式を見つける性能がある@code{nusum}のようなツールも持ちます。
足し算や掛け算のような演算は、級数上で普通に機能します。
この節は、展開を制御するグローバル変数を提供します。

@c end concepts Series

@c -----------------------------------------------------------------------------
@node Functions and Variables for Series, Poisson series, Introduction to Series, Sums Products and Series
@section Functions and Variables for Series
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{cauchysum}
@defvr {オプション変数} cauchysum
デフォルト値: @code{false}

@c REPHRASE
上限として@code{inf}を持つ和同士を掛ける時、
もし@code{sumexpand}が@code{true}、かつ、@code{cauchysum}が@code{true}なら、
通常の積ではなくCauchy積が使われます。
Cauchy積では、
内側の和のインデックスは、独立に変化するのではなく、外側のインデックスの関数です。

例:

@example
(%i1) sumexpand: false$
(%i2) cauchysum: false$
(%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                      inf         inf
                      ====        ====
                      \           \
(%o3)                ( >    f(i))  >    g(j)
                      /           /
                      ====        ====
                      i = 0       j = 0
(%i4) sumexpand: true$
(%i5) cauchysum: true$
(%i6) ''s;
                 inf     i1
                 ====   ====
                 \      \
(%o6)             >      >     g(i1 - i2) f(i2)
                 /      /
                 ====   ====
                 i1 = 0 i2 = 0
@end example

@opencatbox
@category{Sums and products}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{deftaylor}
@deffn {関数} deftaylor (@var{f_1}(@var{x_1}), @var{expr_1}, @dots{}, @var{f_n}(@var{x_n}), @var{expr_n})

@code{deftaylor}は、
ある変数@var{x_i}の関数@var{f_i}それぞれに関して、
@var{expr_i}をゼロの回りのTaylor級数と定義します。
@var{expr_i}は、典型的には、@var{x_i}の多項式か和です;
@code{deftaylor}は、もっと一般的な式も問題なく受け付けます。

@code{powerseries (@var{f_i}(@var{x_i}), @var{x_i}, 0)}は、
@code{deftaylor}で定義された級数を返します。

@code{deftaylor}は、
関数@var{f_1}, ..., @var{f_n}のリストを返します。
@code{deftaylor}は、引数を評価します。

例:

@example
(%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
(%o1)                          [f]
(%i2) powerseries (f(x), x, 0);
                      inf
                      ====      i1
                      \        x         2
(%o2)                  >     -------- + x
                      /       i1    2
                      ====   2   i1!
                      i1 = 4
(%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                      2         3          4
                     x    3073 x    12817 x
(%o3)/T/     1 + x + -- + ------- + -------- + . . .
                     2     18432     307200
@end example

@opencatbox
@category{Power series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{maxtayorder}
@defvr {オプション変数} maxtayorder
デフォルト値: @code{true}

@c REPHRASE
@code{maxtayorder}が@code{true}の時、
(切り詰められた)Taylor級数の代数操作の間、
@code{taylor}は、厳密とわかっているできるだけ多くの項を保とうとします。

@opencatbox
@category{Power series}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{niceindices}
@deffn {関数} niceindices (@var{expr})

@var{expr}の中の和や積のインデックスを改名します。
@code{niceindices}は、
その名前が被加数や非積数の中に現れないなら、
インデックスそれぞれを@code{niceindicespref[1]}の値に改名しようとします。
現れた場合、
@code{niceindices}は、
未使用の変数が見つかるまで@code{niceindicespref}の次の要素を順に試します。
もしリスト全部が使い果たされたら、
例えば, @code{i0}, @code{i1}, @code{i2}, ....というように、
@code{niceindicespref[1]}の値に整数を追加することで、
追加のインデックスが構成されます。

@code{niceindices}は式を返します。
@code{niceindices}は引数を評価します。

例:

@example
(%i1) niceindicespref;
(%o1)                  [i, j, k, l, m, n]
(%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                 inf    inf
                /===\   ====
                 ! !    \
(%o2)            ! !     >      f(bar i j + foo)
                 ! !    /
                bar = 1 ====
                        foo = 1
(%i3) niceindices (%);
@group
                     inf  inf
                    /===\ ====
                     ! !  \
(%o3)                ! !   >    f(i j l + k)
                     ! !  /
                    l = 1 ====
                          k = 1
@end group
@end example

@opencatbox
@category{Sums and products}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{niceindicespref}
@defvr {オプション変数} niceindicespref
デフォルト値: @code{[i, j, k, l, m, n]}

@code{niceindicespref}は、
@code{niceindices}が和や積のインデックスの名前を取ってくる
リストです。

The elements of 
@code{niceindicespref}の要素は、
@code{niceindices}によって強制されませんが、
通常、変数名です。

例:

@example
(%i1) niceindicespref: [p, q, r, s, t, u]$
(%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                 inf    inf
                /===\   ====
                 ! !    \
(%o2)            ! !     >      f(bar i j + foo)
                 ! !    /
                bar = 1 ====
                        foo = 1
(%i3) niceindices (%);
                     inf  inf
                    /===\ ====
                     ! !  \
(%o3)                ! !   >    f(i j q + p)
                     ! !  /
                    q = 1 ====
                          p = 1
@end example

@opencatbox
@category{Sums and products}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{nusum}
@deffn {関数} nusum (@var{expr}, @var{x}, @var{i_0}, @var{i_1})

R.W. Gosperによる決定手続きを使って、
@var{x}に関する@var{expr}の不定超幾何総和を実行します。
@var{expr}と結果は、
整数べき、階乗、二項式、有理関数の積として表現可能でなければいけません。

@c UMM, DO WE REALLY NEED TO DEFINE "DEFINITE" AND "INDEFINITE" SUMMATION HERE ??
@c (CAN'T WE MAKE THE POINT WITHOUT DRAGGING IN SOME NONSTANDARD TERMINOLOGY ??)
用語「定」と「不定和」は、
「定」と「不定積分」へ類似して使われています。
不定に和を取ることは、
ただ、例えば0からinfまででなく、
変数の長さの区間上の和に関して、シンボリックな結果を与えることを意味します。
例えば、二項級数の一般的な部分和に関する公式はないので、
@code{nusum}はそれができません。

@code{nusum}と@code{unsum}は、有限積の和と差について少し知っています。
@code{unsum}も参照してください。

例:

@example
(%i1) nusum (n*n!, n, 0, n);

Dependent equations eliminated:  (1)
(%o1)                     (n + 1)! - 1
(%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                     4        3       2              n
      2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
(%o2) ------------------------------------------------ - ------
                    693 binomial(2 n, n)                 3 11 7
(%i3) unsum (%, n);
                              4  n
                             n  4
(%o3)                   ----------------
                        binomial(2 n, n)
(%i4) unsum (prod (i^2, i, 1, n), n);
                    n - 1
                    /===\
                     ! !   2
(%o4)              ( ! !  i ) (n - 1) (n + 1)
                     ! !
                    i = 1
(%i5) nusum (%, n, 1, n);

Dependent equations eliminated:  (2 3)
                            n
                          /===\
                           ! !   2
(%o5)                      ! !  i  - 1
                           ! !
                          i = 1
@end example

@opencatbox
@category{Sums and products}
@closecatbox
@end deffn

@c THIS ITEM NEEDS SERIOUS WORK

@c -----------------------------------------------------------------------------
@anchor{pade}
@deffn {関数} pade (@var{taylor_series}, @var{numer_deg_bound}, @var{denom_deg_bound})

分子と分母の次数の和がべき級数の切り詰めレベル以下の
与えられたTaylor級数展開、すなわち、「最良」近似を持ち
加えて指定された次数範囲を満たす、有理関数すべてのリストを返します。

@var{taylor_series}は１変数Taylor級数です。
@var{numer_deg_bound}と@var{denom_deg_bound}は、
分子と分母上の次数範囲を指定する
正の整数です。

@var{taylor_series}は
Laurent級数も可能です。
次数範囲は、@code{inf}も可能で、
総次数が、冪級数の長さ以下の有理関数すべてを返すことになります。
総次数は
@code{@var{numer_deg_bound} + @var{denom_deg_bound}}として定義されます。
べき級数の長さは
@code{"truncation level" + 1 - min(0, "order of series")}として定義されます。

@example
(%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                              2    3
(%o1)/T/             1 + x + x  + x  + . . .
(%i2) pade (%, 1, 1);
                                 1
(%o2)                       [- -----]
                               x - 1
(%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                   + 387072*x^7 + 86016*x^6 - 1507328*x^5
                   + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                   + 67108864*x - 134217728)
       /134217728, x, 0, 10);
                    2    3       4       5       6        7
             x   3 x    x    15 x    23 x    21 x    189 x
(%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
             2    16    32   1024    2048    32768   65536

                                  8         9          10
                            5853 x    2847 x    83787 x
                          + ------- + ------- - --------- + . . .
                            4194304   8388608   134217728
(%i4) pade (t, 4, 4);
(%o4)                          []
@end example

このべき級数展開を持つ次数4の 分子/分母の有理関数はありません。
一般的に、
解くのに十分な数の未知の係数を持つために、
その和が少なくともべき級数の次数になるまで
分子の次数と分母の次数を増やさなければいけません。

@example
(%i5) pade (t, 5, 5);
                     5                4                 3
(%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                  2
 - 1619100813312 x  - 2176885157888 x - 2386516803584)

               5                 4                  3
/(47041365435 x  + 381702613848 x  + 1360678489152 x

                  2
 + 2856700692480 x  + 3370143559680 x + 2386516803584)]
@end example

@opencatbox
@category{Power series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{powerseries}
@deffn {関数} powerseries (@var{expr}, @var{x}, @var{a})

変数@var{x}に関する点@var{a}
 (無限大のためには@code{inf}かもしれません)
の回りの@var{expr}のべき級数展開の一般形式を返します:
@example
@group
           inf
           ====
           \               n
            >    b  (x - a)
           /      n
           ====
           n = 0
@end group
@end example

もし@code{powerseries}が@var{expr}を展開することができないなら、
@code{taylor}が、級数の最初のいくつかの項を与えることができます。

@code{verbose}が@code{true}の時、
@code{powerseries}は進捗メッセージを印字します。

@example
(%i1) verbose: true$
(%i2) powerseries (log(sin(x)/x), x, 0);
can't expand 
                                 log(sin(x))
so we'll try again after applying the rule:
                                        d
                                      / -- (sin(x))
                                      [ dx
                        log(sin(x)) = i ----------- dx
                                      ]   sin(x)
                                      /
in the first simplification we have returned:
                             /
                             [
                             i cot(x) dx - log(x)
                             ]
                             /
                    inf
                    ====        i1  2 i1             2 i1
                    \      (- 1)   2     bern(2 i1) x
                     >     ------------------------------
                    /                i1 (2 i1)!
                    ====
                    i1 = 1
(%o2)                -------------------------------------
                                      2
@end example

@opencatbox
@category{Power series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{psexpand}
@defvr {オプション変数} psexpand
デフォルト値: @code{false}

@code{psexpand}が@code{true}の時、
拡張有理関数展開が完全に展開されて表示されます。
スイッチ@code{ratexpand}は同じ効果を持ちます。

@c WE NEED TO BE EXPLICIT HERE
@code{psexpand}が@code{false}の時、
多変数式がちょうど有理関数パッケージにあるかのように表示されます。

@c TERMS OF WHAT ??
@code{psexpand}が@code{multi}の時、
変数に関する同じ総次数の項は一緒にまとめられます。

@opencatbox
@category{Display flags and variables}
@closecatbox

@end defvr

@c -----------------------------------------------------------------------------
@anchor{revert}
@deffn  {関数} revert (@var{expr}, @var{x})
@deffnx {関数} revert2 (@var{expr}, @var{x}, @var{n})
これらの関数は、
変数@var{x}に関するゼロの回りのTaylor級数@var{expr}の反転を返します。
@code{revert}は、
@var{expr}の最高次数と等しい次数の多項式を返します。
@code{revert2}は、次数@var{n}の多項式を返します。
@var{n}は、@var{expr}の次数よりも大きい値も小さい値も同じ値も取り得ます。

@code{load ("revert")}はこれらの関数をロードします。

例:

@example
(%i1) load ("revert")$
(%i2) t: taylor (exp(x) - 1, x, 0, 6);
                   2    3    4    5     6
                  x    x    x    x     x
(%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                  2    6    24   120   720
(%i3) revert (t, x);
               6       5       4       3       2
           10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
(%o3)/R/ - --------------------------------------------
                                60
(%i4) ratexpand (%);
                     6    5    4    3    2
                    x    x    x    x    x
(%o4)             - -- + -- - -- + -- - -- + x
                    6    5    4    3    2
(%i5) taylor (log(x+1), x, 0, 6);
                    2    3    4    5    6
                   x    x    x    x    x
(%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                   2    3    4    5    6
(%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
(%o6)                           0
(%i7) revert2 (t, x, 4);
                          4    3    2
                         x    x    x
(%o7)                  - -- + -- - -- + x
                         4    3    2
@end example

@opencatbox
@category{Power series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylor}
@deffn  {関数} taylor (@var{expr}, @var{x}, @var{a}, @var{n})
@deffnx {関数} taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], @var{a}, @var{n})
@deffnx {関数} taylor (@var{expr}, [@var{x}, @var{a}, @var{n}, 'asymp])
@deffnx {関数} taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], [@var{a_1}, @var{a_2}, ...], [@var{n_1}, @var{n_2}, ...])
@deffnx {関数} taylor (@var{expr}, [@var{x_1}, @var{a_1}, @var{n_1}], [@var{x_2}, @var{a_2}, @var{n_2}], ...)

@code{taylor (@var{expr}, @var{x}, @var{a}, @var{n})}は、
式@var{expr}を、変数@var{x}の@var{a}の周りのTaylorもしくはLaurent級数を
@code{(@var{x} - @var{a})^@var{n}}まで展開します。

もし@var{expr}が形式@code{@var{f}(@var{x})/@var{g}(@var{x})} の形であり、
@code{@var{g}(@var{x})}が@var{n}次まで項を持たないなら、
@code{taylor}は@code{@var{g}(@var{x})}を@code{2 @var{n}}次まで展開しようとします。
もしまだ0でない項がないなら、
@code{taylor}は、展開の次数が@code{@var{n} 2^taylordepth}以下である限り
@code{@var{g}(@var{x})}の展開の次数を倍にしていきます。

@code{taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], @var{a}, @var{n})}
は、すべての変数@var{x_1}, @var{x_2}, ...について
点@code{(@var{a}, @var{a}, , ...)}の周りで@var{n}次までのべき級数を返します。

@code{taylor (@var{expr}, [@var{x_1}, @var{a_1}, @var{n_1}], [@var{x_2}, @var{a_2}, @var{n_2}], ...)}は、変数@var{x_1}, @var{x_2}, ...について
点@code{(@var{a_1}, @var{a_2}, ...)}の回りで
@var{n_1}次, @var{n_2}次, ....まで展開したべき級数を返します。

@code{taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], [@var{a_1}, @var{a_2}, ...], [@var{n_1}, @var{n_2}, ...])}は、
変数@var{x_1}, @var{x_2}, ...について、
点@code{(@var{a_1}, @var{a_2}, ...)}の回りで
@var{n_1}次, @var{n_2}次, ....まで展開したべき級数を返します。

@code{taylor (@var{expr}, [@var{x}, @var{a}, @var{n}, 'asymp])}は、
@var{expr}の@code{@var{x} - @var{a}}の負のべき乗展開を返します。
最高次の項は@code{(@var{x} - @var{a})^@var{-n}}です。

@code{maxtaylorder}が@code{true}の時、
（丸められた）Taylor級数の代数操作の間、
@code{talyor}は正確とわかっている限り多くの項を保とうとします。

@code{psexpand}が@code{true}の時、
拡張有理関数式は、フルに展開されて表示されます。
スイッチ@code{ratexpand}は同じ効果を持ちます。
@code{psexpand}が@code{false}の時、
有理関数パッケージかのように多変数式が表示されます。
@code{psexpand}が@code{multi}なら、同じ総次数の項が一緒にグループ化されます。

展開を制御するには、@code{taylor_logexpand}スイッチも参照してください。

例:

@c EXAMPLES ADAPTED FROM example (taylor)
@c taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
@c %^2;
@c taylor (sqrt (x + 1), x, 0, 5);
@c %^2;
@c product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
@c ev (taylor(%, x,  0, 3), keepfloat);
@c taylor (1/log (x + 1), x, 0, 3);
@c taylor (cos(x) - sec(x), x, 0, 5);
@c taylor ((cos(x) - sec(x))^3, x, 0, 5);
@c taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
@c taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
@c taylor ((x + 1)^n, x, 0, 4);
@c taylor (sin (y + x), x, 0, 3, y, 0, 3);
@c taylor (sin (y + x), [x, y], 0, 3);
@c taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
@c taylor (1/sin (y + x), [x, y], 0, 3);
@example
(%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                           2             2
             (a + 1) x   (a  + 2 a + 1) x
(%o1)/T/ 1 + --------- - -----------------
                 2               8

                                   3      2             3
                               (3 a  + 9 a  + 9 a - 1) x
                             + -------------------------- + . . .
                                           48
(%i2) %^2;
                                    3
                                   x
(%o2)/T/           1 + (a + 1) x - -- + . . .
                                   6
(%i3) taylor (sqrt (x + 1), x, 0, 5);
                       2    3      4      5
                  x   x    x    5 x    7 x
(%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                  2   8    16   128    256
(%i4) %^2;
(%o4)/T/                  1 + x + . . .
(%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
@group
                         inf
                        /===\
                         ! !    i     2.5
                         ! !  (x  + 1)
                         ! !
                        i = 1
(%o5)                   -----------------
                              2
                             x  + 1
@end group
(%i6) ev (taylor(%, x,  0, 3), keepfloat);
                               2           3
(%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
(%i7) taylor (1/log (x + 1), x, 0, 3);
                               2       3
                 1   1   x    x    19 x
(%o7)/T/         - + - - -- + -- - ----- + . . .
                 x   2   12   24    720
(%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                4
                           2   x
(%o8)/T/                - x  - -- + . . .
                               6
(%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
(%o9)/T/                    0 + . . .
(%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                               2          4
            1     1       11      347    6767 x    15377 x
(%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
             6      4        2   15120   604800    7983360
            x    2 x    120 x

                                                          + . . .
(%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
               2  2       4      2   4
              k  x    (3 k  - 4 k ) x
(%o11)/T/ 1 - ----- - ----------------
                2            24

                                    6       4       2   6
                               (45 k  - 60 k  + 16 k ) x
                             - -------------------------- + . . .
                                          720
(%i12) taylor ((x + 1)^n, x, 0, 4);
@group
                      2       2     3      2         3
                    (n  - n) x    (n  - 3 n  + 2 n) x
(%o12)/T/ 1 + n x + ----------- + --------------------
                         2                 6

                               4      3       2         4
                             (n  - 6 n  + 11 n  - 6 n) x
                           + ---------------------------- + . . .
                                          24
@end group
(%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
               3                 2
              y                 y
(%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
              6                 2

                    3                       2
               y   y            2      1   y            3
          + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
               2   12                  6   12
(%i14) taylor (sin (y + x), [x, y], 0, 3);
                     3        2      2      3
                    x  + 3 y x  + 3 y  x + y
(%o14)/T/   y + x - ------------------------- + . . .
                                6
(%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
          1   y              1    1               1            2
(%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
          y   6               2   6                3
                             y                    y

                                           1            3
                                      + (- -- + . . .) x  + . . .
                                            4
                                           y
(%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                             3         2       2        3
            1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
(%o16)/T/ ----- + ----- + ------------------------------- + . . .
          x + y     6                   360
@end example

@opencatbox
@category{Power series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylordepth}
@defvr {オプション変数} taylordepth
デフォルト値: 3

@c UM, THE CONTEXT FOR THIS REMARK NEEDS TO BE ESTABLISHED
もしまだ非ゼロ項がないなら、
展開の次数が@code{@var{n} 2^taylordepth}以下である限り、
@code{taylor}は、
@code{@var{g}(@var{x})}の展開の次数を倍にします。

@opencatbox
@category{Power series}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taylorinfo}
@deffn {関数} taylorinfo (@var{expr})

Taylor級数@var{expr}についての情報を返します。
戻り値はリストのリストです。
リストそれぞれは、変数名、展開点、展開次数から成ります。

もし@var{expr}がTaylor級数でないなら、
@code{taylorinfo}は@code{false}を返します。

例:

@example
(%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                  2                       2
(%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

         2                        2
 + (1 - a  - 2 a (y - a) - (y - a) ) x

         2                        2   2
 + (1 - a  - 2 a (y - a) - (y - a) ) x

         2                        2   3
 + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
(%i2) taylorinfo(%);
(%o2)               [[y, a, inf], [x, 0, 3]]
@end example

@opencatbox
@category{Power series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylorp}
@deffn {関数} taylorp (@var{expr})

もし@var{expr}がTaylor級数なら、@code{true}を、
そうでないなら、@code{false}を返します。

@opencatbox
@category{Predicate functions}
@category{Power series}
@closecatbox
@end deffn

@c WHAT IS THIS ABOUT EXACTLY ??

@c -----------------------------------------------------------------------------
@anchor{taylor_logexpand}
@defvr {オプション変数} taylor_logexpand
デフォルト値: @code{true}

@code{taylor_logexpand}は、
@code{taylor}級数の中の対数の展開を制御します。

@code{taylor_logexpand}が@code{true}の時、
対数すべては完全に展開されるので、対数的恒等式を含むゼロ認識問題は
展開プロセスを邪魔しません。
しかしながら、分岐情報を無視するので、この方法はいつも数学的にただしいわけではありません。

@code{taylor_logexpand}が@code{false}に設定されている時、
生じる対数の唯一の展開は、
形式的なべき級数を得るのに必要なものです。

@c NEED EXAMPLES HERE
@opencatbox
@category{Power series}
@category{Exponential and logarithm functions}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taylor_order_coefficients}
@defvr {オプション変数} taylor_order_coefficients
デフォルト値: @code{true}

@code{taylor_order_coefficients}は、
Taylor級数の中の係数の順序付けを制御します。

@code{taylor_order_coefficients}が@code{true}の時、
Taylor級数の係数は標準に順序付けられます。
@c IS MAXIMA'S NOTION OF "CANONICALLY" DESCRIBED ELSEWHERE ??
@c AND WHAT HAPPENS WHEN IT IS FALSE ??

@c NEED EXAMPLES HERE
@opencatbox
@category{Power series}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taylor_simplifier}
@deffn {関数} taylor_simplifier (@var{expr})

べき級数@var{expr}の係数を整理します。
@code{taylor}はこの関数をコールします。

@opencatbox
@category{Power series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylor_truncate_polynomials}
@defvr {オプション変数} taylor_truncate_polynomials
デフォルト値: @code{true}

@c WHAT IS THE "INPUT TRUNCATION LEVEL" ?? THE ARGUMENT n OF taylor ??
@code{taylor_truncate_polynomials}が@code{true}の時、
多項式は入力切り詰めレベルを基礎に切り詰められます。

そうでないなら、
@code{taylor}への多項式入力は、
不定の精度を持つと考えられます。
@c WHAT IS "INFINITE PRECISION" IN THIS CONTEXT ??

@opencatbox
@category{Power series}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taytorat}
@deffn {関数} taytorat (@var{expr})
@code{taylor}形式から標準有理式(CRE)形式に
@var{expr}を変換します。
効果は@code{rat (ratdisrep (@var{expr}))}と同じですが、より速いです。

@opencatbox
@category{Power series}
@category{Rational expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{trunc}
@deffn {関数} trunc (@var{expr})

一般式@var{expr}の内部表現をアノテートするので、まるでその和が切り詰められたTaylor級数かのように表示されます。
@var{expr}は別に変更されません。

例:

@example
(%i1) expr: x^2 + x + 1;
                            2
(%o1)                      x  + x + 1
(%i2) trunc (expr);
                                2
(%o2)                  1 + x + x  + . . .
(%i3) is (expr = trunc (expr));
(%o3)                         true
@end example

@opencatbox
@category{Power series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{unsum}
@deffn {関数} unsum (@var{f}, @var{n})

最初の後方差@code{@var{f}(@var{n}) - @var{f}(@var{n} - 1)}を返します。
従って、
@code{unsum}は、ある意味、@code{sum}の逆です。

@code{nusum}も参照してください。

例:
@c GENERATED FROM THE FOLLOWING INPUTS
@c g(p) := p*4^n/binomial(2*n,n);
@c g(n^4);
@c nusum (%, n, 0, n);
@c unsum (%, n);

@example
(%i1) g(p) := p*4^n/binomial(2*n,n);
                                     n
                                  p 4
(%o1)               g(p) := ----------------
                            binomial(2 n, n)
(%i2) g(n^4);
                              4  n
                             n  4
(%o2)                   ----------------
                        binomial(2 n, n)
(%i3) nusum (%, n, 0, n);
                     4        3       2              n
      2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
(%o3) ------------------------------------------------ - ------
                    693 binomial(2 n, n)                 3 11 7
(%i4) unsum (%, n);
                              4  n
                             n  4
(%o4)                   ----------------
                        binomial(2 n, n)
@end example

@opencatbox
@category{Sums and products}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{verbose}
@defvr {オプション変数} verbose
デフォルト値: @code{false}

@code{verbose}が@code{true}の時、
@code{powerseries}は進捗メッセージを印字します。

@opencatbox
@category{Power series}
@closecatbox

@end defvr

@c -----------------------------------------------------------------------------
@node Poisson series, , Functions and Variables for Series, Sums Products and Series
@section Poisson series
@c -----------------------------------------------------------------------------

@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{intopois}
@deffn {関数} intopois (@var{a})
@var{a}をPoisson符号に変換します。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{outopois}
@deffn {関数} outofpois (@var{a})

@var{a}をPoisson符号から一般表現に変換します。
もし@var{a}がPoisson形式でないなら、
@code{outofpois}は変換を実行し、
すなわち、その戻り値は、@code{outofpois (intopois (@var{a}))}です。
例えば、この関数は、
特定のタイプのサインやコサイン項のべきの和に関する
標準整理器です。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c NEED MORE INFO HERE
@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{poisdiff}
@deffn {関数} poisdiff (@var{a}, @var{b})

@var{a}を@var{b}に関して微分します。
@var{b}は三角関数の引数の中だけ、または係数の中だけにいなければいけません。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c LOOKING AT THE CODE IN src/pois3.lisp, THIS FCN SEEMS TO COMPUTE THE EXPONENT BY MULTIPLYING IN A LOOP
@c DUNNO HOW WE WANT TO EXPLAIN THAT
@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poisexpt}
@deffn {関数} poisexpt (@var{a}, @var{b})

関数的に@code{intopois (@var{a}^@var{b})}と同一です。
@var{b}は正の整数でなければいけません。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c WHAT IS THIS ABOUT ??

@c -----------------------------------------------------------------------------
@anchor{poisint}
@deffn {関数} poisint (@var{a}, @var{b})

(@code{poisdiffと})似て制限された意味で積分します。
もし@var{b}が三角関数の引数の中にあるなら、
@var{b}の中の非周期的項は落とされます。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{poislim}
@defvr {オプション変数} poislim
デフォルト値: 5

@code{poislim}は、三角関数の引数の中の係数の領域を決定します。
初期値5は
区間[-2^(5-1)+1,2^(5-1)]、すなわち[-15,16]に対応しますが、
[-2^(n-1)+1, 2^(n-1)]に設定することができます。

@opencatbox
@category{Poisson series}
@closecatbox
@end defvr

@c UMM, WHAT IS THIS ABOUT EXACTLY ?? EXAMPLES NEEDED

@c -----------------------------------------------------------------------------
@anchor{poismap}
@deffn {関数} poismap (@var{series}, @var{sinfn}, @var{cosfn})

関数@var{sinfn}を与えられたPoisson級数のサイン項に、
@var{cosfn}をコサイン項に
マップします。
@var{sinfn}と @var{cosfn}は、２引数関数です。
引数それぞれは、級数の中の項の係数と三角関数部です。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poisplus}
@deffn {関数} poisplus (@var{a}, @var{b})

関数的に@code{intopois (a + b)}と同一です。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{poissimp}
@deffn {関数} poissimp (@var{a})

@var{a}を、一般表現の@var{a}に関するPoisson級数に変換します。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c MORE INFO NEEDED HERE

@c -----------------------------------------------------------------------------
@anchor{poisson}
@defvr {特殊シンボル} poisson

シンボル@code{/P/}は、Poisson級数式の行ラベルに続きます。

@opencatbox
@category{Poisson series}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{poissubst}
@deffn {関数} poissubst (@var{a}, @var{b}, @var{c})

@var{a}を@var{c}の中の@var{b}に代入します。
@var{c}はPoisson級数です。

(1) @var{b}が変数@var{u}, @var{v}, @var{w}, @var{x}, @var{y}, @var{z}のいずれかの場合、
@var{a}はそれらの変数に関して線形の式(例えば、@code{6*u + 4*v})でなければいけません。

(2) @var{b}はそれらの変数以外の場合、
@var{a}もまたそれらの変数を含んではいけなく、さらに、サインもコサインも含んではいけません。

@code{poissubst (@var{a}, @var{b}, @var{c}, @var{d}, @var{n})}は、
上のタイプ(1)のように@var{a}と@var{b}に関して演算しますが、
@var{d}がPoisson級数の場合、
@var{c}の中で@var{b}に@code{@var{a} + @var{d}}を代入した結果を供給するために、
@code{cos(@var{d})}と@code{sin(@var{d})}を次数@var{n}に展開する
特殊なタイプの代入です。
アイデアは、
@var{d}が小さなパラメータの項に関する展開だということです。
例えば、
@code{poissubst (u, v, cos(v), %e, 3)}は@code{cos(u)*(1 - %e^2/2) - sin(u)*(%e - %e^3/6)}をもたらします。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poistimes}
@deffn {関数} poistimes (@var{a}, @var{b})

@code{intopois (@var{a}*@var{b})}と同じ機能です。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c HOW DOES THIS WORK ?? NEED MORE INFO AND EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{poistrim}
@deffn {関数} poistrim ()

(もしユーザーがそれを定義したら)
Poisson乗算の間、適用する予約関数です。
項の中の@var{u}, @var{v}, ..., @var{z}の係数を引数とする６引数の述語論理関数です。
 (この項の係数に関して)@code{poistrim}が@code{true}の項は、
乗算の間に消去されます。

@opencatbox
@category{Poisson series}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{printpois}
@deffn {関数} printpois (@var{a})

可読フォーマットでPoisson級数を印字します。
@code{outofpois}と共通で、
もし必要なら、@var{a}を最初にPoisson符号に変換します。

@opencatbox
@category{Poisson series}
@category{Display functions}
@closecatbox
@end deffn

